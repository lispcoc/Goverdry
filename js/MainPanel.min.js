class MainPanel {
  constructor () {
    this.WINDOW_WIDTH = GameBody.width
    this.WINDOW_HEIGHT = GameBody.height
    this.MAIN_WIDTH = this.WINDOW_WIDTH
    this.MAIN_HEIGHT = this.WINDOW_WIDTH
    this.MAIN_X = 0
    this.MAIN_Y = 0
    this.CONTROLLER_WIDTH = this.MAIN_WIDTH
    this.CONTROLLER_HEIGHT = this.WINDOW_HEIGHT - this.MAIN_HEIGHT
    this.CONTROLLER_X = this.MAIN_X
    this.CONTROLLER_Y = this.MAIN_Y + this.MAIN_HEIGHT
    this.CONTROLLER_BG_COLOR = '#dcdcdc'
    this.FRAME_WIDTH = this.MAIN_WIDTH / 100
    this.BUTTON_FRAME_WIDTH = this.FRAME_WIDTH / 3
    this.FRAME_ARC = this.MAIN_WIDTH / 200
    this.BUTTON_FRAME_ARC = this.FRAME_ARC * 1.5
    this.DUNGEON_FRAME_WIDTH = this.FRAME_WIDTH / 2
    this.FULL_FRAME_WIDTH = this.MAIN_WIDTH - this.FRAME_WIDTH * 2
    this.FULL_FRAME_HEIGHT = this.MAIN_HEIGHT - this.FRAME_WIDTH * 2
    this.FULL_FRAME_X = this.MAIN_X + this.FRAME_WIDTH
    this.FULL_FRAME_Y = this.MAIN_Y + this.FRAME_WIDTH
    this.NUMBER_OF_CHARACTERS = 60
    this.NUMBER_OF_LINES = 25
    this.FONT_NAME = ''
    if (GoverdryPatch) {
      this.FONT_SIZE = SDL.QueryFontSize()
    } else {
      this.FONT_SIZE =
        Math.floor(this.MAIN_WIDTH / this.NUMBER_OF_CHARACTERS) * 2
    }
    if (GoverdryPatch) {
      this.FONT_HALF_SIZE = this.FONT_SIZE * SDL.QueryFontAspect()
    } else {
      this.FONT_HALF_SIZE = calDiv(this.FONT_SIZE, 2)
    }
    this.MAIN_TEXT_X =
      (this.MAIN_WIDTH - this.FONT_HALF_SIZE * this.NUMBER_OF_CHARACTERS) / 2
    this.LINE_HEIGHT = this.MAIN_HEIGHT / this.NUMBER_OF_LINES
    this.CENTER_FRAME_WIDTH = this.MAIN_WIDTH * 0.75
    this.CENTER_FRAME_HEIGHT = Math.floor((this.CENTER_FRAME_WIDTH * 21) / 22)
    this.CENTER_FRAME_X = (this.MAIN_WIDTH - this.CENTER_FRAME_WIDTH) / 2
    this.CENTER_FRAME_Y = this.FULL_FRAME_Y + this.LINE_HEIGHT * 0.8
    this.CENTER_FRAME_FILL = []
    this.CENTER_FRAME_FILL[0] = this.CENTER_FRAME_Y - this.MAIN_Y
    this.CENTER_FRAME_FILL[1] = this.CENTER_FRAME_Y + this.CENTER_FRAME_HEIGHT
    this.CENTER_FRAME_FILL[2] =
      this.MAIN_Y + this.MAIN_HEIGHT - this.CENTER_FRAME_FILL[1]
    this.CENTER_FRAME_FILL[3] = this.CENTER_FRAME_X - this.MAIN_X
    this.CENTER_FRAME_FILL[4] = this.CENTER_FRAME_X + this.CENTER_FRAME_WIDTH
    if (LaunchSettings['Controller']) {
      this.CAMERA_Y = 1.284
      this.CAMERA_Z = 17.1
    } else {
      this.CAMERA_Y = 0.555
      this.CAMERA_Z = 12.93
    }
    this.X_AXIS_MAGNIFICATION = 1.1
    this.Z_AXIS_MAGNIFICATION = 5.5 * (this.WINDOW_HEIGHT / this.WINDOW_WIDTH)
    if (GoverdryPatch) {
      this.X_AXIS_MAGNIFICATION = 1
      this.Z_AXIS_MAGNIFICATION = 1
    }
    this.Z_AXIS_REFERENCE_VALUE = (-1 * this.Z_AXIS_MAGNIFICATION) / 2
    this.ButtonObject = []
    this.WIRE_FRAME_POINT_X = []
    this.WIRE_FRAME_POINT_Y = []
    let len = this.CENTER_FRAME_WIDTH / 25
    this.WIRE_FRAME_POINT_X[0] = this.CENTER_FRAME_X + len
    this.WIRE_FRAME_POINT_Y[0] = this.CENTER_FRAME_Y
    this.WIRE_FRAME_POINT_X[1] =
      this.CENTER_FRAME_X + this.CENTER_FRAME_WIDTH - len
    this.WIRE_FRAME_POINT_Y[1] = this.WIRE_FRAME_POINT_Y[0]
    this.WIRE_FRAME_POINT_X[2] = this.WIRE_FRAME_POINT_X[1]
    this.WIRE_FRAME_POINT_Y[2] = this.CENTER_FRAME_Y + this.CENTER_FRAME_HEIGHT
    this.WIRE_FRAME_POINT_X[3] = this.WIRE_FRAME_POINT_X[0]
    this.WIRE_FRAME_POINT_Y[3] = this.WIRE_FRAME_POINT_Y[2]
    let wireRatio = []
    wireRatio[0] =
      (this.WIRE_FRAME_POINT_Y[2] - this.WIRE_FRAME_POINT_Y[0]) /
      (this.WIRE_FRAME_POINT_X[2] - this.WIRE_FRAME_POINT_X[0])
    for (let i = 0; i < 5; i++) {
      let n
      if (i == 0) {
        n = 4
        len = this.CENTER_FRAME_WIDTH / 9
      } else if (i >= 1) {
        if (i == 1) {
          n = 8
        } else if (i == 2) {
          n = 12
        } else if (i == 3) {
          n = 16
        } else if (i == 4) {
          n = 20
        }
        len =
          ((this.CENTER_FRAME_X +
            this.CENTER_FRAME_WIDTH / 2 -
            this.WIRE_FRAME_POINT_X[n - 4]) /
            10) *
          4.5
      }
      this.WIRE_FRAME_POINT_X[n] = this.WIRE_FRAME_POINT_X[n - 4] + len
      let yLen =
        (this.WIRE_FRAME_POINT_X[n] - this.WIRE_FRAME_POINT_X[0]) * wireRatio[0]
      this.WIRE_FRAME_POINT_Y[n] = this.WIRE_FRAME_POINT_Y[0] + yLen
      this.WIRE_FRAME_POINT_X[n + 1] = this.WIRE_FRAME_POINT_X[n - 3] - len
      this.WIRE_FRAME_POINT_Y[n + 1] = this.WIRE_FRAME_POINT_Y[n]
      if (i < 4) {
        this.WIRE_FRAME_POINT_X[n + 2] = this.WIRE_FRAME_POINT_X[n + 1]
        this.WIRE_FRAME_POINT_Y[n + 2] = this.WIRE_FRAME_POINT_Y[2] - yLen
        this.WIRE_FRAME_POINT_X[n + 3] = this.WIRE_FRAME_POINT_X[n]
        this.WIRE_FRAME_POINT_Y[n + 3] = this.WIRE_FRAME_POINT_Y[n + 2]
      }
    }
    this.WIRE_FRAME_POINT_X[22] = this.CENTER_FRAME_X
    this.WIRE_FRAME_POINT_Y[22] =
      this.CENTER_FRAME_Y + this.CENTER_FRAME_HEIGHT / 7
    wireRatio[1] =
      (this.CENTER_FRAME_Y +
        this.CENTER_FRAME_HEIGHT / 2 -
        this.WIRE_FRAME_POINT_Y[22]) /
      (this.CENTER_FRAME_X +
        this.CENTER_FRAME_WIDTH / 2 -
        this.WIRE_FRAME_POINT_X[22])
    len = this.CENTER_FRAME_WIDTH / 15
    this.WIRE_FRAME_POINT_X[23] = this.WIRE_FRAME_POINT_X[22] + len
    let yLen =
      (this.WIRE_FRAME_POINT_X[23] - this.WIRE_FRAME_POINT_X[22]) * wireRatio[1]
    this.WIRE_FRAME_POINT_Y[23] = this.WIRE_FRAME_POINT_Y[22] + yLen
    this.WIRE_FRAME_POINT_X[24] = this.WIRE_FRAME_POINT_X[23]
    yLen =
      (this.WIRE_FRAME_POINT_X[23] - this.WIRE_FRAME_POINT_X[3]) * wireRatio[0]
    this.WIRE_FRAME_POINT_Y[24] = this.WIRE_FRAME_POINT_Y[3] - yLen
    for (let i = 0; i < 3; i++) {
      let n, len1, len2
      if (i == 0) {
        n = 25
      } else if (i == 1) {
        n = 29
      } else if (i == 2) {
        n = 33
      }
      this.WIRE_FRAME_POINT_X[n] =
        this.WIRE_FRAME_POINT_X[n - 21] +
        ((this.WIRE_FRAME_POINT_X[n - 17] - this.WIRE_FRAME_POINT_X[n - 21]) /
          10) *
          4.25
      this.WIRE_FRAME_POINT_Y[n] =
        this.WIRE_FRAME_POINT_Y[22] +
        (this.WIRE_FRAME_POINT_X[n] - this.WIRE_FRAME_POINT_X[22]) *
          wireRatio[1]
      this.WIRE_FRAME_POINT_X[n + 1] =
        this.WIRE_FRAME_POINT_X[n - 21] +
        ((this.WIRE_FRAME_POINT_X[n - 17] - this.WIRE_FRAME_POINT_X[n - 21]) /
          10) *
          7.5
      this.WIRE_FRAME_POINT_Y[n + 1] =
        this.WIRE_FRAME_POINT_Y[22] +
        (this.WIRE_FRAME_POINT_X[n + 1] - this.WIRE_FRAME_POINT_X[22]) *
          wireRatio[1]
      this.WIRE_FRAME_POINT_X[n + 2] = this.WIRE_FRAME_POINT_X[n + 1]
      this.WIRE_FRAME_POINT_Y[n + 2] =
        this.WIRE_FRAME_POINT_Y[n - 19] -
        (this.WIRE_FRAME_POINT_X[n + 2] - this.WIRE_FRAME_POINT_X[n - 21]) *
          wireRatio[0]
      this.WIRE_FRAME_POINT_X[n + 3] = this.WIRE_FRAME_POINT_X[n]
      this.WIRE_FRAME_POINT_Y[n + 3] =
        this.WIRE_FRAME_POINT_Y[n - 19] -
        (this.WIRE_FRAME_POINT_X[n + 3] - this.WIRE_FRAME_POINT_X[n - 21]) *
          wireRatio[0]
    }
    this.WIRE_FRAME_POINT_X[38] = this.CENTER_FRAME_X + this.CENTER_FRAME_WIDTH
    this.WIRE_FRAME_POINT_Y[38] = this.WIRE_FRAME_POINT_Y[22]
    len = this.WIRE_FRAME_POINT_X[23] - this.CENTER_FRAME_X
    this.WIRE_FRAME_POINT_X[37] =
      this.CENTER_FRAME_X + this.CENTER_FRAME_WIDTH - len
    this.WIRE_FRAME_POINT_Y[37] = this.WIRE_FRAME_POINT_Y[23]
    this.WIRE_FRAME_POINT_X[39] = this.WIRE_FRAME_POINT_X[37]
    this.WIRE_FRAME_POINT_Y[39] = this.WIRE_FRAME_POINT_Y[24]
    for (let i = 0; i < 3; i++) {
      let n, len1, len2
      if (i == 0) {
        n = 40
      } else if (i == 1) {
        n = 44
      } else if (i == 2) {
        n = 48
      }
      this.WIRE_FRAME_POINT_X[n] =
        this.CENTER_FRAME_X +
        this.CENTER_FRAME_WIDTH -
        (this.WIRE_FRAME_POINT_X[n - 14] - this.CENTER_FRAME_X)
      this.WIRE_FRAME_POINT_Y[n] = this.WIRE_FRAME_POINT_Y[n - 14]
      this.WIRE_FRAME_POINT_X[n + 1] =
        this.CENTER_FRAME_X +
        this.CENTER_FRAME_WIDTH -
        (this.WIRE_FRAME_POINT_X[n - 15] - this.CENTER_FRAME_X)
      this.WIRE_FRAME_POINT_Y[n + 1] = this.WIRE_FRAME_POINT_Y[n - 15]
      this.WIRE_FRAME_POINT_X[n + 2] = this.WIRE_FRAME_POINT_X[n + 1]
      this.WIRE_FRAME_POINT_Y[n + 2] = this.WIRE_FRAME_POINT_Y[n - 12]
      this.WIRE_FRAME_POINT_X[n + 3] = this.WIRE_FRAME_POINT_X[n]
      this.WIRE_FRAME_POINT_Y[n + 3] = this.WIRE_FRAME_POINT_Y[n - 13]
    }
    len = this.WIRE_FRAME_POINT_X[9] - this.WIRE_FRAME_POINT_X[12]
    this.WIRE_FRAME_POINT_X[52] = this.WIRE_FRAME_POINT_X[8] - len
    this.WIRE_FRAME_POINT_Y[52] = this.WIRE_FRAME_POINT_Y[12]
    this.WIRE_FRAME_POINT_X[55] = this.WIRE_FRAME_POINT_X[9] + len
    this.WIRE_FRAME_POINT_Y[55] = this.WIRE_FRAME_POINT_Y[12]
    len = this.WIRE_FRAME_POINT_X[9] - this.WIRE_FRAME_POINT_X[13]
    this.WIRE_FRAME_POINT_X[53] = this.WIRE_FRAME_POINT_X[8] - len
    this.WIRE_FRAME_POINT_Y[53] = this.WIRE_FRAME_POINT_Y[12]
    this.WIRE_FRAME_POINT_X[54] = this.WIRE_FRAME_POINT_X[9] + len
    this.WIRE_FRAME_POINT_Y[54] = this.WIRE_FRAME_POINT_Y[12]
    len = this.WIRE_FRAME_POINT_X[13] - this.WIRE_FRAME_POINT_X[12]
    this.WIRE_FRAME_POINT_X[56] = this.WIRE_FRAME_POINT_X[12] - len
    this.WIRE_FRAME_POINT_Y[56] = this.WIRE_FRAME_POINT_Y[12]
    this.WIRE_FRAME_POINT_X[57] = this.WIRE_FRAME_POINT_X[13] + len
    this.WIRE_FRAME_POINT_Y[57] = this.WIRE_FRAME_POINT_Y[12]
    for (let i = 0; i < 2; i++) {
      let n1, n2
      if (i == 0) {
        n1 = 58
        n2 = 63
        len = this.WIRE_FRAME_POINT_X[13] - this.WIRE_FRAME_POINT_X[16]
      } else if (i == 1) {
        n1 = 59
        n2 = 62
        len = this.WIRE_FRAME_POINT_X[13] - this.WIRE_FRAME_POINT_X[17]
      }
      this.WIRE_FRAME_POINT_X[n1] = this.WIRE_FRAME_POINT_X[56] - len
      this.WIRE_FRAME_POINT_Y[n1] = this.WIRE_FRAME_POINT_Y[16]
      this.WIRE_FRAME_POINT_X[n1 + 2] = this.WIRE_FRAME_POINT_X[12] - len
      this.WIRE_FRAME_POINT_Y[n1 + 2] = this.WIRE_FRAME_POINT_Y[16]
      this.WIRE_FRAME_POINT_X[n2] = this.WIRE_FRAME_POINT_X[13] + len
      this.WIRE_FRAME_POINT_Y[n2] = this.WIRE_FRAME_POINT_Y[16]
      this.WIRE_FRAME_POINT_X[n2 + 2] = this.WIRE_FRAME_POINT_X[57] + len
      this.WIRE_FRAME_POINT_Y[n2 + 2] = this.WIRE_FRAME_POINT_Y[16]
    }
    len = this.WIRE_FRAME_POINT_X[17] - this.WIRE_FRAME_POINT_X[16]
    this.WIRE_FRAME_POINT_X[67] = this.WIRE_FRAME_POINT_X[16] - len
    this.WIRE_FRAME_POINT_Y[67] = this.WIRE_FRAME_POINT_Y[16]
    this.WIRE_FRAME_POINT_X[66] = this.WIRE_FRAME_POINT_X[67] - len
    this.WIRE_FRAME_POINT_Y[66] = this.WIRE_FRAME_POINT_Y[16]
    this.WIRE_FRAME_POINT_X[68] = this.WIRE_FRAME_POINT_X[17] + len
    this.WIRE_FRAME_POINT_Y[68] = this.WIRE_FRAME_POINT_Y[16]
    this.WIRE_FRAME_POINT_X[69] = this.WIRE_FRAME_POINT_X[68] + len
    this.WIRE_FRAME_POINT_Y[69] = this.WIRE_FRAME_POINT_Y[16]
    for (let i = 0; i < 2; i++) {
      let n1, n2
      if (i == 0) {
        n1 = 70
        n2 = 77
        len = this.WIRE_FRAME_POINT_X[17] - this.WIRE_FRAME_POINT_X[20]
      } else if (i == 1) {
        n1 = 71
        n2 = 76
        len = this.WIRE_FRAME_POINT_X[17] - this.WIRE_FRAME_POINT_X[21]
      }
      this.WIRE_FRAME_POINT_X[n1] = this.WIRE_FRAME_POINT_X[67] - len
      this.WIRE_FRAME_POINT_Y[n1] = this.WIRE_FRAME_POINT_Y[20]
      this.WIRE_FRAME_POINT_X[n1 + 2] = this.WIRE_FRAME_POINT_X[16] - len
      this.WIRE_FRAME_POINT_Y[n1 + 2] = this.WIRE_FRAME_POINT_Y[20]
      this.WIRE_FRAME_POINT_X[n2] = this.WIRE_FRAME_POINT_X[68] + len
      this.WIRE_FRAME_POINT_Y[n2] = this.WIRE_FRAME_POINT_Y[20]
      this.WIRE_FRAME_POINT_X[n2 - 2] = this.WIRE_FRAME_POINT_X[17] + len
      this.WIRE_FRAME_POINT_Y[n2 - 2] = this.WIRE_FRAME_POINT_Y[20]
    }
    wireRatio[2] =
      (this.WIRE_FRAME_POINT_Y[67] - this.WIRE_FRAME_POINT_Y[56]) /
      (this.WIRE_FRAME_POINT_X[67] - this.WIRE_FRAME_POINT_X[56])
    this.WIRE_FRAME_POINT_X[78] = this.CENTER_FRAME_X
    len =
      (this.WIRE_FRAME_POINT_X[56] - this.WIRE_FRAME_POINT_X[78]) * wireRatio[2]
    this.WIRE_FRAME_POINT_Y[78] = this.WIRE_FRAME_POINT_Y[56] - len
    this.WIRE_FRAME_POINT_X[79] = this.CENTER_FRAME_X
    this.WIRE_FRAME_POINT_Y[79] = this.WIRE_FRAME_POINT_Y[15] + len
    this.WIRE_FRAME_POINT_X[80] = this.CENTER_FRAME_X + this.CENTER_FRAME_WIDTH
    this.WIRE_FRAME_POINT_Y[80] = this.WIRE_FRAME_POINT_Y[78]
    this.WIRE_FRAME_POINT_X[81] = this.CENTER_FRAME_X + this.CENTER_FRAME_WIDTH
    this.WIRE_FRAME_POINT_Y[81] = this.WIRE_FRAME_POINT_Y[79]
    wireRatio[3] =
      (this.CENTER_FRAME_Y +
        this.CENTER_FRAME_HEIGHT / 2 -
        this.WIRE_FRAME_POINT_Y[66]) /
      (this.CENTER_FRAME_X +
        this.CENTER_FRAME_WIDTH / 2 -
        this.WIRE_FRAME_POINT_X[66])
    len =
      (this.WIRE_FRAME_POINT_X[56] -
        (this.WIRE_FRAME_POINT_X[8] -
          (this.WIRE_FRAME_POINT_X[9] - this.WIRE_FRAME_POINT_X[8]))) /
      10
    this.WIRE_FRAME_POINT_X[82] = this.WIRE_FRAME_POINT_X[56] - len * 5.75
    this.WIRE_FRAME_POINT_Y[82] =
      this.WIRE_FRAME_POINT_Y[66] -
      (this.WIRE_FRAME_POINT_X[66] - this.WIRE_FRAME_POINT_X[82]) * wireRatio[3]
    this.WIRE_FRAME_POINT_X[83] = this.WIRE_FRAME_POINT_X[56] - len * 2.5
    this.WIRE_FRAME_POINT_Y[83] =
      this.WIRE_FRAME_POINT_Y[66] -
      (this.WIRE_FRAME_POINT_X[66] - this.WIRE_FRAME_POINT_X[83]) * wireRatio[3]
    this.WIRE_FRAME_POINT_X[84] = this.WIRE_FRAME_POINT_X[83]
    this.WIRE_FRAME_POINT_Y[84] =
      this.WIRE_FRAME_POINT_Y[19] +
      (this.WIRE_FRAME_POINT_X[67] - this.WIRE_FRAME_POINT_X[84]) * wireRatio[2]
    this.WIRE_FRAME_POINT_X[85] = this.WIRE_FRAME_POINT_X[82]
    this.WIRE_FRAME_POINT_Y[85] =
      this.WIRE_FRAME_POINT_Y[19] +
      (this.WIRE_FRAME_POINT_X[67] - this.WIRE_FRAME_POINT_X[85]) * wireRatio[2]
    len = (this.WIRE_FRAME_POINT_X[67] - this.WIRE_FRAME_POINT_X[56]) / 10
    this.WIRE_FRAME_POINT_X[86] = this.WIRE_FRAME_POINT_X[67] - len * 5.75
    this.WIRE_FRAME_POINT_Y[86] =
      this.CENTER_FRAME_Y +
      this.CENTER_FRAME_HEIGHT / 2 -
      (this.CENTER_FRAME_X +
        this.CENTER_FRAME_WIDTH / 2 -
        this.WIRE_FRAME_POINT_X[86]) *
        wireRatio[3]
    this.WIRE_FRAME_POINT_X[87] = this.WIRE_FRAME_POINT_X[67] - len * 2.5
    this.WIRE_FRAME_POINT_Y[87] =
      this.CENTER_FRAME_Y +
      this.CENTER_FRAME_HEIGHT / 2 -
      (this.CENTER_FRAME_X +
        this.CENTER_FRAME_WIDTH / 2 -
        this.WIRE_FRAME_POINT_X[87]) *
        wireRatio[3]
    this.WIRE_FRAME_POINT_X[88] = this.WIRE_FRAME_POINT_X[87]
    this.WIRE_FRAME_POINT_Y[88] =
      this.WIRE_FRAME_POINT_Y[19] +
      (this.WIRE_FRAME_POINT_X[67] - this.WIRE_FRAME_POINT_X[88]) * wireRatio[2]
    this.WIRE_FRAME_POINT_X[89] = this.WIRE_FRAME_POINT_X[86]
    this.WIRE_FRAME_POINT_Y[89] =
      this.WIRE_FRAME_POINT_Y[19] +
      (this.WIRE_FRAME_POINT_X[67] - this.WIRE_FRAME_POINT_X[89]) * wireRatio[2]
    this.WIRE_FRAME_POINT_X[90] =
      this.WIRE_FRAME_POINT_X[68] +
      (this.WIRE_FRAME_POINT_X[67] - this.WIRE_FRAME_POINT_X[87])
    this.WIRE_FRAME_POINT_Y[90] = this.WIRE_FRAME_POINT_Y[87]
    this.WIRE_FRAME_POINT_X[91] =
      this.WIRE_FRAME_POINT_X[68] +
      (this.WIRE_FRAME_POINT_X[67] - this.WIRE_FRAME_POINT_X[86])
    this.WIRE_FRAME_POINT_Y[91] = this.WIRE_FRAME_POINT_Y[86]
    this.WIRE_FRAME_POINT_X[92] = this.WIRE_FRAME_POINT_X[91]
    this.WIRE_FRAME_POINT_Y[92] = this.WIRE_FRAME_POINT_Y[89]
    this.WIRE_FRAME_POINT_X[93] = this.WIRE_FRAME_POINT_X[90]
    this.WIRE_FRAME_POINT_Y[93] = this.WIRE_FRAME_POINT_Y[88]
    this.WIRE_FRAME_POINT_X[94] =
      this.WIRE_FRAME_POINT_X[68] +
      (this.WIRE_FRAME_POINT_X[67] - this.WIRE_FRAME_POINT_X[83])
    this.WIRE_FRAME_POINT_Y[94] = this.WIRE_FRAME_POINT_Y[83]
    this.WIRE_FRAME_POINT_X[95] =
      this.WIRE_FRAME_POINT_X[68] +
      (this.WIRE_FRAME_POINT_X[67] - this.WIRE_FRAME_POINT_X[82])
    this.WIRE_FRAME_POINT_Y[95] = this.WIRE_FRAME_POINT_Y[82]
    this.WIRE_FRAME_POINT_X[96] = this.WIRE_FRAME_POINT_X[95]
    this.WIRE_FRAME_POINT_Y[96] = this.WIRE_FRAME_POINT_Y[85]
    this.WIRE_FRAME_POINT_X[97] = this.WIRE_FRAME_POINT_X[94]
    this.WIRE_FRAME_POINT_Y[97] = this.WIRE_FRAME_POINT_Y[84]
    wireRatio[4] =
      (this.WIRE_FRAME_POINT_Y[11] -
        (this.CENTER_FRAME_Y + this.CENTER_FRAME_HEIGHT / 2)) /
      (this.CENTER_FRAME_X +
        this.CENTER_FRAME_WIDTH / 2 -
        (this.WIRE_FRAME_POINT_X[11] +
          ((this.WIRE_FRAME_POINT_X[10] - this.WIRE_FRAME_POINT_X[11]) / 10) *
            1.5))
    for (let i = 0; i < 4; i++) {
      let nXY = []
      if (i == 0) {
        nXY[0] = 98
        nXY[1] = 24
        nXY[2] = 7
      } else if (i == 1) {
        nXY[0] = 104
        nXY[1] = 27
        nXY[2] = 11
      } else if (i == 2) {
        nXY[0] = 114
        nXY[1] = 31
        nXY[2] = 15
      } else if (i == 3) {
        nXY[0] = 126
        nXY[1] = 35
        nXY[2] = 19
      }
      this.WIRE_FRAME_POINT_Y[nXY[0]] =
        this.WIRE_FRAME_POINT_Y[nXY[1]] -
        ((this.WIRE_FRAME_POINT_Y[nXY[1]] - this.WIRE_FRAME_POINT_Y[nXY[2]]) /
          10) *
          (5 - i)
      len =
        (this.WIRE_FRAME_POINT_Y[nXY[0]] -
          (this.CENTER_FRAME_Y + this.CENTER_FRAME_HEIGHT / 2)) /
        wireRatio[4]
      this.WIRE_FRAME_POINT_X[nXY[0]] =
        this.CENTER_FRAME_X + this.CENTER_FRAME_WIDTH / 2 - len
      this.WIRE_FRAME_POINT_X[nXY[0] + 1] =
        this.CENTER_FRAME_X + this.CENTER_FRAME_WIDTH / 2 + len
      this.WIRE_FRAME_POINT_Y[nXY[0] + 1] = this.WIRE_FRAME_POINT_Y[nXY[0]]
    }
    for (let i = 0; i < 3; i++) {
      let nXY = []
      if (i == 0) {
        nXY[0] = 107
        nXY[1] = 7
        nXY[2] = 28
      } else if (i == 1) {
        nXY[0] = 117
        nXY[1] = 11
        nXY[2] = 32
      } else if (i == 2) {
        nXY[0] = 129
        nXY[1] = 15
        nXY[2] = 36
      }
      this.WIRE_FRAME_POINT_Y[nXY[0]] =
        this.WIRE_FRAME_POINT_Y[nXY[1]] -
        ((this.WIRE_FRAME_POINT_Y[nXY[1]] - this.WIRE_FRAME_POINT_Y[nXY[2]]) /
          10) *
          (6 + i)
      len =
        (this.WIRE_FRAME_POINT_Y[nXY[0]] -
          (this.CENTER_FRAME_Y + this.CENTER_FRAME_HEIGHT / 2)) /
        wireRatio[4]
      this.WIRE_FRAME_POINT_X[nXY[0]] =
        this.CENTER_FRAME_X + this.CENTER_FRAME_WIDTH / 2 - len
      this.WIRE_FRAME_POINT_X[nXY[0] - 1] =
        this.CENTER_FRAME_X + this.CENTER_FRAME_WIDTH / 2 + len
      this.WIRE_FRAME_POINT_Y[nXY[0] - 1] = this.WIRE_FRAME_POINT_Y[nXY[0]]
    }
    this.WIRE_FRAME_POINT_Y[101] =
      this.CENTER_FRAME_Y + this.CENTER_FRAME_HEIGHT
    len =
      (this.WIRE_FRAME_POINT_Y[101] -
        (this.CENTER_FRAME_Y + this.CENTER_FRAME_HEIGHT / 2)) /
      wireRatio[4]
    this.WIRE_FRAME_POINT_X[101] =
      this.CENTER_FRAME_X + this.CENTER_FRAME_WIDTH / 2 - len
    this.WIRE_FRAME_POINT_X[100] =
      this.CENTER_FRAME_X + this.CENTER_FRAME_WIDTH / 2 + len
    this.WIRE_FRAME_POINT_Y[100] = this.WIRE_FRAME_POINT_Y[101]
    wireRatio[5] =
      (this.WIRE_FRAME_POINT_Y[15] -
        (this.CENTER_FRAME_Y + this.CENTER_FRAME_HEIGHT / 2)) /
      (this.CENTER_FRAME_X +
        this.CENTER_FRAME_WIDTH / 2 -
        (this.WIRE_FRAME_POINT_X[56] +
          ((this.WIRE_FRAME_POINT_X[15] - this.WIRE_FRAME_POINT_X[56]) / 10) *
            1.5))
    for (let i = 0; i < 4; i++) {
      let nXY = []
      if (i == 0) {
        nXY[0] = 110
        nXY[1] = 114
        nXY[2] = 119
      } else if (i == 1) {
        nXY[0] = 113
        nXY[1] = 117
        nXY[2] = 120
      } else if (i == 2) {
        nXY[0] = 122
        nXY[1] = 126
        nXY[2] = 131
      } else if (i == 3) {
        nXY[0] = 125
        nXY[1] = 129
        nXY[2] = 132
      }
      this.WIRE_FRAME_POINT_Y[nXY[0]] = this.WIRE_FRAME_POINT_Y[nXY[1]]
      len =
        (this.WIRE_FRAME_POINT_Y[nXY[0]] -
          (this.CENTER_FRAME_Y + this.CENTER_FRAME_HEIGHT / 2)) /
        wireRatio[5]
      this.WIRE_FRAME_POINT_X[nXY[0]] =
        this.CENTER_FRAME_X + this.CENTER_FRAME_WIDTH / 2 - len
      this.WIRE_FRAME_POINT_X[nXY[2]] =
        this.CENTER_FRAME_X + this.CENTER_FRAME_WIDTH / 2 + len
      this.WIRE_FRAME_POINT_Y[nXY[2]] = this.WIRE_FRAME_POINT_Y[nXY[0]]
    }
    wireRatio[6] =
      (this.WIRE_FRAME_POINT_Y[15] -
        (this.CENTER_FRAME_Y + this.CENTER_FRAME_HEIGHT / 2)) /
      (this.CENTER_FRAME_X +
        this.CENTER_FRAME_WIDTH / 2 -
        (this.WIRE_FRAME_POINT_X[56] +
          ((this.WIRE_FRAME_POINT_X[15] - this.WIRE_FRAME_POINT_X[56]) / 10) *
            8.5))
    for (let i = 0; i < 6; i++) {
      let nXY = []
      if (i == 0) {
        nXY[0] = 102
        nXY[1] = 104
        nXY[2] = 108
      } else if (i == 1) {
        nXY[0] = 103
        nXY[1] = 107
        nXY[2] = 109
      } else if (i == 2) {
        nXY[0] = 111
        nXY[1] = 114
        nXY[2] = 118
      } else if (i == 3) {
        nXY[0] = 112
        nXY[1] = 117
        nXY[2] = 121
      } else if (i == 4) {
        nXY[0] = 123
        nXY[1] = 126
        nXY[2] = 130
      } else if (i == 5) {
        nXY[0] = 124
        nXY[1] = 129
        nXY[2] = 133
      }
      this.WIRE_FRAME_POINT_Y[nXY[0]] = this.WIRE_FRAME_POINT_Y[nXY[1]]
      len =
        (this.WIRE_FRAME_POINT_Y[nXY[0]] -
          (this.CENTER_FRAME_Y + this.CENTER_FRAME_HEIGHT / 2)) /
        wireRatio[6]
      this.WIRE_FRAME_POINT_X[nXY[0]] =
        this.CENTER_FRAME_X + this.CENTER_FRAME_WIDTH / 2 - len
      this.WIRE_FRAME_POINT_X[nXY[2]] =
        this.CENTER_FRAME_X + this.CENTER_FRAME_WIDTH / 2 + len
      this.WIRE_FRAME_POINT_Y[nXY[2]] = this.WIRE_FRAME_POINT_Y[nXY[0]]
    }
    for (let i = 134; i < 170; i++) {
      let n
      if (i >= 166) {
        n = 133 - (i - 166)
      } else if (i >= 162) {
        n = 129 - (i - 162)
      } else if (i >= 158) {
        n = 125 - (i - 158)
      } else if (i >= 154) {
        n = 121 - (i - 154)
      } else if (i >= 150) {
        n = 117 - (i - 150)
      } else if (i >= 146) {
        n = 113 - (i - 146)
      } else if (i >= 144) {
        n = 109 - (i - 144)
      } else if (i >= 140) {
        n = 107 - (i - 140)
      } else if (i >= 138) {
        n = 103 - (i - 138)
      } else {
        n = 101 - (i - 134)
      }
      this.WIRE_FRAME_POINT_X[i] = this.WIRE_FRAME_POINT_X[n]
      this.WIRE_FRAME_POINT_Y[i] =
        this.CENTER_FRAME_Y +
        this.CENTER_FRAME_HEIGHT / 2 -
        (this.WIRE_FRAME_POINT_Y[n] -
          (this.CENTER_FRAME_Y + this.CENTER_FRAME_HEIGHT / 2))
    }
    let fCenter = this.CENTER_FRAME_X + this.CENTER_FRAME_WIDTH / 2
    this.WIRE_FRAME_POINT_X[170] = fCenter - calTimes(fCenter, 0.45)
    this.WIRE_FRAME_POINT_Y[170] = this.WIRE_FRAME_POINT_Y[122]
    this.WIRE_FRAME_POINT_X[171] = fCenter - calTimes(fCenter, 0.32)
    this.WIRE_FRAME_POINT_Y[171] = this.WIRE_FRAME_POINT_Y[122]
    this.WIRE_FRAME_POINT_X[172] = fCenter - calTimes(fCenter, 0.42)
    this.WIRE_FRAME_POINT_Y[172] = this.WIRE_FRAME_POINT_Y[124]
    this.WIRE_FRAME_POINT_X[173] = fCenter - calTimes(fCenter, 0.6)
    this.WIRE_FRAME_POINT_Y[173] = this.WIRE_FRAME_POINT_Y[124]
    this.WIRE_FRAME_POINT_X[174] = fCenter - calTimes(fCenter, 0.6)
    this.WIRE_FRAME_POINT_Y[174] = this.WIRE_FRAME_POINT_Y[158]
    this.WIRE_FRAME_POINT_X[175] = fCenter - calTimes(fCenter, 0.42)
    this.WIRE_FRAME_POINT_Y[175] = this.WIRE_FRAME_POINT_Y[158]
    this.WIRE_FRAME_POINT_X[176] = fCenter - calTimes(fCenter, 0.32)
    this.WIRE_FRAME_POINT_Y[176] = this.WIRE_FRAME_POINT_Y[160]
    this.WIRE_FRAME_POINT_X[177] = fCenter - calTimes(fCenter, 0.45)
    this.WIRE_FRAME_POINT_Y[177] = this.WIRE_FRAME_POINT_Y[160]
    this.WIRE_FRAME_POINT_X[178] = fCenter + calTimes(fCenter, 0.45)
    this.WIRE_FRAME_POINT_Y[178] = this.WIRE_FRAME_POINT_Y[122]
    this.WIRE_FRAME_POINT_X[179] = fCenter + calTimes(fCenter, 0.32)
    this.WIRE_FRAME_POINT_Y[179] = this.WIRE_FRAME_POINT_Y[122]
    this.WIRE_FRAME_POINT_X[180] = fCenter + calTimes(fCenter, 0.42)
    this.WIRE_FRAME_POINT_Y[180] = this.WIRE_FRAME_POINT_Y[124]
    this.WIRE_FRAME_POINT_X[181] = fCenter + calTimes(fCenter, 0.6)
    this.WIRE_FRAME_POINT_Y[181] = this.WIRE_FRAME_POINT_Y[124]
    this.WIRE_FRAME_POINT_X[182] = fCenter + calTimes(fCenter, 0.6)
    this.WIRE_FRAME_POINT_Y[182] = this.WIRE_FRAME_POINT_Y[158]
    this.WIRE_FRAME_POINT_X[183] = fCenter + calTimes(fCenter, 0.42)
    this.WIRE_FRAME_POINT_Y[183] = this.WIRE_FRAME_POINT_Y[158]
    this.WIRE_FRAME_POINT_X[184] = fCenter + calTimes(fCenter, 0.32)
    this.WIRE_FRAME_POINT_Y[184] = this.WIRE_FRAME_POINT_Y[160]
    this.WIRE_FRAME_POINT_X[185] = fCenter + calTimes(fCenter, 0.45)
    this.WIRE_FRAME_POINT_Y[185] = this.WIRE_FRAME_POINT_Y[160]
    this.WIRE_FRAME_POINT_X[186] = this.CENTER_FRAME_X
    this.WIRE_FRAME_POINT_Y[186] = this.WIRE_FRAME_POINT_Y[110]
    this.WIRE_FRAME_POINT_X[187] = fCenter - calTimes(fCenter, 0.56)
    this.WIRE_FRAME_POINT_Y[187] = this.WIRE_FRAME_POINT_Y[110]
    this.WIRE_FRAME_POINT_X[188] = this.CENTER_FRAME_X
    this.WIRE_FRAME_POINT_Y[188] = calTimes(this.WIRE_FRAME_POINT_Y[112], 0.995)
    this.WIRE_FRAME_POINT_X[189] = this.CENTER_FRAME_X
    this.WIRE_FRAME_POINT_Y[189] = calTimes(this.WIRE_FRAME_POINT_Y[112], 0.995)
    this.WIRE_FRAME_POINT_X[190] = fCenter - calTimes(fCenter, 0.56)
    this.WIRE_FRAME_POINT_Y[190] = this.WIRE_FRAME_POINT_Y[110]
    this.WIRE_FRAME_POINT_X[191] = this.CENTER_FRAME_X
    this.WIRE_FRAME_POINT_Y[191] = this.WIRE_FRAME_POINT_Y[110]
    this.WIRE_FRAME_POINT_X[192] = this.CENTER_FRAME_X + this.CENTER_FRAME_WIDTH
    this.WIRE_FRAME_POINT_Y[192] = this.WIRE_FRAME_POINT_Y[110]
    this.WIRE_FRAME_POINT_X[193] = fCenter + calTimes(fCenter, 0.56)
    this.WIRE_FRAME_POINT_Y[193] = this.WIRE_FRAME_POINT_Y[110]
    this.WIRE_FRAME_POINT_X[194] = this.CENTER_FRAME_X + this.CENTER_FRAME_WIDTH
    this.WIRE_FRAME_POINT_Y[194] = calTimes(this.WIRE_FRAME_POINT_Y[112], 0.995)
    this.WIRE_FRAME_POINT_X[195] = this.CENTER_FRAME_X + this.CENTER_FRAME_WIDTH
    this.WIRE_FRAME_POINT_Y[195] = calTimes(this.WIRE_FRAME_POINT_Y[112], 0.995)
    this.WIRE_FRAME_POINT_X[196] = fCenter + calTimes(fCenter, 0.56)
    this.WIRE_FRAME_POINT_Y[196] = this.WIRE_FRAME_POINT_Y[110]
    this.WIRE_FRAME_POINT_X[197] = this.CENTER_FRAME_X + this.CENTER_FRAME_WIDTH
    this.WIRE_FRAME_POINT_Y[197] = this.WIRE_FRAME_POINT_Y[110]
    this.WIRE_FRAME_POINT_X[200] = this.CENTER_FRAME_X
    this.WIRE_FRAME_POINT_Y[200] =
      this.CENTER_FRAME_Y +
      this.CENTER_FRAME_HEIGHT / 2 +
      (this.CENTER_FRAME_X +
        this.CENTER_FRAME_WIDTH / 2 -
        this.CENTER_FRAME_X) *
        wireRatio[5]
    this.WIRE_FRAME_POINT_X[201] = this.CENTER_FRAME_X
    this.WIRE_FRAME_POINT_Y[201] =
      this.CENTER_FRAME_Y +
      this.CENTER_FRAME_HEIGHT / 2 +
      (this.CENTER_FRAME_X +
        this.CENTER_FRAME_WIDTH / 2 -
        this.CENTER_FRAME_X) *
        wireRatio[6]
    let scene3D = new Scene3D()
    this.Sprite3D = new Sprite3D()
    this.Wall3D = []
    for (let i = 0; i < 8; i++) {
      this.Wall3D[i] = []
      for (let j = 0; j < 62; j++) {
        this.Wall3D[i][j] = []
        this.createWall3D(i, j, 0)
        this.createWall3D(i, j, 1)
      }
    }
    this.Floor3D = []
    for (let i = 0; i < 5; i++) {
      this.Floor3D[i] = []
      for (let j = 0; j < 2; j++) {
        this.Floor3D[i][j] = []
        for (let k = 0; k < 16; k++) {
          this.Floor3D[i][j][k] = []
          for (let l = 0; l < 2; l++) {
            this.Floor3D[i][j][k][l] = []
            this.createFloor3D(i, j, k, l, 0)
            this.createFloor3D(i, j, k, l, 1)
          }
        }
      }
    }
    this.Ladder3D = []
    for (let i = 0; i < 2; i++) {
      this.Ladder3D[i] = []
      for (let j = 0; j < 16; j++) {
        this.Ladder3D[i][j] = []
        for (let k = 0; k < 2; k++) {
          this.Ladder3D[i][j][k] = []
          this.createLadder3D(i, j, k, 0)
          this.createLadder3D(i, j, k, 1)
        }
      }
    }
    let aLight = new AmbientLight()
    aLight.color = [10.0, 10.0, 10.0]
    aLight.directionX = 0
    aLight.directionY = 0
    aLight.directionZ = 0
    scene3D.setAmbientLight(aLight)
    this.Sprite3D.y = this.CAMERA_Y
    scene3D.addChild(this.Sprite3D)
    let camera = scene3D.getCamera()
    camera.y = this.CAMERA_Y
    camera.z = this.CAMERA_Z
    this.PreSecretDoor = [-1, -1, -1]
    let baseSprite = new Sprite(this.WINDOW_WIDTH, this.WINDOW_HEIGHT)
    this.BaseSurface = new Surface(this.WINDOW_WIDTH, this.WINDOW_HEIGHT)
    baseSprite.image = this.BaseSurface
    GameBody.rootScene.addChild(baseSprite)
    this.BaseSurface.context.fillStyle = this.CONTROLLER_BG_COLOR
    this.BaseSurface.context.fillRect(
      this.CONTROLLER_X,
      this.CONTROLLER_Y,
      this.CONTROLLER_WIDTH,
      this.CONTROLLER_HEIGHT
    )
    this.BaseSurface.context.fillStyle = 'black'
    this.BaseSurface.context.fillRect(
      this.MAIN_X,
      this.MAIN_Y,
      this.MAIN_WIDTH,
      this.CENTER_FRAME_FILL[0]
    )
    this.BaseSurface.context.fillRect(
      this.MAIN_X,
      this.CENTER_FRAME_FILL[1],
      this.MAIN_WIDTH,
      this.CENTER_FRAME_FILL[2]
    )
    this.BaseSurface.context.fillRect(
      this.MAIN_X,
      this.MAIN_Y,
      this.CENTER_FRAME_FILL[3],
      this.MAIN_HEIGHT
    )
    this.BaseSurface.context.fillRect(
      this.CENTER_FRAME_FILL[4],
      this.MAIN_Y,
      this.CENTER_FRAME_FILL[3],
      this.MAIN_HEIGHT
    )
    let mainSprite = new Sprite(this.MAIN_WIDTH, this.MAIN_HEIGHT)
    this.MainSurface = new Surface(this.MAIN_WIDTH, this.MAIN_HEIGHT)
    mainSprite.image = this.MainSurface
    GameBody.rootScene.addChild(mainSprite)
    let statusSprite = new Sprite(this.MAIN_WIDTH, this.MAIN_HEIGHT)
    this.StatusSurface = new Surface(this.MAIN_WIDTH, this.MAIN_HEIGHT)
    statusSprite.image = this.StatusSurface
    GameBody.rootScene.addChild(statusSprite)
    this.TextSurfaceNum = 0
    this.TextSurface = []
    this.BackupTextSurface = []
    for (let i = 0; i < 4; i++) {
      this.BackupTextSurface[i] = null
      let textSprite = new Sprite(this.MAIN_WIDTH, this.MAIN_HEIGHT)
      this.TextSurface[i] = new Surface(this.MAIN_WIDTH, this.MAIN_HEIGHT)
      textSprite.image = this.TextSurface[i]
      GameBody.rootScene.addChild(textSprite)
    }
    let statusTopSprite = new Sprite(this.MAIN_WIDTH, this.MAIN_HEIGHT)
    this.StatusTopSurface = new Surface(this.MAIN_WIDTH, this.MAIN_HEIGHT)
    statusTopSprite.image = this.StatusTopSurface
    GameBody.rootScene.addChild(statusTopSprite)
    let maskSprite = new Sprite(this.WINDOW_WIDTH, this.WINDOW_HEIGHT)
    this.MaskSurface = new Surface(this.WINDOW_WIDTH, this.WINDOW_HEIGHT)
    maskSprite.image = this.MaskSurface
    GameBody.rootScene.addChild(maskSprite)
    let topSprite = new Sprite(this.WINDOW_WIDTH, this.WINDOW_HEIGHT)
    this.TopSurface = new Surface(this.WINDOW_WIDTH, this.WINDOW_HEIGHT)
    topSprite.image = this.TopSurface
    GameBody.rootScene.addChild(topSprite)
    this.SelectMode = {}
    this.SelectMode['run'] = false
    this.PreSelectKey = [
      'mode',
      'selAry',
      'valueAry',
      'colorAry',
      'comment',
      'align',
      'y',
      'charMin',
      'lineNum',
      'textAlign',
      'select',
      'selectF',
      'selectColor'
    ]
    this.PreSelect = {}
    for (let i = 0; i < this.PreSelectKey.length; i++) {
      this.PreSelect[this.PreSelectKey[i]] = []
    }
    this.ImgWall = null
    this.ImgWallSide = null
    this.ImgDoor = null
    this.ImgSecretDoor = null
    this.ImgFloor = []
    this.ImgCeil = []
    this.ImgDownStairs = []
    this.ImgUpStairs = []
    this.ImgLadder = null
    this.ImgEvent = []
    this.ImgElevator = []
    this.ImgDistantView = null
    this.DungeonMode = ''
    this.DungeonLight = true
    this.DungeonSpace = []
    this.DungeonWall = []
    this.FloorPatternFlag = false
    this.clearDungeonPaintData()
    this.MapLineWidth = this.FRAME_WIDTH / 3
    if (this.MapLineWidth < 2) {
      this.MapLineWidth = 2
    }
    this.MapLineWidthHalf = this.MapLineWidth / 2
    if (this.MapLineWidthHalf < 1) {
      this.MapLineWidthHalf = 1
    }
    this.MapBaseX = this.MAIN_X + this.MAIN_WIDTH / 2 - this.FONT_HALF_SIZE * 28
    this.MapBaseY = this.MAIN_WIDTH * 0.92 - this.MapLineWidth
    this.MapBlock = this.FONT_SIZE + this.MapLineWidth
  }
  backupTextSurface (mode, numAry) {
    if (mode == undefined || mode == null) {
      mode = 'backup'
    }
    if (numAry == undefined || numAry == null) {
      numAry = 'all'
    }
    if (!Array.isArray(numAry)) {
      if (!isNaN(numAry)) {
        numAry = [Number(numAry)]
      } else {
        numAry = 'all'
      }
    }
    if (numAry == 'all') {
      numAry = []
      for (let i = 0; i < this.BackupTextSurface.length; i++) {
        numAry.push(i)
      }
    }
    for (let i = 0; i < numAry.length; i++) {
      let num = numAry[i]
      if (num < 0 || num >= this.BackupTextSurface.length) {
        continue
      }
      if (mode == 'backup') {
        this.BackupTextSurface[num] = this.TextSurface[num].clone()
      }
      if (mode.match(/^(set|recovery)$/)) {
        if (
          this.BackupTextSurface[num] != undefined &&
          this.BackupTextSurface[num] != null
        ) {
          this.TextSurface[num].draw(this.BackupTextSurface[num])
        }
      }
      if (mode.match(/^(clear|recovery)$/)) {
        this.BackupTextSurface[num] = void0
      }
    }
  }
  checkConditionAndViewMessage (conditionStr) {
    let result = false
    if (conditionStr == 'NO_ONE_IN_PARTY') {
      let ptNum = PlayData['ActiveParty']
      if (ptNum < 0) {
        result = true
      } else if (PARTY[ptNum].PartyMember[0] < 0) {
        result = true
      }
    } else if (conditionStr == 'NO_ONE') {
      if (PlayData['PcMax'] < 1) {
        result = true
      }
    } else if (conditionStr == 'FACILITIES_FULL') {
      if (PlayData['PcMax'] >= GameData['PC_ENTRY_MAX']) {
        result = true
      }
    } else if (conditionStr == 'NO_ONE_CAN_DO') {
      if (TempVariable['pcAry'].length < 1) {
        result = true
      }
    } else if (conditionStr == 'PARTY_FULL') {
      let ptNum = PlayData['ActiveParty']
      if (ptNum < 0) {
        result = false
      } else if (
        PARTY[ptNum].PartyMember[GameData['PARTY_MEMBER_MAX'] - 1] > -1
      ) {
        result = true
      }
    } else if (conditionStr == 'NO_ONE_ADD') {
      conditionStr = 'NO_ONE'
      result = true
      for (let i = 0; i < PlayData['PcMax']; i++) {
        if (PC[PlayData['PcList'][i]].PartyNum < 0) {
          result = false
          break
        }
      }
    } else if (conditionStr == 'NO_DUNGEON') {
      if (DUNGEON.DUNGEON_MAX == 0) {
        result = true
      }
    } else if (conditionStr == 'NO_DUNGEON2') {
      conditionStr = 'NO_DUNGEON'
      if (TempVariable['dungeonList'].length == 0) {
        result = true
      }
    } else if (conditionStr == 'NO_PC_IN_MAZE') {
      if (TempVariable['pcInMaze'].length == 0) {
        result = true
      }
    }
    if (!result) {
      return false
    }
    this.drawTextFrame(
      this.TextSurface[this.TextSurfaceNum],
      getDefaultMessage(conditionStr, 1),
      'center',
      this.LINE_HEIGHT * 6
    )
    return true
  }
  checkPaintWall (wall, dungeon) {
    if (wall < 3) {
      if (this.DungeonSpace[0] == 1) {
        return false
      } else {
        return true
      }
    } else if (wall == 3) {
      if (this.DungeonWall[1] > 0) {
        return false
      } else {
        return true
      }
    } else if (wall == 4) {
      if (this.DungeonWall[2] > 0) {
        return false
      } else {
        return true
      }
    } else if (wall == 5) {
      if (this.DungeonWall[0] > 0) {
        return false
      } else {
        return true
      }
    } else if (wall == 6 || wall == 7) {
      if (this.DungeonWall[0] > 0 || this.DungeonSpace[4] == 1) {
        return false
      } else {
        return true
      }
    } else if (wall == 8) {
      if (dungeon == 'graphic') {
        if (
          (this.DungeonWall[1] > 0 ||
            this.DungeonWall[3] > 0 ||
            this.DungeonSpace[1] == 1) &&
          (this.DungeonWall[0] > 0 ||
            this.DungeonWall[6] > 0 ||
            this.DungeonSpace[4] == 1)
        ) {
          return false
        } else {
          return true
        }
      } else {
        if (
          (this.DungeonWall[1] > 0 ||
            this.DungeonWall[3] > 0 ||
            this.DungeonSpace[1] == 1) &&
          (this.DungeonWall[0] > 0 ||
            this.DungeonWall[6] > 0 ||
            this.DungeonSpace[4] == 1)
        ) {
          return false
        } else {
          return true
        }
      }
    } else if (wall == 9) {
      if (dungeon == 'graphic') {
        if (
          (this.DungeonWall[2] > 0 ||
            this.DungeonWall[4] > 0 ||
            this.DungeonSpace[2] == 1) &&
          (this.DungeonWall[0] > 0 ||
            this.DungeonWall[7] > 0 ||
            this.DungeonSpace[4] == 1)
        ) {
          return false
        } else {
          return true
        }
      } else {
        if (
          (this.DungeonWall[2] > 0 ||
            this.DungeonWall[4] > 0 ||
            this.DungeonSpace[2] == 1) &&
          (this.DungeonWall[0] > 0 ||
            this.DungeonWall[7] > 0 ||
            this.DungeonSpace[4] == 1)
        ) {
          return false
        } else {
          return true
        }
      }
    } else if (wall == 10) {
      if (!this.DungeonLight) {
        return false
      }
      if (
        this.DungeonWall[0] > 0 ||
        this.DungeonWall[5] > 0 ||
        this.DungeonSpace[4] == 1
      ) {
        return false
      } else {
        return true
      }
    } else if (wall == 11) {
      if (!this.DungeonLight) {
        return false
      }
      if (dungeon == 'graphic') {
        if (
          this.DungeonWall[1] > 0 ||
          this.DungeonWall[3] > 0 ||
          this.DungeonWall[8] > 0 ||
          this.DungeonSpace[1] == 1 ||
          this.DungeonSpace[3] == 1 ||
          this.DungeonSpace[7] == 1
        ) {
          return false
        } else {
          return true
        }
      } else {
        if (
          this.DungeonWall[8] > 0 ||
          this.DungeonSpace[3] == 1 ||
          this.DungeonSpace[7] == 1
        ) {
          return false
        } else if (
          (this.DungeonWall[1] > 0 ||
            this.DungeonWall[3] > 0 ||
            this.DungeonSpace[1] == 1) &&
          (this.DungeonWall[0] > 0 ||
            this.DungeonWall[6] > 0 ||
            this.DungeonSpace[4] == 1)
        ) {
          return false
        } else {
          return true
        }
      }
    } else if (wall == 12 || wall == 13) {
      if (!this.DungeonLight) {
        return false
      }
      if (
        this.DungeonWall[0] > 0 ||
        this.DungeonWall[5] > 0 ||
        this.DungeonSpace[4] == 1 ||
        this.DungeonSpace[8] == 1
      ) {
        return false
      } else {
        return true
      }
    } else if (wall == 14) {
      if (!this.DungeonLight) {
        return false
      }
      if (dungeon == 'graphic') {
        if (
          this.DungeonWall[2] > 0 ||
          this.DungeonWall[4] > 0 ||
          this.DungeonWall[9] > 0 ||
          this.DungeonSpace[2] == 1 ||
          this.DungeonSpace[5] == 1 ||
          this.DungeonSpace[9] == 1
        ) {
          return false
        } else {
          return true
        }
      } else {
        if (
          this.DungeonWall[9] > 0 ||
          this.DungeonSpace[5] == 1 ||
          this.DungeonSpace[9] == 1
        ) {
          return false
        } else if (
          (this.DungeonWall[2] > 0 ||
            this.DungeonWall[4] > 0 ||
            this.DungeonSpace[2] == 1) &&
          (this.DungeonWall[0] > 0 ||
            this.DungeonWall[7] > 0 ||
            this.DungeonSpace[4] == 1)
        ) {
          return false
        } else {
          return true
        }
      }
    } else if (wall == 15) {
      if (!this.DungeonLight) {
        return false
      }
      if (dungeon == 'graphic') {
        if (
          this.DungeonWall[1] > 0 ||
          this.DungeonWall[3] > 0 ||
          this.DungeonWall[8] > 0 ||
          this.DungeonWall[11] > 0 ||
          this.DungeonSpace[1] == 1 ||
          this.DungeonSpace[3] == 1 ||
          this.DungeonSpace[7] == 1
        ) {
          return false
        } else {
          return true
        }
      } else {
        if (
          this.DungeonWall[8] > 0 ||
          this.DungeonWall[11] > 0 ||
          this.DungeonSpace[3] == 1 ||
          this.DungeonSpace[7] == 1
        ) {
          return false
        } else if (
          (this.DungeonWall[1] > 0 ||
            this.DungeonWall[3] > 0 ||
            this.DungeonSpace[1] == 1) &&
          (this.DungeonWall[0] > 0 ||
            this.DungeonWall[6] > 0 ||
            this.DungeonSpace[4] == 1)
        ) {
          return false
        } else {
          return true
        }
      }
    } else if (wall == 16) {
      if (!this.DungeonLight) {
        return false
      }
      if (dungeon == 'graphic') {
        if (
          (this.DungeonWall[8] > 0 || this.DungeonSpace[3] == 1) &&
          (this.DungeonWall[0] > 0 ||
            this.DungeonWall[5] > 0 ||
            this.DungeonWall[12] > 0 ||
            this.DungeonSpace[4] == 1 ||
            this.DungeonSpace[8] == 1)
        ) {
          return false
        } else if (
          (this.DungeonWall[1] > 0 ||
            this.DungeonWall[3] > 0 ||
            this.DungeonSpace[1] == 1) &&
          (this.DungeonWall[0] > 0 ||
            this.DungeonSpace[4] == 1 ||
            (this.DungeonWall[6] > 0 &&
              (this.DungeonWall[5] > 0 ||
                this.DungeonWall[12] > 0 ||
                this.DungeonSpace[8] == 1)))
        ) {
          return false
        } else {
          return true
        }
      } else {
        if (this.DungeonWall[0] > 0 || this.DungeonSpace[4] == 1) {
          return false
        } else if (
          (this.DungeonWall[6] > 0 ||
            this.DungeonWall[8] > 0 ||
            this.DungeonSpace[3] == 1) &&
          (this.DungeonWall[5] > 0 ||
            this.DungeonWall[12] > 0 ||
            this.DungeonSpace[8] == 1)
        ) {
          return false
        } else {
          return true
        }
      }
    } else if (wall == 17) {
      if (!this.DungeonLight) {
        return false
      }
      if (dungeon == 'graphic') {
        if (
          (this.DungeonWall[9] > 0 || this.DungeonSpace[5] == 1) &&
          (this.DungeonWall[0] > 0 ||
            this.DungeonWall[5] > 0 ||
            this.DungeonWall[13] > 0 ||
            this.DungeonSpace[4] == 1 ||
            this.DungeonSpace[8] == 1)
        ) {
          return false
        } else if (
          (this.DungeonWall[2] > 0 ||
            this.DungeonWall[4] > 0 ||
            this.DungeonSpace[2] == 1) &&
          (this.DungeonWall[0] > 0 ||
            this.DungeonSpace[4] == 1 ||
            (this.DungeonWall[7] > 0 &&
              (this.DungeonWall[5] > 0 ||
                this.DungeonWall[13] > 0 ||
                this.DungeonSpace[8] == 1)))
        ) {
          return false
        } else {
          return true
        }
      } else {
        if (this.DungeonWall[0] > 0 || this.DungeonSpace[4] == 1) {
          return false
        } else if (
          (this.DungeonWall[7] > 0 ||
            this.DungeonWall[9] > 0 ||
            this.DungeonSpace[5] == 1) &&
          (this.DungeonWall[5] > 0 ||
            this.DungeonWall[13] > 0 ||
            this.DungeonSpace[8] == 1)
        ) {
          return false
        } else {
          return true
        }
      }
    } else if (wall == 18) {
      if (!this.DungeonLight) {
        return false
      }
      if (dungeon == 'graphic') {
        if (
          this.DungeonWall[2] > 0 ||
          this.DungeonWall[4] > 0 ||
          this.DungeonWall[9] > 0 ||
          this.DungeonWall[14] > 0 ||
          this.DungeonSpace[2] == 1 ||
          this.DungeonSpace[5] == 1 ||
          this.DungeonSpace[9] == 1
        ) {
          return false
        } else {
          return true
        }
      } else {
        if (
          this.DungeonWall[9] > 0 ||
          this.DungeonWall[14] > 0 ||
          this.DungeonSpace[5] == 1 ||
          this.DungeonSpace[9] == 1
        ) {
          return false
        } else if (
          (this.DungeonWall[2] > 0 ||
            this.DungeonWall[4] > 0 ||
            this.DungeonSpace[2] == 1) &&
          (this.DungeonWall[0] > 0 ||
            this.DungeonWall[7] > 0 ||
            this.DungeonSpace[4] == 1)
        ) {
          return false
        } else {
          return true
        }
      }
    } else if (wall == 19) {
      if (!this.DungeonLight) {
        return false
      }
      if (
        this.DungeonWall[0] > 0 ||
        this.DungeonWall[5] > 0 ||
        this.DungeonWall[10] > 0 ||
        this.DungeonSpace[4] == 1 ||
        this.DungeonSpace[8] == 1
      ) {
        return false
      } else {
        return true
      }
    } else if (wall == 20) {
      if (!this.DungeonLight) {
        return false
      }
      if (dungeon == 'graphic') {
        if (
          this.DungeonWall[8] > 0 ||
          this.DungeonWall[16] > 0 ||
          this.DungeonSpace[3] == 1 ||
          this.DungeonSpace[7] == 1 ||
          this.DungeonSpace[12] == 1
        ) {
          return false
        } else if (
          (this.DungeonWall[1] > 0 ||
            this.DungeonWall[3] > 0 ||
            this.DungeonSpace[1] == 1) &&
          (this.DungeonWall[0] > 0 ||
            this.DungeonWall[6] > 0 ||
            this.DungeonSpace[4] == 1)
        ) {
          return false
        } else {
          return true
        }
      } else {
        if (
          this.DungeonWall[0] > 0 ||
          this.DungeonWall[16] > 0 ||
          this.DungeonSpace[4] == 1 ||
          this.DungeonSpace[12] == 1
        ) {
          return false
        } else if (
          (this.DungeonWall[6] > 0 ||
            this.DungeonWall[8] > 0 ||
            this.DungeonSpace[3] == 1) &&
          (this.DungeonWall[5] > 0 ||
            this.DungeonWall[12] > 0 ||
            this.DungeonSpace[8] == 1)
        ) {
          return false
        } else {
          return true
        }
      }
    } else if (wall == 21 || wall == 22) {
      if (!this.DungeonLight) {
        return false
      }
      if (
        this.DungeonWall[0] > 0 ||
        this.DungeonWall[5] > 0 ||
        this.DungeonWall[10] > 0 ||
        this.DungeonSpace[4] == 1 ||
        this.DungeonSpace[8] == 1 ||
        this.DungeonSpace[13] == 1
      ) {
        return false
      } else {
        return true
      }
    } else if (wall == 23) {
      if (!this.DungeonLight) {
        return false
      }
      if (dungeon == 'graphic') {
        if (
          this.DungeonWall[9] > 0 ||
          this.DungeonWall[17] > 0 ||
          this.DungeonSpace[5] == 1 ||
          this.DungeonSpace[9] == 1 ||
          this.DungeonSpace[14] == 1
        ) {
          return false
        } else if (
          (this.DungeonWall[2] > 0 ||
            this.DungeonWall[4] > 0 ||
            this.DungeonSpace[2] == 1) &&
          (this.DungeonWall[0] > 0 ||
            this.DungeonWall[7] > 0 ||
            this.DungeonSpace[4] == 1)
        ) {
          return false
        } else {
          return true
        }
      } else {
        if (
          this.DungeonWall[0] > 0 ||
          this.DungeonWall[17] > 0 ||
          this.DungeonSpace[4] == 1 ||
          this.DungeonSpace[14] == 1
        ) {
          return false
        } else if (
          (this.DungeonWall[7] > 0 ||
            this.DungeonWall[9] > 0 ||
            this.DungeonSpace[5] == 1) &&
          (this.DungeonWall[5] > 0 ||
            this.DungeonWall[13] > 0 ||
            this.DungeonSpace[8] == 1)
        ) {
          return false
        } else {
          return true
        }
      }
    } else if (wall == 24) {
      if (!this.DungeonLight) {
        return false
      }
      if (dungeon == 'graphic') {
        if (
          this.DungeonWall[8] > 0 ||
          this.DungeonSpace[3] == 1 ||
          this.DungeonSpace[7] == 1
        ) {
          return false
        } else if (
          (this.DungeonWall[11] > 0 ||
            this.DungeonWall[15] > 0 ||
            this.DungeonSpace[6] == 1 ||
            this.DungeonWall[1] > 0 ||
            this.DungeonWall[3] > 0 ||
            this.DungeonSpace[1] == 1) &&
          (this.DungeonWall[20] > 0 ||
            this.DungeonWall[16] > 0 ||
            this.DungeonSpace[12] == 1)
        ) {
          return false
        } else if (
          (this.DungeonWall[1] > 0 ||
            this.DungeonWall[3] > 0 ||
            this.DungeonSpace[1] == 1) &&
          (this.DungeonWall[0] > 0 ||
            this.DungeonWall[6] > 0 ||
            this.DungeonSpace[4] == 1)
        ) {
          return false
        } else {
          return true
        }
      } else {
        if (
          ((this.DungeonWall[16] > 0 ||
            this.DungeonWall[20] > 0 ||
            this.DungeonSpace[12] == 1) &&
            (this.DungeonWall[11] > 0 ||
              this.DungeonWall[15] > 0 ||
              this.DungeonSpace[6] == 1)) ||
          this.DungeonSpace[7] == 1
        ) {
          return false
        } else if (
          (this.DungeonWall[6] > 0 ||
            this.DungeonWall[8] > 0 ||
            this.DungeonSpace[3] == 1) &&
          (this.DungeonWall[5] > 0 ||
            this.DungeonWall[12] > 0 ||
            this.DungeonSpace[8] == 1)
        ) {
          return false
        } else {
          return true
        }
      }
    } else if (wall == 25) {
      if (!this.DungeonLight) {
        return false
      }
      if (dungeon == 'graphic') {
        if (this.DungeonSpace[0] == 1) {
          return false
        } else if (
          (this.DungeonWall[6] > 0 ||
            this.DungeonWall[8] > 0 ||
            this.DungeonSpace[3] == 1) &&
          (this.DungeonWall[5] > 0 || this.DungeonSpace[8] == 1)
        ) {
          return false
        } else if (
          (this.DungeonWall[16] > 0 ||
            this.DungeonSpace[7] == 1 ||
            (this.DungeonWall[12] > 0 &&
              (this.DungeonWall[6] > 0 ||
                this.DungeonWall[8] > 0 ||
                this.DungeonSpace[3] == 1))) &&
          (this.DungeonWall[5] > 0 ||
            this.DungeonWall[10] > 0 ||
            this.DungeonWall[21] > 0 ||
            this.DungeonSpace[8] == 1 ||
            this.DungeonSpace[13] == 1)
        ) {
          return false
        } else {
          return true
        }
      } else {
        if (
          this.DungeonWall[0] > 0 ||
          this.DungeonWall[5] > 0 ||
          this.DungeonSpace[4] == 1
        ) {
          return false
        } else if (
          (this.DungeonWall[12] > 0 ||
            this.DungeonWall[16] > 0 ||
            this.DungeonSpace[7] == 1) &&
          (this.DungeonWall[10] > 0 ||
            this.DungeonWall[21] > 0 ||
            this.DungeonSpace[8] == 1 ||
            this.DungeonSpace[13] == 1)
        ) {
          return false
        } else {
          return true
        }
      }
    } else if (wall == 26) {
      if (!this.DungeonLight) {
        return false
      }
      if (dungeon == 'graphic') {
        if (this.DungeonSpace[0] == 1) {
          return false
        } else if (
          (this.DungeonWall[7] > 0 ||
            this.DungeonWall[9] > 0 ||
            this.DungeonSpace[5] == 1) &&
          (this.DungeonWall[5] > 0 || this.DungeonSpace[8] == 1)
        ) {
          return false
        } else if (
          (this.DungeonWall[17] > 0 ||
            this.DungeonSpace[9] == 1 ||
            (this.DungeonWall[13] > 0 &&
              (this.DungeonWall[7] > 0 ||
                this.DungeonWall[9] > 0 ||
                this.DungeonSpace[5] == 1))) &&
          (this.DungeonWall[5] > 0 ||
            this.DungeonWall[10] > 0 ||
            this.DungeonWall[22] > 0 ||
            this.DungeonSpace[8] == 1 ||
            this.DungeonSpace[13] == 1)
        ) {
          return false
        } else {
          return true
        }
      } else {
        if (
          this.DungeonWall[0] > 0 ||
          this.DungeonWall[5] > 0 ||
          this.DungeonSpace[4] == 1
        ) {
          return false
        } else if (
          (this.DungeonWall[13] > 0 ||
            this.DungeonWall[17] > 0 ||
            this.DungeonSpace[9] == 1) &&
          (this.DungeonWall[10] > 0 ||
            this.DungeonWall[22] > 0 ||
            this.DungeonSpace[8] == 1 ||
            this.DungeonSpace[13] == 1)
        ) {
          return false
        } else {
          return true
        }
      }
    } else if (wall == 27) {
      if (!this.DungeonLight) {
        return false
      }
      if (dungeon == 'graphic') {
        if (
          this.DungeonWall[9] > 0 ||
          this.DungeonSpace[5] == 1 ||
          this.DungeonSpace[9] == 1
        ) {
          return false
        } else if (
          (this.DungeonWall[14] > 0 ||
            this.DungeonWall[18] > 0 ||
            this.DungeonSpace[10] == 1 ||
            this.DungeonWall[2] > 0 ||
            this.DungeonWall[4] > 0 ||
            this.DungeonSpace[2] == 1) &&
          (this.DungeonWall[23] > 0 ||
            this.DungeonWall[17] > 0 ||
            this.DungeonSpace[14] == 1)
        ) {
          return false
        } else if (
          (this.DungeonWall[2] > 0 ||
            this.DungeonWall[4] > 0 ||
            this.DungeonSpace[2] == 1) &&
          (this.DungeonWall[0] > 0 ||
            this.DungeonWall[7] > 0 ||
            this.DungeonSpace[4] == 1)
        ) {
          return false
        } else {
          return true
        }
      } else {
        if (
          ((this.DungeonWall[17] > 0 ||
            this.DungeonWall[23] > 0 ||
            this.DungeonSpace[14] == 1) &&
            (this.DungeonWall[14] > 0 ||
              this.DungeonWall[18] > 0 ||
              this.DungeonSpace[10] == 1)) ||
          this.DungeonSpace[9] == 1
        ) {
          return false
        } else if (
          (this.DungeonWall[7] > 0 ||
            this.DungeonWall[9] > 0 ||
            this.DungeonSpace[5] == 1) &&
          (this.DungeonWall[5] > 0 ||
            this.DungeonWall[13] > 0 ||
            this.DungeonSpace[8] == 1)
        ) {
          return false
        } else {
          return true
        }
      }
    }
  }
  checkPaintWallSide (wall, dungeon) {
    if (dungeon != 'graphic') {
      return false
    }
    if (wall == 3) {
      if (
        this.DungeonWall[3] > 0 &&
        this.DungeonWall[0] == 0 &&
        this.DungeonWall[1] == 0 &&
        this.DungeonWall[6] == 0 &&
        this.DungeonSpace[0] != 1 &&
        this.DungeonSpace[4] != 1
      ) {
        return true
      }
    } else if (wall == 4) {
      if (
        this.DungeonWall[4] > 0 &&
        this.DungeonWall[0] == 0 &&
        this.DungeonWall[2] == 0 &&
        this.DungeonWall[7] == 0 &&
        this.DungeonSpace[0] != 1 &&
        this.DungeonSpace[4] != 1
      ) {
        return true
      }
    } else if (wall == 6) {
      if (
        this.DungeonWall[6] > 0 &&
        this.DungeonWall[1] == 0 &&
        this.DungeonWall[3] == 0 &&
        this.DungeonSpace[1] != 1
      ) {
        return true
      }
    } else if (wall == 7) {
      if (
        this.DungeonWall[7] > 0 &&
        this.DungeonWall[2] == 0 &&
        this.DungeonWall[4] == 0 &&
        this.DungeonSpace[2] != 1
      ) {
        return true
      }
    } else if (wall == 8) {
      if (
        this.DungeonWall[8] > 0 &&
        this.DungeonWall[5] == 0 &&
        this.DungeonWall[6] == 0 &&
        this.DungeonWall[12] == 0 &&
        this.DungeonSpace[4] != 1 &&
        this.DungeonSpace[8] != 1
      ) {
        return true
      }
    } else if (wall == 9) {
      if (
        this.DungeonWall[9] > 0 &&
        this.DungeonWall[5] == 0 &&
        this.DungeonWall[7] == 0 &&
        this.DungeonWall[13] == 0 &&
        this.DungeonSpace[4] != 1 &&
        this.DungeonSpace[8] != 1
      ) {
        return true
      }
    } else if (wall == 12) {
      if (
        this.DungeonWall[12] > 0 &&
        this.DungeonWall[6] == 0 &&
        this.DungeonWall[8] == 0 &&
        this.DungeonSpace[3] != 1
      ) {
        return true
      }
    } else if (wall == 13) {
      if (
        this.DungeonWall[13] > 0 &&
        this.DungeonWall[7] == 0 &&
        this.DungeonWall[9] == 0 &&
        this.DungeonSpace[5] != 1
      ) {
        return true
      }
    } else if (wall == 15) {
      if (
        this.DungeonWall[15] > 0 &&
        this.DungeonWall[11] == 0 &&
        this.DungeonWall[16] == 0 &&
        this.DungeonWall[20] == 0 &&
        this.DungeonSpace[7] != 1 &&
        this.DungeonSpace[12] != 1
      ) {
        return true
      }
    } else if (wall == 16) {
      if (
        this.DungeonWall[16] > 0 &&
        this.DungeonWall[10] == 0 &&
        this.DungeonWall[12] == 0 &&
        this.DungeonWall[21] == 0 &&
        this.DungeonSpace[8] != 1 &&
        this.DungeonSpace[13] != 1
      ) {
        return true
      }
    } else if (wall == 17) {
      if (
        this.DungeonWall[17] > 0 &&
        this.DungeonWall[10] == 0 &&
        this.DungeonWall[13] == 0 &&
        this.DungeonWall[22] == 0 &&
        this.DungeonSpace[8] != 1 &&
        this.DungeonSpace[13] != 1
      ) {
        return true
      }
    } else if (wall == 18) {
      if (
        this.DungeonWall[18] > 0 &&
        this.DungeonWall[14] == 0 &&
        this.DungeonWall[17] == 0 &&
        this.DungeonWall[23] == 0 &&
        this.DungeonSpace[9] != 1 &&
        this.DungeonSpace[14] != 1
      ) {
        return true
      }
    } else if (wall == 20) {
      if (
        this.DungeonWall[20] > 0 &&
        this.DungeonWall[11] == 0 &&
        this.DungeonWall[15] == 0 &&
        this.DungeonSpace[6] != 1
      ) {
        return true
      }
    } else if (wall == 21) {
      if (
        this.DungeonWall[21] > 0 &&
        this.DungeonWall[12] == 0 &&
        this.DungeonWall[16] == 0 &&
        this.DungeonSpace[7] != 1
      ) {
        return true
      }
    } else if (wall == 22) {
      if (
        this.DungeonWall[22] > 0 &&
        this.DungeonWall[13] == 0 &&
        this.DungeonWall[17] == 0 &&
        this.DungeonSpace[9] != 1
      ) {
        return true
      }
    } else if (wall == 23) {
      if (
        this.DungeonWall[23] > 0 &&
        this.DungeonWall[14] == 0 &&
        this.DungeonWall[18] == 0 &&
        this.DungeonSpace[10] != 1
      ) {
        return true
      }
    }
    return false
  }
  checkPolygonFloor3D (imgNum, patternNum, num, typeNum, perspectiveNum) {
    if (imgNum == 0 && perspectiveNum == 1) {
      return false
    } else if (imgNum != 0 && num >= 0 && num <= 2 && perspectiveNum == 1) {
      return false
    }
    return true
  }
  checkPolygonLadder3D (num) {
    if (num == 1 || num == 2 || num == 6 || num == 10) {
      return false
    }
    return true
  }
  checkPolygonWall3D (imgNum, num, perspectiveNum) {
    if (imgNum == 0) {
      return false
    } else if (
      imgNum >= 1 &&
      imgNum <= 4 &&
      num >= 0 &&
      num <= 4 &&
      perspectiveNum == 1
    ) {
      return false
    } else if (imgNum == 5 && (num != 28 || perspectiveNum == 1)) {
      return false
    } else if (
      imgNum == 6 &&
      (num == 1 ||
        num == 2 ||
        num == 28 ||
        (num >= 30 && num <= 59) ||
        perspectiveNum == 1)
    ) {
      return false
    } else if (
      imgNum == 7 &&
      ((num >= 0 && num <= 32) ||
        num == 35 ||
        num == 40 ||
        num == 41 ||
        num == 44 ||
        num == 49 ||
        num >= 54)
    ) {
      return false
    }
    return true
  }
  clearDungeonPaintData () {
    for (let i = 0; i < 16; i++) {
      this.DungeonSpace[i] = 0
    }
    for (let i = 0; i < 28; i++) {
      this.DungeonWall[i] = 0
    }
  }
  clearMainWindow (bgColor) {
    while (this.Sprite3D.childNodes.length > 0) {
      this.Sprite3D.removeChild(this.Sprite3D.childNodes[0])
    }
    this.MainSurface.clear()
    this.viewPartyStatus(false)
    this.clearTextSurface('all')
    this.TopSurface.clear()
    this.paintMask('clear')
    if (this.OptionParts != undefined) {
      if (this.OptionParts['text']._element.style.visibility == 'visible') {
        this.controlInputText('clear')
      }
    }
    if (bgColor != undefined && bgColor != null) {
      this.MainSurface.context.fillStyle = bgColor
      this.MainSurface.context.fillRect(
        this.MAIN_X,
        this.MAIN_Y,
        this.MAIN_WIDTH,
        this.MAIN_HEIGHT
      )
    }
  }
  clearTextSurface (num) {
    if (num == undefined || num == null || num < 0) {
      if (
        this.TextSurfaceNum > -1 &&
        this.TextSurfaceNum < this.TextSurface.length
      ) {
        this.TextSurface[this.TextSurfaceNum].clear()
      }
    } else if (num == 'all' || num == 'full') {
      this.TextSurfaceNum = 0
      for (let i = 0; i < this.TextSurface.length; i++) {
        this.TextSurface[i].clear()
      }
    } else if (num < this.TextSurface.length) {
      this.TextSurface[num].clear()
    }
  }
  controlInputText (mode) {
    if (mode == 'set') {
      this.ButtonObject['game_window_div'].style.display = 'none'
      if (this.ButtonObject['escape_div'] != undefined) {
        this.ButtonObject['escape_div'].style.display = 'none'
      }
      removeKeyEvent()
      this.OptionParts['text']._element.value = ''
      this.OptionParts['text']._element.setSelectionRange(0, 0)
      this.OptionParts['text']._element.style.visibility = 'visible'
      this.OptionParts['text']._element.addEventListener(
        'keydown',
        eventKeydownInputText
      )
      this.OptionParts['text']._element.focus()
      GenericVariable['TextMemoryNum'] = -1
    } else if (mode == 'clear') {
      this.ButtonObject['game_window_div'].style.display = ''
      if (this.ButtonObject['escape_div'] != undefined) {
        this.ButtonObject['escape_div'].style.display = ''
      }
      this.OptionParts['text']._element.removeEventListener(
        'keydown',
        eventKeydownInputText
      )
      this.OptionParts['text']._element.style.visibility = 'hidden'
      this.OptionParts['text']._element.value = ''
      addKeyEvent()
      window.focus()
    }
  }
  controlPreSelect (mode) {
    for (let i = 0; i < this.PreSelectKey.length; i++) {
      if (mode == undefined || mode == null || mode == 'clear') {
        this.PreSelect[this.PreSelectKey[i]] = []
      } else if (mode == 'push') {
        if (Array.isArray(this.SelectMode[this.PreSelectKey[i]])) {
          this.PreSelect[this.PreSelectKey[i]].push(
            this.SelectMode[this.PreSelectKey[i]].slice()
          )
        } else {
          this.PreSelect[this.PreSelectKey[i]].push(
            this.SelectMode[this.PreSelectKey[i]]
          )
        }
      } else if (mode == 'pop') {
        let popPreSel = this.PreSelect[this.PreSelectKey[i]].pop()
        if (Array.isArray(popPreSel)) {
          this.SelectMode[this.PreSelectKey[i]] = popPreSel.slice()
        } else {
          this.SelectMode[this.PreSelectKey[i]] = popPreSel
        }
      }
    }
  }
  controlSelect (mode, listNum, selStr, valueStr) {
    if (mode.match(/^(delete|deleteSlide)$/)) {
      let num = this.SelectMode['select']
      if (num >= this.SelectMode['selAry'].length - 1) {
        num = this.SelectMode['selAry'].length - 2
        if (
          this.SelectMode['selectF'] >=
          this.SelectMode['selAry'].length - 1
        ) {
          this.SelectMode['selectF'] = this.SelectMode['selAry'].length - 2
          if (this.SelectMode['selectF'] < 0) {
            this.SelectMode['selectF'] = 0
          }
        }
      }
      if (mode == 'delete') {
        this.SelectMode['selAry'].splice(this.SelectMode['select'], 1)
        this.SelectMode['valueAry'].splice(this.SelectMode['select'], 1)
        if (this.SelectMode['selAry'].length < 1) {
          num = -1
        }
      } else if (this.SelectMode['selAry'].length < 2) {
        num = -1
      }
      this.SelectMode['select'] = num
    } else if (mode == 'add') {
      this.SelectMode['selAry'].splice(listNum, 0, selStr)
      this.SelectMode['valueAry'].splice(listNum, 0, valueStr)
    }
    return this.SelectMode['valueAry'][this.SelectMode['select']]
  }
  createButton (name, w, h, normalAppearance, onMouseAppearance, pointer) {
    if (GoverdryPatch) {
      console.log('[Goverdry]createButton skip')
      console.log(name, w, h, normalAppearance, onMouseAppearance, pointer)
      return
    }
    normalAppearance = checkNull(normalAppearance, null)
    onMouseAppearance = checkNull(onMouseAppearance, null)
    pointer = checkNull(pointer, true)
    let nameDiv = name + '_div'
    this.ButtonObject[nameDiv] = document.createElement('div')
    this.ButtonObject[nameDiv].setAttribute('id', nameDiv)
    this.ButtonObject[nameDiv].style.position = 'absolute'
    let sf = document.createElement('canvas')
    ;(sf.width = w), (sf.height = h), (sf.style.position = 'absolute')
    sf.setAttribute('id', name)
    this.ButtonObject[nameDiv].normalAppearance = normalAppearance
    this.ButtonObject[nameDiv].onMouseAppearance = onMouseAppearance
    if (normalAppearance != null) {
      sf.getContext('2d').drawImage(normalAppearance, 0, 0)
    }
    this.ButtonObject[nameDiv].appendChild(sf)
    this.ButtonObject[nameDiv].x = 0
    this.ButtonObject[nameDiv].y = 0
    this.ButtonObject[nameDiv].width = w
    this.ButtonObject[nameDiv].height = h
    this.ButtonObject[nameDiv].clickCount = -1
    if (pointer) {
      this.ButtonObject[nameDiv].style.cursor = 'pointer'
    }
    let stage = document.getElementById('enchant-stage')
    stage.appendChild(this.ButtonObject[nameDiv])
  }
  createControlButton (position) {
    if (GoverdryPatch) {
      console.log('[Goverdry]createControlButton skip')
      console.log(position)
      return
    }
    let w = this.MAIN_WIDTH
    let h = this.MAIN_HEIGHT
    this.createButton('game_window', w, h, null, null, false)
    w = this.CONTROLLER_WIDTH
    h = this.CONTROLLER_HEIGHT
    this.createButton('controller', w, h, null, null, false)
    this.ButtonObject['controller_div'].y = this.CONTROLLER_Y
    w = calTimes(this.MAIN_WIDTH, 0.65)
    h = this.MAIN_HEIGHT
    this.createButton('keyConfigCancel', w, h, null, null, false)
    this.ButtonObject['keyConfigCancel_div'].x = calTimes(this.MAIN_WIDTH, 0.35)
    this.ButtonObject['keyConfigCancel_div'].style.display = 'none'
    let unit = calTimes(this.CONTROLLER_WIDTH, 0.0162)
    w = (6 + 2) * unit
    h = unit * 4
    let normalImg = createControlButtonCreateTextImg(
      this,
      w,
      h,
      'Option',
      'white'
    )
    let onMouseImg = createControlButtonCreateTextImg(
      this,
      w,
      h,
      'Option',
      'dodgerblue'
    )
    this.createButton('option', w, h, normalImg, onMouseImg)
    if (LaunchSettings['Controller']) {
      w = calTimes(this.MAIN_WIDTH, 0.5)
      h = calTimes(this.MAIN_HEIGHT, 0.2)
      onMouseImg = document.createElement('canvas')
      ;(onMouseImg.width = w), (onMouseImg.height = h)
      onMouseImg.getContext('2d').globalAlpha = 0.5
      this.drawRect(onMouseImg, 0, 0, w, h, 0, 0, 'dodgerblue', '')
      this.createButton('escape', w, h, null, onMouseImg, true)
      this.ButtonObject['escape_div'].x = calTimes(this.MAIN_WIDTH, 0.25)
      this.ButtonObject['escape_div'].y = calTimes(this.MAIN_HEIGHT, 0.8)
      w = calTimes(this.MAIN_WIDTH, 0.5)
      h = calTimes(this.MAIN_HEIGHT, 0.2)
      this.createButton('debug', w, h, null, null, false)
      this.ButtonObject['debug_div'].x = calTimes(this.MAIN_WIDTH, 0.25)
      this.ButtonObject['debug_div'].y = calTimes(this.MAIN_HEIGHT, 0.4)
      w = (5 + 2) * unit
      h = unit * 4
      normalImg = createControlButtonCreateTextImg(this, w, h, 'Reset', 'white')
      onMouseImg = createControlButtonCreateTextImg(
        this,
        w,
        h,
        'Reset',
        'dodgerblue'
      )
      this.createButton('reset', w, h, normalImg, onMouseImg)
      w = calTimes(11, unit)
      h = calTimes(11, unit)
      normalImg = createControlButtonCreateArrowImg(this, w, h, 'up', 'white')
      onMouseImg = createControlButtonCreateArrowImg(
        this,
        w,
        h,
        'up',
        'dodgerblue'
      )
      this.createButton('up', w, h, normalImg, onMouseImg, true)
      normalImg = createControlButtonCreateArrowImg(this, w, h, 'down', 'white')
      onMouseImg = createControlButtonCreateArrowImg(
        this,
        w,
        h,
        'down',
        'dodgerblue'
      )
      this.createButton('down', w, h, normalImg, onMouseImg, true)
      normalImg = createControlButtonCreateArrowImg(
        this,
        w,
        h,
        'right',
        'white'
      )
      onMouseImg = createControlButtonCreateArrowImg(
        this,
        w,
        h,
        'right',
        'dodgerblue'
      )
      this.createButton('right', w, h, normalImg, onMouseImg, true)
      normalImg = createControlButtonCreateArrowImg(this, w, h, 'left', 'white')
      onMouseImg = createControlButtonCreateArrowImg(
        this,
        w,
        h,
        'left',
        'dodgerblue'
      )
      this.createButton('left', w, h, normalImg, onMouseImg, true)
      h = 9 * unit
      normalImg = createControlButtonCreateArrowImg(
        this,
        w,
        h,
        'shift_right',
        'white'
      )
      onMouseImg = createControlButtonCreateArrowImg(
        this,
        w,
        h,
        'shift_right',
        'dodgerblue'
      )
      this.createButton('shift_right', w, h, normalImg, onMouseImg, true)
      normalImg = createControlButtonCreateArrowImg(
        this,
        w,
        h,
        'shift_left',
        'white'
      )
      onMouseImg = createControlButtonCreateArrowImg(
        this,
        w,
        h,
        'shift_left',
        'dodgerblue'
      )
      this.createButton('shift_left', w, h, normalImg, onMouseImg, true)
      w = calTimes(12, unit)
      h = calTimes(12, unit)
      normalImg = createControlButtonCreateTextImg(this, w, h, 'Enter', 'white')
      onMouseImg = createControlButtonCreateTextImg(
        this,
        w,
        h,
        'Enter',
        'dodgerblue'
      )
      this.createButton('enter', w, h, normalImg, onMouseImg)
      normalImg = createControlButtonCreateTextImg(
        this,
        w,
        h,
        'Cancel',
        'white'
      )
      onMouseImg = createControlButtonCreateTextImg(
        this,
        w,
        h,
        'Cancel',
        'dodgerblue'
      )
      this.createButton('cancel', w, h, normalImg, onMouseImg)
      h = 8 * unit
      normalImg = createControlButtonCreateTextImg(
        this,
        w,
        h,
        'Submenu',
        'white'
      )
      onMouseImg = createControlButtonCreateTextImg(
        this,
        w,
        h,
        'Submenu',
        'dodgerblue'
      )
      this.createButton('submenu', w, h, normalImg, onMouseImg)
      normalImg = createControlButtonCreateTextImg(this, w, h, 'Map', 'white')
      onMouseImg = createControlButtonCreateTextImg(
        this,
        w,
        h,
        'Map',
        'dodgerblue'
      )
      this.createButton('map', w, h, normalImg, onMouseImg)
      normalImg = createControlButtonCreateTextImg(
        this,
        w,
        h,
        'Status',
        'white'
      )
      onMouseImg = createControlButtonCreateTextImg(
        this,
        w,
        h,
        'Status',
        'dodgerblue'
      )
      this.createButton('status', w, h, normalImg, onMouseImg)
    }
    this.setAlignControlButton(position)
    resizeWindow()
    function createControlButtonCreateArrowImg (self, w, h, type, color) {
      let img = document.createElement('canvas')
      ;(img.width = w), (img.height = h)
      let ctx = img.getContext('2d')
      ctx.globalAlpha = 0.8
      self.drawRect(
        img,
        self.BUTTON_FRAME_WIDTH,
        self.BUTTON_FRAME_WIDTH,
        w - self.BUTTON_FRAME_WIDTH * 2,
        h - self.BUTTON_FRAME_WIDTH * 2,
        self.BUTTON_FRAME_ARC,
        0,
        color,
        ''
      )
      ctx.globalAlpha = 1.0
      self.drawRect(
        img,
        self.BUTTON_FRAME_WIDTH,
        self.BUTTON_FRAME_WIDTH,
        w - self.BUTTON_FRAME_WIDTH * 2,
        h - self.BUTTON_FRAME_WIDTH * 2,
        self.BUTTON_FRAME_ARC,
        self.BUTTON_FRAME_WIDTH,
        '',
        'black'
      )
      ctx.strokeStyle = 'black'
      ctx.lineWidth = 2 * self.BUTTON_FRAME_WIDTH
      ctx.lineCap = 'round'
      ctx.lineJoin = 'round'
      let pX = [],
        pY = []
      pX[0] = calDiv(w, 6)
      pY[0] = calDiv(h, 6)
      pX[1] = calDiv(w, 2)
      pY[1] = pY[0]
      pX[2] = calTimes(5, calDiv(w, 6))
      pY[2] = pY[0]
      pX[3] = pX[0]
      pY[3] = calDiv(h, 2)
      pX[4] = pX[2]
      pY[4] = pY[3]
      pX[5] = pX[0]
      pY[5] = calTimes(5, calDiv(h, 6))
      pX[6] = pX[1]
      pY[6] = pY[5]
      pX[7] = pX[2]
      pY[7] = pY[5]
      ctx.beginPath()
      if (type == 'up') {
        ctx.moveTo(pX[5], pY[5])
        ctx.lineTo(pX[1], pY[1])
        ctx.lineTo(pX[7], pY[7])
        ctx.stroke()
      } else if (type == 'down') {
        ctx.moveTo(pX[0], pY[0])
        ctx.lineTo(pX[6], pY[6])
        ctx.lineTo(pX[2], pY[2])
        ctx.stroke()
      } else if (type == 'right') {
        ctx.moveTo(pX[0], pY[0])
        ctx.lineTo(pX[4], pY[4])
        ctx.lineTo(pX[5], pY[5])
        ctx.stroke()
      } else if (type == 'left') {
        ctx.moveTo(pX[2], pY[2])
        ctx.lineTo(pX[3], pY[3])
        ctx.lineTo(pX[7], pY[7])
        ctx.stroke()
      } else if (type == 'shift_right') {
        ctx.moveTo(pX[3], pY[3])
        ctx.lineTo(pX[4], pY[4])
        ctx.stroke()
        ctx.moveTo(calTimes(4, calDiv(w, 6)), calTimes(2, calDiv(h, 6)))
        ctx.lineTo(pX[4], pY[4])
        ctx.lineTo(calTimes(4, calDiv(w, 6)), calTimes(4, calDiv(h, 6)))
        ctx.stroke()
      } else if (type == 'shift_left') {
        ctx.moveTo(pX[3], pY[3])
        ctx.lineTo(pX[4], pY[4])
        ctx.stroke()
        ctx.moveTo(calTimes(2, calDiv(w, 6)), calTimes(2, calDiv(h, 6)))
        ctx.lineTo(pX[3], pY[3])
        ctx.lineTo(calTimes(2, calDiv(w, 6)), calTimes(4, calDiv(h, 6)))
        ctx.stroke()
      }
      return img
    }
    function createControlButtonCreateTextImg (self, w, h, text, color) {
      let img = document.createElement('canvas')
      ;(w = Math.ceil(w)), (h = Math.ceil(h))
      ;(img.width = w), (img.height = h)
      let ctx = img.getContext('2d')
      ctx.globalAlpha = 0.8
      self.drawRect(
        img,
        self.BUTTON_FRAME_WIDTH,
        self.BUTTON_FRAME_WIDTH,
        calMinus(w, calTimes(self.BUTTON_FRAME_WIDTH, 3)),
        calMinus(h, calTimes(self.BUTTON_FRAME_WIDTH, 3)),
        self.BUTTON_FRAME_ARC,
        0,
        color,
        ''
      )
      ctx.globalAlpha = 1.0
      self.drawRect(
        img,
        self.BUTTON_FRAME_WIDTH,
        self.BUTTON_FRAME_WIDTH,
        calMinus(w, calTimes(self.BUTTON_FRAME_WIDTH, 3)),
        calMinus(h, calTimes(self.BUTTON_FRAME_WIDTH, 3)),
        self.BUTTON_FRAME_ARC,
        self.BUTTON_FRAME_WIDTH,
        '',
        'black'
      )
      ctx.font = self.FONT_SIZE + 'px ' + self.FONT_NAME
      ctx.fillStyle = 'black'
      ctx.textBaseline = 'middle'
      let metrics = ctx.measureText(text)
      let centerPoint = calDiv(w, 2)
      ctx.fillText(
        text,
        calMinus(centerPoint, calDiv(metrics.width, 2)),
        calDiv(h, 2)
      )
      return img
    }
  }
  createFloor3D (imgNum, patternNum, num, typeNum, perspectiveNum) {
    if (
      !this.checkPolygonFloor3D(
        imgNum,
        patternNum,
        num,
        typeNum,
        perspectiveNum
      )
    ) {
      return
    }
    this.Floor3D[imgNum][patternNum][num][typeNum][perspectiveNum] =
      new PlaneXZ()
    this.Floor3D[imgNum][patternNum][num][typeNum][
      perspectiveNum
    ].mesh.texture.specular = [0.0, 0.0, 0.0, 1.0]
    if (imgNum == 0) {
      this.Floor3D[imgNum][patternNum][num][typeNum][
        perspectiveNum
      ].mesh.texture.diffuse = [0.0, 0.0, 0.0, 1.0]
      this.Floor3D[imgNum][patternNum][num][typeNum][
        perspectiveNum
      ].mesh.texture.ambient = [0.0, 0.0, 0.0, 1.0]
    } else {
      if (perspectiveNum == 1) {
        if (num >= 3 && num <= 5) {
          this.Floor3D[imgNum][patternNum][num][typeNum][
            perspectiveNum
          ].mesh.texture.ambient = [0.08, 0.08, 0.08, 1.0]
          this.Floor3D[imgNum][patternNum][num][typeNum][
            perspectiveNum
          ].mesh.texture.diffuse = [0.8, 0.8, 0.8, 1.0]
        } else if (num >= 6 && num <= 10) {
          this.Floor3D[imgNum][patternNum][num][typeNum][
            perspectiveNum
          ].mesh.texture.ambient = [0.06, 0.06, 0.06, 1.0]
          this.Floor3D[imgNum][patternNum][num][typeNum][
            perspectiveNum
          ].mesh.texture.diffuse = [0.6, 0.6, 0.6, 1.0]
        } else if (num >= 11 && num <= 15) {
          this.Floor3D[imgNum][patternNum][num][typeNum][
            perspectiveNum
          ].mesh.texture.ambient = [0.04, 0.04, 0.04, 1.0]
          this.Floor3D[imgNum][patternNum][num][typeNum][
            perspectiveNum
          ].mesh.texture.diffuse = [0.4, 0.4, 0.4, 1.0]
        }
      }
    }
    this.Floor3D[imgNum][patternNum][num][typeNum][perspectiveNum].rotatePitch(
      Math.PI
    )
    this.Floor3D[imgNum][patternNum][num][typeNum][perspectiveNum].scale(
      this.X_AXIS_MAGNIFICATION,
      1.0,
      this.Z_AXIS_MAGNIFICATION
    )
    if (typeNum == 1) {
      this.Floor3D[imgNum][patternNum][num][typeNum][perspectiveNum].y = 0.5
    } else {
      this.Floor3D[imgNum][patternNum][num][typeNum][perspectiveNum].y = -0.5
    }
    if (num == 1 || num == 3 || num == 7 || num == 12) {
      this.Floor3D[imgNum][patternNum][num][typeNum][perspectiveNum].x =
        -1 * this.X_AXIS_MAGNIFICATION
    } else if (num == 2 || num == 5 || num == 9 || num == 14) {
      this.Floor3D[imgNum][patternNum][num][typeNum][perspectiveNum].x =
        this.X_AXIS_MAGNIFICATION
    } else if (num == 6 || num == 11) {
      this.Floor3D[imgNum][patternNum][num][typeNum][perspectiveNum].x =
        -2 * this.X_AXIS_MAGNIFICATION
    } else if (num == 10 || num == 15) {
      this.Floor3D[imgNum][patternNum][num][typeNum][perspectiveNum].x =
        2 * this.X_AXIS_MAGNIFICATION
    }
    if (num <= 2) {
      this.Floor3D[imgNum][patternNum][num][typeNum][perspectiveNum].z =
        this.Z_AXIS_REFERENCE_VALUE + this.Z_AXIS_MAGNIFICATION * 2
    } else if (num >= 3 && num <= 5) {
      this.Floor3D[imgNum][patternNum][num][typeNum][perspectiveNum].z =
        this.Z_AXIS_REFERENCE_VALUE + this.Z_AXIS_MAGNIFICATION
    } else if (num >= 6 && num <= 10) {
      this.Floor3D[imgNum][patternNum][num][typeNum][perspectiveNum].z =
        this.Z_AXIS_REFERENCE_VALUE
    } else if (num >= 11 && num <= 15) {
      this.Floor3D[imgNum][patternNum][num][typeNum][perspectiveNum].z =
        this.Z_AXIS_REFERENCE_VALUE - this.Z_AXIS_MAGNIFICATION
    }
  }
  createLadder3D (imgNum, num, perspectiveNum) {
    if (!this.checkPolygonLadder3D(num)) {
      return
    }
    this.Ladder3D[imgNum][num][perspectiveNum] = new Plane()
    this.Ladder3D[imgNum][num][perspectiveNum].mesh.texture.specular = [
      0.0, 0.0, 0.0, 1.0
    ]
    if (perspectiveNum == 1) {
      if (num >= 3 && num <= 5) {
        this.Ladder3D[imgNum][num][perspectiveNum].mesh.texture.ambient = [
          0.08, 0.08, 0.08, 1.0
        ]
        this.Ladder3D[imgNum][num][perspectiveNum].mesh.texture.diffuse = [
          0.8, 0.8, 0.8, 1.0
        ]
      } else if (num >= 6 && num <= 10) {
        this.Ladder3D[imgNum][num][perspectiveNum].mesh.texture.ambient = [
          0.06, 0.06, 0.06, 1.0
        ]
        this.Ladder3D[imgNum][num][perspectiveNum].mesh.texture.diffuse = [
          0.6, 0.6, 0.6, 1.0
        ]
      } else if (num >= 11 && num <= 15) {
        this.Ladder3D[imgNum][num][perspectiveNum].mesh.texture.ambient = [
          0.04, 0.04, 0.04, 1.0
        ]
        this.Ladder3D[imgNum][num][perspectiveNum].mesh.texture.diffuse = [
          0.4, 0.4, 0.4, 1.0
        ]
      }
    }
    this.Ladder3D[imgNum][num][perspectiveNum].scale(
      this.X_AXIS_MAGNIFICATION,
      1.0,
      1.0
    )
    if (num == 0) {
      this.Ladder3D[imgNum][num][perspectiveNum].z = calTimes(
        this.Z_AXIS_MAGNIFICATION,
        1.5
      )
      if (imgNum == 0) {
        this.Ladder3D[imgNum][num][perspectiveNum].y = 0.05
      } else {
        this.Ladder3D[imgNum][num][perspectiveNum].rotateRoll(Math.PI)
        this.Ladder3D[imgNum][num][perspectiveNum].y = -0.05
      }
    } else if (num >= 3 && num <= 5) {
      this.Ladder3D[imgNum][num][perspectiveNum].z = calTimes(
        this.Z_AXIS_MAGNIFICATION,
        0.5
      )
      if (num == 3) {
        this.Ladder3D[imgNum][num][perspectiveNum].x =
          -1 * this.X_AXIS_MAGNIFICATION
      } else if (num == 5) {
        this.Ladder3D[imgNum][num][perspectiveNum].x = this.X_AXIS_MAGNIFICATION
      }
      if (imgNum == 1) {
        this.Ladder3D[imgNum][num][perspectiveNum].rotateRoll(Math.PI)
      }
    } else if (num >= 7 && num <= 9) {
      this.Ladder3D[imgNum][num][perspectiveNum].z = calTimes(
        this.Z_AXIS_MAGNIFICATION,
        -0.5
      )
      if (num == 7) {
        this.Ladder3D[imgNum][num][perspectiveNum].x =
          -1 * this.X_AXIS_MAGNIFICATION
      } else if (num == 9) {
        this.Ladder3D[imgNum][num][perspectiveNum].x = this.X_AXIS_MAGNIFICATION
      }
      if (imgNum == 1) {
        this.Ladder3D[imgNum][num][perspectiveNum].rotateRoll(Math.PI)
      }
    } else if (num >= 11 && num <= 15) {
      this.Ladder3D[imgNum][num][perspectiveNum].z = calTimes(
        this.Z_AXIS_MAGNIFICATION,
        -1.5
      )
      if (num == 11) {
        this.Ladder3D[imgNum][num][perspectiveNum].x =
          -2 * this.X_AXIS_MAGNIFICATION
      } else if (num == 12) {
        this.Ladder3D[imgNum][num][perspectiveNum].x =
          -1 * this.X_AXIS_MAGNIFICATION
      } else if (num == 14) {
        this.Ladder3D[imgNum][num][perspectiveNum].x = this.X_AXIS_MAGNIFICATION
      } else if (num == 15) {
        this.Ladder3D[imgNum][num][perspectiveNum].x =
          2 * this.X_AXIS_MAGNIFICATION
      }
      if (imgNum == 1) {
        this.Ladder3D[imgNum][num][perspectiveNum].rotateRoll(Math.PI)
      }
    }
  }
  createOptionParts () {
    this.OptionParts = {}
    this.OptionParts['text'] = new Entity()
    this.OptionParts['text']._element = document.createElement('input')
    this.OptionParts['text']._element.setAttribute('type', 'text')
    this.OptionParts['text']._element.style.fontFamily = this.FONT_NAME
    this.OptionParts['text']._element.style.fontSize = this.FONT_SIZE + 'px'
    this.OptionParts['text']._element.style.border = '0px solid'
    this.OptionParts['text']._element.style.padding =
      Math.ceil(calDiv(this.FONT_SIZE, 4)) + 'px'
    this.OptionParts['text']._element.style.borderRadius =
      Math.ceil(calDiv(this.FONT_SIZE, 5)) + 'px'
    this.OptionParts['text'].width = this.FONT_SIZE * 24
    this.OptionParts['text'].height = this.FONT_SIZE * 1.5
    this.OptionParts['text'].x =
      this.MAIN_X + (this.MAIN_WIDTH / 2 - this.OptionParts['text'].width / 2)
    this.OptionParts['text'].y = this.MAIN_Y + this.LINE_HEIGHT * 8
    GameBody.rootScene.addChild(this.OptionParts['text'])
    this.OptionParts['text']._element.style.visibility = 'hidden'
    let xBase = this.MAIN_X + this.MAIN_WIDTH / 2 - this.FONT_HALF_SIZE * 25
    for (let i = 0; i < OPTION_NAME.length; i++) {
      for (let j = 0; j < 2; j++) {
        let name = OPTION_NAME[i] + '_' + j
        this.OptionParts[name] = new Entity()
        this.OptionParts[name]._element = document.createElement('input')
        this.OptionParts[name]._element.setAttribute('type', 'radio')
        this.OptionParts[name]._element.setAttribute('name', OPTION_NAME[i])
        this.OptionParts[name]._element.addEventListener(
          'change',
          eventChangeRadioButton
        )
        this.OptionParts[name]._element.style.cursor = 'pointer'
        this.OptionParts[name].width = this.FONT_SIZE
        this.OptionParts[name].height = this.FONT_SIZE
        let x = this.FONT_HALF_SIZE
        if (this.MAIN_WIDTH <= 350) {
          x *= 19.7
        } else if (this.MAIN_WIDTH <= 400) {
          x *= 20
        } else if (this.MAIN_WIDTH <= 500) {
          x *= 20.5
        } else {
          x *= 21
        }
        let y = this.LINE_HEIGHT
        if (this.MAIN_WIDTH <= 350) {
          y *= 2.6
        } else if (this.MAIN_WIDTH <= 400) {
          y *= 2.8
        } else if (this.MAIN_WIDTH <= 600) {
          y *= 2.85
        } else if (this.MAIN_WIDTH <= 1000) {
          y *= 2.9
        } else {
          y *= 3.0
        }
        this.OptionParts[name].x = xBase + x + this.FONT_HALF_SIZE * 14 * j
        this.OptionParts[name].y = this.MAIN_Y + y + this.LINE_HEIGHT * 2.2 * i
        GameBody.rootScene.addChild(this.OptionParts[name])
        this.OptionParts[name]._element.style.visibility = 'hidden'
      }
    }
    let vol_x = this.MAIN_X + this.MAIN_WIDTH / 2 - this.FONT_HALF_SIZE * 25
    let vol_y = this.MAIN_Y + this.LINE_HEIGHT * 3
    let vol_y2 = this.LINE_HEIGHT * 2.2
    for (let i = 0; i < 2; i++) {
      for (let j = 0; j < 3; j++) {
        var name
        if (i == 0) {
          name = 'bgm_volume'
        } else {
          name = 'se_volume'
        }
        if (j == 0) {
          name += '_down'
        } else if (j == 2) {
          name += '_up'
        }
        this.OptionParts[name] = new Entity()
        this.OptionParts[name]._element = document.createElement('div')
        this.OptionParts[name]._element.style.position = 'absolute'
        this.OptionParts[name]._element.style.fontFamily = this.FONT_NAME
        this.OptionParts[name]._element.style.fontSize = this.FONT_SIZE + 'px'
        if (j == 1) {
          this.OptionParts[name]._element.style.textAlign = 'right'
          this.OptionParts[name]._element.style.color = 'white'
          this.OptionParts[name].width = this.FONT_HALF_SIZE * 3
        } else {
          this.OptionParts[name]._element.setAttribute('id', name)
          this.OptionParts[name]._element.style.borderRadius =
            Math.floor(this.FONT_SIZE / 6) + 'px'
          this.OptionParts[name]._element.style.backgroundColor = 'white'
          this.OptionParts[name]._element.style.color = 'black'
          this.OptionParts[name]._element.style.cursor = 'pointer'
          this.OptionParts[name].width = this.FONT_HALF_SIZE * 2
        }
        this.OptionParts[name].height = this.FONT_SIZE
        if (j == 0) {
          this.OptionParts[name]._element.textContent = '<<'
        } else if (j == 2) {
          this.OptionParts[name]._element.textContent = '>>'
        } else {
          this.OptionParts[name]._element.textContent = '100'
        }
        let vol_x_plus
        if (j == 0) {
          vol_x_plus = this.FONT_HALF_SIZE * 11
        } else if (j == 1) {
          vol_x_plus = this.FONT_HALF_SIZE * 14
        } else {
          vol_x_plus = this.FONT_HALF_SIZE * 18
        }
        this.OptionParts[name].x = vol_x + vol_x_plus
        this.OptionParts[name].y = vol_y + vol_y2 * i
        GameBody.rootScene.addChild(this.OptionParts[name])
        this.OptionParts[name]._element.style.visibility = 'hidden'
      }
    }
    for (let i = 0; i < OPTION_BUTTON_NAME.length; i++) {
      this.OptionParts[OPTION_BUTTON_NAME[i]] = new Entity()
      this.OptionParts[OPTION_BUTTON_NAME[i]]._element =
        document.createElement('input')
      this.OptionParts[OPTION_BUTTON_NAME[i]]._element.setAttribute(
        'type',
        'submit'
      )
      this.OptionParts[OPTION_BUTTON_NAME[i]]._element.value =
        OPTION_BUTTON_NAME[i]
      this.OptionParts[OPTION_BUTTON_NAME[i]]._element.style.padding = 0
      this.OptionParts[OPTION_BUTTON_NAME[i]]._element.style.fontFamily =
        this.FONT_NAME
      this.OptionParts[OPTION_BUTTON_NAME[i]]._element.style.fontSize =
        this.FONT_SIZE + 'px'
      this.OptionParts[OPTION_BUTTON_NAME[i]]._element.style.color = 'black'
      this.OptionParts[OPTION_BUTTON_NAME[i]]._element.style.borderStyle =
        'none'
      this.OptionParts[OPTION_BUTTON_NAME[i]]._element.style.WebkitAppearance =
        'none'
      this.OptionParts[OPTION_BUTTON_NAME[i]]._element.style.borderRadius =
        calDiv(this.FONT_SIZE, 5) + 'px'
      this.OptionParts[OPTION_BUTTON_NAME[i]]._element.style.backgroundColor =
        'white'
      this.OptionParts[OPTION_BUTTON_NAME[i]]._element.style.cursor = 'pointer'
      this.OptionParts[OPTION_BUTTON_NAME[i]].width =
        this.FONT_HALF_SIZE * (OPTION_BUTTON_NAME[i].length + 4)
      this.OptionParts[OPTION_BUTTON_NAME[i]].height = calTimes(
        this.FONT_SIZE,
        1.6
      )
      let x, y
      if (i == 0) {
        x = xBase + this.FONT_HALF_SIZE * 21
        y = this.LINE_HEIGHT * 2.5 + this.LINE_HEIGHT * 2.2 * 7
        this.OptionParts[OPTION_BUTTON_NAME[i]]._element.addEventListener(
          'click',
          eventClickBackup
        )
      } else if (i == 1) {
        x = xBase + this.FONT_HALF_SIZE * 21 + this.FONT_HALF_SIZE * 14
        y = this.LINE_HEIGHT * 2.5 + this.LINE_HEIGHT * 2.2 * 7
        this.OptionParts[OPTION_BUTTON_NAME[i]]._element.addEventListener(
          'click',
          eventClickRecovery
        )
      } else if (i == 2) {
        x = xBase + this.FONT_HALF_SIZE * 16
        y = this.LINE_HEIGHT * 2.5 + this.LINE_HEIGHT * 2.5 * 7.3
        this.OptionParts[OPTION_BUTTON_NAME[i]]._element.addEventListener(
          'click',
          eventClickKeyname
        )
      } else if (i == 3) {
        x = xBase + this.FONT_HALF_SIZE * 29
        y = this.LINE_HEIGHT * 2.5 + this.LINE_HEIGHT * 2.5 * 7.3
        this.OptionParts[OPTION_BUTTON_NAME[i]]._element.addEventListener(
          'click',
          eventClickDeleteOption
        )
      } else if (i == 4) {
        x = xBase + this.FONT_HALF_SIZE * 0
        y = this.LINE_HEIGHT * 2.5 + this.LINE_HEIGHT * 2.5 * 7.3
        this.OptionParts[OPTION_BUTTON_NAME[i]]._element.addEventListener(
          'click',
          eventClickKeyConfig
        )
      }
      this.OptionParts[OPTION_BUTTON_NAME[i]].x = x
      this.OptionParts[OPTION_BUTTON_NAME[i]].y = y
      GameBody.rootScene.addChild(this.OptionParts[OPTION_BUTTON_NAME[i]])
      this.OptionParts[OPTION_BUTTON_NAME[i]]._element.style.visibility =
        'hidden'
    }
    for (let i = 0; i < KEY_NAME.length; i++) {
      let keyName = KEY_NAME[i].replace('KEY_', '')
      this.OptionParts[KEY_NAME[i]] = new Entity()
      this.OptionParts[KEY_NAME[i]]._element = document.createElement('input')
      this.OptionParts[KEY_NAME[i]]._element.setAttribute('type', 'submit')
      this.OptionParts[KEY_NAME[i]]._element.value = keyName
      this.OptionParts[KEY_NAME[i]]._element.style.padding = 0
      this.OptionParts[KEY_NAME[i]]._element.style.fontFamily = this.FONT_NAME
      this.OptionParts[KEY_NAME[i]]._element.style.fontSize =
        this.FONT_SIZE + 'px'
      this.OptionParts[KEY_NAME[i]]._element.style.color = 'black'
      this.OptionParts[KEY_NAME[i]]._element.style.borderStyle = 'none'
      this.OptionParts[KEY_NAME[i]]._element.style.WebkitAppearance = 'none'
      this.OptionParts[KEY_NAME[i]]._element.style.borderRadius =
        calDiv(this.FONT_SIZE, 5) + 'px'
      this.OptionParts[KEY_NAME[i]]._element.style.backgroundColor = 'white'
      this.OptionParts[KEY_NAME[i]]._element.style.cursor = 'pointer'
      this.OptionParts[KEY_NAME[i]].width =
        this.FONT_HALF_SIZE * (keyName.length + 4)
      this.OptionParts[KEY_NAME[i]].height = this.FONT_SIZE * 1.6
      let x, y
      x = xBase - this.FONT_SIZE / 4
      y = this.LINE_HEIGHT * 2.5 + this.LINE_HEIGHT * 1.5 * i
      this.OptionParts[KEY_NAME[i]]._element.addEventListener('click', {
        name: keyName,
        handleEvent: eventClickKeyConfig
      })
      this.OptionParts[KEY_NAME[i]].x = x
      this.OptionParts[KEY_NAME[i]].y = y
      GameBody.rootScene.addChild(this.OptionParts[KEY_NAME[i]])
      this.OptionParts[KEY_NAME[i]]._element.style.visibility = 'hidden'
    }
  }
  createWall3D (imgNum, num, perspectiveNum) {
    if (!this.checkPolygonWall3D(imgNum, num, perspectiveNum)) {
      return
    }
    this.Wall3D[imgNum][num][perspectiveNum] = new Plane()
    this.Wall3D[imgNum][num][perspectiveNum].mesh.texture.specular = [
      0.0, 0.0, 0.0, 1.0
    ]
    if (imgNum == 5) {
      this.Wall3D[imgNum][num][perspectiveNum].mesh.texture.ambient = [
        0.03, 0.03, 0.03, 1.0
      ]
    } else if (imgNum == 6) {
      this.Wall3D[imgNum][num][perspectiveNum].mesh.texture.ambient = [
        0.0, 0.0, 0.0, 1.0
      ]
      this.Wall3D[imgNum][num][perspectiveNum].mesh.texture.diffuse = [
        0.0, 0.0, 0.0, 1.0
      ]
    } else {
      if (perspectiveNum == 1) {
        let perNum = num
        if (perNum > 30) {
          perNum -= 30
          if (perNum == 3 || perNum == 4) {
            perNum += 3
          } else if (perNum == 6 || perNum == 7) {
            perNum -= 3
          } else if (perNum == 8 || perNum == 9) {
            perNum += 4
          } else if (perNum == 12 || perNum == 13) {
            perNum -= 4
          } else if (perNum >= 15 && perNum <= 18) {
            perNum += 5
          } else if (perNum >= 20 && perNum <= 23) {
            perNum -= 5
          }
        }
        if (perNum >= 5 && perNum <= 9) {
          this.Wall3D[imgNum][num][perspectiveNum].mesh.texture.ambient = [
            0.08, 0.08, 0.08, 1.0
          ]
          this.Wall3D[imgNum][num][perspectiveNum].mesh.texture.diffuse = [
            0.8, 0.8, 0.8, 1.0
          ]
        } else if (perNum >= 10 && perNum <= 18) {
          this.Wall3D[imgNum][num][perspectiveNum].mesh.texture.ambient = [
            0.06, 0.06, 0.06, 1.0
          ]
          this.Wall3D[imgNum][num][perspectiveNum].mesh.texture.diffuse = [
            0.6, 0.6, 0.6, 1.0
          ]
        } else if (perNum >= 19 && perNum <= 27) {
          this.Wall3D[imgNum][num][perspectiveNum].mesh.texture.ambient = [
            0.04, 0.04, 0.04, 1.0
          ]
          this.Wall3D[imgNum][num][perspectiveNum].mesh.texture.diffuse = [
            0.4, 0.4, 0.4, 1.0
          ]
        }
      }
    }
    if (num == 0 || num == 3 || num == 4) {
      this.Wall3D[imgNum][num][perspectiveNum].scale(
        this.X_AXIS_MAGNIFICATION,
        1.0,
        1.0
      )
      this.Wall3D[imgNum][num][perspectiveNum].z = this.Z_AXIS_MAGNIFICATION
      if (num == 3) {
        this.Wall3D[imgNum][num][perspectiveNum].x =
          -1 * this.X_AXIS_MAGNIFICATION
      } else if (num == 4) {
        this.Wall3D[imgNum][num][perspectiveNum].x = this.X_AXIS_MAGNIFICATION
      }
    } else if (num == 5 || num == 8 || num == 9) {
      this.Wall3D[imgNum][num][perspectiveNum].scale(
        this.X_AXIS_MAGNIFICATION,
        1.0,
        1.0
      )
      this.Wall3D[imgNum][num][perspectiveNum].z = 0
      if (num == 8) {
        this.Wall3D[imgNum][num][perspectiveNum].x =
          -1 * this.X_AXIS_MAGNIFICATION
      } else if (num == 9) {
        this.Wall3D[imgNum][num][perspectiveNum].x = this.X_AXIS_MAGNIFICATION
      }
    } else if (num == 10 || (num >= 15 && num <= 18)) {
      this.Wall3D[imgNum][num][perspectiveNum].scale(
        this.X_AXIS_MAGNIFICATION,
        1.0,
        1.0
      )
      this.Wall3D[imgNum][num][perspectiveNum].z =
        -1 * this.Z_AXIS_MAGNIFICATION
      if (num == 15) {
        this.Wall3D[imgNum][num][perspectiveNum].x =
          -2 * this.X_AXIS_MAGNIFICATION
      } else if (num == 16) {
        this.Wall3D[imgNum][num][perspectiveNum].x =
          -1 * this.X_AXIS_MAGNIFICATION
      } else if (num == 17) {
        this.Wall3D[imgNum][num][perspectiveNum].x = this.X_AXIS_MAGNIFICATION
      } else if (num == 18) {
        this.Wall3D[imgNum][num][perspectiveNum].x =
          2 * this.X_AXIS_MAGNIFICATION
      }
    } else if (num == 19 || (num >= 24 && num <= 27)) {
      this.Wall3D[imgNum][num][perspectiveNum].scale(
        this.X_AXIS_MAGNIFICATION,
        1.0,
        1.0
      )
      this.Wall3D[imgNum][num][perspectiveNum].z =
        this.Z_AXIS_MAGNIFICATION * -2
      if (num == 24) {
        this.Wall3D[imgNum][num][perspectiveNum].x =
          -2 * this.X_AXIS_MAGNIFICATION
      } else if (num == 25) {
        this.Wall3D[imgNum][num][perspectiveNum].x =
          -1 * this.X_AXIS_MAGNIFICATION
      } else if (num == 26) {
        this.Wall3D[imgNum][num][perspectiveNum].x = this.X_AXIS_MAGNIFICATION
      } else if (num == 27) {
        this.Wall3D[imgNum][num][perspectiveNum].x =
          2 * this.X_AXIS_MAGNIFICATION
      }
    } else if (num >= 20 && num <= 23) {
      this.Wall3D[imgNum][num][perspectiveNum].scale(
        this.Z_AXIS_MAGNIFICATION,
        1.0,
        1.0
      )
      this.Wall3D[imgNum][num][perspectiveNum].z =
        this.Z_AXIS_REFERENCE_VALUE - this.Z_AXIS_MAGNIFICATION
      if (num == 20 || num == 21) {
        this.Wall3D[imgNum][num][perspectiveNum].rotateYaw(Math.PI * 0.5)
        if (num == 20) {
          this.Wall3D[imgNum][num][perspectiveNum].x =
            -1.5 * this.X_AXIS_MAGNIFICATION
        } else if (num == 21) {
          this.Wall3D[imgNum][num][perspectiveNum].x =
            -0.5 * this.X_AXIS_MAGNIFICATION
        }
      } else if (num == 22 || num == 23) {
        this.Wall3D[imgNum][num][perspectiveNum].rotateYaw(Math.PI * -0.5)
        if (num == 22) {
          this.Wall3D[imgNum][num][perspectiveNum].x =
            0.5 * this.X_AXIS_MAGNIFICATION
        } else if (num == 23) {
          this.Wall3D[imgNum][num][perspectiveNum].x =
            1.5 * this.X_AXIS_MAGNIFICATION
        }
      }
    } else if (num == 60 || num == 61) {
      this.Wall3D[imgNum][num][perspectiveNum].scale(
        this.Z_AXIS_MAGNIFICATION,
        1.0,
        1.0
      )
      this.Wall3D[imgNum][num][perspectiveNum].z =
        this.Z_AXIS_REFERENCE_VALUE - this.Z_AXIS_MAGNIFICATION
      if (num == 60) {
        this.Wall3D[imgNum][num][perspectiveNum].rotateYaw(Math.PI * 0.5)
        this.Wall3D[imgNum][num][perspectiveNum].x =
          -2.5 * this.X_AXIS_MAGNIFICATION
      } else if (num == 61) {
        this.Wall3D[imgNum][num][perspectiveNum].rotateYaw(Math.PI * -0.5)
        this.Wall3D[imgNum][num][perspectiveNum].x =
          2.5 * this.X_AXIS_MAGNIFICATION
      }
    } else if (num >= 11 && num <= 14) {
      this.Wall3D[imgNum][num][perspectiveNum].scale(
        this.Z_AXIS_MAGNIFICATION,
        1.0,
        1.0
      )
      this.Wall3D[imgNum][num][perspectiveNum].z = this.Z_AXIS_REFERENCE_VALUE
      if (num == 11 || num == 12) {
        this.Wall3D[imgNum][num][perspectiveNum].rotateYaw(Math.PI * 0.5)
        if (num == 11) {
          this.Wall3D[imgNum][num][perspectiveNum].x =
            -1.5 * this.X_AXIS_MAGNIFICATION
        } else if (num == 12) {
          this.Wall3D[imgNum][num][perspectiveNum].x =
            -0.5 * this.X_AXIS_MAGNIFICATION
        }
      } else if (num == 13 || num == 14) {
        this.Wall3D[imgNum][num][perspectiveNum].rotateYaw(Math.PI * -0.5)
        if (num == 13) {
          this.Wall3D[imgNum][num][perspectiveNum].x =
            0.5 * this.X_AXIS_MAGNIFICATION
        } else if (num == 14) {
          this.Wall3D[imgNum][num][perspectiveNum].x =
            1.5 * this.X_AXIS_MAGNIFICATION
        }
      }
    } else if (num == 6 || num == 7) {
      this.Wall3D[imgNum][num][perspectiveNum].scale(
        this.Z_AXIS_MAGNIFICATION,
        1.0,
        1.0
      )
      this.Wall3D[imgNum][num][perspectiveNum].z =
        this.Z_AXIS_REFERENCE_VALUE + this.Z_AXIS_MAGNIFICATION
      if (num == 6) {
        this.Wall3D[imgNum][num][perspectiveNum].rotateYaw(Math.PI * 0.5)
        this.Wall3D[imgNum][num][perspectiveNum].x =
          -0.5 * this.X_AXIS_MAGNIFICATION
      } else if (num == 7) {
        this.Wall3D[imgNum][num][perspectiveNum].rotateYaw(Math.PI * -0.5)
        this.Wall3D[imgNum][num][perspectiveNum].x =
          0.5 * this.X_AXIS_MAGNIFICATION
      }
    } else if (num == 1 || num == 2) {
      this.Wall3D[imgNum][num][perspectiveNum].scale(
        this.Z_AXIS_MAGNIFICATION,
        1.0,
        1.0
      )
      this.Wall3D[imgNum][num][perspectiveNum].z =
        this.Z_AXIS_REFERENCE_VALUE + this.Z_AXIS_MAGNIFICATION * 2
      if (num == 1) {
        this.Wall3D[imgNum][num][perspectiveNum].rotateYaw(Math.PI * 0.5)
        this.Wall3D[imgNum][num][perspectiveNum].x =
          -0.5 * this.X_AXIS_MAGNIFICATION
      } else if (num == 2) {
        this.Wall3D[imgNum][num][perspectiveNum].rotateYaw(Math.PI * -0.5)
        this.Wall3D[imgNum][num][perspectiveNum].x =
          0.5 * this.X_AXIS_MAGNIFICATION
      }
    } else if (num == 28) {
      this.Wall3D[imgNum][num][perspectiveNum].scale(6.15, 5.85, 1.0)
      this.Wall3D[imgNum][num][perspectiveNum].z =
        this.Z_AXIS_MAGNIFICATION * -2 - 0.002
    } else if (num == 29) {
      this.Wall3D[imgNum][num][perspectiveNum].scale(6.5, 1.0, 1.0)
      this.Wall3D[imgNum][num][perspectiveNum].z =
        this.Z_AXIS_MAGNIFICATION * -2 - 0.001
    } else if (num > 30) {
      let num2 = num - 30
      if (num2 == 3 || num2 == 4) {
        this.Wall3D[imgNum][num][perspectiveNum].scale(
          this.Z_AXIS_MAGNIFICATION / 15,
          1.0,
          1.0
        )
        this.Wall3D[imgNum][num][perspectiveNum].z =
          this.Z_AXIS_REFERENCE_VALUE +
          this.Z_AXIS_MAGNIFICATION * 1.5 -
          this.Z_AXIS_MAGNIFICATION / 30
        if (num2 == 3) {
          this.Wall3D[imgNum][num][perspectiveNum].rotateYaw(Math.PI * 0.5)
          this.Wall3D[imgNum][num][perspectiveNum].x =
            -0.5 * this.X_AXIS_MAGNIFICATION
        } else if (num2 == 4) {
          this.Wall3D[imgNum][num][perspectiveNum].rotateYaw(Math.PI * -0.5)
          this.Wall3D[imgNum][num][perspectiveNum].x =
            0.5 * this.X_AXIS_MAGNIFICATION
        }
      } else if (num2 == 6 || num2 == 7) {
        this.Wall3D[imgNum][num][perspectiveNum].scale(
          this.X_AXIS_MAGNIFICATION / 15,
          1.0,
          1.0
        )
        this.Wall3D[imgNum][num][perspectiveNum].z = this.Z_AXIS_MAGNIFICATION
        if (num2 == 6) {
          this.Wall3D[imgNum][num][perspectiveNum].x =
            -0.5 * this.X_AXIS_MAGNIFICATION - this.X_AXIS_MAGNIFICATION / 30
        } else if (num2 == 7) {
          this.Wall3D[imgNum][num][perspectiveNum].x =
            0.5 * this.X_AXIS_MAGNIFICATION + this.X_AXIS_MAGNIFICATION / 30
        }
      } else if (num2 == 8 || num2 == 9) {
        this.Wall3D[imgNum][num][perspectiveNum].scale(
          this.Z_AXIS_MAGNIFICATION / 15,
          1.0,
          1.0
        )
        this.Wall3D[imgNum][num][perspectiveNum].z =
          this.Z_AXIS_REFERENCE_VALUE +
          this.Z_AXIS_MAGNIFICATION * 0.5 -
          this.Z_AXIS_MAGNIFICATION / 30
        if (num2 == 8) {
          this.Wall3D[imgNum][num][perspectiveNum].rotateYaw(Math.PI * 0.5)
          this.Wall3D[imgNum][num][perspectiveNum].x =
            -0.5 * this.X_AXIS_MAGNIFICATION
        } else if (num2 == 9) {
          this.Wall3D[imgNum][num][perspectiveNum].rotateYaw(Math.PI * -0.5)
          this.Wall3D[imgNum][num][perspectiveNum].x =
            0.5 * this.X_AXIS_MAGNIFICATION
        }
      } else if (num2 == 12 || num2 == 13) {
        this.Wall3D[imgNum][num][perspectiveNum].scale(
          this.X_AXIS_MAGNIFICATION / 15,
          1.0,
          1.0
        )
        if (num2 == 12) {
          this.Wall3D[imgNum][num][perspectiveNum].x =
            -0.5 * this.X_AXIS_MAGNIFICATION - this.X_AXIS_MAGNIFICATION / 30
        } else if (num2 == 13) {
          this.Wall3D[imgNum][num][perspectiveNum].x =
            0.5 * this.X_AXIS_MAGNIFICATION + this.X_AXIS_MAGNIFICATION / 30
        }
      } else if (num2 >= 15 && num2 <= 18) {
        this.Wall3D[imgNum][num][perspectiveNum].scale(
          this.Z_AXIS_MAGNIFICATION / 15,
          1.0,
          1.0
        )
        this.Wall3D[imgNum][num][perspectiveNum].z =
          this.Z_AXIS_REFERENCE_VALUE -
          this.Z_AXIS_MAGNIFICATION * 0.5 -
          this.Z_AXIS_MAGNIFICATION / 30
        if (num2 == 15) {
          this.Wall3D[imgNum][num][perspectiveNum].rotateYaw(Math.PI * 0.5)
          this.Wall3D[imgNum][num][perspectiveNum].x =
            -1.5 * this.X_AXIS_MAGNIFICATION
        } else if (num2 == 16) {
          this.Wall3D[imgNum][num][perspectiveNum].rotateYaw(Math.PI * 0.5)
          this.Wall3D[imgNum][num][perspectiveNum].x =
            -0.5 * this.X_AXIS_MAGNIFICATION
        } else if (num2 == 17) {
          this.Wall3D[imgNum][num][perspectiveNum].rotateYaw(Math.PI * -0.5)
          this.Wall3D[imgNum][num][perspectiveNum].x =
            0.5 * this.X_AXIS_MAGNIFICATION
        } else if (num2 == 18) {
          this.Wall3D[imgNum][num][perspectiveNum].rotateYaw(Math.PI * -0.5)
          this.Wall3D[imgNum][num][perspectiveNum].x =
            1.5 * this.X_AXIS_MAGNIFICATION
        }
      } else if (num2 >= 20 && num2 <= 23) {
        this.Wall3D[imgNum][num][perspectiveNum].scale(
          this.X_AXIS_MAGNIFICATION / 15,
          1.0,
          1.0
        )
        this.Wall3D[imgNum][num][perspectiveNum].z =
          -1 * this.Z_AXIS_MAGNIFICATION
        if (num2 == 20) {
          this.Wall3D[imgNum][num][perspectiveNum].x =
            -1.5 * this.X_AXIS_MAGNIFICATION - this.X_AXIS_MAGNIFICATION / 30
        } else if (num2 == 21) {
          this.Wall3D[imgNum][num][perspectiveNum].x =
            -0.5 * this.X_AXIS_MAGNIFICATION - this.X_AXIS_MAGNIFICATION / 30
        } else if (num2 == 22) {
          this.Wall3D[imgNum][num][perspectiveNum].x =
            0.5 * this.X_AXIS_MAGNIFICATION + this.X_AXIS_MAGNIFICATION / 30
        } else if (num2 == 23) {
          this.Wall3D[imgNum][num][perspectiveNum].x =
            1.5 * this.X_AXIS_MAGNIFICATION + this.X_AXIS_MAGNIFICATION / 30
        }
      }
    }
  }
  drawArrow3D (surface, x, y, w, h, type, lineWidth, lineColor, bgColor) {
    let ctx = surface.context
    ctx.lineWidth = lineWidth
    lineColor = checkNull(lineColor, '')
    bgColor = checkNull(bgColor, '')
    let unitW = calDiv(w, 40)
    let unitH = calDiv(h, 40)
    let unit = calDiv(unitW + unitH, 2)
    ctx.beginPath()
    if (type == 'turnRight') {
      ctx.moveTo(x + calTimes(unitW, 6), y + h)
      ctx.lineTo(x + calTimes(unitW, 14), y + calTimes(unitH, 8))
      ctx.arcTo(
        x + calTimes(unitW, 15),
        y + calTimes(unitH, 4),
        x + w - calTimes(unitW, 11),
        y + calTimes(unitH, 4),
        calTimes(unit, 3)
      )
      ctx.lineTo(x + w - calTimes(unitW, 11), y + calTimes(unitH, 4))
      ctx.lineTo(x + w - calTimes(unitW, 12.5), y)
      ctx.lineTo(x + w - calTimes(unitW, 2), y + calTimes(unitH, 6))
      ctx.lineTo(x + w - calTimes(unitW, 7), y + calTimes(unitH, 17))
      ctx.lineTo(x + w - calTimes(unitW, 9.5), y + calTimes(unitH, 10))
      ctx.lineTo(x + w - calTimes(unitW, 12), y + calTimes(unitH, 10))
      ctx.arcTo(
        x + w - calTimes(unitW, 13.5),
        y + calTimes(unitH, 11),
        x + w - calTimes(unitW, 13),
        y + calTimes(unitH, 12),
        unit
      )
      ctx.lineTo(x + w - calTimes(unitW, 6), y + h)
    } else if (type == 'turnLeft') {
      ctx.moveTo(x + w - calTimes(unitW, 6), y + h)
      ctx.lineTo(x + w - calTimes(unitW, 14), y + calTimes(unitH, 8))
      ctx.arcTo(
        x + w - calTimes(unitW, 15),
        y + calTimes(unitH, 4),
        x + calTimes(unitW, 11),
        y + calTimes(unitH, 4),
        calTimes(unit, 3)
      )
      ctx.lineTo(x + calTimes(unitW, 11), y + calTimes(unitH, 4))
      ctx.lineTo(x + calTimes(unitW, 12.5), y)
      ctx.lineTo(x + calTimes(unitW, 2), y + calTimes(unitH, 6))
      ctx.lineTo(x + calTimes(unitW, 7), y + calTimes(unitH, 17))
      ctx.lineTo(x + calTimes(unitW, 9.5), y + calTimes(unitH, 10))
      ctx.lineTo(x + calTimes(unitW, 12), y + calTimes(unitH, 10))
      ctx.arcTo(
        x + calTimes(unitW, 13.5),
        y + calTimes(unitH, 11),
        x + calTimes(unitW, 13),
        y + calTimes(unitH, 12),
        unit
      )
      ctx.lineTo(x + calTimes(unitW, 6), y + h)
    } else {
      ctx.moveTo(x + calTimes(unitW, 6), y + h)
      ctx.lineTo(x + calTimes(unitW, 14), y + calTimes(unitH, 8))
      ctx.lineTo(x + calTimes(unitW, 8), y + calTimes(unitH, 8))
      ctx.lineTo(x + calTimes(unitW, 20), y)
      ctx.lineTo(x + w - calTimes(unitW, 8), y + calTimes(unitH, 8))
      ctx.lineTo(x + w - calTimes(unitW, 14), y + calTimes(unitH, 8))
      ctx.lineTo(x + w - calTimes(unitW, 6), y + h)
    }
    ctx.closePath()
    if (bgColor != '') {
      ctx.fillStyle = bgColor
      ctx.fill()
    }
    if (lineColor != '') {
      ctx.strokeStyle = lineColor
      ctx.stroke()
    }
  }
  drawCircle (surface, cx, cy, r, lineWidth, lineColor, bgColor) {
    let ctx = surface.context
    if (lineWidth == undefined || lineWidth == null) {
      lineWidth = 1
    }
    if (lineWidth > 0 && lineWidth < 1) {
      lineWidth = 1
    }
    ctx.lineWidth = lineWidth
    ctx.beginPath()
    ctx.arc(cx, cy, r, 0, Math.PI * 2)
    ctx.closePath()
    if (bgColor != undefined && bgColor != null) {
      ctx.fillStyle = bgColor
      ctx.fill()
    }
    if (lineColor != undefined && lineColor != null) {
      ctx.strokeStyle = lineColor
      ctx.stroke()
    }
  }
  drawDungeon (surface, type, num) {
    let ctx = surface.context
    ctx.lineWidth = this.DUNGEON_FRAME_WIDTH
    ctx.lineJoin = 'bevel'
    ctx.beginPath()
    if (type.match(/^(w|wall|wd|wallDark)$/)) {
      ctx.strokeStyle = 'white'
      ctx.fillStyle = 'black'
      if (
        num == 0 ||
        num == 5 ||
        num == 6 ||
        num == 7 ||
        num == 10 ||
        num == 11 ||
        num == 12 ||
        num == 13 ||
        num == 14 ||
        num == 16 ||
        num == 17 ||
        num == 19 ||
        num == 20 ||
        num == 21 ||
        num == 22 ||
        num == 23 ||
        num == 24 ||
        num == 25 ||
        num == 26 ||
        num == 27
      ) {
        let nX = []
        let nY = []
        if (num == 0 || num == 5 || num == 10 || num == 19) {
          if (num == 0) {
            nX[0] = 4
          } else if (num == 5) {
            nX[0] = 8
          } else if (num == 10) {
            nX[0] = 12
          } else if (num == 19) {
            nX[0] = 16
          }
          nY[0] = nX[0]
          nX[1] = nX[0] + 1
          nY[1] = nX[1]
          nX[2] = nX[0] + 2
          nY[2] = nX[2]
          nX[3] = nX[0] + 3
          nY[3] = nX[3]
        } else if (num == 6 || num == 12 || num == 21) {
          if (num == 6) {
            nX[0] = 4
          } else if (num == 12) {
            nX[0] = 8
          } else if (num == 21) {
            nX[0] = 12
          }
          nY[0] = nX[0]
          nX[1] = nX[0] + 4
          nY[1] = nX[1]
          nX[2] = nX[0] + 7
          nY[2] = nX[2]
          nX[3] = nX[0] + 3
          nY[3] = nX[3]
        } else if (num == 7 || num == 13 || num == 22) {
          if (num == 7) {
            nX[0] = 5
          } else if (num == 13) {
            nX[0] = 9
          } else if (num == 22) {
            nX[0] = 13
          }
          nY[0] = nX[0]
          nX[1] = nX[0] + 1
          nY[1] = nX[1]
          nX[2] = nX[0] + 5
          nY[2] = nX[2]
          nX[3] = nX[0] + 4
          nY[3] = nX[3]
        } else if (num == 11 || num == 14) {
          if (num == 11) {
            nX[0] = 79
            nX[2] = 56
          } else if (num == 14) {
            nX[0] = 81
            nX[2] = 57
          }
          nY[0] = nX[0]
          nX[1] = nX[0] - 1
          nY[1] = nX[1]
          nY[2] = nX[2]
          nX[3] = nX[2]
          nY[3] = 15
        } else if (num == 16) {
          nX[0] = 56
          nY[0] = nX[0]
          nX[1] = 12
          nY[1] = nX[1]
          nX[2] = 15
          nY[2] = nX[2]
          nX[3] = 56
          nY[3] = nY[2]
        } else if (num == 17) {
          nX[0] = 14
          nY[0] = nX[0]
          nX[1] = 13
          nY[1] = nX[1]
          nX[2] = 57
          nY[2] = nX[2]
          nX[3] = 57
          nY[3] = nY[0]
        } else if (num == 20 || num == 23) {
          if (num == 20) {
            nX[0] = 56
            nX[1] = 67
          } else if (num == 23) {
            nX[0] = 57
            nX[1] = 68
          }
          nY[0] = nX[0]
          nY[1] = nX[1]
          nX[2] = nX[1]
          nY[2] = 19
          nX[3] = nX[0]
          nY[3] = 15
        } else if (num == 24 || num == 27) {
          if (num == 24) {
            nX[0] = 66
          } else if (num == 27) {
            nX[0] = 68
          }
          nY[0] = nX[0]
          nX[1] = nX[0] + 1
          nY[1] = nX[1]
          nX[2] = nX[1]
          nY[2] = 19
          nX[3] = nX[0]
          nY[3] = nY[2]
        } else if (num == 25 || num == 26) {
          if (num == 25) {
            nX[0] = 67
            nX[1] = 16
          } else if (num == 26) {
            nX[0] = 17
            nX[1] = 68
          }
          nY[0] = nX[0]
          nY[1] = nX[1]
          nX[2] = nX[1]
          nY[2] = 19
          nX[3] = nX[0]
          nY[3] = nY[2]
        }
        ctx.moveTo(
          this.WIRE_FRAME_POINT_X[nX[0]],
          this.WIRE_FRAME_POINT_Y[nY[0]]
        )
        ctx.lineTo(
          this.WIRE_FRAME_POINT_X[nX[1]],
          this.WIRE_FRAME_POINT_Y[nY[1]]
        )
        ctx.lineTo(
          this.WIRE_FRAME_POINT_X[nX[2]],
          this.WIRE_FRAME_POINT_Y[nY[2]]
        )
        ctx.lineTo(
          this.WIRE_FRAME_POINT_X[nX[3]],
          this.WIRE_FRAME_POINT_Y[nY[3]]
        )
        ctx.closePath()
        ctx.fill()
        if (type.match(/^(wd|wallDark)$/)) {
          ctx.lineWidth *= 1.5
          ctx.strokeStyle = 'black'
        }
        ctx.stroke()
      } else if (num == 1 || num == 2) {
        let nXY = []
        let len
        if (num == 1) {
          nXY[0] = 0
          nXY[1] = 0
          nXY[2] = 4
          nXY[3] = 7
          nXY[4] = 3
          nXY[5] = 3
          len = this.CENTER_FRAME_X
        } else if (num == 2) {
          nXY[0] = 0
          nXY[1] = 1
          nXY[2] = 5
          nXY[3] = 6
          nXY[4] = 2
          nXY[5] = 3
          len = this.CENTER_FRAME_X + this.CENTER_FRAME_WIDTH
        }
        ctx.moveTo(len, this.WIRE_FRAME_POINT_Y[nXY[0]])
        ctx.lineTo(
          this.WIRE_FRAME_POINT_X[nXY[1]],
          this.WIRE_FRAME_POINT_Y[nXY[1]]
        )
        ctx.lineTo(
          this.WIRE_FRAME_POINT_X[nXY[2]],
          this.WIRE_FRAME_POINT_Y[nXY[2]]
        )
        ctx.lineTo(
          this.WIRE_FRAME_POINT_X[nXY[3]],
          this.WIRE_FRAME_POINT_Y[nXY[3]]
        )
        ctx.lineTo(
          this.WIRE_FRAME_POINT_X[nXY[4]],
          this.WIRE_FRAME_POINT_Y[nXY[4]]
        )
        ctx.lineTo(len, this.WIRE_FRAME_POINT_Y[nXY[5]])
        ctx.closePath()
        ctx.fill()
        ctx.beginPath()
        ctx.lineTo(
          this.WIRE_FRAME_POINT_X[nXY[1]],
          this.WIRE_FRAME_POINT_Y[nXY[1]]
        )
        ctx.lineTo(
          this.WIRE_FRAME_POINT_X[nXY[2]],
          this.WIRE_FRAME_POINT_Y[nXY[2]]
        )
        ctx.lineTo(
          this.WIRE_FRAME_POINT_X[nXY[3]],
          this.WIRE_FRAME_POINT_Y[nXY[3]]
        )
        ctx.lineTo(
          this.WIRE_FRAME_POINT_X[nXY[4]],
          this.WIRE_FRAME_POINT_Y[nXY[4]]
        )
        if (type.match(/^(wd|wallDark)$/)) {
          ctx.lineWidth *= 1.5
          ctx.strokeStyle = 'black'
        }
        ctx.stroke()
      } else if (
        num == 3 ||
        num == 4 ||
        num == 8 ||
        num == 9 ||
        num == 15 ||
        num == 18
      ) {
        let nXY = []
        let len
        if (num == 3) {
          nXY[0] = 4
          nXY[1] = 7
          len = this.CENTER_FRAME_X
        } else if (num == 4) {
          nXY[0] = 5
          nXY[1] = 6
          len = this.CENTER_FRAME_X + this.CENTER_FRAME_WIDTH
        } else if (num == 8) {
          nXY[0] = 8
          nXY[1] = 11
          len = this.CENTER_FRAME_X
        } else if (num == 9) {
          nXY[0] = 9
          nXY[1] = 10
          len = this.CENTER_FRAME_X + this.CENTER_FRAME_WIDTH
        } else if (num == 15) {
          nXY[0] = 56
          nXY[1] = 15
          len = this.CENTER_FRAME_X
        } else if (num == 18) {
          nXY[0] = 57
          nXY[1] = 14
          len = this.CENTER_FRAME_X + this.CENTER_FRAME_WIDTH
        }
        ctx.moveTo(len, this.WIRE_FRAME_POINT_Y[nXY[0]])
        ctx.lineTo(
          this.WIRE_FRAME_POINT_X[nXY[0]],
          this.WIRE_FRAME_POINT_Y[nXY[0]]
        )
        ctx.lineTo(
          this.WIRE_FRAME_POINT_X[nXY[0]],
          this.WIRE_FRAME_POINT_Y[nXY[1]]
        )
        ctx.lineTo(len, this.WIRE_FRAME_POINT_Y[nXY[1]])
        ctx.closePath()
        ctx.fill()
        if (type.match(/^(wd|wallDark)$/)) {
          ctx.lineWidth *= 1.5
          ctx.strokeStyle = 'black'
        }
        ctx.stroke()
      }
    } else if (type.match(/^(d|door)$/)) {
      ctx.strokeStyle = 'white'
      if (
        num == 0 ||
        num == 5 ||
        num == 6 ||
        num == 7 ||
        num == 8 ||
        num == 9 ||
        num == 10 ||
        num == 11 ||
        num == 12 ||
        num == 13 ||
        num == 14 ||
        num == 15 ||
        num == 16 ||
        num == 17 ||
        num == 18 ||
        num == 19 ||
        num == 20 ||
        num == 21 ||
        num == 22 ||
        num == 23 ||
        num == 24 ||
        num == 25 ||
        num == 26 ||
        num == 27
      ) {
        let nX = []
        let nY = []
        if (num == 0 || num == 5 || num == 10 || num == 19) {
          if (num == 0) {
            nX[0] = 8
          } else if (num == 5) {
            nX[0] = 12
          } else if (num == 10) {
            nX[0] = 16
          } else if (num == 19) {
            nX[0] = 20
          }
          nY[0] = nX[0] - 2
          nX[1] = nX[0]
          nY[1] = nX[0]
          nX[2] = nX[0] + 1
          nY[2] = nX[0] + 1
          nX[3] = nX[0] + 1
          nY[3] = nX[0] - 2
        } else if (
          num == 6 ||
          num == 7 ||
          num == 11 ||
          num == 12 ||
          num == 13 ||
          num == 14 ||
          num == 20 ||
          num == 21 ||
          num == 22 ||
          num == 23
        ) {
          if (num == 6) {
            nX[0] = 28
          } else if (num == 7) {
            nX[0] = 43
          } else if (num == 11) {
            nX[0] = 85
          } else if (num == 12) {
            nX[0] = 32
          } else if (num == 13) {
            nX[0] = 47
          } else if (num == 14) {
            nX[0] = 97
          } else if (num == 20) {
            nX[0] = 89
          } else if (num == 21) {
            nX[0] = 36
          } else if (num == 22) {
            nX[0] = 51
          } else if (num == 23) {
            nX[0] = 93
          }
          nY[0] = nX[0]
          nX[1] = nX[0] - 3
          nY[1] = nX[1]
          nX[2] = nX[0] - 2
          nY[2] = nX[2]
          nX[3] = nX[0] - 1
          nY[3] = nX[3]
        } else if (
          num == 8 ||
          num == 9 ||
          num == 15 ||
          num == 16 ||
          num == 17 ||
          num == 18
        ) {
          if (num == 8) {
            nX[0] = 52
            nY[0] = 11
          } else if (num == 9) {
            nX[0] = 54
            nY[0] = 11
          } else if (num == 15) {
            nX[0] = 58
            nY[0] = 15
          } else if (num == 16) {
            nX[0] = 60
            nY[0] = 15
          } else if (num == 17) {
            nX[0] = 62
            nY[0] = 15
          } else if (num == 18) {
            nX[0] = 64
            nY[0] = 15
          }
          nX[1] = nX[0]
          nY[1] = nX[0]
          nX[2] = nX[0] + 1
          nY[2] = nX[0] + 1
          nX[3] = nX[2]
          nY[3] = nY[0]
        } else if (num == 24 || num == 25 || num == 26 || num == 27) {
          if (num == 24) {
            nX[0] = 70
          } else if (num == 25) {
            nX[0] = 72
          } else if (num == 26) {
            nX[0] = 74
          } else if (num == 27) {
            nX[0] = 76
          }
          nY[0] = 19
          nX[1] = nX[0]
          nY[1] = nX[0]
          nX[2] = nX[0] + 1
          nY[2] = nX[2]
          nX[3] = nX[2]
          nY[3] = nY[0]
        }
        ctx.moveTo(
          this.WIRE_FRAME_POINT_X[nX[0]],
          this.WIRE_FRAME_POINT_Y[nY[0]]
        )
        ctx.lineTo(
          this.WIRE_FRAME_POINT_X[nX[1]],
          this.WIRE_FRAME_POINT_Y[nY[1]]
        )
        ctx.lineTo(
          this.WIRE_FRAME_POINT_X[nX[2]],
          this.WIRE_FRAME_POINT_Y[nY[2]]
        )
        ctx.lineTo(
          this.WIRE_FRAME_POINT_X[nX[3]],
          this.WIRE_FRAME_POINT_Y[nY[3]]
        )
      } else if (num == 1 || num == 2) {
        let nXY = []
        if (num == 1) {
          nXY[0] = 22
          nXY[1] = 23
          nXY[2] = 24
        } else if (num == 2) {
          nXY[0] = 38
          nXY[1] = 37
          nXY[2] = 39
        }
        ctx.moveTo(
          this.WIRE_FRAME_POINT_X[nXY[0]],
          this.WIRE_FRAME_POINT_Y[nXY[0]]
        )
        ctx.lineTo(
          this.WIRE_FRAME_POINT_X[nXY[1]],
          this.WIRE_FRAME_POINT_Y[nXY[1]]
        )
        ctx.lineTo(
          this.WIRE_FRAME_POINT_X[nXY[2]],
          this.WIRE_FRAME_POINT_Y[nXY[2]]
        )
      }
      ctx.stroke()
    } else if (type.match(/^(sd|secretDoor)$/)) {
      ctx.strokeStyle = '#666666'
      if (num == 0) {
        ctx.moveTo(this.WIRE_FRAME_POINT_X[8], this.WIRE_FRAME_POINT_Y[6])
        ctx.lineTo(this.WIRE_FRAME_POINT_X[8], this.WIRE_FRAME_POINT_Y[8])
        ctx.lineTo(this.WIRE_FRAME_POINT_X[9], this.WIRE_FRAME_POINT_Y[9])
        ctx.lineTo(this.WIRE_FRAME_POINT_X[9], this.WIRE_FRAME_POINT_Y[6])
        ctx.stroke()
        ctx.strokeStyle = 'white'
        ctx.beginPath()
        ctx.moveTo(this.WIRE_FRAME_POINT_X[7], this.WIRE_FRAME_POINT_Y[7])
        ctx.lineTo(this.WIRE_FRAME_POINT_X[6], this.WIRE_FRAME_POINT_Y[6])
        ctx.stroke()
      } else if (num == 1 || num == 2) {
        let nXY = []
        if (num == 1) {
          nXY[0] = 22
          nXY[1] = 23
          nXY[2] = 24
          nXY[3] = 3
          nXY[4] = 7
        } else if (num == 2) {
          nXY[0] = 38
          nXY[1] = 37
          nXY[2] = 39
          nXY[3] = 6
          nXY[4] = 2
        }
        ctx.moveTo(
          this.WIRE_FRAME_POINT_X[nXY[0]],
          this.WIRE_FRAME_POINT_Y[nXY[0]]
        )
        ctx.lineTo(
          this.WIRE_FRAME_POINT_X[nXY[1]],
          this.WIRE_FRAME_POINT_Y[nXY[1]]
        )
        ctx.lineTo(
          this.WIRE_FRAME_POINT_X[nXY[2]],
          this.WIRE_FRAME_POINT_Y[nXY[2]]
        )
        ctx.stroke()
        ctx.strokeStyle = 'white'
        ctx.beginPath()
        ctx.moveTo(
          this.WIRE_FRAME_POINT_X[nXY[3]],
          this.WIRE_FRAME_POINT_Y[nXY[3]]
        )
        ctx.lineTo(
          this.WIRE_FRAME_POINT_X[nXY[4]],
          this.WIRE_FRAME_POINT_Y[nXY[4]]
        )
        ctx.stroke()
      }
    } else if (
      type.match(/^(fs|floorStroke|ff|floorFill|cs|ceilStroke|cf|ceilFill)$/)
    ) {
      if (num == 3 || num == 5) {
        let n, pX
        if (type.match(/^(fs|floorStroke|ff|floorFill)$/)) {
          if (num == 3) {
            n = 102
            pX = this.CENTER_FRAME_X
          } else if (num == 5) {
            n = 108
            pX = this.CENTER_FRAME_X + this.CENTER_FRAME_WIDTH
          }
        } else {
          if (num == 3) {
            n = 138
            pX = this.CENTER_FRAME_X
          } else if (num == 5) {
            n = 144
            pX = this.CENTER_FRAME_X + this.CENTER_FRAME_WIDTH
          }
        }
        ctx.moveTo(this.WIRE_FRAME_POINT_X[n], this.WIRE_FRAME_POINT_Y[n])
        ctx.lineTo(
          this.WIRE_FRAME_POINT_X[n + 1],
          this.WIRE_FRAME_POINT_Y[n + 1]
        )
        ctx.lineTo(pX, this.WIRE_FRAME_POINT_Y[n + 1])
        ctx.lineTo(pX, this.WIRE_FRAME_POINT_Y[n])
      } else if (num == 6 || num == 10) {
        let n
        if (type.match(/^(fs|floorStroke|ff|floorFill)$/)) {
          if (num == 6) {
            n = 186
          } else if (num == 10) {
            n = 192
          }
        } else {
          if (num == 6) {
            n = 189
          } else if (num == 10) {
            n = 195
          }
        }
        ctx.moveTo(this.WIRE_FRAME_POINT_X[n], this.WIRE_FRAME_POINT_Y[n])
        ctx.lineTo(
          this.WIRE_FRAME_POINT_X[n + 1],
          this.WIRE_FRAME_POINT_Y[n + 1]
        )
        ctx.lineTo(
          this.WIRE_FRAME_POINT_X[n + 2],
          this.WIRE_FRAME_POINT_Y[n + 2]
        )
      } else {
        let n
        if (type.match(/^(fs|floorStroke|ff|floorFill)$/)) {
          if (num == 0) {
            n = 98
          } else if (num == 4) {
            n = 104
          } else if (num == 7) {
            n = 110
          } else if (num == 8) {
            n = 114
          } else if (num == 9) {
            n = 118
          } else if (num == 11) {
            n = 170
          } else if (num == 12) {
            n = 122
          } else if (num == 13) {
            n = 126
          } else if (num == 14) {
            n = 130
          } else if (num == 15) {
            n = 178
          }
        } else {
          if (num == 0) {
            n = 134
          } else if (num == 4) {
            n = 140
          } else if (num == 7) {
            n = 146
          } else if (num == 8) {
            n = 150
          } else if (num == 9) {
            n = 154
          } else if (num == 11) {
            n = 174
          } else if (num == 12) {
            n = 158
          } else if (num == 13) {
            n = 162
          } else if (num == 14) {
            n = 166
          } else if (num == 15) {
            n = 182
          }
        }
        ctx.moveTo(this.WIRE_FRAME_POINT_X[n], this.WIRE_FRAME_POINT_Y[n])
        ctx.lineTo(
          this.WIRE_FRAME_POINT_X[n + 1],
          this.WIRE_FRAME_POINT_Y[n + 1]
        )
        ctx.lineTo(
          this.WIRE_FRAME_POINT_X[n + 2],
          this.WIRE_FRAME_POINT_Y[n + 2]
        )
        ctx.lineTo(
          this.WIRE_FRAME_POINT_X[n + 3],
          this.WIRE_FRAME_POINT_Y[n + 3]
        )
      }
      ctx.closePath()
      if (type.match(/^(fs|floorStroke|cs|ceilStroke)$/)) {
        ctx.strokeStyle = 'white'
        ctx.stroke()
      } else {
        ctx.fillStyle = 'white'
        ctx.fill()
      }
    }
  }
  drawEllipse (surface, cx, cy, w, h, lineWidth, lineColor, bgColor) {
    let ctx = surface.context
    if (lineWidth == undefined || lineWidth == null) {
      lineWidth = 1
    }
    if (lineWidth > 0 && lineWidth < 1) {
      lineWidth = 1
    }
    ctx.lineWidth = lineWidth
    let pi2 = Math.PI * 2
    let ratio = h / w
    let radius = Math.max(w, h) / 2
    let increment = 1 / radius
    ctx.beginPath()
    let x = cx + radius * Math.cos(0)
    let y = cy - ratio * radius * Math.sin(0)
    ctx.lineTo(x, y)
    for (let radians = increment; radians < pi2; radians += increment) {
      x = cx + radius * Math.cos(radians)
      y = cy - ratio * radius * Math.sin(radians)
      ctx.lineTo(x, y)
    }
    ctx.closePath()
    if (bgColor != undefined && bgColor != null) {
      ctx.fillStyle = bgColor
      ctx.fill()
    }
    if (lineColor != undefined && lineColor != null) {
      ctx.strokeStyle = lineColor
      ctx.stroke()
    }
  }
  drawFrame (surface, x, y, w, h, r, lineWidth, color, borderColor, bgColor) {
    let ctx = surface.context
    if (borderColor != undefined && borderColor != null) {
      this.drawFrame(
        surface,
        x - lineWidth * 0.2,
        y - lineWidth * 0.2,
        w + lineWidth * 0.4,
        h + lineWidth * 0.4,
        r,
        lineWidth,
        borderColor
      )
    }
    ctx.lineWidth = lineWidth
    ctx.strokeStyle = color
    ctx.beginPath()
    ctx.moveTo(x, y + r)
    ctx.arc(x + r, y + h - r, r, Math.PI, Math.PI * 0.5, true)
    ctx.arc(x + w - r, y + h - r, r, Math.PI * 0.5, 0, 1)
    ctx.arc(x + w - r, y + r, r, 0, Math.PI * 1.5, 1)
    ctx.arc(x + r, y + r, r, Math.PI * 1.5, Math.PI, 1)
    ctx.closePath()
    if (bgColor != undefined && bgColor != null) {
      ctx.fillStyle = bgColor
      ctx.fill()
    }
    ctx.stroke()
  }
  drawFrame2 (sf, x, y, w, h, r, lineWidth, color, bgColor) {
    let ctx = sf.getContext('2d')
    ctx.lineWidth = lineWidth
    ctx.strokeStyle = color
    ctx.beginPath()
    ctx.moveTo(x, y + r)
    ctx.arc(x + r, y + h - r, r, Math.PI, Math.PI * 0.5, true)
    ctx.arc(x + w - r, y + h - r, r, Math.PI * 0.5, 0, 1)
    ctx.arc(x + w - r, y + r, r, 0, Math.PI * 1.5, 1)
    ctx.arc(x + r, y + r, r, Math.PI * 1.5, Math.PI, 1)
    ctx.closePath()
    if (bgColor != undefined && bgColor != null) {
      ctx.fillStyle = bgColor
      ctx.fill()
    }
    ctx.stroke()
  }
  drawFrame_Center (surface) {
    this.drawFrame(
      surface,
      this.CENTER_FRAME_X,
      this.CENTER_FRAME_Y,
      this.CENTER_FRAME_WIDTH,
      this.CENTER_FRAME_HEIGHT,
      this.FRAME_ARC,
      this.FRAME_WIDTH,
      'white',
      'black'
    )
  }
  drawFrame_Center_Title (surface, title, img) {
    if (title == undefined || title == null) {
      title = ''
    }
    if (img != undefined && img != null) {
      this.paintGraphic(
        surface,
        img,
        this.CENTER_FRAME_X,
        this.CENTER_FRAME_Y,
        this.CENTER_FRAME_WIDTH,
        this.CENTER_FRAME_HEIGHT
      )
    }
    this.drawFrame(
      surface,
      this.CENTER_FRAME_X,
      this.CENTER_FRAME_Y,
      this.CENTER_FRAME_WIDTH,
      this.CENTER_FRAME_HEIGHT,
      this.FRAME_ARC,
      this.FRAME_WIDTH,
      'white',
      'black'
    )
    this.drawTextFrame(
      surface,
      ' ' + title + ' ',
      'center',
      this.CENTER_FRAME_Y - this.FONT_HALF_SIZE,
      null,
      null,
      'center'
    )
  }
  drawFrame_Full (surface) {
    this.drawFrame(
      surface,
      this.FULL_FRAME_X,
      this.FULL_FRAME_Y,
      this.FULL_FRAME_WIDTH,
      this.FULL_FRAME_HEIGHT,
      this.FRAME_ARC,
      this.FRAME_WIDTH,
      'white',
      'black'
    )
  }
  drawFrame_Full_Title (surface, title, img) {
    if (title == undefined || title == null) {
      title = ''
    }
    let yPlus = this.LINE_HEIGHT * 0.8
    let y = this.FULL_FRAME_Y + yPlus
    if (img != undefined && img != null) {
      this.paintGraphic(
        surface,
        img,
        this.FULL_FRAME_X,
        y,
        this.FULL_FRAME_WIDTH,
        this.FULL_FRAME_HEIGHT - yPlus
      )
    }
    this.drawFrame(
      surface,
      this.FULL_FRAME_X,
      y,
      this.FULL_FRAME_WIDTH,
      this.FULL_FRAME_HEIGHT - yPlus,
      this.FRAME_ARC,
      this.FRAME_WIDTH,
      'white',
      'black'
    )
    if (title != '') {
      this.drawTextFrame(
        surface,
        ' ' + title + ' ',
        'center',
        y - this.FONT_HALF_SIZE,
        null,
        null,
        'center'
      )
    }
  }
  drawHaveMoney (pc) {
    let str = this.strFitLength(getDefaultMessage('HAVE_MONEY', 1), 20) + ' '
    str += this.strFitLength(this.numberFormat(pc.Gold), 15, 'right') + ' '
    str += GameData['GP']
    this.drawTextFrame(
      this.TextSurface[this.TextSurfaceNum],
      str,
      'center',
      this.LINE_HEIGHT * 16
    )
  }
  drawMap (dungeon, floor, ptX, ptY, ptDirection, viewTrap, viewEvent) {
    if (ptX == undefined || ptX == null || ptY == undefined || ptY == null) {
      ;(ptX = -1), (ptY = -1)
    }
    if (ptDirection == undefined || ptDirection == null) {
      ptDirection = -1
    }
    if (
      viewTrap == undefined ||
      viewTrap == null ||
      viewTrap == '1' ||
      viewTrap
    ) {
      viewTrap = true
    } else {
      viewTrap = false
    }
    if (
      viewEvent == undefined ||
      viewEvent == null ||
      viewEvent == '1' ||
      viewEvent
    ) {
      viewEvent = true
    } else {
      viewEvent = false
    }
    this.clearMainWindow()
    let surface = this.MainSurface
    let ctx = surface.context
    this.drawFrame_Full_Title(surface, DUNGEON.DungeonName[dungeon])
    let width = DUNGEON.Width[dungeon]
    let height = DUNGEON.Height[dungeon]
    if (ptX >= width || ptX < 0 || ptY >= height || ptY < 0) {
      ptX = -1
      ptY = -1
    }
    this.drawText_FullFrame(
      surface,
      DUNGEON.getFloorName(dungeon, floor),
      'right',
      3
    )
    let directionStr = ''
    if (ptDirection == 0) {
      directionStr = 'NORTH'
    } else if (ptDirection == 1) {
      directionStr = 'EAST'
    } else if (ptDirection == 2) {
      directionStr = 'SOUTH'
    } else if (ptDirection == 3) {
      directionStr = 'WEST'
    }
    if (directionStr != '') {
      directionStr = '[' + getDefaultMessage(directionStr, 1, 20) + ']'
      this.drawText_FullFrame(surface, directionStr, 'right', 4)
    }
    if (ptX > -1 && ptY > -1) {
      let pointStr = getDefaultMessage('TO_EAST', 1, 5) + ':'
      pointStr =
        this.strFitLength(pointStr, 6) + this.strFitLength(ptX, 2, 'right')
      this.drawText_FullFrame(surface, pointStr, 'right', 5)
      pointStr = getDefaultMessage('TO_NORTH', 1, 5) + ':'
      pointStr =
        this.strFitLength(pointStr, 6) + this.strFitLength(ptY, 2, 'right')
      this.drawText_FullFrame(surface, pointStr, 'right', 6)
    }
    for (let i = 0; i < width; i++) {
      let str = this.strFitLength(String(i), 2, 'right')
      this.drawText(
        surface,
        this.MapBaseX + this.MapLineWidth + this.MapBlock * (i + 1),
        this.MapBaseY + this.MapBlock / 3,
        null,
        null,
        str
      )
    }
    for (let i = 0; i < height; i++) {
      let str = this.strFitLength(String(i), 2, 'right')
      this.drawText(
        surface,
        this.MapBaseX - this.MapBlock / 3,
        this.MapBaseY + this.MapLineWidthHalf - this.MapBlock * (i + 1),
        null,
        null,
        str
      )
    }
    this.drawLine(
      surface,
      [
        [
          this.MapBaseX + this.MapBlock - this.MapLineWidthHalf,
          this.MapBaseY + this.MapLineWidthHalf
        ],
        [
          this.MapBaseX + this.MapBlock * (width + 1) + this.MapLineWidthHalf,
          this.MapBaseY + this.MapLineWidthHalf
        ],
        [
          this.MapBaseX + this.MapBlock * (width + 1) + this.MapLineWidthHalf,
          this.MapBaseY - this.MapBlock * height - this.MapLineWidthHalf
        ],
        [
          this.MapBaseX + this.MapBlock - this.MapLineWidthHalf,
          this.MapBaseY - this.MapBlock * height - this.MapLineWidthHalf
        ]
      ],
      0,
      'butt',
      'miter',
      null,
      true,
      'MediumSlateBlue'
    )
    for (let x = 0; x < width; x++) {
      for (let y = 0; y < height; y++) {
        if (!PlayData['MapFlag'][dungeon][floor][x][y]) {
          continue
        }
        this.drawMap_SpacePaintOut(x, y, 'black')
        let space = DUNGEON.Space[dungeon][floor][x][y]
        if (space.charAt(0) == '1' && viewTrap) {
          this.drawMap_SpacePaintOut(x, y, 'DimGray')
          if (DUNGEON.checkSpaceNotTeleport(space, 'c')) {
            this.drawMap_SpaceSpellNotUse(x, y)
          }
          if (DUNGEON.checkSpaceNotTeleport(space, 'b')) {
            this.drawMap_SpaceNotTeleport(x, y)
          }
        } else if (space.charAt(0) == 'a') {
          this.drawMap_SpacePaintOut(x, y, 'white', true)
        } else if (space.charAt(0) == '2') {
          if (DUNGEON.checkSpaceNotTeleport(space, 'c') && viewTrap) {
            this.drawMap_SpaceSpellNotUse(x, y)
          }
          this.drawLine(
            surface,
            [
              [
                this.MapBaseX + this.MapBlock * (x + 1) + this.MapBlock * 0.5,
                this.MapBaseY - this.MapBlock * y - this.MapBlock * 0.2
              ],
              [
                this.MapBaseX + this.MapBlock * (x + 1) + this.MapBlock * 0.5,
                this.MapBaseY - this.MapBlock * (y + 1) + this.MapBlock * 0.2
              ]
            ],
            this.MapLineWidthHalf,
            'round',
            null,
            'Orange'
          )
          this.drawLine(
            surface,
            [
              [
                this.MapBaseX + this.MapBlock * (x + 1) + this.MapBlock * 0.25,
                this.MapBaseY - this.MapBlock * y - this.MapBlock * 0.6
              ],
              [
                this.MapBaseX + this.MapBlock * (x + 1) + this.MapBlock * 0.5,
                this.MapBaseY - this.MapBlock * (y + 1) + this.MapBlock * 0.2
              ],
              [
                this.MapBaseX + this.MapBlock * (x + 2) - this.MapBlock * 0.25,
                this.MapBaseY - this.MapBlock * y - this.MapBlock * 0.6
              ]
            ],
            this.MapLineWidthHalf,
            'round',
            'round',
            'Orange'
          )
          if (DUNGEON.checkSpaceNotTeleport(space, 'b') && viewTrap) {
            this.drawMap_SpaceNotTeleport(x, y)
          }
        } else if (space.charAt(0) == '3') {
          if (DUNGEON.checkSpaceNotTeleport(space, 'c') && viewTrap) {
            this.drawMap_SpaceSpellNotUse(x, y)
          }
          this.drawLine(
            surface,
            [
              [
                this.MapBaseX + this.MapBlock * (x + 1) + this.MapBlock * 0.5,
                this.MapBaseY - this.MapBlock * y - this.MapBlock * 0.2
              ],
              [
                this.MapBaseX + this.MapBlock * (x + 1) + this.MapBlock * 0.5,
                this.MapBaseY - this.MapBlock * (y + 1) + this.MapBlock * 0.2
              ]
            ],
            this.MapLineWidthHalf,
            'round',
            null,
            'Orange'
          )
          this.drawLine(
            surface,
            [
              [
                this.MapBaseX + this.MapBlock * (x + 1) + this.MapBlock * 0.25,
                this.MapBaseY - this.MapBlock * y - this.MapBlock * 0.6
              ],
              [
                this.MapBaseX + this.MapBlock * (x + 1) + this.MapBlock * 0.5,
                this.MapBaseY - this.MapBlock * (y + 1) + this.MapBlock * 0.2
              ],
              [
                this.MapBaseX + this.MapBlock * (x + 2) - this.MapBlock * 0.25,
                this.MapBaseY - this.MapBlock * y - this.MapBlock * 0.6
              ]
            ],
            this.MapLineWidthHalf,
            'round',
            'round',
            'Orange'
          )
          this.drawLine(
            surface,
            [
              [
                this.MapBaseX + this.MapBlock * (x + 1) + this.MapBlock * 0.25,
                this.MapBaseY - this.MapBlock * y - this.MapBlock * 0.4
              ],
              [
                this.MapBaseX + this.MapBlock * (x + 1) + this.MapBlock * 0.5,
                this.MapBaseY - this.MapBlock * y - this.MapBlock * 0.2
              ],
              [
                this.MapBaseX + this.MapBlock * (x + 2) - this.MapBlock * 0.25,
                this.MapBaseY - this.MapBlock * y - this.MapBlock * 0.4
              ]
            ],
            this.MapLineWidthHalf,
            'round',
            'round',
            'Orange'
          )
          if (DUNGEON.checkSpaceNotTeleport(space, 'b') && viewTrap) {
            this.drawMap_SpaceNotTeleport(x, y)
          }
        } else if (space.charAt(0) == '4') {
          if (DUNGEON.checkSpaceNotTeleport(space, 'c') && viewTrap) {
            this.drawMap_SpaceSpellNotUse(x, y)
          }
          this.drawLine(
            surface,
            [
              [
                this.MapBaseX + this.MapBlock * (x + 1) + this.MapBlock * 0.5,
                this.MapBaseY - this.MapBlock * y - this.MapBlock * 0.2
              ],
              [
                this.MapBaseX + this.MapBlock * (x + 1) + this.MapBlock * 0.5,
                this.MapBaseY - this.MapBlock * (y + 1) + this.MapBlock * 0.2
              ]
            ],
            this.MapLineWidthHalf,
            'round',
            null,
            'Orange'
          )
          this.drawLine(
            surface,
            [
              [
                this.MapBaseX + this.MapBlock * (x + 1) + this.MapBlock * 0.25,
                this.MapBaseY - this.MapBlock * y - this.MapBlock * 0.4
              ],
              [
                this.MapBaseX + this.MapBlock * (x + 1) + this.MapBlock * 0.5,
                this.MapBaseY - this.MapBlock * y - this.MapBlock * 0.2
              ],
              [
                this.MapBaseX + this.MapBlock * (x + 2) - this.MapBlock * 0.25,
                this.MapBaseY - this.MapBlock * y - this.MapBlock * 0.4
              ]
            ],
            this.MapLineWidthHalf,
            'round',
            'round',
            'Orange'
          )
          if (DUNGEON.checkSpaceNotTeleport(space, 'b') && viewTrap) {
            this.drawMap_SpaceNotTeleport(x, y)
          }
        } else if (space.charAt(0) == '5' && viewTrap) {
          if (DUNGEON.checkSpaceNotTeleport(space, 'c')) {
            this.drawMap_SpaceSpellNotUse(x, y)
          }
          this.drawCircle(
            surface,
            this.MapBaseX + this.MapBlock * (x + 1) + this.MapBlock * 0.5,
            this.MapBaseY - this.MapBlock * y - this.MapBlock * 0.5,
            this.MapBlock * 0.3,
            this.MapLineWidthHalf,
            'aqua'
          )
          this.drawCircle(
            surface,
            this.MapBaseX + this.MapBlock * (x + 1) + this.MapBlock * 0.5,
            this.MapBaseY - this.MapBlock * y - this.MapBlock * 0.5,
            this.MapBlock * 0.15,
            this.MapLineWidthHalf,
            'aqua'
          )
          if (DUNGEON.checkSpaceNotTeleport(space, 'b')) {
            this.drawMap_SpaceNotTeleport(x, y)
          }
        } else if (space.charAt(0) == '6' && viewTrap) {
          if (DUNGEON.checkSpaceNotTeleport(space, 'c')) {
            this.drawMap_SpaceSpellNotUse(x, y)
          }
          this.drawEllipse(
            surface,
            this.MapBaseX + this.MapBlock * (x + 1) + this.MapBlock * 0.5,
            this.MapBaseY - this.MapBlock * y - this.MapBlock * 0.3,
            this.MapBlock * 0.7,
            this.MapBlock * 0.3,
            this.MapLineWidthHalf,
            'red'
          )
          if (DUNGEON.checkSpaceNotTeleport(space, 'b')) {
            this.drawMap_SpaceNotTeleport(x, y)
          }
        } else if (space.charAt(0) == '7' && viewTrap) {
          if (DUNGEON.checkSpaceNotTeleport(space, 'c')) {
            this.drawMap_SpaceSpellNotUse(x, y)
          }
          if (DUNGEON.checkSpaceNotTeleport(space, 'b')) {
            this.drawMap_SpaceNotTeleport(x, y)
          }
          this.drawMap_SpaceText(x, y, 'M', 'yellow')
        } else if (space.charAt(0) == '8' && viewTrap) {
          if (DUNGEON.checkSpaceNotTeleport(space, 'c')) {
            this.drawMap_SpaceSpellNotUse(x, y)
          }
          this.drawEllipse(
            surface,
            this.MapBaseX + this.MapBlock * (x + 1) + this.MapBlock * 0.5,
            this.MapBaseY - this.MapBlock * y - this.MapBlock * 0.3,
            this.MapBlock * 0.7,
            this.MapBlock * 0.3,
            this.MapLineWidthHalf,
            'aqua'
          )
          this.drawLine(
            surface,
            [
              [
                this.MapBaseX + this.MapBlock * (x + 1) + this.MapBlock * 0.25,
                this.MapBaseY - this.MapBlock * y - this.MapBlock * 0.7
              ],
              [
                this.MapBaseX + this.MapBlock * (x + 1) + this.MapBlock * 0.5,
                this.MapBaseY - this.MapBlock * y - this.MapBlock * 0.3
              ],
              [
                this.MapBaseX + this.MapBlock * (x + 2) - this.MapBlock * 0.25,
                this.MapBaseY - this.MapBlock * y - this.MapBlock * 0.7
              ]
            ],
            this.MapLineWidthHalf,
            'round',
            'round',
            'Orange'
          )
          if (DUNGEON.checkSpaceNotTeleport(space, 'b')) {
            this.drawMap_SpaceNotTeleport(x, y)
          }
        } else if (space.charAt(0) == '9' && viewTrap) {
          if (DUNGEON.checkSpaceNotTeleport(space, 'c')) {
            this.drawMap_SpaceSpellNotUse(x, y)
          }
          this.drawEllipse(
            surface,
            this.MapBaseX + this.MapBlock * (x + 1) + this.MapBlock * 0.5,
            this.MapBaseY - this.MapBlock * y - this.MapBlock * 0.7,
            this.MapBlock * 0.7,
            this.MapBlock * 0.3,
            this.MapLineWidthHalf,
            'aqua'
          )
          this.drawLine(
            surface,
            [
              [
                this.MapBaseX + this.MapBlock * (x + 1) + this.MapBlock * 0.25,
                this.MapBaseY - this.MapBlock * y - this.MapBlock * 0.3
              ],
              [
                this.MapBaseX + this.MapBlock * (x + 1) + this.MapBlock * 0.5,
                this.MapBaseY - this.MapBlock * y - this.MapBlock * 0.7
              ],
              [
                this.MapBaseX + this.MapBlock * (x + 2) - this.MapBlock * 0.25,
                this.MapBaseY - this.MapBlock * y - this.MapBlock * 0.3
              ]
            ],
            this.MapLineWidthHalf,
            'round',
            'round',
            'Orange'
          )
          if (DUNGEON.checkSpaceNotTeleport(space, 'b')) {
            this.drawMap_SpaceNotTeleport(x, y)
          }
        } else if (space.charAt(0) == 'E') {
          if (DUNGEON.checkSpaceNotTeleport(space, 'c') && viewTrap) {
            this.drawMap_SpaceSpellNotUse(x, y)
          }
          if (DUNGEON.checkSpaceNotTeleport(space, 'b') && viewTrap) {
            this.drawMap_SpaceNotTeleport(x, y)
          }
          let strAry = space.split('<>')
          if (strAry.length > 2) {
            let strAry2 = strAry[0].split(',')
            if (strAry2.indexOf('m') < 0 && viewEvent) {
              this.drawMap_SpaceText(x, y, 'E', 'red')
            }
          }
        } else if (space.charAt(0) == 'R') {
          if (DUNGEON.checkSpaceNotTeleport(space, 'b') && viewTrap) {
            this.drawMap_SpaceNotTeleport(x, y)
          }
          this.drawMap_SpaceText(x, y, 'R', 'fuchsia')
        } else if (space.charAt(0) == 'S' && viewTrap) {
          if (DUNGEON.checkSpaceNotTeleport(space, 'c')) {
            this.drawMap_SpaceSpellNotUse(x, y)
          }
          this.drawLine(
            surface,
            [
              [
                this.MapBaseX +
                  this.MapLineWidthHalf +
                  this.MapBlock * (x + 1) +
                  this.MapBlock * 0.15,
                this.MapBaseY -
                  this.MapLineWidthHalf -
                  this.MapBlock * y -
                  this.MapBlock * 0.15
              ],
              [
                this.MapBaseX -
                  this.MapLineWidthHalf +
                  this.MapBlock * (x + 2) -
                  this.MapBlock * 0.15,
                this.MapBaseY -
                  this.MapLineWidthHalf -
                  this.MapBlock * y -
                  this.MapBlock * 0.15
              ],
              [
                this.MapBaseX -
                  this.MapLineWidthHalf +
                  this.MapBlock * (x + 2) -
                  this.MapBlock * 0.15,
                this.MapBaseY +
                  this.MapLineWidthHalf -
                  this.MapBlock * (y + 1) +
                  this.MapBlock * 0.15
              ],
              [
                this.MapBaseX +
                  this.MapLineWidthHalf +
                  this.MapBlock * (x + 1) +
                  this.MapBlock * 0.15,
                this.MapBaseY +
                  this.MapLineWidthHalf -
                  this.MapBlock * (y + 1) +
                  this.MapBlock * 0.15
              ]
            ],
            this.MapLineWidthHalf,
            'butt',
            'miter',
            'yellow',
            true
          )
          this.drawLine(
            surface,
            [
              [
                this.MapBaseX +
                  this.MapLineWidthHalf +
                  this.MapLineWidthHalf / 2 +
                  this.MapBlock * (x + 1) +
                  this.MapBlock * 0.15,
                this.MapBaseY -
                  this.MapLineWidthHalf -
                  this.MapLineWidthHalf / 2 -
                  this.MapBlock * y -
                  this.MapBlock * 0.15
              ],
              [
                this.MapBaseX -
                  this.MapLineWidthHalf -
                  this.MapLineWidthHalf / 2 +
                  this.MapBlock * (x + 2) -
                  this.MapBlock * 0.15,
                this.MapBaseY +
                  this.MapLineWidthHalf +
                  this.MapLineWidthHalf / 2 -
                  this.MapBlock * (y + 1) +
                  this.MapBlock * 0.15
              ]
            ],
            this.MapLineWidthHalf,
            'round',
            null,
            'yellow'
          )
          this.drawLine(
            surface,
            [
              [
                this.MapBaseX -
                  this.MapLineWidthHalf -
                  this.MapLineWidthHalf / 2 +
                  this.MapBlock * (x + 2) -
                  this.MapBlock * 0.15,
                this.MapBaseY -
                  this.MapLineWidthHalf -
                  this.MapLineWidthHalf / 2 -
                  this.MapBlock * y -
                  this.MapBlock * 0.15
              ],
              [
                this.MapBaseX +
                  this.MapLineWidthHalf +
                  this.MapLineWidthHalf / 2 +
                  this.MapBlock * (x + 1) +
                  this.MapBlock * 0.15,
                this.MapBaseY +
                  this.MapLineWidthHalf +
                  this.MapLineWidthHalf / 2 -
                  this.MapBlock * (y + 1) +
                  this.MapBlock * 0.15
              ]
            ],
            this.MapLineWidthHalf,
            'round',
            null,
            'yellow'
          )
          if (DUNGEON.checkSpaceNotTeleport(space, 'b')) {
            this.drawMap_SpaceNotTeleport(x, y)
          }
        } else if (space.charAt(0) == 'W' && viewTrap) {
          if (DUNGEON.checkSpaceNotTeleport(space, 'b') && viewTrap) {
            this.drawMap_SpaceNotTeleport(x, y)
          }
          this.drawMap_SpaceText(x, y, 'W', 'fuchsia')
        } else if (space.charAt(0) == 'b' && viewTrap) {
          if (DUNGEON.checkSpaceNotTeleport(space, 'c')) {
            this.drawMap_SpaceSpellNotUse(x, y)
          }
          this.drawMap_SpaceNotTeleport(x, y)
        } else if (space.charAt(0) == 'c' && viewTrap) {
          this.drawMap_SpaceSpellNotUse(x, y)
          if (DUNGEON.checkSpaceNotTeleport(space, 'b')) {
            this.drawMap_SpaceNotTeleport(x, y)
          }
        } else if (space.charAt(0) == 'd' && viewTrap) {
          let strAry = space.split(',')
          let d = Number(strAry[1])
          if (d == 0) {
            this.drawLine(
              surface,
              [
                [
                  this.MapBaseX +
                    this.MapBlock * (x + 1) +
                    this.MapBlock * 0.15,
                  this.MapBaseY - this.MapBlock * y - this.MapBlock * 0.15
                ],
                [
                  this.MapBaseX + this.MapBlock * (x + 1) + this.MapBlock * 0.5,
                  this.MapBaseY - this.MapBlock * (y + 1) + this.MapBlock * 0.15
                ],
                [
                  this.MapBaseX +
                    this.MapBlock * (x + 2) -
                    this.MapBlock * 0.15,
                  this.MapBaseY - this.MapBlock * y - this.MapBlock * 0.15
                ]
              ],
              this.MapLineWidthHalf,
              'round',
              'round',
              'fuchsia'
            )
          } else if (d == 1) {
            this.drawLine(
              surface,
              [
                [
                  this.MapBaseX +
                    this.MapBlock * (x + 1) +
                    this.MapBlock * 0.15,
                  this.MapBaseY - this.MapBlock * (y + 1) + this.MapBlock * 0.15
                ],
                [
                  this.MapBaseX +
                    this.MapBlock * (x + 2) -
                    this.MapBlock * 0.15,
                  this.MapBaseY - this.MapBlock * y - this.MapBlock * 0.5
                ],
                [
                  this.MapBaseX +
                    this.MapBlock * (x + 1) +
                    this.MapBlock * 0.15,
                  this.MapBaseY - this.MapBlock * y - this.MapBlock * 0.15
                ]
              ],
              this.MapLineWidthHalf,
              'round',
              'round',
              'fuchsia'
            )
          } else if (d == 2) {
            this.drawLine(
              surface,
              [
                [
                  this.MapBaseX +
                    this.MapBlock * (x + 1) +
                    this.MapBlock * 0.15,
                  this.MapBaseY - this.MapBlock * (y + 1) + this.MapBlock * 0.15
                ],
                [
                  this.MapBaseX + this.MapBlock * (x + 1) + this.MapBlock * 0.5,
                  this.MapBaseY - this.MapBlock * y - this.MapBlock * 0.15
                ],
                [
                  this.MapBaseX +
                    this.MapBlock * (x + 2) -
                    this.MapBlock * 0.15,
                  this.MapBaseY - this.MapBlock * (y + 1) + this.MapBlock * 0.15
                ]
              ],
              this.MapLineWidthHalf,
              'round',
              'round',
              'fuchsia'
            )
          } else if (d == 3) {
            this.drawLine(
              surface,
              [
                [
                  this.MapBaseX +
                    this.MapBlock * (x + 2) -
                    this.MapBlock * 0.15,
                  this.MapBaseY - this.MapBlock * (y + 1) + this.MapBlock * 0.15
                ],
                [
                  this.MapBaseX +
                    this.MapBlock * (x + 1) +
                    this.MapBlock * 0.15,
                  this.MapBaseY - this.MapBlock * y - this.MapBlock * 0.5
                ],
                [
                  this.MapBaseX +
                    this.MapBlock * (x + 2) -
                    this.MapBlock * 0.15,
                  this.MapBaseY - this.MapBlock * y - this.MapBlock * 0.15
                ]
              ],
              this.MapLineWidthHalf,
              'round',
              'round',
              'fuchsia'
            )
          } else {
            this.drawLine(
              surface,
              [
                [
                  this.MapBaseX + this.MapBlock * (x + 1) + this.MapBlock * 0.5,
                  this.MapBaseY - this.MapBlock * y - this.MapBlock * 0.15
                ],
                [
                  this.MapBaseX + this.MapBlock * (x + 1) + this.MapBlock * 0.5,
                  this.MapBaseY - this.MapBlock * (y + 1) + this.MapBlock * 0.15
                ]
              ],
              this.MapLineWidthHalf,
              'round',
              'round',
              'fuchsia'
            )
            this.drawLine(
              surface,
              [
                [
                  this.MapBaseX +
                    this.MapBlock * (x + 1) +
                    this.MapBlock * 0.15,
                  this.MapBaseY - this.MapBlock * y - this.MapBlock * 0.5
                ],
                [
                  this.MapBaseX +
                    this.MapBlock * (x + 2) -
                    this.MapBlock * 0.15,
                  this.MapBaseY - this.MapBlock * y - this.MapBlock * 0.5
                ]
              ],
              this.MapLineWidthHalf,
              'round',
              'round',
              'fuchsia'
            )
          }
          if (DUNGEON.checkSpaceNotTeleport(space, 'b')) {
            this.drawMap_SpaceNotTeleport(x, y)
          }
        }
      }
    }
    for (let x = 0; x < width + 1; x++) {
      for (let y = 0; y < height; y++) {
        if (
          PlayData['MapFlag'][dungeon][floor][
            DUNGEON.getPoint(dungeon, 'w', x)
          ][y] ||
          PlayData['MapFlag'][dungeon][floor][
            DUNGEON.getPoint(dungeon, 'w', x - 1)
          ][y]
        ) {
          if (
            DUNGEON.Space[dungeon][floor][DUNGEON.getPoint(dungeon, 'w', x)][
              y
            ].charAt(0) != 'a' &&
            DUNGEON.Space[dungeon][floor][
              DUNGEON.getPoint(dungeon, 'w', x - 1)
            ][y].charAt(0) != 'a'
          ) {
            this.drawMap_WallWest(x, y, 'DarkSlateGray')
          }
        }
      }
    }
    for (let x = 0; x < width; x++) {
      for (let y = 0; y < height + 1; y++) {
        if (
          PlayData['MapFlag'][dungeon][floor][x][
            DUNGEON.getPoint(dungeon, 'h', y)
          ] ||
          PlayData['MapFlag'][dungeon][floor][x][
            DUNGEON.getPoint(dungeon, 'h', y - 1)
          ]
        ) {
          if (
            DUNGEON.Space[dungeon][floor][x][
              DUNGEON.getPoint(dungeon, 'h', y)
            ].charAt(0) != 'a' &&
            DUNGEON.Space[dungeon][floor][x][
              DUNGEON.getPoint(dungeon, 'h', y - 1)
            ].charAt(0) != 'a'
          ) {
            this.drawMap_WallSouth(x, y, 'DarkSlateGray')
          }
        }
      }
    }
    for (let x = 0; x < width + 1; x++) {
      for (let y = 0; y < height; y++) {
        let hereFlag = true
        let nextFlag = true
        if (
          !PlayData['MapFlag'][dungeon][floor][
            DUNGEON.getPoint(dungeon, 'w', x)
          ][y]
        ) {
          hereFlag = false
        }
        if (
          !PlayData['MapFlag'][dungeon][floor][
            DUNGEON.getPoint(dungeon, 'w', x - 1)
          ][y]
        ) {
          nextFlag = false
        }
        if (!hereFlag && !nextFlag) {
          continue
        }
        let wall =
          DUNGEON.WestWall[dungeon][floor][DUNGEON.getPoint(dungeon, 'w', x)][y]
        let wallFlag = false
        let hereSpace =
          DUNGEON.Space[dungeon][floor][DUNGEON.getPoint(dungeon, 'w', x)][y]
        let nextSpace =
          DUNGEON.Space[dungeon][floor][DUNGEON.getPoint(dungeon, 'w', x - 1)][
            y
          ]
        if (hereSpace.charAt(0) == 'a' || nextSpace.charAt(0) == 'a') {
          this.drawMap_WallWest(x, y, 'white')
          wallFlag = true
          if (hereSpace.charAt(0) == 'a') {
            hereFlag = false
          }
          if (nextSpace.charAt(0) == 'a') {
            nextFlag = false
          }
        } else if (wall.charAt(0) == '1' || wall.charAt(0) == '2') {
          wallFlag = true
          let num = 0
          let strAry = wall.split(',')
          if (strAry.length > 1) {
            num = Number(strAry[1])
          }
          if (num >= 0 && num < 512) {
            if (!PlayData['WallFlag'][dungeon][floor][num]) {
              wallFlag = false
            }
          }
        } else if (wall.match(/^[346]/)) {
          wallFlag = true
        } else if (wall.charAt(0) == '5') {
          let strAry = wall.split(',')
          let d = Number(strAry[1])
          if (hereFlag && nextFlag) {
            wallFlag = true
          } else if (hereFlag) {
            if (d == 1) {
              wallFlag = true
            }
          } else if (nextFlag) {
            if (d == 3) {
              wallFlag = true
            }
          }
        }
        if (!wallFlag || (!hereFlag && !nextFlag)) {
          continue
        }
        this.drawMap_WallWest(x, y, 'white')
        if (wall.match(/^[26]/)) {
          let color = 'white'
          if (wall.charAt(0) == '6' && viewTrap) {
            color = 'red'
          }
          if (hereFlag && nextFlag) {
            this.drawMap_DoorWest(x, y, color)
          } else if (hereFlag) {
            this.drawMap_DoorWestHalfEast(x, y, color)
          } else {
            this.drawMap_DoorWestHalfWest(x, y, color)
          }
        } else if (wall.charAt(0) == '3') {
          let num = -1
          let strAry = wall.split(',')
          if (strAry.length > 2) {
            num = Number(strAry[2])
            if (num < 0 || num > 511) {
              num = -1
            } else if (PlayData['SecretDoor'][dungeon][floor][num]) {
              if (hereFlag && nextFlag) {
                this.drawMap_DoorWest(x, y, 'white')
              } else if (hereFlag) {
                this.drawMap_DoorWestHalfEast(x, y, 'white')
              } else {
                this.drawMap_DoorWestHalfWest(x, y, 'white')
              }
            }
          }
          if (num == -1) {
            let color = 'white'
            if (viewTrap) {
              color = 'lime'
            }
            if (hereFlag && nextFlag) {
              this.drawMap_DoorWest(x, y, color)
            } else if (hereFlag) {
              this.drawMap_DoorWestHalfEast(x, y, color)
            } else {
              this.drawMap_DoorWestHalfWest(x, y, color)
            }
          }
        } else if (wall.charAt(0) == '4') {
          let strAry = wall.split(',')
          let d = Number(strAry[1])
          if (d == 1 && nextFlag) {
            this.drawMap_DoorWestHalfWest(x, y, 'white')
          } else if (d == 3 && hereFlag) {
            this.drawMap_DoorWestHalfEast(x, y, 'white')
          }
        } else if (wall.charAt(0) == '5') {
          if (hereFlag && nextFlag) {
            let strAry = wall.split(',')
            let d = Number(strAry[1])
            if (d == 1) {
              this.drawLine(
                surface,
                [
                  [
                    this.MapBaseX +
                      this.MapBlock * (x + 1) -
                      this.MapBlock * 0.2,
                    this.MapBaseY -
                      this.MapBlock * (y + 1) +
                      this.MapBlock * 0.2
                  ],
                  [
                    this.MapBaseX +
                      this.MapBlock * (x + 1) +
                      this.MapBlock * 0.3,
                    this.MapBaseY - this.MapBlock * y - this.MapBlock * 0.5
                  ],
                  [
                    this.MapBaseX +
                      this.MapBlock * (x + 1) -
                      this.MapBlock * 0.2,
                    this.MapBaseY - this.MapBlock * y - this.MapBlock * 0.2
                  ]
                ],
                0,
                'butt',
                'round',
                null,
                true,
                'lime'
              )
            } else if (d == 3) {
              this.drawLine(
                surface,
                [
                  [
                    this.MapBaseX +
                      this.MapBlock * (x + 1) +
                      this.MapBlock * 0.2,
                    this.MapBaseY -
                      this.MapBlock * (y + 1) +
                      this.MapBlock * 0.2
                  ],
                  [
                    this.MapBaseX +
                      this.MapBlock * (x + 1) -
                      this.MapBlock * 0.3,
                    this.MapBaseY - this.MapBlock * y - this.MapBlock * 0.5
                  ],
                  [
                    this.MapBaseX +
                      this.MapBlock * (x + 1) +
                      this.MapBlock * 0.2,
                    this.MapBaseY - this.MapBlock * y - this.MapBlock * 0.2
                  ]
                ],
                0,
                'butt',
                'round',
                null,
                true,
                'lime'
              )
            }
          }
        }
      }
    }
    for (let x = 0; x < width; x++) {
      for (let y = 0; y < height + 1; y++) {
        let hereFlag = true
        let nextFlag = true
        if (
          !PlayData['MapFlag'][dungeon][floor][x][
            DUNGEON.getPoint(dungeon, 'h', y)
          ]
        ) {
          hereFlag = false
        }
        if (
          !PlayData['MapFlag'][dungeon][floor][x][
            DUNGEON.getPoint(dungeon, 'h', y - 1)
          ]
        ) {
          nextFlag = false
        }
        if (!hereFlag && !nextFlag) {
          continue
        }
        let wall =
          DUNGEON.SouthWall[dungeon][floor][x][
            DUNGEON.getPoint(dungeon, 'h', y)
          ]
        let wallFlag = false
        let hereSpace =
          DUNGEON.Space[dungeon][floor][x][DUNGEON.getPoint(dungeon, 'h', y)]
        let nextSpace =
          DUNGEON.Space[dungeon][floor][x][
            DUNGEON.getPoint(dungeon, 'h', y - 1)
          ]
        if (hereSpace.charAt(0) == 'a' || nextSpace.charAt(0) == 'a') {
          wallFlag = true
          if (hereSpace.charAt(0) == 'a') {
            hereFlag = false
          }
          if (nextSpace.charAt(0) == 'a') {
            nextFlag = false
          }
        } else if (wall.charAt(0) == '1' || wall.charAt(0) == '2') {
          wallFlag = true
          let num = 0
          let strAry = wall.split(',')
          if (strAry.length > 1) {
            num = Number(strAry[1])
          }
          if (num >= 0 && num < 512) {
            if (!PlayData['WallFlag'][dungeon][floor][num]) {
              wallFlag = false
            }
          }
        } else if (wall.match(/^[346]/)) {
          wallFlag = true
        } else if (wall.charAt(0) == '5') {
          let strAry = wall.split(',')
          let d = Number(strAry[1])
          if (hereFlag && nextFlag) {
            wallFlag = true
          } else if (hereFlag) {
            if (d == 0) {
              wallFlag = true
            }
          } else if (nextFlag) {
            if (d == 2) {
              wallFlag = true
            }
          }
        }
        if (!wallFlag) {
          continue
        }
        this.drawMap_WallSouth(x, y, 'white')
        if (wall.match(/^[26]/)) {
          let color = 'white'
          if (wall.charAt(0) == '6' && viewTrap) {
            color = 'red'
          }
          if (hereFlag && nextFlag) {
            this.drawMap_DoorSouth(x, y, color)
          } else if (hereFlag) {
            this.drawMap_DoorSouthHalfNorth(x, y, color)
          } else {
            this.drawMap_DoorSouthHalfSouth(x, y, color)
          }
        } else if (wall.charAt(0) == '3') {
          let num = -1
          let strAry = wall.split(',')
          if (strAry.length > 2) {
            num = Number(strAry[2])
            if (num < 0 || num > 511) {
              num = -1
            } else if (PlayData['SecretDoor'][dungeon][floor][num]) {
              if (hereFlag && nextFlag) {
                this.drawMap_DoorSouth(x, y, 'white')
              } else if (hereFlag) {
                this.drawMap_DoorSouthHalfNorth(x, y, 'white')
              } else {
                this.drawMap_DoorSouthHalfSouth(x, y, 'white')
              }
            }
          }
          if (num == -1) {
            let color = 'white'
            if (viewTrap) {
              color = 'lime'
            }
            if (hereFlag && nextFlag) {
              this.drawMap_DoorSouth(x, y, color)
            } else if (hereFlag) {
              this.drawMap_DoorSouthHalfNorth(x, y, color)
            } else {
              this.drawMap_DoorSouthHalfSouth(x, y, color)
            }
          }
        } else if (wall.charAt(0) == '4') {
          let strAry = wall.split(',')
          let d = Number(strAry[1])
          if (d == 0 && nextFlag) {
            this.drawMap_DoorSouthHalfSouth(x, y, 'white')
          } else if (d == 2 && hereFlag) {
            this.drawMap_DoorSouthHalfNorth(x, y, 'white')
          }
        } else if (wall.charAt(0) == '5') {
          if (hereFlag && nextFlag) {
            let strAry = wall.split(',')
            let d = Number(strAry[1])
            if (d == 0) {
              this.drawLine(
                surface,
                [
                  [
                    this.MapBaseX +
                      this.MapBlock * (x + 1) +
                      this.MapBlock * 0.2,
                    this.MapBaseY - this.MapBlock * y + this.MapBlock * 0.2
                  ],
                  [
                    this.MapBaseX +
                      this.MapBlock * (x + 1) +
                      this.MapBlock * 0.5,
                    this.MapBaseY - this.MapBlock * y - this.MapBlock * 0.3
                  ],
                  [
                    this.MapBaseX +
                      this.MapBlock * (x + 2) -
                      this.MapBlock * 0.2,
                    this.MapBaseY - this.MapBlock * y + this.MapBlock * 0.2
                  ]
                ],
                0,
                'butt',
                'round',
                null,
                true,
                'lime'
              )
            } else if (d == 2) {
              this.drawLine(
                surface,
                [
                  [
                    this.MapBaseX +
                      this.MapBlock * (x + 1) +
                      this.MapBlock * 0.2,
                    this.MapBaseY - this.MapBlock * y - this.MapBlock * 0.2
                  ],
                  [
                    this.MapBaseX +
                      this.MapBlock * (x + 1) +
                      this.MapBlock * 0.5,
                    this.MapBaseY - this.MapBlock * y + this.MapBlock * 0.3
                  ],
                  [
                    this.MapBaseX +
                      this.MapBlock * (x + 2) -
                      this.MapBlock * 0.2,
                    this.MapBaseY - this.MapBlock * y - this.MapBlock * 0.2
                  ]
                ],
                0,
                'butt',
                'round',
                null,
                true,
                'lime'
              )
            }
          }
        }
      }
    }
    if (ptX > -1 && ptY > -1) {
      this.StatusSurface.clear()
      this.drawMap_Location(ptX, ptY, ptDirection)
      GenericVariable['TimeEventCountMax'] = TIME_COUNT[0]
      GenericVariable['TimeEventCount'] = 0
      GenericVariable['TimeEvent'] = 'mapLocationClear'
    }
  }
  drawMap_Location (x, y, direction) {
    if (direction == 0) {
      this.drawLine(
        this.StatusSurface,
        [
          [
            this.MapBaseX + this.MapBlock * (x + 1) + this.MapBlock * 0.2,
            this.MapBaseY - this.MapBlock * y - this.MapBlock * 0.1
          ],
          [
            this.MapBaseX + this.MapBlock * (x + 1) + this.MapBlock * 0.8,
            this.MapBaseY - this.MapBlock * y - this.MapBlock * 0.1
          ],
          [
            this.MapBaseX + this.MapBlock * (x + 1) + this.MapBlock * 0.5,
            this.MapBaseY - this.MapBlock * y - this.MapBlock
          ]
        ],
        0,
        'round',
        'round',
        null,
        true,
        'red'
      )
    } else if (direction == 1) {
      this.drawLine(
        this.StatusSurface,
        [
          [
            this.MapBaseX + this.MapBlock * (x + 1) + this.MapBlock * 0.1,
            this.MapBaseY - this.MapBlock * y - this.MapBlock * 0.2
          ],
          [
            this.MapBaseX + this.MapBlock * (x + 1) + this.MapBlock * 0.1,
            this.MapBaseY - this.MapBlock * y - this.MapBlock * 0.8
          ],
          [
            this.MapBaseX + this.MapBlock * (x + 1) + this.MapBlock,
            this.MapBaseY - this.MapBlock * y - this.MapBlock * 0.5
          ]
        ],
        0,
        'round',
        'round',
        null,
        true,
        'red'
      )
    } else if (direction == 2) {
      this.drawLine(
        this.StatusSurface,
        [
          [
            this.MapBaseX + this.MapBlock * (x + 1) + this.MapBlock * 0.2,
            this.MapBaseY - this.MapBlock * y - this.MapBlock * 0.9
          ],
          [
            this.MapBaseX + this.MapBlock * (x + 1) + this.MapBlock * 0.8,
            this.MapBaseY - this.MapBlock * y - this.MapBlock * 0.9
          ],
          [
            this.MapBaseX + this.MapBlock * (x + 1) + this.MapBlock * 0.5,
            this.MapBaseY - this.MapBlock * y
          ]
        ],
        0,
        'round',
        'round',
        null,
        true,
        'red'
      )
    } else if (direction == 3) {
      this.drawLine(
        this.StatusSurface,
        [
          [
            this.MapBaseX + this.MapBlock * (x + 1) + this.MapBlock * 0.9,
            this.MapBaseY - this.MapBlock * y - this.MapBlock * 0.2
          ],
          [
            this.MapBaseX + this.MapBlock * (x + 1) + this.MapBlock * 0.9,
            this.MapBaseY - this.MapBlock * y - this.MapBlock * 0.8
          ],
          [
            this.MapBaseX + this.MapBlock * (x + 1),
            this.MapBaseY - this.MapBlock * y - this.MapBlock * 0.5
          ]
        ],
        0,
        'round',
        'round',
        null,
        true,
        'red'
      )
    } else {
      this.drawCircle(
        this.StatusSurface,
        this.MapBaseX + this.MapBlock * (x + 1) + this.MapBlock * 0.5,
        this.MapBaseY - this.MapBlock * y - this.MapBlock * 0.5,
        this.MapBlock * 0.3,
        this.MapLineWidthHalf,
        'red',
        'red'
      )
    }
  }
  drawMap_SpaceNotTeleport (x, y) {
    this.drawLine(
      this.MainSurface,
      [
        [
          this.MapBaseX + this.MapLineWidth + this.MapBlock * (x + 1),
          this.MapBaseY - this.MapLineWidth - this.MapBlock * y
        ],
        [
          this.MapBaseX - this.MapLineWidth + this.MapBlock * (x + 2),
          this.MapBaseY + this.MapLineWidth - this.MapBlock * (y + 1)
        ]
      ],
      this.MapLineWidthHalf,
      'round',
      null,
      'white'
    )
    this.drawLine(
      this.MainSurface,
      [
        [
          this.MapBaseX - this.MapLineWidth + this.MapBlock * (x + 2),
          this.MapBaseY - this.MapLineWidth - this.MapBlock * y
        ],
        [
          this.MapBaseX + this.MapLineWidth + this.MapBlock * (x + 1),
          this.MapBaseY + this.MapLineWidth - this.MapBlock * (y + 1)
        ]
      ],
      this.MapLineWidthHalf,
      'round',
      null,
      'white'
    )
  }
  drawMap_SpacePaintOut (x, y, color, big) {
    if (big == undefined || big == null) {
      big = false
    }
    let lineMag = 1
    if (big) {
      lineMag = 0.5
    }
    this.drawLine(
      this.MainSurface,
      [
        [
          this.MapBaseX +
            this.MapLineWidthHalf * lineMag +
            this.MapBlock * (x + 1),
          this.MapBaseY - this.MapLineWidthHalf * lineMag - this.MapBlock * y
        ],
        [
          this.MapBaseX -
            this.MapLineWidthHalf * lineMag +
            this.MapBlock * (x + 2),
          this.MapBaseY - this.MapLineWidthHalf * lineMag - this.MapBlock * y
        ],
        [
          this.MapBaseX -
            this.MapLineWidthHalf * lineMag +
            this.MapBlock * (x + 2),
          this.MapBaseY +
            this.MapLineWidthHalf * lineMag -
            this.MapBlock * (y + 1)
        ],
        [
          this.MapBaseX +
            this.MapLineWidthHalf * lineMag +
            this.MapBlock * (x + 1),
          this.MapBaseY +
            this.MapLineWidthHalf * lineMag -
            this.MapBlock * (y + 1)
        ]
      ],
      0,
      'butt',
      'miter',
      null,
      true,
      color
    )
  }
  drawMap_SpaceSpellNotUse (x, y) {
    this.drawLine(
      this.MainSurface,
      [
        [
          this.MapBaseX +
            this.MapLineWidthHalf +
            this.MapBlock * (x + 1) +
            this.MapBlock * 0.15,
          this.MapBaseY -
            this.MapLineWidthHalf -
            this.MapBlock * y -
            this.MapBlock * 0.15
        ],
        [
          this.MapBaseX -
            this.MapLineWidthHalf +
            this.MapBlock * (x + 2) -
            this.MapBlock * 0.15,
          this.MapBaseY -
            this.MapLineWidthHalf -
            this.MapBlock * y -
            this.MapBlock * 0.15
        ],
        [
          this.MapBaseX -
            this.MapLineWidthHalf +
            this.MapBlock * (x + 2) -
            this.MapBlock * 0.15,
          this.MapBaseY +
            this.MapLineWidthHalf -
            this.MapBlock * (y + 1) +
            this.MapBlock * 0.15
        ],
        [
          this.MapBaseX +
            this.MapLineWidthHalf +
            this.MapBlock * (x + 1) +
            this.MapBlock * 0.15,
          this.MapBaseY +
            this.MapLineWidthHalf -
            this.MapBlock * (y + 1) +
            this.MapBlock * 0.15
        ]
      ],
      0,
      'butt',
      'miter',
      null,
      true,
      'purple'
    )
  }
  drawMap_SpaceText (x, y, str, color) {
    this.drawText(
      this.MainSurface,
      this.MapBaseX +
        this.MapLineWidth +
        this.MapBlock * (x + 1) +
        this.FONT_SIZE / 4,
      this.MapBaseY + this.MapLineWidthHalf - this.MapBlock * (y + 1),
      null,
      null,
      str,
      null,
      null,
      color
    )
  }
  drawMap_DoorSouth (x, y, color) {
    this.drawLine(
      this.MainSurface,
      [
        [
          this.MapBaseX + this.MapBlock * (x + 1) + this.MapBlock * 0.35,
          this.MapBaseY - this.MapBlock * y + this.MapBlock * 0.15
        ],
        [
          this.MapBaseX + this.MapBlock * (x + 1) + this.MapBlock * 0.35,
          this.MapBaseY - this.MapBlock * y - this.MapBlock * 0.15
        ]
      ],
      this.MapLineWidth,
      'round',
      null,
      color
    )
    this.drawLine(
      this.MainSurface,
      [
        [
          this.MapBaseX + this.MapBlock * (x + 2) - this.MapBlock * 0.35,
          this.MapBaseY - this.MapBlock * y + this.MapBlock * 0.15
        ],
        [
          this.MapBaseX + this.MapBlock * (x + 2) - this.MapBlock * 0.35,
          this.MapBaseY - this.MapBlock * y - this.MapBlock * 0.15
        ]
      ],
      this.MapLineWidth,
      'round',
      null,
      color
    )
  }
  drawMap_DoorSouthHalfNorth (x, y, color) {
    this.drawLine(
      this.MainSurface,
      [
        [
          this.MapBaseX + this.MapBlock * (x + 1) + this.MapBlock * 0.35,
          this.MapBaseY - this.MapBlock * y
        ],
        [
          this.MapBaseX + this.MapBlock * (x + 1) + this.MapBlock * 0.35,
          this.MapBaseY - this.MapBlock * y - this.MapBlock * 0.15
        ]
      ],
      this.MapLineWidth,
      'round',
      null,
      color
    )
    this.drawLine(
      this.MainSurface,
      [
        [
          this.MapBaseX + this.MapBlock * (x + 2) - this.MapBlock * 0.35,
          this.MapBaseY - this.MapBlock * y
        ],
        [
          this.MapBaseX + this.MapBlock * (x + 2) - this.MapBlock * 0.35,
          this.MapBaseY - this.MapBlock * y - this.MapBlock * 0.15
        ]
      ],
      this.MapLineWidth,
      'round',
      null,
      color
    )
  }
  drawMap_DoorSouthHalfSouth (x, y, color) {
    this.drawLine(
      this.MainSurface,
      [
        [
          this.MapBaseX + this.MapBlock * (x + 1) + this.MapBlock * 0.35,
          this.MapBaseY - this.MapBlock * y + this.MapBlock * 0.15
        ],
        [
          this.MapBaseX + this.MapBlock * (x + 1) + this.MapBlock * 0.35,
          this.MapBaseY - this.MapBlock * y
        ]
      ],
      this.MapLineWidth,
      'round',
      null,
      color
    )
    this.drawLine(
      this.MainSurface,
      [
        [
          this.MapBaseX + this.MapBlock * (x + 2) - this.MapBlock * 0.35,
          this.MapBaseY - this.MapBlock * y + this.MapBlock * 0.15
        ],
        [
          this.MapBaseX + this.MapBlock * (x + 2) - this.MapBlock * 0.35,
          this.MapBaseY - this.MapBlock * y
        ]
      ],
      this.MapLineWidth,
      'round',
      null,
      color
    )
  }
  drawMap_DoorWest (x, y, color) {
    this.drawLine(
      this.MainSurface,
      [
        [
          this.MapBaseX + this.MapBlock * (x + 1) - this.MapBlock * 0.15,
          this.MapBaseY - this.MapBlock * y - this.MapBlock * 0.35
        ],
        [
          this.MapBaseX + this.MapBlock * (x + 1) + this.MapBlock * 0.15,
          this.MapBaseY - this.MapBlock * y - this.MapBlock * 0.35
        ]
      ],
      this.MapLineWidth,
      'round',
      null,
      color
    )
    this.drawLine(
      this.MainSurface,
      [
        [
          this.MapBaseX + this.MapBlock * (x + 1) - this.MapBlock * 0.15,
          this.MapBaseY - this.MapBlock * (y + 1) + this.MapBlock * 0.35
        ],
        [
          this.MapBaseX + this.MapBlock * (x + 1) + this.MapBlock * 0.15,
          this.MapBaseY - this.MapBlock * (y + 1) + this.MapBlock * 0.35
        ]
      ],
      this.MapLineWidth,
      'round',
      null,
      color
    )
  }
  drawMap_DoorWestHalfEast (x, y, color) {
    this.drawLine(
      this.MainSurface,
      [
        [
          this.MapBaseX + this.MapBlock * (x + 1),
          this.MapBaseY - this.MapBlock * y - this.MapBlock * 0.35
        ],
        [
          this.MapBaseX + this.MapBlock * (x + 1) + this.MapBlock * 0.15,
          this.MapBaseY - this.MapBlock * y - this.MapBlock * 0.35
        ]
      ],
      this.MapLineWidth,
      'round',
      null,
      color
    )
    this.drawLine(
      this.MainSurface,
      [
        [
          this.MapBaseX + this.MapBlock * (x + 1),
          this.MapBaseY - this.MapBlock * (y + 1) + this.MapBlock * 0.35
        ],
        [
          this.MapBaseX + this.MapBlock * (x + 1) + this.MapBlock * 0.15,
          this.MapBaseY - this.MapBlock * (y + 1) + this.MapBlock * 0.35
        ]
      ],
      this.MapLineWidth,
      'round',
      null,
      color
    )
  }
  drawMap_DoorWestHalfWest (x, y, color) {
    this.drawLine(
      this.MainSurface,
      [
        [
          this.MapBaseX + this.MapBlock * (x + 1) - this.MapBlock * 0.15,
          this.MapBaseY - this.MapBlock * y - this.MapBlock * 0.35
        ],
        [
          this.MapBaseX + this.MapBlock * (x + 1),
          this.MapBaseY - this.MapBlock * y - this.MapBlock * 0.35
        ]
      ],
      this.MapLineWidth,
      'round',
      null,
      color
    )
    this.drawLine(
      this.MainSurface,
      [
        [
          this.MapBaseX + this.MapBlock * (x + 1) - this.MapBlock * 0.15,
          this.MapBaseY - this.MapBlock * (y + 1) + this.MapBlock * 0.35
        ],
        [
          this.MapBaseX + this.MapBlock * (x + 1),
          this.MapBaseY - this.MapBlock * (y + 1) + this.MapBlock * 0.35
        ]
      ],
      this.MapLineWidth,
      'round',
      null,
      color
    )
  }
  drawMap_WallSouth (x, y, color) {
    this.drawLine(
      this.MainSurface,
      [
        [
          this.MapBaseX + this.MapBlock * (x + 1),
          this.MapBaseY - this.MapBlock * y
        ],
        [
          this.MapBaseX + this.MapBlock * (x + 2),
          this.MapBaseY - this.MapBlock * y
        ]
      ],
      this.MapLineWidth,
      'butt',
      null,
      color
    )
  }
  drawMap_WallWest (x, y, color) {
    this.drawLine(
      this.MainSurface,
      [
        [
          this.MapBaseX + this.MapBlock * (x + 1),
          this.MapBaseY - this.MapBlock * y
        ],
        [
          this.MapBaseX + this.MapBlock * (x + 1),
          this.MapBaseY - this.MapBlock * (y + 1)
        ]
      ],
      this.MapLineWidth,
      'butt',
      null,
      color
    )
  }
  drawMapText (dungeon, floor, x, y, direction) {
    let mapStr = '[' + DUNGEON.DungeonName[dungeon] + ']'
    let str
    if (direction > -1) {
      str = getDefaultMessage('FACING', 1)
      let tmpStr = ''
      if (direction == 0) {
        tmpStr = 'NORTH'
      } else if (direction == 1) {
        tmpStr = 'EAST'
      } else if (direction == 2) {
        tmpStr = 'SOUTH'
      } else if (direction == 3) {
        tmpStr = 'WEST'
      }
      tmpStr = getDefaultMessage(tmpStr, 1)
      str = this.strCut(str.replace(/\[direction\]/g, tmpStr), 46)
      mapStr += '\n' + str
    }
    if (x > -1 && y > -1) {
      str = getDefaultMessage('TO_EAST_NORTH', 1)
      str = str.replace(/\[eastPoint\]/g, String(x))
      str = str.replace(/\[northPoint\]/g, String(y))
      str = this.strCut(str, 46)
      mapStr += '\n' + str
    }
    str = getDefaultMessage('FLOOR', 1)
    str = str.replace(/\[floor\]/g, DUNGEON.getFloorName(dungeon, floor))
    str = this.strCut(str, 46)
    mapStr += '\n' + str
    let lineNum = Math.ceil(this.strGetLineNum(mapStr) / 2)
    this.drawTextFrame(
      this.TextSurface[this.TextSurfaceNum],
      mapStr,
      'center',
      this.LINE_HEIGHT * (10 - lineNum),
      46,
      0
    )
  }
  drawLine (
    surface,
    point,
    lineWidth,
    lineCap,
    lineJoin,
    lineColor,
    polygon,
    bgColor
  ) {
    let ctx = surface.context
    if (point.length < 2) {
      return
    }
    if (lineWidth == undefined || lineWidth == null) {
      lineWidth = 1
    }
    if (lineWidth > 0 && lineWidth < 1) {
      lineWidth = 1
    }
    if (lineCap == undefined || lineCap == null) {
      lineCap = 'round'
    }
    if (lineJoin == undefined || lineJoin == null) {
      lineJoin = 'miter'
    }
    if (lineColor == undefined || lineColor == null) {
      lineColor = 'white'
    }
    if (polygon == undefined || polygon == null) {
      polygon = false
    }
    ctx.lineWidth = lineWidth
    ctx.lineCap = lineCap
    ctx.strokeStyle = lineColor
    ctx.beginPath()
    ctx.moveTo(point[0][0], point[0][1])
    for (let i = 1; i < point.length; i++) {
      ctx.lineTo(point[i][0], point[i][1])
    }
    if (polygon && point.length > 2) {
      ctx.closePath()
      if (bgColor != undefined && bgColor != null) {
        ctx.fillStyle = bgColor
        ctx.fill()
        if (lineWidth > 0) {
          ctx.stroke()
        }
      } else {
        ctx.stroke()
      }
    } else {
      ctx.stroke()
    }
  }
  drawOptionFrame () {
    let x = this.MAIN_X + this.MAIN_WIDTH / 20
    let y = this.MAIN_Y + this.MAIN_HEIGHT / 20
    let w = this.MAIN_WIDTH - this.MAIN_WIDTH / 10
    let h = this.MAIN_HEIGHT - this.MAIN_HEIGHT / 10
    this.drawFrame(
      this.TopSurface,
      x,
      y,
      w,
      h,
      this.FRAME_ARC,
      this.FRAME_WIDTH,
      'white',
      'black'
    )
    this.drawTextFrame(
      this.TopSurface,
      ' Option ',
      'center',
      y - this.FONT_HALF_SIZE,
      null,
      null,
      'center'
    )
  }
  drawRect (sf, x, y, w, h, r, lineWidth, fillColor, strokeColor) {
    let ctx = sf.getContext('2d')
    fillColor = checkNull(fillColor, '')
    strokeColor = checkNull(strokeColor, '')
    ;(x = checkNull(x, 0)), (y = checkNull(y, 0))
    ;(w = checkNull(w, calMinus(sf.width, x))),
      (h = checkNull(h, calMinus(sf.height, y)))
    r = checkNull(r, 0)
    lineWidth = checkNull(lineWidth, 1)
    if (r < 0) {
      let minW = w
      if (h < w) {
        minW = h
      }
      r = calDiv(minW, 20)
    }
    ctx.lineWidth = lineWidth
    if (r != 0) {
      ctx.beginPath()
      ctx.moveTo(calPlus(x, r), y)
      ctx.lineTo(calPlus(x, w) - r, y)
      ctx.arc(
        calMinus(calPlus(x, w), r),
        calPlus(y, r),
        r,
        Math.PI * (3 / 2),
        0,
        false
      )
      ctx.lineTo(calPlus(x, w), calPlus(y, h) - r)
      ctx.arc(
        calMinus(calPlus(x, w), r),
        calMinus(calPlus(y, h), r),
        r,
        0,
        Math.PI * (1 / 2),
        false
      )
      ctx.lineTo(calPlus(x, r), calPlus(y, h))
      ctx.arc(
        calPlus(x, r),
        calMinus(calPlus(y, h), r),
        r,
        Math.PI * (1 / 2),
        Math.PI,
        false
      )
      ctx.lineTo(x, calPlus(y, r))
      ctx.arc(
        calPlus(x, r),
        calPlus(y, r),
        r,
        Math.PI,
        Math.PI * (3 / 2),
        false
      )
      ctx.closePath()
    }
    if (fillColor != '') {
      ctx.fillStyle = fillColor
      if (r != 0) {
        ctx.fill()
      } else {
        ctx.fillRect(x, y, w, h)
      }
    }
    if (strokeColor != '') {
      ctx.strokeStyle = strokeColor
      if (r != 0) {
        ctx.stroke()
      } else {
        ctx.strokeRect(x, y, w, h)
      }
    }
  }
  drawScrollFrame (surface, x, y, charMin, lineNum, scroll) {
    let ctx = surface.context
    let frameX = x - this.FRAME_WIDTH * 1.3
    let frameY = y - (this.FRAME_WIDTH + this.FRAME_WIDTH * 0.3)
    let frameW = this.FONT_HALF_SIZE * charMin + this.FRAME_WIDTH * 2.6
    let frameH = this.LINE_HEIGHT * lineNum + this.FRAME_WIDTH * 1.9
    ctx.lineJoin = 'round'
    let xLeft = frameX + frameW / 2 - this.FONT_HALF_SIZE
    let xRight = frameX + frameW / 2 + this.FONT_HALF_SIZE
    if (scroll.indexOf('up') > -1) {
      ctx.fillStyle = 'black'
      ctx.beginPath()
      ctx.moveTo(xLeft, frameY + this.FRAME_WIDTH * 0.5)
      ctx.lineTo(frameX + frameW / 2, frameY - this.FRAME_WIDTH * 2)
      ctx.lineTo(xRight, frameY + this.FRAME_WIDTH * 0.5)
      ctx.closePath()
      ctx.fill()
      ctx.fillStyle = GameData['SELECT_OVER_COLOR']
      ctx.beginPath()
      ctx.moveTo(
        xLeft + this.FRAME_WIDTH * 0.6,
        frameY + this.FRAME_WIDTH * 0.5
      )
      ctx.lineTo(frameX + frameW / 2, frameY - this.FRAME_WIDTH * 1.3)
      ctx.lineTo(
        xRight - this.FRAME_WIDTH * 0.6,
        frameY + this.FRAME_WIDTH * 0.5
      )
      ctx.closePath()
      ctx.fill()
    }
    if (scroll.indexOf('down') > -1) {
      ctx.fillStyle = 'black'
      ctx.beginPath()
      ctx.moveTo(xLeft, frameY + frameH - this.FRAME_WIDTH * 0.5)
      ctx.lineTo(frameX + frameW / 2, frameY + frameH + this.FRAME_WIDTH * 2)
      ctx.lineTo(xRight, frameY + frameH - this.FRAME_WIDTH * 0.5)
      ctx.closePath()
      ctx.fill()
      ctx.fillStyle = GameData['SELECT_OVER_COLOR']
      ctx.beginPath()
      ctx.moveTo(
        xLeft + this.FRAME_WIDTH * 0.6,
        frameY + frameH - this.FRAME_WIDTH * 0.5
      )
      ctx.lineTo(frameX + frameW / 2, frameY + frameH + this.FRAME_WIDTH * 1.3)
      ctx.lineTo(
        xRight - this.FRAME_WIDTH * 0.6,
        frameY + frameH - this.FRAME_WIDTH * 0.5
      )
      ctx.closePath()
      ctx.fill()
    }
    ctx.fillStyle = 'white'
  }
  drawStatusFrameText (surface) {
    let ctx = surface.context
    let diff = this.strDiffLength(
      this.strFitLength('', 56, 'left'),
      this.NUMBER_OF_CHARACTERS - 4,
      'center'
    )
    let x = this.MAIN_TEXT_X + this.FONT_HALF_SIZE * (2 + diff[1])
    let y = this.LINE_HEIGHT * 18.6 - this.FRAME_WIDTH
    let y2 = this.LINE_HEIGHT * 18.6 - this.FONT_SIZE / 1.2 - this.FRAME_WIDTH
    let str = getDefaultMessage('NAME', 1, 18)
    let len = this.strCount(str)
    if (str != '') {
      ctx.fillStyle = 'black'
      ctx.fillRect(
        x + this.FONT_HALF_SIZE * 2 - this.FONT_SIZE / 4,
        y2,
        this.FONT_HALF_SIZE * len + this.FONT_HALF_SIZE,
        this.FONT_SIZE
      )
    }
    ctx.fillStyle = 'white'
    ctx.fillText(str, x + this.FONT_HALF_SIZE * 2, y)
    str = getDefaultMessage('CLASS', 1, 6)
    len = this.strCount(str)
    let lenHalf = Math.floor(len / 2)
    if (str != '') {
      ctx.fillStyle = 'black'
      ctx.fillRect(
        x + this.FONT_HALF_SIZE * (26 - lenHalf) - this.FONT_SIZE / 4,
        y2,
        this.FONT_HALF_SIZE * len + this.FONT_HALF_SIZE,
        this.FONT_SIZE
      )
    }
    ctx.fillStyle = 'white'
    ctx.fillText(str, x + this.FONT_HALF_SIZE * (26 - lenHalf), y)
    str = getDefaultMessage('AC', 1, 4)
    len = this.strCount(str)
    if (str != '') {
      ctx.fillStyle = 'black'
      ctx.fillRect(
        x + this.FONT_HALF_SIZE * (36 - len) - this.FONT_SIZE / 4,
        y2,
        this.FONT_HALF_SIZE * len + this.FONT_HALF_SIZE,
        this.FONT_SIZE
      )
    }
    ctx.fillStyle = 'white'
    ctx.fillText(str, x + this.FONT_HALF_SIZE * (36 - len), y)
    str = getDefaultMessage('HP', 1, 4)
    len = this.strCount(str)
    if (str != '') {
      ctx.fillStyle = 'black'
      ctx.fillRect(
        x + this.FONT_HALF_SIZE * (42 - len) - this.FONT_SIZE / 4,
        y2,
        this.FONT_HALF_SIZE * len + this.FONT_HALF_SIZE,
        this.FONT_SIZE
      )
    }
    ctx.fillStyle = 'white'
    ctx.fillText(str, x + this.FONT_HALF_SIZE * (42 - len), y)
    str = getDefaultMessage('STATUS', 1, 8)
    len = this.strCount(str)
    lenHalf = Math.floor(len / 2)
    if (str != '') {
      ctx.fillStyle = 'black'
      ctx.fillRect(
        x + this.FONT_HALF_SIZE * (49 - lenHalf) - this.FONT_SIZE / 4,
        y2,
        this.FONT_HALF_SIZE * len + this.FONT_HALF_SIZE,
        this.FONT_SIZE
      )
    }
    ctx.fillStyle = 'white'
    ctx.fillText(str, x + this.FONT_HALF_SIZE * (49 - lenHalf), y)
    y += this.FRAME_WIDTH + this.FONT_SIZE / 1.2
    y2 += this.FRAME_WIDTH + this.FONT_SIZE / 1.2
    if (PlayData['ActiveParty'] < 0) {
      return
    }
    let ptNum = PlayData['ActiveParty']
    let memberNum = PARTY[ptNum].getMemberNum()
    for (let i = 0; i < memberNum; i++) {
      let pcNum = PARTY[ptNum].PartyMember[i]
      if (PC[pcNum].NextExp > 0) {
        continue
      }
      ctx.fillStyle = 'black'
      ctx.fillRect(
        x +
          this.FONT_HALF_SIZE * 56 +
          this.FRAME_WIDTH / 2 -
          this.FONT_SIZE / 4,
        y2 + this.LINE_HEIGHT * i - this.FONT_SIZE * 0.08,
        this.FONT_HALF_SIZE + this.FONT_HALF_SIZE,
        this.FONT_SIZE + this.FONT_SIZE * 0.2
      )
      ctx.fillStyle = 'white'
      ctx.fillText(
        GameData['LEVEL_UP'],
        x + this.FONT_HALF_SIZE * 56 + this.FRAME_WIDTH / 2,
        y + this.LINE_HEIGHT * i
      )
    }
  }
  drawText (surface, x, y, charMax, lineMax, str, align, line, color) {
    let ctx = surface.context
    y += this.FONT_SIZE / 1.2
    if (color == undefined || color == null || color == '') {
      color = 'white'
    }
    ctx.fillStyle = color
    if (charMax == undefined || charMax == null) {
      charMax = this.NUMBER_OF_CHARACTERS
    }
    if (lineMax == undefined || lineMax == null) {
      lineMax = this.NUMBER_OF_LINES
    }
    if (line == undefined || line == null || isNaN(line)) {
      line = 1
    }
    if (line < 1) {
      line = 1
    } else if (line > lineMax) {
      line = lineMax
    }
    let charNum = -1
    if (align == undefined || align == null) {
      align = 'left'
    }
    if (!isNaN(align)) {
      align = Number(align)
      if (align < 0) {
        align = 0
      } else if (align >= charMax) {
        align = charMax - 1
      }
      charNum = align
    }
    let len = charMax
    if (charNum > 0) {
      len -= charNum
    }
    let strAryP = str.split('<p>')
    let strAry = strAryP[0].split(/<br>|\r\n|\n|\r/)
    for (let i = 0; i < strAry.length; i++) {
      let line2 = line + i
      if (line2 > lineMax) {
        break
      }
      if (this.strCount(strAry[i]) > len) {
        strAry[i] = this.strFitLength(strAry[i], len, align)
      }
      let charNum2 = 0
      if (charNum > -1) {
        charNum2 = charNum
      } else if (align.match(/center|right/)) {
        let diff = this.strDiffLength(strAry[i], charMax, align)
        charNum2 = diff[1]
      }
      ctx.fillText(
        strAry[i],
        x + this.FONT_HALF_SIZE * charNum2,
        y + this.LINE_HEIGHT * (line2 - 1)
      )
    }
  }
  drawText_Full (surface, str, align, line, color) {
    this.drawText(
      surface,
      this.MAIN_TEXT_X,
      this.MAIN_Y,
      this.NUMBER_OF_CHARACTERS,
      this.NUMBER_OF_LINES,
      str,
      align,
      line,
      color
    )
  }
  drawText_FullFrame (surface, str, align, line, color) {
    this.drawText(
      surface,
      this.MAIN_TEXT_X + this.FONT_SIZE,
      this.MAIN_Y + this.FONT_SIZE / 1.4,
      this.NUMBER_OF_CHARACTERS - 4,
      this.NUMBER_OF_LINES - 1,
      str,
      align,
      line,
      color
    )
  }
  drawTextFrame (
    surface,
    str,
    align,
    y,
    charMin,
    lineMin,
    textAlign,
    color,
    select,
    selectColor,
    scroll
  ) {
    let ctx = surface.context
    let strAryP = str.split('<p>')
    let strAry = strAryP[0].split(/<br>|\r\n|\n|\r/)
    scroll = checkNull(scroll, '')
    if (charMin == undefined || charMin == null) {
      charMin = 1
    }
    if (charMin < 1) {
      charMin = 1
    }
    let charMax = 0
    for (let i = 0; i < strAry.length; i++) {
      if (strAry[i].match(/^<img *src=\"[^>]*?\".*?>$/)) {
        continue
      }
      let len = this.strCount(strAry[i])
      if (len > charMax) {
        charMax = len
      }
    }
    if (charMax < charMin) {
      charMax = charMin
    }
    if (charMax > this.NUMBER_OF_CHARACTERS - 4) {
      charMax = this.NUMBER_OF_CHARACTERS - 4
    }
    if (lineMin == undefined || lineMin == null) {
      lineMin = 1
    }
    if (lineMin < 1) {
      lineMin = 1
    }
    if (lineMin < strAry.length) {
      lineMin = strAry.length
    }
    let x = 0
    if (!isNaN(align)) {
      x = Number(align)
    } else if (align.match(/left|center|right/)) {
      let diff = this.strDiffLength(
        this.strFitLength('', charMax, 'left'),
        this.NUMBER_OF_CHARACTERS - 4,
        align
      )
      x = this.MAIN_TEXT_X + this.FONT_HALF_SIZE * (2 + diff[1])
    }
    let frameX = x - this.FRAME_WIDTH * 1.3
    let frameY = y - (this.FRAME_WIDTH + this.FRAME_WIDTH * 0.3)
    let frameW = this.FONT_HALF_SIZE * charMax + this.FRAME_WIDTH * 2.6
    let frameH = this.LINE_HEIGHT * lineMin + this.FRAME_WIDTH * 1.9
    this.drawFrame(
      surface,
      frameX,
      frameY,
      frameW,
      frameH,
      this.FRAME_ARC,
      this.FRAME_WIDTH,
      'white',
      'black',
      'black'
    )
    if (!Number.isNaN(select)) {
      if (select > -1 && select < lineMin) {
        if (selectColor == undefined || selectColor == null) {
          selectColor = 'red'
        }
        ctx.fillStyle = selectColor
        let t1 = 0.3,
          t2 = 0.0
        if (lineMin == 1) {
          ;(t1 += 0.7), (t2 += 1.2)
        } else if (select == 0) {
          ;(t1 += 0.7), (t2 += 0.7)
        } else if (select == lineMin - 1) {
          t2 += 0.6
        }
        ctx.fillRect(
          x - this.FRAME_WIDTH,
          y - this.FRAME_WIDTH * t1 + this.LINE_HEIGHT * select,
          this.FONT_HALF_SIZE * charMax + this.FRAME_WIDTH * 2,
          this.LINE_HEIGHT + this.FRAME_WIDTH * t2
        )
        this.drawFrame(
          surface,
          frameX,
          frameY,
          frameW,
          frameH,
          this.FRAME_ARC,
          this.FRAME_WIDTH,
          'white'
        )
      }
    }
    if (color == undefined || color == null) {
      color = ''
    }
    if (!Array.isArray(color)) {
      if (color.indexOf(',') > -1) {
        color = color.split(',')
      } else {
        let colorTmp = color
        color = []
        for (let i = 0; i < strAry.length; i++) {
          color.push(colorTmp)
        }
      }
    }
    for (let i = 0; i < strAry.length; i++) {
      if (strAry[i].match(/^(|[ ]+)$/)) {
        continue
      } else if (strAry[i].match(/^<img *src=\"[^>]*?\".*?>$/)) {
        let srcStr = strAry[i].replace(/^<img *src=\"([^>]*?)\".*?>$/, '$1')
        if (srcStr == '') {
          continue
        }
        srcStr = 'graphic/' + srcStr
        if (GraphicData[srcStr] == undefined || GraphicData[srcStr] == null) {
          continue
        }
        let widthStr = ''
        if (strAry[i].match(/^<.*width=\"[^>]*?\".*?>$/)) {
          widthStr = strAry[i].replace(/^<.*width=\"([^>]*?)\" *>$/, '$1')
        }
        let wScale = 100
        if (!isNaN(widthStr) && widthStr != '') {
          wScale = Number(widthStr)
        }
        if (wScale <= 0) {
          wScale = 1
        } else if (wScale > 200) {
          wScale = 200
        }
        let wMax = this.FONT_HALF_SIZE * charMax
        let hMax = this.LINE_HEIGHT * 10 - this.FRAME_WIDTH
        let gH = hMax
        let gW = (wScale * gH) / 100
        if (gW > wMax) {
          gW = wMax
          gH = (gW * 100) / wScale
        }
        let gX = frameX + frameW / 2 - gW / 2
        let gY = frameY + this.FRAME_WIDTH / 2 + this.LINE_HEIGHT * 5 - gH / 2
        this.paintGraphic(surface, GraphicData[srcStr], gX, gY, gW, gH)
        continue
      }
      this.drawText(
        surface,
        x,
        y,
        charMax,
        strAry.length,
        strAry[i],
        textAlign,
        i + 1,
        color[i]
      )
    }
    if (scroll != '') {
      this.drawScrollFrame(surface, x, y, charMin, lineMin, scroll)
    }
  }
  drawPartyTeleport (select, x, y, floor) {
    this.clearTextSurface()
    let text = getDefaultMessage('PARTY_TELEPORT', 1, 52) + '\n\n'
    if (x > -1) {
      text += this.strFitLength(getDefaultMessage('EAST', 1), 5)
    } else {
      text += this.strFitLength(getDefaultMessage('WEST', 1), 5)
      x *= -1
    }
    text += '[' + this.strFitLength(String(x), 2, 'right') + ']'
    text += '\n'
    if (y > -1) {
      text += this.strFitLength(getDefaultMessage('NORTH', 1), 5)
    } else {
      text += this.strFitLength(getDefaultMessage('SOUTH', 1), 5)
      y *= -1
    }
    text += '[' + this.strFitLength(String(y), 2, 'right') + ']'
    text += '\n'
    if (floor > -1) {
      text += this.strFitLength(getDefaultMessage('UP', 1), 5)
    } else {
      text += this.strFitLength(getDefaultMessage('DOWN', 1), 5)
      floor *= -1
    }
    text += '[' + this.strFitLength(String(floor), 2, 'right') + ']'
    this.drawTextFrame(
      this.TextSurface[this.TextSurfaceNum],
      text,
      'center',
      this.LINE_HEIGHT * 8,
      36,
      5,
      'left',
      null,
      select + 2
    )
  }
  escapeProcessing (str) {
    str = str.replace(/\\/g, '\\\\')
    str = str.replace(/\*/g, '\\*')
    str = str.replace(/\+/g, '\\+')
    str = str.replace(/\./g, '\\.')
    str = str.replace(/\?/g, '\\?')
    str = str.replace(/\^/g, '\\^')
    str = str.replace(/\$/g, '\\$')
    str = str.replace(/\-/g, '\\-')
    str = str.replace(/\|/g, '\\|')
    str = str.replace(/\[/g, '\\[')
    str = str.replace(/\]/g, '\\]')
    str = str.replace(/\{/g, '\\{')
    str = str.replace(/\}/g, '\\}')
    str = str.replace(/\(/g, '\\(')
    str = str.replace(/\)/g, '\\)')
    return str
  }
  filterAlpha (img, alpha) {
    if (img == null) {
      return
    }
    let imageData = img.context.getImageData(0, 0, img.width, img.height)
    let data = imageData.data
    for (let i = 0; i < data.length; i += 4) {
      data[i + 3] = alpha
    }
    img.context.putImageData(imageData, 0, 0)
  }
  filterAlphaNotOpaque (img) {
    if (img == null) {
      return
    }
    let imageData = img.context.getImageData(0, 0, img.width, img.height)
    let data = imageData.data
    for (let i = 0; i < data.length; i += 4) {
      if (data[i + 3] != 0) {
        data[i + 3] = 255
      }
    }
    img.context.putImageData(imageData, 0, 0)
  }
  filterGamma (img, gamma) {
    if (img == null) {
      return
    }
    let imageData = img.context.getImageData(0, 0, img.width, img.height)
    let data = imageData.data
    let correctify = val => 255 * Math.pow(val / 255, 1 / gamma)
    for (let i = 0; i < data.length; i += 4) {
      if (data[i + 3] > 0) {
        data[i] = correctify(data[i])
        data[i + 1] = correctify(data[i + 1])
        data[i + 2] = correctify(data[i + 2])
      }
    }
    img.context.putImageData(imageData, 0, 0)
  }
  filterGlobalAlpha (img, alpha) {
    if (img == null) {
      return
    }
    let cloneImg = img.clone()
    img.clear()
    img.context.globalAlpha = alpha
    img.draw(cloneImg)
  }
  filterMosaic (img, sizePercent) {
    if (img == null || sizePercent < 1 || sizePercent > 100) {
      return
    }
    let ctx = img.context
    let imageData = null,
      data
    try {
      imageData = ctx.getImageData(0, 0, img.width, img.height)
      data = imageData.data
    } catch (error) {}
    let w = img.width,
      h = img.height
    let sizeX = Math.floor((w * sizePercent) / 100)
    let sizeY = Math.floor((h * sizePercent) / 100)
    for (let j = 0; j < h; j += sizeY) {
      for (let i = 0; i < w; i += sizeX) {
        if (i + sizeX > w || j + sizeY > h) {
          continue
        }
        if (imageData != null) {
          let red = 0,
            green = 0,
            blue = 0
          let aryX = [
            i,
            i + sizeX - 1,
            i + sizeX - 1,
            i,
            i + Math.floor(sizeX / 2)
          ]
          let aryY = [
            j,
            j,
            j + sizeY - 1,
            j + sizeY - 1,
            j + Math.floor(sizeY / 2)
          ]
          for (let k = 0; k < 5; k++) {
            if (data[aryX[k] * 4 + aryY[k] * w * 4 + 3] != 0) {
              red += data[aryX[k] * 4 + aryY[k] * w * 4]
              green += data[aryX[k] * 4 + aryY[k] * w * 4 + 1]
              blue += data[aryX[k] * 4 + aryY[k] * w * 4 + 2]
            }
          }
          ;(red /= 5), (green /= 5), (blue /= 5)
          ctx.fillStyle = 'rgb(' + red + ',' + green + ',' + blue + ')'
          ctx.fillRect(i, j, sizeX, sizeY)
        } else {
          let x = i + Math.floor(sizeX / 2)
          let y = j + Math.floor(sizeY / 2)
          img.draw(img, x, y, 1, 1, i, j, sizeX, sizeY)
        }
      }
    }
  }
  getCmNum (str) {
    let result = ''
    let strAry = str.split(',')
    for (let i = 0; i < strAry.length; i++) {
      if (!strAry[i].match(/[0-9]+|[0-9]+\-[0-9]+/)) {
        continue
      }
      result += ','
      if (strAry[i].indexOf('-') > -1) {
        let strAry2 = strAry[i].split('-')
        let num1, num2
        if (!strAry2[0].match(/[0-9]+/)) {
          num1 = 0
        } else {
          num1 = Number(strAry2[0])
        }
        if (!strAry2[1].match(/[0-9]+/)) {
          num2 = 0
        } else {
          num2 = Number(strAry2[1])
        }
        if (num1 > num2) {
          let num = num1
          num1 = num2
          num2 = num
        }
        let start, end
        if (num1 < num2) {
          start = num1
          end = num2 + 1
        } else {
          start = num1
          end = num1 + 1
        }
        for (let j = start; j < end; j++) {
          if (j > start) {
            result += ','
          }
          result += String(j)
        }
      } else {
        result += strAry[i]
      }
    }
    return result.replace(/^,/, '')
  }
  hanKana2zenKana (str) {
    let replaceFm = new Array(
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      ''
    )
    let replaceTo = new Array(
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      ''
    )
    for (let key in replaceFm) {
      str = str.replace(new RegExp(replaceFm[key], 'g'), replaceTo[key])
    }
    return str
  }
  isZenkaku (c) {
    if (c.match(/[^\x01-\x7E]/) && c.match(/[^\uFF65-\uFF9F]/)) {
      return true
    } else {
      return false
    }
  }
  loadingScreen () {
    this.clearDungeonPaintData()
    this.setDungeonView('', true)
    let moveAction = this.loadingScreenWalk()
    this.paintDungeon('wireFrame', false)
    if (LaunchSettings['LoadingScreen'] == 1) {
      this.StatusSurface.clear()
      let arrowW = calDiv(this.CENTER_FRAME_WIDTH, 4)
      let arrowH = calDiv(this.CENTER_FRAME_HEIGHT, 6)
      this.drawArrow3D(
        this.StatusSurface,
        this.CENTER_FRAME_X +
          calDiv(this.CENTER_FRAME_WIDTH, 2) -
          calDiv(arrowW, 2),
        this.CENTER_FRAME_Y +
          this.CENTER_FRAME_HEIGHT -
          arrowH -
          calTimes(this.FRAME_WIDTH, 4),
        arrowW,
        arrowH,
        moveAction,
        this.DUNGEON_FRAME_WIDTH,
        'red',
        'green'
      )
    }
    if (
      !TempVariable['loadingEnd'] &&
      this.FONT_NAME != '' &&
      TempVariable['loadingText'] != undefined
    ) {
      this.drawText_Full(
        this.MainSurface,
        TempVariable['loadingText'],
        'center',
        21,
        'yellow'
      )
    }
  }
  loadingScreenWalk () {
    let move = '',
      moveAction
    if (LaunchSettings['LoadingScreen'] == 1) {
      if (TempVariable['ptNext'] == 'forward') {
        if (this.DungeonWall[0] != 1) {
          move = 'f'
        }
      } else if (TempVariable['ptNext'] == 'turnRight') {
        move = 'r'
      } else if (TempVariable['ptNext'] == 'turnLeft') {
        move = 'l'
      }
      TempVariable['ptNext'] = ''
    } else {
      move = 'f'
    }
    if (move == '') {
      let x = TempVariable['ptX'],
        y = TempVariable['ptY'],
        d = TempVariable['ptDirection']
      if (x == 0 && y == 2) {
        if (d == 0) {
          move = 'f'
        } else if (d == 3) {
          move = 'r'
        }
      } else if (x == 3 && y == 6) {
        if (d == 1) {
          move = 'r'
        } else if (d == 3) {
          move = 'l'
        }
      } else if (x == 5 && y == 0) {
        if (d == 2) {
          move = 'l'
        }
      } else if (x == 6 && y == 1) {
        if (d == 3) {
          move = 'l'
        }
      } else if (x == 6 && y == 5) {
        if (d == 1) {
          move = 'l'
        }
      }
    }
    if (move == '') {
      if (this.DungeonWall[0] != 1) {
        move += 'f'
      }
      if (
        this.DungeonWall[1] != 1 &&
        !(
          this.DungeonWall[0] != 1 &&
          this.DungeonWall[3] == 0 &&
          this.DungeonWall[6] == 0
        )
      ) {
        move += 'l'
      }
      if (
        this.DungeonWall[2] != 1 &&
        !(
          this.DungeonWall[0] != 1 &&
          this.DungeonWall[4] == 0 &&
          this.DungeonWall[7] == 0
        )
      ) {
        move += 'r'
      }
    }
    if (move == '') {
      move = 'turn'
    } else if (move == 'f') {
      move = 'forward'
    } else if (move.indexOf('f') > -1) {
      if (dice(1, 100) <= 75) {
        move = 'forward'
      } else {
        move = move.replace('f', '')
      }
    }
    if (move == 'lr') {
      if (dice(1, 100) <= 50) {
        move = 'l'
      } else {
        move = 'r'
      }
    }
    if (move == 'l') {
      move = 'turnLeft'
    } else if (move == 'r') {
      move = 'turnRight'
    }
    moveAction = move
    if (move == 'forward') {
      if (TempVariable['ptDirection'] == 0) {
        TempVariable['ptY']++
      } else if (TempVariable['ptDirection'] == 1) {
        TempVariable['ptX']++
      } else if (TempVariable['ptDirection'] == 2) {
        TempVariable['ptY']--
      } else {
        TempVariable['ptX']--
      }
      if (TempVariable['ptX'] >= TempVariable['width']) {
        TempVariable['ptX'] = 0
      } else if (TempVariable['ptX'] < 0) {
        TempVariable['ptX'] = TempVariable['width'] - 1
      }
      if (TempVariable['ptY'] >= TempVariable['height']) {
        TempVariable['ptY'] = 0
      } else if (TempVariable['ptY'] < 0) {
        TempVariable['ptY'] = TempVariable['height'] - 1
      }
    } else if (move == 'turn') {
      TempVariable['ptDirection']++
      if (TempVariable['ptDirection'] >= 4) {
        TempVariable['ptDirection'] = 0
      }
      TempVariable['ptNext'] = 'turnRight'
      moveAction = 'turnRight'
    } else if (move == 'turnRight') {
      TempVariable['ptDirection']++
      if (TempVariable['ptDirection'] >= 4) {
        TempVariable['ptDirection'] = 0
      }
      TempVariable['ptNext'] = 'forward'
    } else if (move == 'turnLeft') {
      TempVariable['ptDirection']--
      if (TempVariable['ptDirection'] < 0) {
        TempVariable['ptDirection'] = 3
      }
      TempVariable['ptNext'] = 'forward'
    }
    return moveAction
  }
  numberDigitMatch (num, digit) {
    if (isNaN(num)) {
      return num
    }
    let str = String(num)
    while (str.length < digit) {
      str = '0' + str
    }
    return str
  }
  numberFormat (num) {
    if (isNaN(num)) {
      return num
    }
    return String(num).replace(/(\d)(?=(\d\d\d)+(?!\d))/g, '$1,')
  }
  paintDungeon (dungeon, perspective) {
    if (dungeon == undefined || dungeon == null || dungeon == '') {
      dungeon = Config['Dungeon']
    }
    if (perspective == undefined || perspective == null) {
      perspective = Config['PerspectiveView']
    }
    while (this.Sprite3D.childNodes.length > 0) {
      this.Sprite3D.removeChild(this.Sprite3D.childNodes[0])
    }
    this.MainSurface.clear()
    if (
      this.DungeonSpace[0] == 1 ||
      (dungeon == 'graphic' && this.ImgWall == null) ||
      dungeon == 'clear'
    ) {
      this.drawFrame_Center(this.MainSurface)
      return
    }
    if (dungeon == 'graphic' && this.ImgDistantView != null) {
      this.setWall3D(5, 28, false)
      if (this.DungeonLight) {
        this.setWall3D(6, 29, false)
      } else {
        for (let i = 6; i <= 10; i++) {
          this.setFloor3D(1, 0, i, 'f', false)
          this.setFloor3D(1, 0, i, 'c', false)
        }
        this.setWall3D(6, 10, false)
        for (let i = 15; i <= 18; i++) {
          this.setWall3D(6, i, false)
        }
      }
    }
    if (this.checkPaintWall(24, dungeon)) {
      if (this.DungeonSpace[11] != 1) {
        this.paintDungeonBlockWall(24, dungeon, perspective)
      }
    }
    this.paintDungeonBlockSpace(11, dungeon, perspective)
    if (this.checkPaintWall(25, dungeon)) {
      if (this.DungeonSpace[12] != 1) {
        this.paintDungeonBlockWall(25, dungeon, perspective)
      }
    }
    this.paintDungeonBlockSpace(12, dungeon, perspective)
    if (this.checkPaintWall(19, dungeon)) {
      if (this.DungeonSpace[13] != 1) {
        this.paintDungeonBlockWall(19, dungeon, perspective)
      }
    }
    this.paintDungeonBlockSpace(13, dungeon, perspective)
    if (this.checkPaintWall(26, dungeon)) {
      if (this.DungeonSpace[14] != 1) {
        this.paintDungeonBlockWall(26, dungeon, perspective)
      }
    }
    this.paintDungeonBlockSpace(14, dungeon, perspective)
    if (this.checkPaintWall(27, dungeon)) {
      if (this.DungeonSpace[15] != 1) {
        this.paintDungeonBlockWall(27, dungeon, perspective)
      }
    }
    this.paintDungeonBlockSpace(15, dungeon, perspective)
    if (this.checkPaintWall(20, dungeon)) {
      if (dungeon == 'graphic') {
        this.setWall3D(this.DungeonWall[20], 20, perspective)
        if (this.checkPaintWallSide(20, dungeon)) {
          this.setWall3D(7, 50, perspective)
        }
      } else {
        this.paintDungeonBlockWall(20, dungeon, perspective)
      }
    } else if (this.DungeonSpace[12] == 1 && this.DungeonLight) {
      if (dungeon == 'graphic') {
        if (!this.checkPaintWallSide(15, dungeon)) {
          this.setWall3D(6, 20, false)
        }
      } else {
        this.drawDungeon(this.MainSurface, 'wd', 20)
      }
    }
    if (this.checkPaintWall(21, dungeon)) {
      if (dungeon == 'graphic') {
        this.setWall3D(this.DungeonWall[21], 21, perspective)
        if (this.checkPaintWallSide(21, dungeon)) {
          this.setWall3D(7, 51, perspective)
        }
      } else {
        this.paintDungeonBlockWall(21, dungeon, perspective)
      }
    } else if (this.DungeonSpace[13] == 1 && this.DungeonLight) {
      if (dungeon == 'graphic') {
        if (!this.checkPaintWallSide(16, dungeon)) {
          this.setWall3D(6, 21, false)
        }
      } else {
        this.drawDungeon(this.MainSurface, 'wd', 21)
      }
    }
    if (this.checkPaintWall(22, dungeon)) {
      if (dungeon == 'graphic') {
        this.setWall3D(this.DungeonWall[22], 22, perspective)
        if (this.checkPaintWallSide(22, dungeon)) {
          this.setWall3D(7, 52, perspective)
        }
      } else {
        this.paintDungeonBlockWall(22, dungeon, perspective)
      }
    } else if (this.DungeonSpace[13] == 1 && this.DungeonLight) {
      if (dungeon == 'graphic') {
        if (!this.checkPaintWallSide(17, dungeon)) {
          this.setWall3D(6, 22, false)
        }
      } else {
        this.drawDungeon(this.MainSurface, 'wd', 22)
      }
    }
    if (this.checkPaintWall(23, dungeon)) {
      if (dungeon == 'graphic') {
        this.setWall3D(this.DungeonWall[23], 23, perspective)
        if (this.checkPaintWallSide(23, dungeon)) {
          this.setWall3D(7, 53, perspective)
        }
      } else {
        this.paintDungeonBlockWall(23, dungeon, perspective)
      }
    } else if (this.DungeonSpace[14] == 1 && this.DungeonLight) {
      if (dungeon == 'graphic') {
        if (!this.checkPaintWallSide(18, dungeon)) {
          this.setWall3D(6, 23, false)
        }
      } else {
        this.drawDungeon(this.MainSurface, 'wd', 23)
      }
    }
    if (this.checkPaintWall(15, dungeon)) {
      if (this.DungeonSpace[6] != 1) {
        this.paintDungeonBlockWall(15, dungeon, perspective)
        if (this.checkPaintWallSide(15, dungeon)) {
          this.setWall3D(7, 45, perspective)
        }
      }
    }
    this.paintDungeonBlockSpace(6, dungeon, perspective)
    if (this.checkPaintWall(16, dungeon)) {
      if (this.DungeonSpace[7] != 1) {
        this.paintDungeonBlockWall(16, dungeon, perspective)
        if (this.checkPaintWallSide(16, dungeon)) {
          this.setWall3D(7, 46, perspective)
        }
      }
    }
    this.paintDungeonBlockSpace(7, dungeon, perspective)
    if (this.checkPaintWall(10, dungeon)) {
      if (this.DungeonSpace[8] != 1) {
        this.paintDungeonBlockWall(10, dungeon, perspective)
      }
    }
    this.paintDungeonBlockSpace(8, dungeon, perspective)
    if (this.checkPaintWall(17, dungeon)) {
      if (this.DungeonSpace[9] != 1) {
        this.paintDungeonBlockWall(17, dungeon, perspective)
        if (this.checkPaintWallSide(17, dungeon)) {
          this.setWall3D(7, 47, perspective)
        }
      }
    }
    this.paintDungeonBlockSpace(9, dungeon, perspective)
    if (this.checkPaintWall(18, dungeon)) {
      if (this.DungeonSpace[10] != 1) {
        this.paintDungeonBlockWall(18, dungeon, perspective)
        if (this.checkPaintWallSide(18, dungeon)) {
          this.setWall3D(7, 48, perspective)
        }
      }
    }
    this.paintDungeonBlockSpace(10, dungeon, perspective)
    if (this.checkPaintWall(11, dungeon)) {
      if (dungeon == 'graphic') {
        this.setWall3D(this.DungeonWall[11], 11, perspective)
      } else {
        this.paintDungeonBlockWall(11, dungeon, perspective)
      }
    } else if (this.DungeonSpace[7] == 1 && this.DungeonLight) {
      if (dungeon == 'graphic') {
        this.setWall3D(6, 11, false)
      } else {
        this.drawDungeon(this.MainSurface, 'wd', 11)
      }
    }
    if (this.checkPaintWall(12, dungeon)) {
      if (dungeon == 'graphic') {
        this.setWall3D(this.DungeonWall[12], 12, perspective)
        if (this.checkPaintWallSide(12, dungeon)) {
          this.setWall3D(7, 42, perspective)
        }
      } else {
        this.paintDungeonBlockWall(12, dungeon, perspective)
      }
    } else if (this.DungeonSpace[8] == 1 && this.DungeonLight) {
      if (dungeon == 'graphic') {
        if (!this.checkPaintWallSide(8, dungeon)) {
          this.setWall3D(6, 12, false)
        }
      } else {
        this.drawDungeon(this.MainSurface, 'wd', 12)
      }
    }
    if (this.checkPaintWall(13, dungeon)) {
      if (dungeon == 'graphic') {
        this.setWall3D(this.DungeonWall[13], 13, perspective)
        if (this.checkPaintWallSide(13, dungeon)) {
          this.setWall3D(7, 43, perspective)
        }
      } else {
        this.paintDungeonBlockWall(13, dungeon, perspective)
      }
    } else if (this.DungeonSpace[8] == 1 && this.DungeonLight) {
      if (dungeon == 'graphic') {
        if (!this.checkPaintWallSide(9, dungeon)) {
          this.setWall3D(6, 13, false)
        }
      } else {
        this.drawDungeon(this.MainSurface, 'wd', 13)
      }
    }
    if (this.checkPaintWall(14, dungeon)) {
      if (dungeon == 'graphic') {
        this.setWall3D(this.DungeonWall[14], 14, perspective)
      } else {
        this.paintDungeonBlockWall(14, dungeon, perspective)
      }
    } else if (this.DungeonSpace[9] == 1 && this.DungeonLight) {
      if (dungeon == 'graphic') {
        this.setWall3D(6, 14, false)
      } else {
        this.drawDungeon(this.MainSurface, 'wd', 14)
      }
    }
    if (this.checkPaintWall(8, dungeon)) {
      if (this.DungeonSpace[3] != 1) {
        this.paintDungeonBlockWall(8, dungeon, perspective)
        if (this.checkPaintWallSide(8, dungeon)) {
          this.setWall3D(7, 38, perspective)
        }
      }
    }
    this.paintDungeonBlockSpace(3, dungeon, perspective)
    if (this.checkPaintWall(5, dungeon)) {
      if (this.DungeonSpace[4] != 1) {
        this.paintDungeonBlockWall(5, dungeon, perspective)
      }
    }
    this.paintDungeonBlockSpace(4, dungeon, perspective)
    if (this.checkPaintWall(9, dungeon)) {
      if (this.DungeonSpace[5] != 1) {
        this.paintDungeonBlockWall(9, dungeon, perspective)
        if (this.checkPaintWallSide(9, dungeon)) {
          this.setWall3D(7, 39, perspective)
        }
      }
    }
    this.paintDungeonBlockSpace(5, dungeon, perspective)
    if (this.checkPaintWall(6, dungeon)) {
      if (dungeon == 'graphic') {
        this.setWall3D(this.DungeonWall[6], 6, perspective)
        if (this.checkPaintWallSide(6, dungeon)) {
          this.setWall3D(7, 36, perspective)
        }
      } else {
        this.paintDungeonBlockWall(6, dungeon, perspective)
      }
    } else if (this.DungeonSpace[4] == 1) {
      if (dungeon == 'graphic') {
        if (!this.checkPaintWallSide(3, dungeon)) {
          this.setWall3D(6, 6, false)
        }
      } else {
        this.drawDungeon(this.MainSurface, 'wd', 6)
      }
    }
    if (this.checkPaintWall(7, dungeon)) {
      if (dungeon == 'graphic') {
        this.setWall3D(this.DungeonWall[7], 7, perspective)
        if (this.checkPaintWallSide(7, dungeon)) {
          this.setWall3D(7, 37, perspective)
        }
      } else {
        this.paintDungeonBlockWall(7, dungeon, perspective)
      }
    } else if (this.DungeonSpace[4] == 1) {
      if (dungeon == 'graphic') {
        if (!this.checkPaintWallSide(4, dungeon)) {
          this.setWall3D(6, 7, false)
        }
      } else {
        this.drawDungeon(this.MainSurface, 'wd', 7)
      }
    }
    if (this.checkPaintWall(3, dungeon)) {
      if (this.DungeonSpace[1] != 1) {
        this.paintDungeonBlockWall(3, dungeon, false)
        if (this.checkPaintWallSide(3, dungeon)) {
          this.setWall3D(7, 33, false)
        }
      }
    }
    this.paintDungeonBlockSpace(1, dungeon, false)
    if (this.checkPaintWall(0, dungeon)) {
      if (this.DungeonSpace[0] != 1) {
        this.paintDungeonBlockWall(0, dungeon, false)
      }
    }
    this.paintDungeonBlockSpace(0, dungeon, false)
    if (this.checkPaintWall(4, dungeon)) {
      if (this.DungeonSpace[2] != 1) {
        this.paintDungeonBlockWall(4, dungeon, false)
        if (this.checkPaintWallSide(4, dungeon)) {
          this.setWall3D(7, 34, false)
        }
      }
    }
    this.paintDungeonBlockSpace(2, dungeon, false)
    if (this.checkPaintWall(1, dungeon)) {
      if (dungeon == 'graphic') {
        this.setWall3D(this.DungeonWall[1], 1, false)
      } else {
        this.paintDungeonBlockWall(1, dungeon, false)
      }
    }
    if (this.checkPaintWall(2, dungeon)) {
      if (dungeon == 'graphic') {
        this.setWall3D(this.DungeonWall[2], 2, false)
      } else {
        this.paintDungeonBlockWall(2, dungeon, false)
      }
    }
    this.drawFrame_Center(this.MainSurface)
  }
  paintDungeonBlockSpace (space, dungeon, perspective) {
    if (dungeon == 'wireFrame' && !this.DungeonLight && space > 5) {
      return
    }
    let darkZone = false
    let wall = 0
    if (space == 1) {
      wall = 3
    } else if (space == 2) {
      wall = 4
    } else if (space == 3) {
      wall = 8
    } else if (space == 4) {
      wall = 5
    } else if (space == 5) {
      wall = 9
    } else if (space == 6) {
      wall = 15
    } else if (space == 7) {
      wall = 16
    } else if (space == 8) {
      wall = 10
    } else if (space == 9) {
      wall = 17
    } else if (space == 10) {
      wall = 18
    } else if (space == 11) {
      wall = 24
    } else if (space == 12) {
      wall = 25
    } else if (space == 13) {
      wall = 19
    } else if (space == 14) {
      wall = 26
    } else if (space == 15) {
      wall = 27
    }
    if (!this.checkPaintWall(wall, dungeon)) {
      darkZone = true
    } else if (this.DungeonSpace[space] == 1) {
      darkZone = true
    }
    if (!darkZone) {
      if (dungeon == 'graphic') {
        let floorPattern
        if (
          space == 0 ||
          space == 3 ||
          space == 5 ||
          space == 6 ||
          space == 8 ||
          space == 10 ||
          space == 12 ||
          space == 14
        ) {
          if (this.FloorPatternFlag) {
            floorPattern = 0
          } else {
            floorPattern = 1
          }
        } else {
          if (!this.FloorPatternFlag) {
            floorPattern = 0
          } else {
            floorPattern = 1
          }
        }
        let fNum, cNum
        if (this.DungeonSpace[space] == 0) {
          fNum = 1
          cNum = 1
        } else if (this.DungeonSpace[space] == 2) {
          fNum = 3
          cNum = 3
        } else if (this.DungeonSpace[space] == 3) {
          fNum = 1
          cNum = 4
        } else if (this.DungeonSpace[space] == 4) {
          fNum = 4
          cNum = 1
        } else if (this.DungeonSpace[space] == 5) {
          fNum = 1
          cNum = 2
        } else if (this.DungeonSpace[space] == 6) {
          fNum = 2
          cNum = 1
        } else {
          fNum = 4
          cNum = 4
        }
        this.setFloor3D(fNum, floorPattern, space, 'f', perspective)
        this.setFloor3D(cNum, floorPattern, space, 'c', perspective)
      } else {
        if (this.DungeonSpace[space] == 2) {
          this.drawDungeon(this.MainSurface, 'ff', space)
          this.drawDungeon(this.MainSurface, 'cf', space)
        } else if (this.DungeonSpace[space] == 5) {
          this.drawDungeon(this.MainSurface, 'cs', space)
        } else if (this.DungeonSpace[space] == 6) {
          this.drawDungeon(this.MainSurface, 'fs', space)
        }
        if (this.DungeonSpace[space] == 3 || this.DungeonSpace[space] == 7) {
          this.drawDungeon(this.MainSurface, 'cf', space)
        }
        if (this.DungeonSpace[space] == 4 || this.DungeonSpace[space] == 7) {
          this.drawDungeon(this.MainSurface, 'ff', space)
        }
      }
    } else {
      if (space > 0) {
        if (dungeon == 'graphic') {
          if (space == 11) {
            this.setWall3D(6, 60, false)
          } else if (space == 15) {
            this.setWall3D(6, 61, false)
          }
          if (space <= 10) {
            this.setWall3D(6, wall, false)
          }
          this.setFloor3D(0, 0, space, 'f', false)
          this.setFloor3D(0, 0, space, 'c', false)
        } else {
          this.drawDungeon(this.MainSurface, 'wd', wall)
          if (wall == 3) {
            if (this.checkPaintWall(6, dungeon)) {
              this.paintDungeonBlockWall(6, dungeon, perspective)
            }
          } else if (wall == 4) {
            if (this.checkPaintWall(7, dungeon)) {
              this.paintDungeonBlockWall(7, dungeon, perspective)
            } else if (this.checkPaintWall(0, dungeon)) {
              if (this.DungeonSpace[0] != 1) {
                this.paintDungeonBlockWall(0, dungeon, perspective)
              }
            }
          } else if (wall == 8) {
            if (this.checkPaintWall(12, dungeon)) {
              this.paintDungeonBlockWall(12, dungeon, perspective)
            }
          } else if (wall == 9) {
            if (this.checkPaintWall(13, dungeon)) {
              this.paintDungeonBlockWall(13, dungeon, perspective)
            } else if (this.checkPaintWall(5, dungeon)) {
              if (this.DungeonSpace[4] != 1) {
                this.paintDungeonBlockWall(5, dungeon, perspective)
              }
            }
          } else if (wall == 15) {
            if (this.checkPaintWall(20, dungeon)) {
              this.paintDungeonBlockWall(20, dungeon, perspective)
            }
          } else if (wall == 16) {
            if (this.checkPaintWall(21, dungeon)) {
              this.paintDungeonBlockWall(21, dungeon, perspective)
            }
          } else if (wall == 17) {
            if (this.checkPaintWall(22, dungeon)) {
              this.paintDungeonBlockWall(22, dungeon, perspective)
            } else if (this.checkPaintWall(10, dungeon)) {
              if (this.DungeonSpace[8] != 1) {
                this.paintDungeonBlockWall(10, dungeon, perspective)
              }
            }
          } else if (wall == 18) {
            if (this.checkPaintWall(23, dungeon)) {
              this.paintDungeonBlockWall(23, dungeon, perspective)
            } else if (this.checkPaintWall(17, dungeon)) {
              if (this.DungeonSpace[9] != 1) {
                this.paintDungeonBlockWall(17, dungeon, perspective)
              }
            }
          } else if (wall == 26) {
            if (this.checkPaintWall(19, dungeon)) {
              if (this.DungeonSpace[13] != 1) {
                this.paintDungeonBlockWall(19, dungeon, perspective)
              }
            }
          } else if (wall == 27) {
            if (this.checkPaintWall(26, dungeon)) {
              if (this.DungeonSpace[14] != 1) {
                this.paintDungeonBlockWall(26, dungeon, perspective)
              }
            }
          }
        }
      }
    }
  }
  paintDungeonBlockWall (wall, dungeon, perspective) {
    if (!this.DungeonLight && wall > 9) {
      return
    }
    if (dungeon == 'graphic') {
      this.setWall3D(this.DungeonWall[wall], wall, perspective)
    } else {
      if (this.DungeonWall[wall] > 0) {
        this.drawDungeon(this.MainSurface, 'w', wall)
        if (this.DungeonWall[wall] == 2) {
          this.drawDungeon(this.MainSurface, 'd', wall)
        } else if (this.DungeonWall[wall] == 4) {
          this.drawDungeon(this.MainSurface, 'sd', wall)
        }
      }
    }
  }
  paintGraphic (surface, img, x, y, w, h) {
    if (img == undefined || img == null) {
      return
    }
    surface.draw(img, 0, 0, img.width, img.height, x, y, w, h)
  }
  paintMask (mode) {
    this.MaskSurface.clear()
    if (mode != 'clear') {
      this.MaskSurface.context.fillStyle = 'black'
      this.MaskSurface.context.globalAlpha = 0.7
      this.MaskSurface.context.fillRect(
        this.MAIN_X,
        this.MAIN_Y,
        this.MAIN_WIDTH,
        this.MAIN_HEIGHT
      )
    }
  }
  paintMonsterGrahic (cg, decided, mode, stage) {
    this.MainSurface.clear()
    let size = this.MAIN_WIDTH / 2
    let y = this.MAIN_Y + this.LINE_HEIGHT * 6
    for (let i = 0; i < 2; i++) {
      let num = 0
      if (decided[i]) {
        num = 1
      }
      let img
      if (mode[i] == 'line') {
        if (cg[i][num] == '' || GraphicData[cg[i][num]] == null) {
          continue
        }
        img = GraphicData[cg[i][num]].clone()
        let alpha = 1.0
        if (stage == 0) {
          alpha = 0
        } else if (stage == 1) {
          alpha = 0.125
        } else if (stage == 2) {
          alpha = 0.25
        } else if (stage == 3) {
          alpha = 0.375
        } else if (stage == 4) {
          alpha = 0.5
        } else if (stage == 5) {
          alpha = 0.625
        } else if (stage == 6) {
          alpha = 0.75
        } else if (stage == 7) {
          alpha = 0.875
        }
        this.filterGlobalAlpha(img, alpha)
      } else if (mode[i] == 'decided') {
        let cgStr
        if (stage < 4) {
          cgStr = cg[i][0]
        } else {
          cgStr = cg[i][1]
        }
        if (cgStr == '' || GraphicData[cgStr] == null) {
          continue
        }
        img = GraphicData[cgStr].clone()
        let sizePercent = 0
        if (stage == 1 || stage == 7) {
          sizePercent = 4
        } else if (stage == 2 || stage == 6) {
          sizePercent = 8
        } else if (stage == 3 || stage == 5) {
          sizePercent = 12
        } else if (stage == 4) {
          sizePercent = 16
        }
        this.filterMosaic(img, sizePercent)
      } else {
        if (cg[i][num] == '' || GraphicData[cg[i][num]] == null) {
          continue
        }
        img = GraphicData[cg[i][num]]
      }
      let x = this.MAIN_X
      if (i == 0) {
        if (cg[1][0] == '' && cg[1][1] == '') {
          x += size - size / 2
        } else {
          x += 0
        }
      } else {
        x += size
      }
      this.paintGraphic(this.MainSurface, img, x, y, size, size)
    }
  }
  setAlignControlButton (position) {
    if (this.ButtonObject['option_div'] == undefined) {
      return
    }
    let unit = calTimes(this.CONTROLLER_WIDTH, 0.0162)
    if (position == 'left') {
      let nameDiv = 'option_div'
      this.ButtonObject[nameDiv].x = calTimes(this.BUTTON_FRAME_WIDTH, 2)
      this.ButtonObject[nameDiv].y = this.CONTROLLER_Y + this.BUTTON_FRAME_WIDTH
      if (LaunchSettings['Controller']) {
        let y = this.CONTROLLER_Y
        let w = this.CONTROLLER_WIDTH
        let h = this.CONTROLLER_HEIGHT
        nameDiv = 'reset_div'
        this.ButtonObject[nameDiv].x =
          this.CONTROLLER_WIDTH - (7 * unit + this.BUTTON_FRAME_WIDTH)
        this.ButtonObject[nameDiv].y =
          this.CONTROLLER_Y + this.BUTTON_FRAME_WIDTH
        nameDiv = 'up_div'
        this.ButtonObject[nameDiv].x = 13 * unit + this.BUTTON_FRAME_WIDTH
        this.ButtonObject[nameDiv].y = y + 9 * unit
        nameDiv = 'down_div'
        this.ButtonObject[nameDiv].x = 13 * unit + this.BUTTON_FRAME_WIDTH
        this.ButtonObject[nameDiv].y = y + 20 * unit + this.BUTTON_FRAME_WIDTH
        nameDiv = 'right_div'
        this.ButtonObject[nameDiv].x =
          24 * unit + calTimes(2, this.BUTTON_FRAME_WIDTH)
        this.ButtonObject[nameDiv].y = y + 15 * unit
        nameDiv = 'left_div'
        this.ButtonObject[nameDiv].x = 2 * unit
        this.ButtonObject[nameDiv].y = y + 15 * unit
        nameDiv = 'shift_right_div'
        this.ButtonObject[nameDiv].x =
          25 * unit + calTimes(1.5, this.BUTTON_FRAME_WIDTH)
        this.ButtonObject[nameDiv].y = y + 6 * unit
        nameDiv = 'shift_left_div'
        this.ButtonObject[nameDiv].x = unit
        this.ButtonObject[nameDiv].y = y + 6 * unit
        nameDiv = 'enter_div'
        this.ButtonObject[nameDiv].x = 37 * unit
        this.ButtonObject[nameDiv].y = y + 19 * unit + this.BUTTON_FRAME_WIDTH
        nameDiv = 'cancel_div'
        this.ButtonObject[nameDiv].x = 37 * unit
        this.ButtonObject[nameDiv].y = y + 6 * unit
        nameDiv = 'status_div'
        this.ButtonObject[nameDiv].x = 49 * unit + this.BUTTON_FRAME_WIDTH
        this.ButtonObject[nameDiv].y = y + 6 * unit
        nameDiv = 'map_div'
        this.ButtonObject[nameDiv].x = 49 * unit + this.BUTTON_FRAME_WIDTH
        this.ButtonObject[nameDiv].y = y + calTimes(14.5, unit)
        nameDiv = 'submenu_div'
        this.ButtonObject[nameDiv].x = 49 * unit + this.BUTTON_FRAME_WIDTH
        this.ButtonObject[nameDiv].y = y + 23 * unit + this.BUTTON_FRAME_WIDTH
      }
    } else if (position == 'right') {
      let nameDiv = 'option_div'
      this.ButtonObject[nameDiv].x =
        this.CONTROLLER_WIDTH - (8 * unit + this.BUTTON_FRAME_WIDTH)
      this.ButtonObject[nameDiv].y = this.CONTROLLER_Y + this.BUTTON_FRAME_WIDTH
      if (LaunchSettings['Controller']) {
        let y = this.CONTROLLER_Y
        let w = this.CONTROLLER_WIDTH
        let h = this.CONTROLLER_HEIGHT
        nameDiv = 'reset_div'
        this.ButtonObject[nameDiv].x = calTimes(this.BUTTON_FRAME_WIDTH, 2)
        this.ButtonObject[nameDiv].y =
          this.CONTROLLER_Y + this.BUTTON_FRAME_WIDTH
        let x2 = this.CONTROLLER_WIDTH - 11 * unit
        nameDiv = 'up_div'
        this.ButtonObject[nameDiv].x =
          x2 - (13 * unit + this.BUTTON_FRAME_WIDTH)
        this.ButtonObject[nameDiv].y = y + 9 * unit
        nameDiv = 'down_div'
        this.ButtonObject[nameDiv].x =
          x2 - (13 * unit + this.BUTTON_FRAME_WIDTH)
        this.ButtonObject[nameDiv].y = y + 20 * unit + this.BUTTON_FRAME_WIDTH
        nameDiv = 'right_div'
        this.ButtonObject[nameDiv].x = x2 - 2 * unit
        this.ButtonObject[nameDiv].y = y + 15 * unit
        nameDiv = 'left_div'
        this.ButtonObject[nameDiv].x =
          x2 - (24 * unit + calTimes(2, this.BUTTON_FRAME_WIDTH))
        this.ButtonObject[nameDiv].y = y + 15 * unit
        nameDiv = 'shift_right_div'
        this.ButtonObject[nameDiv].x = x2 - unit
        this.ButtonObject[nameDiv].y = y + 6 * unit
        nameDiv = 'shift_left_div'
        this.ButtonObject[nameDiv].x =
          x2 - (25 * unit + calTimes(1.5, this.BUTTON_FRAME_WIDTH))
        this.ButtonObject[nameDiv].y = y + 6 * unit
        x2 = this.CONTROLLER_WIDTH - 12 * unit
        nameDiv = 'enter_div'
        this.ButtonObject[nameDiv].x = x2 - 37 * unit
        this.ButtonObject[nameDiv].y = y + 19 * unit + this.BUTTON_FRAME_WIDTH
        nameDiv = 'cancel_div'
        this.ButtonObject[nameDiv].x = x2 - 37 * unit
        this.ButtonObject[nameDiv].y = y + 6 * unit
        nameDiv = 'status_div'
        this.ButtonObject[nameDiv].x =
          x2 - (49 * unit + this.BUTTON_FRAME_WIDTH)
        this.ButtonObject[nameDiv].y = y + 6 * unit
        nameDiv = 'map_div'
        this.ButtonObject[nameDiv].x =
          x2 - (49 * unit + this.BUTTON_FRAME_WIDTH)
        this.ButtonObject[nameDiv].y = y + calTimes(14.5, unit)
        nameDiv = 'submenu_div'
        this.ButtonObject[nameDiv].x =
          x2 - (49 * unit + this.BUTTON_FRAME_WIDTH)
        this.ButtonObject[nameDiv].y = y + 23 * unit + this.BUTTON_FRAME_WIDTH
      }
    }
  }
  setDungeonGraphic (
    wall,
    wallSide,
    door,
    floor,
    floor2,
    ceil,
    ceil2,
    downStairs,
    upStairs,
    ladder,
    event,
    elevator,
    distantView
  ) {
    if (wall == null || wall == 'none') {
      this.ImgWall = null
      return
    } else {
      this.ImgWall = wall.clone()
      this.filterAlpha(this.ImgWall, 255)
    }
    if (wallSide == 'none') {
      this.ImgWallSide = null
    } else if (wallSide == null) {
      this.ImgWallSide = this.ImgWall.clone()
    } else {
      this.ImgWallSide = new Surface(wallSide.width / 15, wallSide.height)
      this.ImgWallSide._element.src = Math.random()
      this.ImgWallSide.draw(
        wallSide,
        0,
        0,
        wallSide.width / 15,
        wallSide.height,
        0,
        0,
        this.ImgWallSide.width,
        this.ImgWallSide.height
      )
    }
    if (door == null || door == 'none') {
      this.ImgDoor = null
    } else {
      this.ImgDoor = this.ImgWall.clone()
      this.ImgDoor.draw(
        door,
        0,
        0,
        door.width,
        door.height,
        0,
        0,
        this.ImgDoor.width,
        this.ImgDoor.height
      )
      this.ImgSecretDoor = this.ImgWall.clone()
      this.ImgSecretDoor.context.globalAlpha = 0.6
      this.ImgSecretDoor.draw(
        door,
        0,
        0,
        door.width,
        door.height,
        0,
        0,
        this.ImgSecretDoor.width,
        this.ImgSecretDoor.height
      )
    }
    if (floor == null || floor == 'none') {
      this.ImgFloor[0] = null
    } else {
      this.ImgFloor[0] = floor.clone()
    }
    if (floor2 == null || floor2 == 'none') {
      if (this.ImgFloor[0] == null) {
        this.ImgFloor[1] = null
      } else {
        this.ImgFloor[1] = this.ImgFloor[0].clone()
      }
    } else {
      this.ImgFloor[1] = floor2.clone()
    }
    if (ceil == 'none') {
      this.ImgCeil[0] = null
    } else if (ceil == null) {
      if (this.ImgFloor[0] == null) {
        this.ImgCeil[0] = null
      } else {
        this.ImgCeil[0] = this.ImgFloor[0].clone()
      }
    } else {
      this.ImgCeil[0] = ceil.clone()
    }
    if (ceil2 == null || ceil2 == 'none') {
      if (this.ImgCeil[0] == null) {
        this.ImgCeil[1] = null
      } else {
        this.ImgCeil[1] = this.ImgCeil[0].clone()
      }
    } else {
      this.ImgCeil[1] = ceil2.clone()
    }
    if (downStairs == null || downStairs == 'none') {
      for (let i = 0; i < 2; i++) {
        this.ImgDownStairs[i] = null
      }
    } else {
      for (let i = 0; i < 2; i++) {
        if (this.ImgFloor[i] == null) {
          this.ImgDownStairs[i] = downStairs.clone()
        } else {
          this.ImgDownStairs[i] = this.ImgFloor[i].clone()
          this.ImgDownStairs[i].draw(
            downStairs,
            0,
            0,
            downStairs.width,
            downStairs.height,
            0,
            0,
            this.ImgDownStairs[i].width,
            this.ImgDownStairs[i].height
          )
        }
      }
    }
    if (upStairs == 'none') {
      for (let i = 0; i < 2; i++) {
        this.ImgUpStairs[i] = null
      }
    } else if (upStairs == null) {
      if (downStairs == null || downStairs == 'none') {
        for (let i = 0; i < 2; i++) {
          this.ImgUpStairs[i] = null
        }
      } else {
        for (let i = 0; i < 2; i++) {
          if (this.ImgCeil[i] == null) {
            this.ImgUpStairs[i] = downStairs.clone()
          } else {
            this.ImgUpStairs[i] = this.ImgCeil[i].clone()
            this.ImgUpStairs[i].draw(
              downStairs,
              0,
              0,
              downStairs.width,
              downStairs.height,
              0,
              0,
              this.ImgUpStairs[i].width,
              this.ImgUpStairs[i].height
            )
          }
        }
      }
    } else {
      for (let i = 0; i < 2; i++) {
        if (this.ImgCeil[i] == null) {
          this.ImgUpStairs[i] = upStairs.clone()
        } else {
          this.ImgUpStairs[i] = this.ImgCeil[i].clone()
          this.ImgUpStairs[i].draw(
            upStairs,
            0,
            0,
            upStairs.width,
            upStairs.height,
            0,
            0,
            this.ImgUpStairs[i].width,
            this.ImgUpStairs[i].height
          )
        }
      }
    }
    if (ladder == null || ladder == 'none') {
      this.ImgLadder = null
    } else {
      this.ImgLadder = ladder.clone()
      this.filterAlphaNotOpaque(this.ImgLadder)
    }
    if (event == null || event == 'none') {
      for (let i = 0; i < 4; i++) {
        this.ImgEvent[i] = null
      }
    } else {
      for (let i = 0; i < 2; i++) {
        if (this.ImgFloor[i] == null) {
          this.ImgEvent[i] = event.clone()
        } else {
          this.ImgEvent[i] = this.ImgFloor[i].clone()
          this.ImgEvent[i].draw(
            event,
            0,
            0,
            event.width,
            event.height,
            0,
            0,
            this.ImgEvent[i].width,
            this.ImgEvent[i].height
          )
        }
      }
      for (let i = 0; i < 2; i++) {
        if (this.ImgCeil[i] == null) {
          this.ImgEvent[i + 2] = event.clone()
        } else {
          this.ImgEvent[i + 2] = this.ImgCeil[i].clone()
          this.ImgEvent[i + 2].draw(
            event,
            0,
            0,
            event.width,
            event.height,
            0,
            0,
            this.ImgEvent[i + 2].width,
            this.ImgEvent[i + 2].height
          )
        }
      }
    }
    if (elevator == 'none') {
      for (let i = 0; i < 4; i++) {
        this.ImgElevator[i] = null
      }
    } else if (elevator == null) {
      if (event == null || event == 'none') {
        for (let i = 0; i < 4; i++) {
          this.ImgElevator[i] = null
        }
      } else {
        for (let i = 0; i < 4; i++) {
          this.ImgElevator[i] = this.ImgEvent[i].clone()
        }
      }
    } else {
      for (let i = 0; i < 2; i++) {
        if (this.ImgFloor[i] == null) {
          this.ImgElevator[i] = elevator.clone()
        } else {
          this.ImgElevator[i] = this.ImgFloor[i].clone()
          this.ImgElevator[i].draw(
            elevator,
            0,
            0,
            elevator.width,
            elevator.height,
            0,
            0,
            this.ImgElevator[i].width,
            this.ImgElevator[i].height
          )
        }
      }
      for (let i = 0; i < 2; i++) {
        if (this.ImgCeil[i] == null) {
          this.ImgElevator[i + 2] = elevator.clone()
        } else {
          this.ImgElevator[i + 2] = this.ImgCeil[i].clone()
          this.ImgElevator[i + 2].draw(
            elevator,
            0,
            0,
            elevator.width,
            elevator.height,
            0,
            0,
            this.ImgElevator[i + 2].width,
            this.ImgElevator[i + 2].height
          )
        }
      }
    }
    if (distantView == null || distantView == 'none') {
      this.ImgDistantView = null
    } else {
      this.ImgDistantView = distantView.clone()
    }
  }
  setDungeonView (key, loadingFlag) {
    key = checkNull(key, '')
    loadingFlag = checkNull(loadingFlag, false)
    let pt, ptDNumber, ptFloor, ptX, ptY, ptDirection, ptViewDarkZone
    if (loadingFlag) {
      ptDNumber = -1
      ptFloor = -1
      ptX = TempVariable['ptX']
      ptY = TempVariable['ptY']
      ;(ptDirection = TempVariable['ptDirection']), (ptViewDarkZone = false)
    } else {
      pt = PARTY[PlayData['ActiveParty']]
      ptDNumber = pt.DungeonNumber
      ptFloor = pt.Floor
      ptX = pt.X
      ptY = pt.Y
      ;(ptDirection = pt.Direction), (ptViewDarkZone = pt.ViewDarkZone)
    }
    let wallAry = DUNGEON.getWallData(ptDNumber, ptFloor, ptX, ptY, ptDirection)
    let spaceAry = DUNGEON.getSpaceData(
      ptDNumber,
      ptFloor,
      ptX,
      ptY,
      ptDirection
    )
    if (!loadingFlag) {
      if (
        spaceAry[0] != '1' &&
        DUNGEON.checkWall(wallAry[0], ptDNumber, ptFloor, ptDirection) == 0 &&
        spaceAry[4].charAt(0) == 'W'
      ) {
        let warp = DUNGEON.getWarpPoint(spaceAry[4], ptDNumber)
        let tmpWallAry = DUNGEON.getWallData(
          ptDNumber,
          ptFloor,
          warp[0],
          warp[1],
          ptDirection
        )
        let tmpSpaceAry = DUNGEON.getSpaceData(
          ptDNumber,
          ptFloor,
          warp[0],
          warp[1],
          ptDirection
        )
        wallAry[5] = tmpWallAry[0]
        wallAry[6] = tmpWallAry[1]
        wallAry[7] = tmpWallAry[2]
        wallAry[8] = tmpWallAry[3]
        wallAry[9] = tmpWallAry[4]
        wallAry[10] = tmpWallAry[5]
        wallAry[11] = tmpWallAry[28]
        wallAry[12] = tmpWallAry[6]
        wallAry[13] = tmpWallAry[7]
        wallAry[14] = tmpWallAry[29]
        wallAry[15] = tmpWallAry[30]
        wallAry[16] = tmpWallAry[8]
        wallAry[17] = tmpWallAry[9]
        wallAry[18] = tmpWallAry[31]
        wallAry[19] = tmpWallAry[10]
        wallAry[20] = tmpWallAry[11]
        wallAry[21] = tmpWallAry[12]
        wallAry[22] = tmpWallAry[13]
        wallAry[23] = tmpWallAry[14]
        wallAry[24] = tmpWallAry[15]
        wallAry[25] = tmpWallAry[16]
        wallAry[26] = tmpWallAry[17]
        wallAry[27] = tmpWallAry[18]
        spaceAry[3] = tmpSpaceAry[1]
        spaceAry[4] = tmpSpaceAry[0]
        spaceAry[5] = tmpSpaceAry[2]
        spaceAry[6] = tmpSpaceAry[18]
        spaceAry[7] = tmpSpaceAry[3]
        spaceAry[8] = tmpSpaceAry[4]
        spaceAry[9] = tmpSpaceAry[5]
        spaceAry[10] = tmpSpaceAry[19]
        spaceAry[11] = tmpSpaceAry[6]
        spaceAry[12] = tmpSpaceAry[7]
        spaceAry[13] = tmpSpaceAry[8]
        spaceAry[14] = tmpSpaceAry[9]
        spaceAry[15] = tmpSpaceAry[10]
      } else if (
        spaceAry[4] != '1' &&
        DUNGEON.checkWall(wallAry[5], ptDNumber, ptFloor, ptDirection) == 0 &&
        spaceAry[8].charAt(0) == 'W'
      ) {
        let warp = DUNGEON.getWarpPoint(spaceAry[8], ptDNumber)
        let tmpWallAry = DUNGEON.getWallData(
          ptDNumber,
          ptFloor,
          warp[0],
          warp[1],
          ptDirection
        )
        let tmpSpaceAry = DUNGEON.getSpaceData(
          ptDNumber,
          ptFloor,
          warp[0],
          warp[1],
          ptDirection
        )
        wallAry[10] = tmpWallAry[0]
        wallAry[12] = tmpWallAry[1]
        wallAry[13] = tmpWallAry[2]
        wallAry[16] = tmpWallAry[3]
        wallAry[17] = tmpWallAry[4]
        wallAry[19] = tmpWallAry[5]
        wallAry[20] = tmpWallAry[28]
        wallAry[21] = tmpWallAry[6]
        wallAry[22] = tmpWallAry[7]
        wallAry[23] = tmpWallAry[29]
        wallAry[24] = tmpWallAry[30]
        wallAry[25] = tmpWallAry[8]
        wallAry[26] = tmpWallAry[9]
        wallAry[27] = tmpWallAry[31]
        spaceAry[7] = tmpSpaceAry[1]
        spaceAry[8] = tmpSpaceAry[0]
        spaceAry[9] = tmpSpaceAry[2]
        spaceAry[11] = tmpSpaceAry[18]
        spaceAry[12] = tmpSpaceAry[3]
        spaceAry[13] = tmpSpaceAry[4]
        spaceAry[14] = tmpSpaceAry[5]
        spaceAry[15] = tmpSpaceAry[19]
      } else if (
        spaceAry[8] != '1' &&
        DUNGEON.checkWall(wallAry[10], ptDNumber, ptFloor, ptDirection) == 0 &&
        spaceAry[13].charAt(0) == 'W'
      ) {
        let warp = DUNGEON.getWarpPoint(spaceAry[13], ptDNumber)
        let tmpWallAry = DUNGEON.getWallData(
          ptDNumber,
          ptFloor,
          warp[0],
          warp[1],
          ptDirection
        )
        let tmpSpaceAry = DUNGEON.getSpaceData(
          ptDNumber,
          ptFloor,
          warp[0],
          warp[1],
          ptDirection
        )
        wallAry[19] = tmpWallAry[0]
        wallAry[21] = tmpWallAry[1]
        wallAry[22] = tmpWallAry[2]
        wallAry[25] = tmpWallAry[3]
        wallAry[26] = tmpWallAry[4]
        spaceAry[11] = tmpSpaceAry[16]
        spaceAry[12] = tmpSpaceAry[1]
        spaceAry[13] = tmpSpaceAry[0]
        spaceAry[14] = tmpSpaceAry[2]
        spaceAry[15] = tmpSpaceAry[17]
      }
    }
    let loop = wallAry.length - 4
    for (let i = 0; i < loop; i++) {
      if (!this.DungeonLight && i > 9) {
        this.DungeonWall[i] = 0
        continue
      }
      if (wallAry[i].charAt(0) == '4') {
        let strAry = wallAry[i].split(',')
        let d = Number(strAry[1])
        if (d == 0) {
          if (ptDirection == 1) {
            wallAry[i] = '4,3'
          } else if (ptDirection == 2) {
            wallAry[i] = '4,2'
          } else if (ptDirection == 3) {
            wallAry[i] = '4,1'
          }
        } else if (d == 1) {
          if (ptDirection == 1) {
            wallAry[i] = '4,0'
          } else if (ptDirection == 2) {
            wallAry[i] = '4,3'
          } else if (ptDirection == 3) {
            wallAry[i] = '4,2'
          }
        } else if (d == 2) {
          if (ptDirection == 1) {
            wallAry[i] = '4,1'
          } else if (ptDirection == 2) {
            wallAry[i] = '4,0'
          } else if (ptDirection == 3) {
            wallAry[i] = '4,3'
          }
        } else if (d == 3) {
          if (ptDirection == 1) {
            wallAry[i] = '4,2'
          } else if (ptDirection == 2) {
            wallAry[i] = '4,1'
          } else if (ptDirection == 3) {
            wallAry[i] = '4,0'
          }
        }
      } else if (wallAry[i].charAt(0) == '5') {
        let strAry = wallAry[i].split(',')
        let d = Number(strAry[1])
        if (d == 0) {
          if (ptDirection == 1) {
            wallAry[i] = '5,3'
          } else if (ptDirection == 2) {
            wallAry[i] = '5,2'
          } else if (ptDirection == 3) {
            wallAry[i] = '5,1'
          }
        } else if (d == 1) {
          if (ptDirection == 1) {
            wallAry[i] = '5,0'
          } else if (ptDirection == 2) {
            wallAry[i] = '5,3'
          } else if (ptDirection == 3) {
            wallAry[i] = '5,2'
          }
        } else if (d == 2) {
          if (ptDirection == 1) {
            wallAry[i] = '5,1'
          } else if (ptDirection == 2) {
            wallAry[i] = '5,0'
          } else if (ptDirection == 3) {
            wallAry[i] = '5,3'
          }
        } else if (d == 3) {
          if (ptDirection == 1) {
            wallAry[i] = '5,2'
          } else if (ptDirection == 2) {
            wallAry[i] = '5,1'
          } else if (ptDirection == 3) {
            wallAry[i] = '5,0'
          }
        }
      }
      if (wallAry[i].match(/^[12]/)) {
        if (wallAry[i].charAt(0) == '1') {
          this.DungeonWall[i] = 1
        } else if (wallAry[i].charAt(0) == '2') {
          this.DungeonWall[i] = 2
        }
        if (!loadingFlag) {
          let num = 0
          let strAry = wallAry[i].split(',')
          if (strAry.length > 1) {
            num = Number(strAry[1])
          }
          if (num >= 0 && num < 512) {
            if (!PlayData['WallFlag'][ptDNumber][ptFloor][num]) {
              this.DungeonWall[i] = 0
            }
          }
        }
      } else if (wallAry[i].charAt(0) == '6') {
        this.DungeonWall[i] = 2
      } else if (wallAry[i].charAt(0) == '3') {
        if (loadingFlag) {
          this.DungeonWall[i] = 2
        } else {
          let strAry = wallAry[i].split(',')
          let lv = Number(strAry[1]) + pt.PtSpellEffectPlus[2]
          if (lv < 0) {
            lv = 0
          }
          let num = -1
          if (strAry.length > 2) {
            num = Number(strAry[2])
            if (num < 0 || num > 511) {
              num = -1
            } else if (PlayData['SecretDoor'][ptDNumber][ptFloor][num]) {
              this.DungeonWall[i] = 2
            } else if (i > 2) {
              this.DungeonWall[i] = 1
            } else {
              this.DungeonWall[i] = 0
              if (strAry[3].match(/^(ws|en)$/)) {
                if (i == 0) {
                  if (ptDirection == 0) {
                    if (strAry[3].indexOf('ws') > -1) {
                      this.DungeonWall[i] = 1
                    }
                  } else if (ptDirection == 1) {
                    if (strAry[3].indexOf('ws') > -1) {
                      this.DungeonWall[i] = 1
                    }
                  } else if (ptDirection == 2) {
                    if (strAry[3].indexOf('en') > -1) {
                      this.DungeonWall[i] = 1
                    }
                  } else if (ptDirection == 3) {
                    if (strAry[3].indexOf('en') > -1) {
                      this.DungeonWall[i] = 1
                    }
                  }
                } else if (i == 1) {
                  if (ptDirection == 0) {
                    if (strAry[3].indexOf('en') > -1) {
                      this.DungeonWall[i] = 1
                    }
                  } else if (ptDirection == 1) {
                    if (strAry[3].indexOf('ws') > -1) {
                      this.DungeonWall[i] = 1
                    }
                  } else if (ptDirection == 2) {
                    if (strAry[3].indexOf('ws') > -1) {
                      this.DungeonWall[i] = 1
                    }
                  } else if (ptDirection == 3) {
                    if (strAry[3].indexOf('en') > -1) {
                      this.DungeonWall[i] = 1
                    }
                  }
                } else if (i == 2) {
                  if (ptDirection == 0) {
                    if (strAry[3].indexOf('ws') > -1) {
                      this.DungeonWall[i] = 1
                    }
                  } else if (ptDirection == 1) {
                    if (strAry[3].indexOf('en') > -1) {
                      this.DungeonWall[i] = 1
                    }
                  } else if (ptDirection == 2) {
                    if (strAry[3].indexOf('en') > -1) {
                      this.DungeonWall[i] = 1
                    }
                  } else if (ptDirection == 3) {
                    if (strAry[3].indexOf('ws') > -1) {
                      this.DungeonWall[i] = 1
                    }
                  }
                }
              }
              if (this.DungeonWall[i] == 0) {
                if (key.match(/^(ouch|lockedDoor)$/)) {
                  this.DungeonWall[i] = this.PreSecretDoor[i]
                } else {
                  let prob = pt.getDoorsProb(1, lv)
                  if (i == 0) {
                    printDebugMessage('secret door find rate: ' + prob + '%')
                  }
                  if (prob >= dice(1, 100)) {
                    this.DungeonWall[i] = 4
                  } else {
                    this.DungeonWall[i] = 1
                  }
                }
                this.PreSecretDoor[i] = this.DungeonWall[i]
              }
            }
          }
          if (num == -1) {
            if (key.match(/^(ouch|lockedDoor)$/)) {
              this.DungeonWall[i] = this.PreSecretDoor[i]
            } else {
              let prob = pt.getDoorsProb(0, lv)
              if (i == 0) {
                printDebugMessage('secret door find rate: ' + prob + '%')
              }
              if (prob >= dice(1, 100)) {
                this.DungeonWall[i] = 2
              } else {
                this.DungeonWall[i] = 3
              }
              this.PreSecretDoor[i] = this.DungeonWall[i]
            }
          }
        }
      } else if (wallAry[i].charAt(0) == '4') {
        let strAry = wallAry[i].split(',')
        let d = Number(strAry[1])
        if (d == 0) {
          this.DungeonWall[i] = 2
        } else if (d == 2) {
          this.DungeonWall[i] = 1
        } else if (d == 1) {
          if (i == 2 || i == 7 || i == 13 || i == 14 || i == 22 || i == 23) {
            this.DungeonWall[i] = 2
          } else {
            this.DungeonWall[i] = 1
          }
        } else if (d == 3) {
          if (i == 2 || i == 7 || i == 13 || i == 14 || i == 22 || i == 23) {
            this.DungeonWall[i] = 1
          } else {
            this.DungeonWall[i] = 2
          }
        }
      } else if (wallAry[i].charAt(0) == '5') {
        let strAry = wallAry[i].split(',')
        let d = Number(strAry[1])
        if (d == 0) {
          this.DungeonWall[i] = 0
        } else if (d == 2) {
          this.DungeonWall[i] = 1
        } else if (d == 1) {
          if (i == 2 || i == 7 || i == 13 || i == 14 || i == 22 || i == 23) {
            this.DungeonWall[i] = 0
          } else {
            this.DungeonWall[i] = 1
          }
        } else if (d == 3) {
          if (i == 2 || i == 7 || i == 13 || i == 14 || i == 22 || i == 23) {
            this.DungeonWall[i] = 1
          } else {
            this.DungeonWall[i] = 0
          }
        }
      } else {
        this.DungeonWall[i] = 0
      }
    }
    loop = spaceAry.length - 4
    for (let i = 0; i < loop; i++) {
      if (!this.DungeonLight && i > 5) {
        this.DungeonSpace[i] = 0
        continue
      }
      if (spaceAry[i].charAt(0) == '1') {
        if (ptViewDarkZone) {
          this.DungeonSpace[i] = 0
        } else {
          this.DungeonSpace[i] = 1
        }
      } else if (spaceAry[i].charAt(0) == 'a') {
        this.DungeonSpace[i] = 1
      } else if (spaceAry[i].charAt(0) == '2') {
        this.DungeonSpace[i] = 5
      } else if (spaceAry[i].charAt(0) == '3') {
        this.DungeonSpace[i] = 2
      } else if (spaceAry[i].charAt(0) == '4') {
        this.DungeonSpace[i] = 6
      } else if (spaceAry[i].match(/^[57R]/)) {
        this.DungeonSpace[i] = 4
      } else if (spaceAry[i].charAt(0) == 'E') {
        let strAry = spaceAry[i].split('<>')
        let strAry2 = strAry[0].split(',')
        if (strAry2.indexOf('v2') > -1) {
          this.DungeonSpace[i] = 7
        } else if (strAry2.indexOf('v3') > -1) {
          this.DungeonSpace[i] = 3
        } else if (strAry2.indexOf('v4') > -1) {
          this.DungeonSpace[i] = 4
        } else if (strAry2.indexOf('v0') > -1) {
          this.DungeonSpace[i] = 0
        } else {
          this.DungeonSpace[i] = 4
        }
      } else if (spaceAry[i].charAt(0) == '6') {
        if (spaceAry[i].charAt(2) == '0') {
          this.DungeonSpace[i] = 4
        } else {
          this.DungeonSpace[i] = 0
        }
      } else {
        this.DungeonSpace[i] = 0
      }
    }
  }
  setDrawMap (gameState, viewTrap, viewEvent) {
    if (viewTrap == '1') {
      viewTrap = true
    } else {
      viewTrap = false
    }
    if (viewEvent == '1') {
      viewEvent = true
    } else {
      viewEvent = false
    }
    let pt = PARTY[PlayData['ActiveParty']]
    TempVariable['mapViewFloor'] = []
    for (let i = 0; i < DUNGEON.FloorMinMax[pt.DungeonNumber].length; i++) {
      let onFoot = false
      if (i == pt.Floor) {
        onFoot = true
      } else if (gameState != 'map' || GameData['AUTO_MAP'] > 3) {
        for (let j = 0; j < DUNGEON.Width[pt.DungeonNumber]; j++) {
          if (onFoot) {
            break
          }
          for (let k = 0; k < DUNGEON.Height[pt.DungeonNumber]; k++) {
            if (PlayData['MapFlag'][pt.DungeonNumber][i][j][k]) {
              onFoot = true
              break
            }
          }
        }
      }
      if (onFoot) {
        TempVariable['mapViewFloor'].push(i)
      }
    }
    GameState = gameState
    TempVariable['floor'] = TempVariable['mapViewFloor'].indexOf(pt.Floor)
    let x = -1,
      y = -1,
      d = -1
    if (
      gameState != 'map' ||
      (GameData['AUTO_MAP'] != 1 && GameData['AUTO_MAP'] != 4)
    ) {
      x = pt.X
      y = pt.Y
    }
    if (
      gameState != 'map' ||
      GameData['AUTO_MAP'] == 3 ||
      GameData['AUTO_MAP'] == 6
    ) {
      d = pt.Direction
    }
    TempVariable['x'] = x
    TempVariable['y'] = y
    TempVariable['direction'] = d
    if (gameState == 'map') {
      viewTrap = GameData['AUTO_MAP_TRAP']
      viewEvent = GameData['AUTO_MAP_EVENT']
    }
    MP.drawMap(pt.DungeonNumber, pt.Floor, x, y, d, viewTrap, viewEvent)
  }
  setFloor3D (imgNum, patternNum, num, type, perspective) {
    let typeNum = 0
    if (type.match(/^(c|ceil)$/)) {
      typeNum = 1
    }
    let perspectiveNum = 0
    if (perspective) {
      perspectiveNum = 1
    }
    if (
      !this.checkPolygonFloor3D(
        imgNum,
        patternNum,
        num,
        typeNum,
        perspectiveNum
      )
    ) {
      return
    }
    if (
      imgNum == 1 &&
      ((type == 'f' && this.ImgFloor[0] == null) ||
        (type == 'c' && this.ImgCeil[0] == null))
    ) {
      return
    } else {
      this.Sprite3D.addChild(
        this.Floor3D[imgNum][patternNum][num][typeNum][perspectiveNum]
      )
      if (
        imgNum == 2 &&
        this.ImgLadder != null &&
        this.checkPolygonLadder3D(num)
      ) {
        this.Sprite3D.addChild(this.Ladder3D[typeNum][num][perspectiveNum])
      }
    }
  }
  setFont () {
    this.MainSurface.context.font = this.FONT_SIZE + 'px ' + this.FONT_NAME
    this.StatusSurface.context.font = this.FONT_SIZE + 'px ' + this.FONT_NAME
    for (let i = 0; i < this.TextSurface.length; i++) {
      this.TextSurface[i].context.font = this.FONT_SIZE + 'px ' + this.FONT_NAME
    }
    this.StatusTopSurface.context.font = this.FONT_SIZE + 'px ' + this.FONT_NAME
    this.TopSurface.context.font = this.FONT_SIZE + 'px ' + this.FONT_NAME
  }
  setMessage (text, align, through, onePage) {
    if (through == undefined || through == null) {
      through = false
    }
    if (onePage == undefined || onePage == null) {
      onePage = false
    }
    GenericVariable['Message'] = this.strChangeLine(
      text,
      38,
      12,
      onePage
    ).split('<p>')
    GenericVariable['MessageAlign'] = align
    GenericVariable['MessageThrough'] = through
    this.drawTextFrame(
      this.TextSurface[this.TextSurfaceNum],
      GenericVariable['Message'][0],
      'center',
      this.LINE_HEIGHT * 3,
      38,
      0,
      GenericVariable['MessageAlign']
    )
  }
  setOptionMode (mode, text) {
    if (mode == 'option') {
      Mode = 'option'
      this.ButtonObject['game_window_div'].style.display = 'none'
      if (this.ButtonObject['debug_div'] != undefined) {
        this.ButtonObject['debug_div'].style.display = 'none'
      }
      if (this.ButtonObject['escape_div'] != undefined) {
        this.ButtonObject['escape_div'].style.display = 'none'
      }
      this.paintMask()
      this.TopSurface.clear()
      this.drawOptionFrame()
      let x = this.MAIN_X + this.MAIN_WIDTH / 2 - this.FONT_HALF_SIZE * 25
      let y = this.MAIN_Y + this.LINE_HEIGHT * 3
      let h = this.MAIN_HEIGHT - this.MAIN_HEIGHT / 10
      let y2 = this.LINE_HEIGHT * 2.2
      let x2 = x + this.FONT_HALF_SIZE * 50
      let y3 = this.FONT_SIZE * 1.2
      let frameWidth = this.FRAME_WIDTH / 3
      let strAry = [
        'Music',
        'Se',
        'Controller Align',
        'GamePad',
        'Dungeon',
        'Perspective',
        '',
        'Save Data'
      ]
      for (let i = 0; i < strAry.length; i++) {
        if (strAry[i] == '') {
          continue
        }
        this.drawText(
          this.TopSurface,
          x,
          y + y2 * i,
          null,
          null,
          '[' + strAry[i] + ']'
        )
        if (i < 5) {
          let str,
            color = 'white'
          if (i == 2) {
            str = 'left'
          } else if (i == 4) {
            str = 'graphic'
            if (LocalLimit) {
              color = 'gray'
            }
          } else {
            str = 'on'
          }
          this.drawText(
            this.TopSurface,
            x + this.FONT_HALF_SIZE * 24,
            y + y2 * i,
            null,
            null,
            str,
            null,
            null,
            color
          )
          if (i == 2) {
            str = 'right'
          } else if (i == 4) {
            str = 'wire frame'
          } else {
            str = 'off'
          }
          this.drawText(
            this.TopSurface,
            x + this.FONT_HALF_SIZE * 38,
            y + y2 * i,
            null,
            null,
            str
          )
        }
        this.drawLine(
          this.TopSurface,
          [
            [x, y + y3 + y2 * i],
            [x2, y + y3 + y2 * i]
          ],
          frameWidth
        )
      }
      checkRadioButtonText()
      let verStr =
        'GameSystem: ' + VERSION + '    GameData: ' + GameData['VERSION']
      this.drawText(
        this.TopSurface,
        x,
        this.MAIN_Y + this.MAIN_HEIGHT / 20 + h - this.FONT_SIZE * 1.5,
        50,
        1,
        verStr,
        'right'
      )
      for (let i = 0; i < OPTION_NAME.length; i++) {
        this.OptionParts[OPTION_NAME[i] + '_0']._element.style.visibility =
          'visible'
        this.OptionParts[OPTION_NAME[i] + '_1']._element.style.visibility =
          'visible'
      }
      if (LaunchSettings['NoSoundAllowed']) {
        for (let i = 0; i < 2; i++) {
          for (let j = 0; j < 2; j++) {
            this.OptionParts[
              OPTION_NAME[i] + '_' + String(j)
            ]._element.disabled = true
            this.OptionParts[
              OPTION_NAME[i] + '_' + String(j)
            ]._element.style.cursor = 'default'
          }
        }
      }
      for (let i = 0; i < OPTION_BUTTON_NAME.length; i++) {
        this.OptionParts[OPTION_BUTTON_NAME[i]]._element.style.visibility =
          'visible'
      }
      checkRadioButton()
    } else if (mode == 'keyname') {
      Mode = 'optionKeyname'
      this.TopSurface.clear()
      this.drawOptionFrame()
      let y = this.MAIN_Y + this.LINE_HEIGHT * 8
      if (text == undefined || text == null) {
        text = ''
      }
      text = '\n\n' + text
      this.drawTextFrame(this.TopSurface, text, 'center', y, 26, 4, 'center')
      this.drawTextFrame(
        this.TopSurface,
        ' Keyname ',
        'center',
        y - this.FONT_SIZE / 1.1,
        null,
        null,
        'center'
      )
    } else if (mode == 'keyConfig') {
      Mode = 'optionKeyConfig'
      this.ButtonObject['keyConfigCancel_div'].style.display = ''
      this.TopSurface.clear()
      this.drawOptionFrame()
      let x = this.MAIN_X + this.MAIN_WIDTH / 2 - this.FONT_HALF_SIZE * 25
      let y = this.MAIN_Y + this.LINE_HEIGHT * 2.8
      let h = this.MAIN_HEIGHT - this.MAIN_HEIGHT / 10
      let y2 = this.LINE_HEIGHT * 1.5
      let x2 = x + this.FONT_HALF_SIZE * 50
      let y3 = this.FONT_SIZE * 1.2
      let frameWidth = this.FRAME_WIDTH / 3
      let tX = this.MAIN_X + this.MAIN_WIDTH / 2 - this.FONT_HALF_SIZE * 8
      for (let i = 0; i < KEY_NAME.length; i++) {
        if (!GameData['DEBUG'] && i >= KEY_NAME.length - 1) {
          break
        }
        this.OptionParts[KEY_NAME[i]]._element.style.visibility = 'visible'
        this.drawLine(
          this.TopSurface,
          [
            [x, y + y3 + y2 * i],
            [x2, y + y3 + y2 * i]
          ],
          frameWidth
        )
        this.drawText(
          this.TopSurface,
          tX,
          y + y2 * i,
          33,
          1,
          KeyConfigData2[KEY_NAME[i]],
          'left'
        )
      }
    } else if (mode == 'partsClear') {
      for (let i = 0; i < OPTION_NAME.length; i++) {
        this.OptionParts[OPTION_NAME[i] + '_0']._element.style.visibility =
          'hidden'
        this.OptionParts[OPTION_NAME[i] + '_1']._element.style.visibility =
          'hidden'
      }
      for (let i = 0; i < 2; i++) {
        let name
        if (i == 0) {
          name = 'bgm_volume'
        } else {
          name = 'se_volume'
        }
        this.OptionParts[name]._element.style.visibility = 'hidden'
        this.OptionParts[name + '_up']._element.style.visibility = 'hidden'
        this.OptionParts[name + '_down']._element.style.visibility = 'hidden'
      }
      for (let i = 0; i < OPTION_BUTTON_NAME.length; i++) {
        this.OptionParts[OPTION_BUTTON_NAME[i]]._element.style.visibility =
          'hidden'
      }
      for (let i = 0; i < KEY_NAME.length; i++) {
        this.OptionParts[KEY_NAME[i]]._element.style.visibility = 'hidden'
      }
    } else {
      Mode = 'normal'
      this.TopSurface.clear()
      this.setOptionMode('partsClear')
      this.paintMask('clear')
      this.ButtonObject['game_window_div'].style.display = ''
      if (this.ButtonObject['debug_div'] != undefined) {
        this.ButtonObject['debug_div'].style.display = ''
      }
      if (this.ButtonObject['escape_div'] != undefined) {
        this.ButtonObject['escape_div'].style.display = ''
      }
      this.ButtonObject['keyConfigCancel_div'].style.display = 'none'
    }
  }
  setPassingMessage (textAry, line, align, count) {
    GenericVariable['KeyInvalid'] = true
    GenericVariable['Message'] = []
    for (let i = 0; i < textAry.length; i++) {
      GenericVariable['Message'].push(
        this.strChangeLine(textAry[i], 48, 12, true)
      )
    }
    GenericVariable['MessageLine'] = line
    GenericVariable['MessageAlign'] = align
    GenericVariable['MessageCount'] = 0
    if (count < 0) {
      count = 0
    }
    GenericVariable['MessageCountMax'] = count
    this.drawTextFrame(
      this.TextSurface[this.TextSurfaceNum],
      GenericVariable['Message'][0],
      'center',
      this.LINE_HEIGHT * GenericVariable['MessageLine'],
      0,
      0,
      GenericVariable['MessageAlign']
    )
  }
  setSelectMode (
    callBackFunc,
    mode,
    selAry,
    valueAry,
    colorAry,
    comment,
    align,
    y,
    charMin,
    lineNum,
    textAlign,
    select,
    selectF,
    selectColor
  ) {
    if (callBackFunc != null) {
      this.SelectMode['run'] = true
    } else {
      this.SelectMode['run'] = false
    }
    if (mode == undefined || mode == null) {
      mode = 'normal'
    }
    this.SelectMode['mode'] = mode
    this.SelectMode['callBackFunc'] = callBackFunc
    this.SelectMode['selAry'] = selAry.slice()
    if (!Array.isArray(valueAry)) {
      valueAry = []
    }
    for (let i = 0; i < selAry.length; i++) {
      if (valueAry[i] == undefined) {
        valueAry[i] = i
      }
    }
    this.SelectMode['valueAry'] = valueAry.slice()
    if (typeof select == 'string') {
      let num = valueAry.indexOf(select)
      if (num < 0) {
        select = 0
      } else {
        select = num
      }
    }
    if (!Array.isArray(colorAry)) {
      colorAry = []
      for (let i = 0; i < selAry.length; i++) {
        colorAry[i] = 'white'
      }
    }
    this.SelectMode['colorAry'] = colorAry.slice()
    if (comment == undefined || comment == null) {
      comment = ''
    }
    this.SelectMode['comment'] = comment
    this.SelectMode['align'] = align
    this.SelectMode['y'] = y
    let lenAry = []
    for (let i = 0; i < selAry.length; i++) {
      lenAry.push(this.strCount(selAry[i]))
    }
    lenAry.sort(function (a, b) {
      return b - a
    })
    if (lenAry[0] > charMin) {
      charMin = lenAry[0]
    }
    this.SelectMode['charMin'] = charMin
    if (lineNum == undefined || lineNum == null || lineNum <= 0) {
      this.SelectMode['lineNum'] = selAry.length
    } else {
      this.SelectMode['lineNum'] = lineNum
    }
    this.SelectMode['textAlign'] = textAlign
    this.SelectMode['select'] = select
    this.SelectMode['selectF'] = selectF
    if (selectColor == undefined || selectColor == null) {
      selectColor = 'red'
    }
    this.SelectMode['selectColor'] = selectColor
    if (selAry.length < this.SelectMode['lineNum']) {
      this.SelectMode['limit'] = selAry.length
    } else {
      this.SelectMode['limit'] = this.SelectMode['lineNum']
    }
    if (mode == 'normal' && this.SelectMode['select'] > -1) {
      if (this.SelectMode['select'] < this.SelectMode['selectF']) {
        this.SelectMode['selectF'] = this.SelectMode['select']
      } else if (
        this.SelectMode['select'] >
        this.SelectMode['selectF'] + this.SelectMode['limit'] - 1
      ) {
        this.SelectMode['selectF'] =
          this.SelectMode['select'] - this.SelectMode['limit'] + 1
      }
    }
    if (
      callBackFunc != null &&
      !mode.match(/^(statusAbility|(monster|item)Catalog)$/)
    ) {
      this.viewSelectMode()
    }
  }
  setTextureFloor3D (imgNum, patternNum, num, typeNum, perspectiveNum) {
    if (
      !this.checkPolygonFloor3D(
        imgNum,
        patternNum,
        num,
        typeNum,
        perspectiveNum
      )
    ) {
      return
    }
    let flag = false
    if (imgNum == 1) {
      if (typeNum == 0) {
        if (this.ImgFloor[patternNum] != null) {
          this.ImgFloor[patternNum]._element.src = Math.random()
          this.Floor3D[imgNum][patternNum][num][typeNum][
            perspectiveNum
          ].mesh.texture.src = this.ImgFloor[patternNum]
          flag = true
        }
      } else {
        if (this.ImgCeil[patternNum] != null) {
          this.ImgCeil[patternNum]._element.src = Math.random()
          this.Floor3D[imgNum][patternNum][num][typeNum][
            perspectiveNum
          ].mesh.texture.src = this.ImgCeil[patternNum]
          flag = true
        }
      }
    } else if (imgNum == 2) {
      if (typeNum == 0) {
        if (this.ImgDownStairs[patternNum] != null) {
          this.ImgDownStairs[patternNum]._element.src = Math.random()
          this.Floor3D[imgNum][patternNum][num][typeNum][
            perspectiveNum
          ].mesh.texture.src = this.ImgDownStairs[patternNum]
          flag = true
        }
      } else {
        if (this.ImgUpStairs[patternNum] != null) {
          this.ImgUpStairs[patternNum]._element.src = Math.random()
          this.Floor3D[imgNum][patternNum][num][typeNum][
            perspectiveNum
          ].mesh.texture.src = this.ImgUpStairs[patternNum]
          flag = true
        }
      }
      if (this.checkPolygonLadder3D(num)) {
        if (this.ImgLadder != null) {
          this.ImgLadder._element.src = Math.random()
          this.Ladder3D[typeNum][num][perspectiveNum].mesh.texture.src =
            this.ImgLadder
        } else {
          this.Ladder3D[typeNum][num][perspectiveNum].mesh.texture.src = null
        }
      }
    } else if (imgNum == 3) {
      if (typeNum == 0) {
        if (this.ImgElevator[patternNum] != null) {
          this.ImgElevator[patternNum]._element.src = Math.random()
          this.Floor3D[imgNum][patternNum][num][typeNum][
            perspectiveNum
          ].mesh.texture.src = this.ImgElevator[patternNum]
          flag = true
        }
      } else {
        if (this.ImgElevator[patternNum + 2] != null) {
          this.ImgElevator[patternNum + 2]._element.src = Math.random()
          this.Floor3D[imgNum][patternNum][num][typeNum][
            perspectiveNum
          ].mesh.texture.src = this.ImgElevator[patternNum + 2]
          flag = true
        }
      }
    } else if (imgNum == 4) {
      if (typeNum == 0) {
        if (this.ImgEvent[patternNum] != null) {
          this.ImgEvent[patternNum]._element.src = Math.random()
          this.Floor3D[imgNum][patternNum][num][typeNum][
            perspectiveNum
          ].mesh.texture.src = this.ImgEvent[patternNum]
          flag = true
        }
      } else {
        if (this.ImgEvent[patternNum + 2] != null) {
          this.ImgEvent[patternNum + 2]._element.src = Math.random()
          this.Floor3D[imgNum][patternNum][num][typeNum][
            perspectiveNum
          ].mesh.texture.src = this.ImgEvent[patternNum + 2]
          flag = true
        }
      }
    }
    if (!flag) {
      this.Floor3D[imgNum][patternNum][num][typeNum][
        perspectiveNum
      ].mesh.texture.src = null
    }
  }
  setTextureWall3D (imgNum, num, perspectiveNum) {
    if (!this.checkPolygonWall3D(imgNum, num, perspectiveNum)) {
      return
    }
    let flag = false
    if ((imgNum == 1 || imgNum == 3) && this.ImgWall != null) {
      this.ImgWall._element.src = Math.random()
      this.Wall3D[imgNum][num][perspectiveNum].mesh.texture.src = this.ImgWall
      flag = true
    } else if (imgNum == 2 && this.ImgDoor != null) {
      this.ImgDoor._element.src = Math.random()
      this.Wall3D[imgNum][num][perspectiveNum].mesh.texture.src = this.ImgDoor
      flag = true
    } else if (imgNum == 4 && this.ImgSecretDoor != null) {
      this.ImgSecretDoor._element.src = Math.random()
      this.Wall3D[imgNum][num][perspectiveNum].mesh.texture.src =
        this.ImgSecretDoor
      flag = true
    } else if (imgNum == 5 && this.ImgDistantView != null) {
      this.ImgDistantView._element.src = Math.random()
      this.Wall3D[imgNum][num][perspectiveNum].mesh.texture.src =
        this.ImgDistantView
      flag = true
    } else if (imgNum == 7 && this.ImgWallSide != null) {
      this.ImgWallSide._element.src = Math.random()
      this.Wall3D[imgNum][num][perspectiveNum].mesh.texture.src =
        this.ImgWallSide
      flag = true
    }
    if (!flag) {
      this.Wall3D[imgNum][num][perspectiveNum].mesh.texture.src = null
    }
  }
  setWall3D (imgNum, num, perspective) {
    let perspectiveNum = 0
    if (perspective) {
      perspectiveNum = 1
    }
    if (!this.checkPolygonWall3D(imgNum, num, perspectiveNum)) {
      return
    }
    this.Sprite3D.addChild(this.Wall3D[imgNum][num][perspectiveNum])
  }
  strChangeLine (str, w, h, onePage) {
    if (onePage == undefined || onePage == null) {
      onePage = false
    }
    w -= 2
    str = str.replace(/\r\n|\n|\r/g, '<br>')
    str = str.replace(/<br><p><br>|<br><p>|<p><br>/g, '<p>')
    str = str.replace(/<p>(<img *src=\"[^>]*?\".*?>)/g, '$1')
    str = str.replace(/(<img *src=\"[^>]*?\".*?>)<br>/g, '$1')
    str = str.replace(
      /(<img *src=\"[^>]*?\".*?>)/g,
      '<p>$1<br><br><br><br><br><br><br><br><br><br>'
    )
    str = str.replace(/^<p>/, '')
    let result = ''
    let strAryP = str.split('<p>')
    for (let i = 0; i < strAryP.length; i++) {
      if (i > 0) {
        result += '<p>'
      }
      let stack = []
      let strAry = strAryP[i].split('<br>')
      for (let j = 0; j < strAry.length; j++) {
        strAry[j] = this.hanKana2zenKana(strAry[j])
        while (true) {
          let len = this.strChangeLine2(strAry[j], w)
          if (
            len == 0 ||
            len == strAry[j].length - 1 ||
            /^<img*src=\"[^>]*?\".*?>$/.test(strAry[j])
          ) {
            stack.push(strAry[j])
            break
          } else {
            stack.push(strAry[j].slice(0, len + 1))
            strAry[j] = strAry[j].slice(len + 1)
          }
        }
      }
      let count = 1
      for (let j = 0; j < stack.length; j++) {
        let strPlus
        if (count > h) {
          if (onePage) {
            break
          }
          ;(strPlus = '<p>'), (count = 1)
        } else {
          strPlus = '<br>'
        }
        if (j > 0) {
          result += strPlus
        }
        result += stack[j]
        count++
      }
    }
    return result
  }
  strChangeLine2 (str, limitNum) {
    let result = 0
    let count = 0
    for (let i = 0; i < str.length; i++) {
      if (this.isZenkaku(str.charAt(i))) {
        count += 2
      } else {
        count++
      }
      if (count > limitNum) {
        result = i - 1
        break
      }
    }
    let noBegin =
      /[!\.,>\)\}\]\?]/
    if (result > 0) {
      if (noBegin.test(str.charAt(result + 1))) {
        if (result + 2 < str.length) {
          if (noBegin.test(str.charAt(result + 2))) {
            result--
          } else {
            result++
          }
        } else {
          result++
        }
      }
    }
    return result
  }
  strCount (str) {
    if (!Number.isNaN(str)) {
      str = String(str)
    }
    let count = 0
    for (let i = 0; i < str.length; i++) {
      if (this.isZenkaku(str.charAt(i))) {
        count += 2
      } else {
        count++
      }
    }
    return count
  }
  strCountAry (strAry) {
    let countAry = []
    for (let i = 0; i < strAry.length; i++) {
      countAry.push(this.strCount(strAry[i]))
    }
    countAry.sort(function (a, b) {
      return b - a
    })
    return countAry[0]
  }
  strCut (str, len) {
    if (!Number.isNaN(str)) {
      str = String(str)
    }
    if (len < 0) {
      len = 0
    }
    if (this.strCount(str) <= len) {
      return str
    }
    let result = str
    if (str.length > len) {
      result = result.substring(0, len)
    }
    while (this.strCount(result) > len) {
      result = result.substring(0, result.length - 1)
    }
    return result
  }
  strDiffLength (str, len, align) {
    if (!Number.isNaN(str)) {
      str = String(str)
    }
    let result = []
    let strLen = this.strCount(str)
    if (strLen >= len) {
      ;(result[0] = 0), (result[1] = 0), (result[2] = 0)
      return result
    }
    result[0] = len - strLen
    if (align == 'right') {
      ;(result[1] = result[0]), (result[2] = 0)
    } else if (align == 'center') {
      ;(result[1] = result[0] / 2), (result[2] = result[1])
      if (!Number.isInteger(result[1])) {
        result[1] = Math.floor(result[1])
        result[2] = Math.ceil(result[2])
      }
    } else {
      ;(result[1] = 0), (result[2] = result[0])
    }
    return result
  }
  strFitLength (str, len, align) {
    if (!Number.isNaN(str)) {
      str = String(str)
    }
    if (this.strCount(str) > len) {
      let count = 0
      if (align == 'right') {
        for (let i = str.length - 1; i >= 0; i--) {
          if (this.isZenkaku(str.charAt(i))) {
            count += 2
          } else {
            count++
          }
          if (count > len) {
            str = str.slice(i + 1, str.length)
            break
          }
        }
      } else {
        for (let i = 0; i < str.length; i++) {
          if (this.isZenkaku(str.charAt(i))) {
            count += 2
          } else {
            count++
          }
          if (count > len) {
            str = str.slice(0, i)
            break
          }
        }
      }
    }
    let diff = this.strDiffLength(str, len, align)
    if (diff[0] > 0) {
      if (align == 'right') {
        for (let i = 0; i < diff[1]; i++) {
          str = ' ' + str
        }
      } else if (align == 'center') {
        for (let i = 0; i < diff[1]; i++) {
          str = ' ' + str
        }
        for (let i = 0; i < diff[2]; i++) {
          str += ' '
        }
      } else {
        for (let i = 0; i < diff[2]; i++) {
          str += ' '
        }
      }
    }
    return str
  }
  strGetLineNum (str) {
    str = str.replace(/\r\n|\n|\r/g, '<br>')
    let strAry = str.split('<br>')
    return strAry.length
  }
  viewMonsterList (surface, select, frontLine) {
    if (select == undefined || select == null) {
      select = -1
    }
    if (frontLine == undefined || frontLine == null) {
      frontLine = false
    }
    let text = ''
    let colorAry = []
    for (let i = 0; i < 4; i++) {
      if (i > 0) {
        text += '\n'
      }
      if (TempVariable['monsterNum'][i] < 1) {
        break
      }
      text += ' ' + String(TempVariable['monsterNum'][i]) + ' '
      let mData = MONSTER_DATA[TempVariable['setMonster'][i]]
      if (TempVariable['monsterDecided'][i]) {
        let str, str2
        if (TempVariable['monsterNum'][i] > 1) {
          str = mData.NAMES[1]
        } else {
          str = mData.NAME[1]
        }
        text += MP.strFitLength(str, 25)
        if (TempVariable['monsterNum'][i] > 1) {
          str2 = mData.NAMES[0]
        } else {
          str2 = mData.NAME[0]
        }
        if (str != str2) {
          str2 = '[' + str2 + ']'
        } else {
          str2 = ''
        }
        text += MP.strFitLength(str2, 23)
      } else {
        let str
        if (TempVariable['monsterNum'][i] > 1) {
          str = mData.NAMES[0]
        } else {
          str = mData.NAME[0]
        }
        text += MP.strFitLength(str, 48)
      }
      let count = 0
      for (let j = 0; j < TempVariable['monsterNum'][i]; j++) {
        let monNum = PlayData['MonsterList'][i][j]
        if (monNum < 0) {
          continue
        }
        if (MONSTER[monNum].possibleToAction()) {
          count++
        }
      }
      text += '(' + String(count) + ')'
      if (i > 1 && frontLine) {
        colorAry.push('gray')
      } else {
        colorAry.push('white')
      }
    }
    this.drawTextFrame(
      surface,
      text,
      'center',
      this.LINE_HEIGHT * 0.5,
      0,
      4,
      'left',
      colorAry,
      select
    )
  }
  viewPartyStatus (view, select) {
    if (view == undefined || view == null) {
      view = true
    } else if (view == 'clear') {
      view = false
    }
    if (select == undefined || select == null) {
      select = -1
    }
    this.StatusSurface.clear()
    this.StatusTopSurface.clear()
    let surface
    if (select > -1 && GameState.indexOf('battleBox') < 0) {
      surface = this.StatusTopSurface
    } else {
      surface = this.StatusSurface
    }
    PlayData['PartyStatusNow'] = false
    if (!view) {
      return
    }
    PlayData['PartyStatusNow'] = true
    PlayData['PartyStatusNum'] = select
    let statusStr = ''
    let colorAry = []
    if (PlayData['ActiveParty'] > -1) {
      let ptNum = PlayData['ActiveParty']
      let memberNum = PARTY[ptNum].getMemberNum()
      if (select >= memberNum) {
        select = -1
      }
      for (let i = 0; i < memberNum; i++) {
        if (i > 0) {
          statusStr += '\n'
        }
        let pcNum = PARTY[ptNum].PartyMember[i]
        statusStr += this.strFitLength(PC[pcNum].Name[0], 21)
        statusStr += this.strFitLength(
          GameData['RACE_ABBR'][PC[pcNum].Race],
          4,
          'right'
        )
        statusStr += '-'
        statusStr += this.strFitLength(
          GameData['ALIGNMENT_ABBR'][PC[pcNum].Alignment],
          1
        )
        statusStr += '-'
        statusStr += this.strFitLength(
          GameData['PC_CLASS_ABBR'][PC[pcNum].PcClass],
          5
        )
        statusStr += this.strFitLength(String(PC[pcNum].Ac), 3, 'right')
        statusStr += this.strFitLength(String(PC[pcNum].Hp), 6, 'right')
        if (PC[pcNum].HpPlus > 0) {
          statusStr += '+/ '
        } else if (PC[pcNum].HpPlus < 0) {
          statusStr += '-/ '
        } else {
          statusStr += ' / '
        }
        if (PC[pcNum].Action[0] > -1) {
          let num = PC[pcNum].Action[0]
          let commandStr = ''
          if (num == 0) {
            commandStr = getDefaultMessage('BATTLE_FIGHT', 1)
          } else if (num == 1) {
            commandStr = getDefaultMessage('BATTLE_HIDE', 1)
          } else if (num == 2) {
            commandStr = getDefaultMessage('BATTLE_AMBUSH', 1)
          } else if (num == 3) {
            commandStr = getDefaultMessage('BATTLE_BREATH', 1)
          } else if (num == 4) {
            commandStr = getDefaultMessage('BATTLE_PARRY', 1)
          } else if (num == 5) {
            commandStr = getDefaultMessage('BATTLE_ITEM', 1)
          } else if (num == 6) {
            commandStr = getDefaultMessage('BATTLE_SPELL', 1)
          } else if (num == 7) {
            commandStr = getDefaultMessage('BATTLE_DISPELL', 1)
          }
          statusStr += this.strFitLength(commandStr, 10)
        } else if (
          PC[pcNum].State == 0 &&
          PC[pcNum].Asleep == 0 &&
          PC[pcNum].NoBreath <= 0 &&
          PC[pcNum].Silence == 0 &&
          !PC[pcNum].SealSpell &&
          PC[pcNum].Poison <= 0 &&
          PC[pcNum].Hate < 0
        ) {
          statusStr += this.strFitLength(String(PC[pcNum].HpMax), 5, 'right')
        } else {
          statusStr += PC[pcNum].getStateStr()
        }
        if (GameData['STATUS_COLOR']) {
          colorAry.push(getStatusColor(pcNum))
        }
      }
    }
    this.drawTextFrame(
      surface,
      statusStr,
      'center',
      this.LINE_HEIGHT * 18.6,
      56,
      6,
      'left',
      colorAry,
      select
    )
    this.drawStatusFrameText(surface)
  }
  viewPreSelectMode (textSurfaceNum, preNum, comment, select) {
    if (preNum == undefined || preNum == null) {
      preNum = 0
    }
    if (preNum >= this.PreSelect['selAry'].length) {
      return
    }
    if (comment == undefined || comment == null) {
      comment = this.PreSelect['comment'][preNum]
    }
    if (select == undefined) {
      if (this.PreSelect['mode'][preNum] == 'abiSel') {
        select = -1
      } else {
        select = this.PreSelect['select'][preNum]
      }
    }
    this.viewSelectMode(
      textSurfaceNum,
      this.PreSelect['mode'][preNum],
      this.PreSelect['selAry'][preNum],
      this.PreSelect['valueAry'][preNum],
      this.PreSelect['colorAry'][preNum],
      comment,
      this.PreSelect['align'][preNum],
      this.PreSelect['y'][preNum],
      this.PreSelect['charMin'][preNum],
      this.PreSelect['lineNum'][preNum],
      this.PreSelect['textAlign'][preNum],
      select,
      this.PreSelect['selectF'][preNum],
      this.PreSelect['selectColor'][preNum]
    )
  }
  viewRip () {
    this.clearMainWindow()
    musicPlay('annihilate')
    let ptNum = PlayData['ActiveParty']
    let pt = PARTY[ptNum]
    let mNum = pt.getMemberNum()
    let surface = this.MainSurface
    let gd = GraphicData['graphic/restInPeace']
    let size = (this.MAIN_WIDTH - this.FRAME_WIDTH * 4 - this.FONT_SIZE * 6) / 3
    let x = [],
      y = []
    x.push(this.MAIN_X + this.FRAME_WIDTH * 2 + size / 2)
    x.push(x[0])
    x.push(x[0])
    x.push(this.MAIN_X + this.MAIN_WIDTH / 2 - size / 2)
    x.push(
      this.MAIN_X + this.MAIN_WIDTH - (this.FRAME_WIDTH * 2 + size / 2 + size)
    )
    x.push(x[4])
    x.push(x[4])
    y.push(this.MAIN_Y + this.FRAME_WIDTH * 2)
    y.push(y[0] + size + this.FONT_SIZE * 2)
    y.push(y[1] + size + this.FONT_SIZE * 2)
    y.push(y[1])
    y.push(y[0])
    y.push(y[1])
    y.push(y[2])
    this.drawFrame_Full(surface)
    for (let i = 0; i < mNum; i++) {
      let pcNum = pt.PartyMember[i]
      let pc = PC[pcNum]
      let view = 3
      if (i == 0 && mNum > 2) {
        view = 0
      } else if ((i == 1 && mNum == 6) || (i == 0 && mNum == 2)) {
        view = 1
      } else if (
        (i == 2 && mNum == 6) ||
        (i == 1 && (mNum == 4 || mNum == 5))
      ) {
        view = 2
      } else if (
        (i == 0 && mNum == 1) ||
        (i == 1 && mNum == 3) ||
        (i == 2 && mNum == 5)
      ) {
        view = 3
      } else if ((i == 3 && mNum > 4) || (i == 2 && mNum == 4)) {
        view = 4
      } else if ((i == 4 && mNum == 6) || (i == 1 && mNum == 2)) {
        view = 5
      } else if (
        (i == 5 && mNum == 6) ||
        (i == 4 && mNum == 5) ||
        (i == 3 && mNum == 4) ||
        (i == 2 && mNum == 3)
      ) {
        view = 6
      }
      let plus = 0
      if (mNum == 4) {
        if (i == 0 || i == 2) {
          plus = size / 2
        } else {
          plus = (-1 * size) / 2
        }
      }
      this.paintGraphic(surface, gd, x[view], y[view] + plus, size, size)
      this.drawText(
        surface,
        x[view] - this.FONT_SIZE,
        y[view] + size + this.FONT_SIZE / 4 + plus,
        20,
        1,
        pc.Name[0],
        'center'
      )
    }
  }
  viewSelectMode (
    textSurfaceNum,
    mode,
    selAry,
    valueAry,
    colorAry,
    comment,
    align,
    y,
    charMin,
    lineNum,
    textAlign,
    select,
    selectF,
    selectColor
  ) {
    if (mode == undefined || mode == null) {
      mode = this.SelectMode['mode']
    }
    if (textSurfaceNum == undefined || textSurfaceNum == null) {
      textSurfaceNum = this.TextSurfaceNum
      if (mode.indexOf('pcSel') < 0) {
        this.clearTextSurface(textSurfaceNum)
      }
    }
    if (textSurfaceNum < 0 || textSurfaceNum >= this.TextSurface.length) {
      return
    }
    if (selAry == undefined || selAry == null) {
      selAry = this.SelectMode['selAry'].slice()
    }
    if (valueAry == undefined || valueAry == null) {
      valueAry = this.SelectMode['valueAry'].slice()
    }
    if (colorAry == undefined || colorAry == null) {
      colorAry = this.SelectMode['colorAry'].slice()
    }
    if (comment == undefined || comment == null) {
      comment = this.SelectMode['comment']
    }
    if (align == undefined || align == null) {
      align = this.SelectMode['align']
    }
    if (y == undefined || y == null) {
      y = this.SelectMode['y']
    }
    if (charMin == undefined || charMin == null) {
      charMin = this.SelectMode['charMin']
    }
    if (lineNum == undefined || lineNum == null) {
      lineNum = this.SelectMode['lineNum']
    }
    if (textAlign == undefined || textAlign == null) {
      textAlign = this.SelectMode['textAlign']
    }
    if (select == undefined || select == null) {
      select = this.SelectMode['select']
    }
    if (selectF == undefined || selectF == null) {
      selectF = this.SelectMode['selectF']
    }
    if (selectColor == undefined || selectColor == null) {
      selectColor = this.SelectMode['selectColor']
    }
    let ctx = this.TextSurface[textSurfaceNum].context
    if (mode == 'abiSel') {
      let lenAry = []
      for (let i = 0; i < valueAry.length; i++) {
        lenAry.push(this.strCount(GameData['ABILITY'][valueAry[i]]))
      }
      lenAry.push(this.strCount(getDefaultMessage('BONUS', 1)))
      lenAry.sort(function (a, b) {
        return b - a
      })
      let len = lenAry[0]
      if (len > 20) {
        len = 20
      } else if (len < 10) {
        len = 10
      }
      let x = align + this.FONT_HALF_SIZE * (20 - len)
      let str = ''
      for (let i = 0; i < valueAry.length; i++) {
        if (i > 0) {
          str += '\n'
        }
        str +=
          this.strFitLength(GameData['ABILITY'][valueAry[i]], len, 'right') +
          ': '
        str += this.strFitLength(String(selAry[i]), 3, 'right')
      }
      str +=
        '\n\n' +
        this.strFitLength(getDefaultMessage('BONUS', 1), len, 'right') +
        ': '
      str += this.strFitLength(String(selectF), 3, 'right')
      let frameX = x - this.FRAME_WIDTH * 1.3
      let frameY = y - (this.FRAME_WIDTH + this.FRAME_WIDTH * 0.3)
      let frameW = this.FONT_HALF_SIZE * (len + 5) + this.FRAME_WIDTH * 2.6
      let frameH =
        this.LINE_HEIGHT * (selAry.length + 2) + this.FRAME_WIDTH * 1.9
      this.drawFrame(
        this.TextSurface[textSurfaceNum],
        frameX,
        frameY,
        frameW,
        frameH,
        this.FRAME_ARC,
        this.FRAME_WIDTH,
        'white',
        'black',
        'black'
      )
      if (select > -1) {
        if (selectColor == undefined || selectColor == null) {
          selectColor = 'red'
        }
        ctx.fillStyle = selectColor
        ctx.fillRect(
          x + this.FONT_HALF_SIZE * (len + 2),
          y - this.FRAME_WIDTH * 0.3 + this.LINE_HEIGHT * select,
          this.FONT_HALF_SIZE * 3,
          this.LINE_HEIGHT
        )
      }
      this.drawText(this.TextSurface[textSurfaceNum], x, y, null, null, str)
    } else if (mode == 'spellLvSel') {
      let selectKind = select
      let selectLv = selectF
      let pcNum = PlayData['StatusNum']
      let charNum = 4 + GameData['SPELL_LVMAX'] * 3
      let x = this.MAIN_X + this.MAIN_WIDTH / 2 - this.FONT_HALF_SIZE * 12
      let frameX = x - this.FRAME_WIDTH * 1.3
      let frameY = y - (this.FRAME_WIDTH + this.FRAME_WIDTH * 0.3)
      let frameW = this.FONT_HALF_SIZE * charNum + this.FRAME_WIDTH * 2.6
      let frameH =
        this.LINE_HEIGHT * GameData['SPELL_KIND'] + this.FRAME_WIDTH * 1.9
      this.drawFrame(
        this.TextSurface[textSurfaceNum],
        frameX,
        frameY,
        frameW,
        frameH,
        this.FRAME_ARC,
        this.FRAME_WIDTH,
        'white',
        'black',
        'black'
      )
      if (!isNaN(selectKind) && !isNaN(selectLv)) {
        if (
          selectKind > -1 &&
          selectKind < GameData['SPELL_KIND'] &&
          selectLv > -1 &&
          selectLv < GameData['SPELL_LVMAX']
        ) {
          if (selectColor == undefined || selectColor == null) {
            selectColor = 'red'
          }
          ctx.fillStyle = selectColor
          ctx.fillRect(
            x + this.FONT_HALF_SIZE * (5 + selectLv * 3),
            y - this.FRAME_WIDTH * 0.3 + this.LINE_HEIGHT * selectKind,
            this.FONT_SIZE,
            this.LINE_HEIGHT
          )
        }
      }
      for (let i = 0; i < GameData['SPELL_KIND']; i++) {
        let str =
          this.strFitLength(GameData['SPELL_KIND_NAME'][i], 4, 'right') + ':'
        for (let j = 0; j < GameData['SPELL_LVMAX']; j++) {
          let mp
          if (GameState.match(/inspectRead/)) {
            mp = PC[pcNum].MpMax[i][j]
          } else {
            mp = PC[pcNum].Mp[i][j]
          }
          str += this.strFitLength(mp, 2, 'right')
          if (j < GameData['SPELL_LVMAX'] - 1) {
            str += '/'
          }
        }
        this.drawText(
          this.TextSurface[textSurfaceNum],
          x,
          y,
          charNum,
          GameData['SPELL_KIND'],
          str,
          'left',
          i + 1
        )
      }
    } else if (mode == 'status') {
      this.viewStatus('status', Number(valueAry[select]))
    } else if (mode.indexOf('pcSel') > -1) {
      this.viewPartyStatus(true, select)
    } else if (mode.match(/^monsterSel/)) {
      let frontLine = false
      if (mode.indexOf('Front') > -1) {
        frontLine = true
      }
      this.viewMonsterList(this.TextSurface[textSurfaceNum], select, frontLine)
    } else {
      let str = ''
      let count = 0
      for (let i = selectF; i < selAry.length; i++) {
        if (count > 0) {
          str += '\n'
        }
        str += selAry[i]
        count++
        if (count >= lineNum) {
          break
        }
      }
      let color = ''
      count = 0
      for (let i = selectF; i < colorAry.length; i++) {
        if (count > 0) {
          color += ','
        }
        color += colorAry[i]
        count++
        if (count >= lineNum) {
          break
        }
      }
      let select2 = select - selectF
      if (selAry.length < 1) {
        select2 = -1
      }
      this.drawTextFrame(
        this.TextSurface[textSurfaceNum],
        str,
        align,
        y,
        charMin,
        lineNum,
        textAlign,
        color,
        select2,
        selectColor
      )
      if (selAry.length > lineNum || selectF > 0) {
        let x = 0
        if (!isNaN(align)) {
          x = Number(align)
        } else if (align.match(/left|center|right/)) {
          let diff = this.strDiffLength(
            this.strFitLength('', charMin, 'left'),
            this.NUMBER_OF_CHARACTERS - 4,
            align
          )
          x = this.MAIN_TEXT_X + this.FONT_HALF_SIZE * (2 + diff[1])
        }
        let scroll = ''
        if (selectF > 0) {
          scroll += 'up'
        }
        if (selAry.length - selectF > lineNum) {
          scroll += 'down'
        }
        if (scroll != '') {
          this.drawScrollFrame(
            this.TextSurface[textSurfaceNum],
            x,
            y,
            charMin,
            lineNum,
            scroll
          )
        }
      }
    }
    if (comment == '') {
      return
    }
    if (comment.match(/^create/)) {
      if (GameData['HELP_COMMENT']) {
        if (comment == 'createRace') {
          let str = GameData['RACE_COMMENT'][valueAry[select]]
          if (str != '') {
            this.drawTextFrame(
              this.TextSurface[textSurfaceNum],
              str,
              this.MAIN_X + this.MAIN_WIDTH / 2 - this.FONT_HALF_SIZE * 24,
              this.LINE_HEIGHT * 13,
              28
            )
          }
        } else if (comment == 'createClass') {
          let str = GameData['CLASS_COMMENT'][valueAry[select]]
          if (str != '') {
            this.drawTextFrame(
              this.TextSurface[textSurfaceNum],
              str,
              this.MAIN_X + this.MAIN_WIDTH / 2 - this.FONT_HALF_SIZE * 25,
              this.LINE_HEIGHT * 7,
              26
            )
          }
        }
      }
      if (comment.match(/(Race|Sex)$/)) {
        let race = -1,
          sex = -1
        if (comment.match(/Race$/)) {
          race = valueAry[select]
          if (GameData['RACE_SEX_INSIDE'][race] > -1) {
            sex = GameData['RACE_SEX_INSIDE'][race]
          }
        } else {
          race = this.PreSelect['valueAry'][0][this.PreSelect['select'][0]]
          sex = valueAry[select]
        }
        let str = ''
        for (let i = 0; i < GameData['ABILITY_DISPLAY'].length; i++) {
          let abi = GameData['ABILITY_DISPLAY'][i]
          if (i > 0) {
            str += '\n'
          }
          str +=
            this.strFitLength(GameData['ABILITY_ABBR'][abi], 6, 'right') + ':'
          let raceAbi = GameData['RACE_ABI'][race][abi]
          if (comment.match(/Race$/) && sex > -1) {
            raceAbi += GameData['ABILITY_SEX'][sex][abi]
          }
          str += this.strFitLength(raceAbi, 3, 'right')
          if (comment.match(/Sex$/) && sex > -1) {
            let str2 = ''
            let abiSex = GameData['ABILITY_SEX'][sex][abi]
            if (abiSex != 0) {
              str2 += ' ('
              if (abiSex > 0) {
                str2 += '+'
              }
              str2 += String(abiSex) + ')'
            }
            str += this.strFitLength(str2, 7)
          }
        }
        this.drawTextFrame(
          this.TextSurface[textSurfaceNum],
          str,
          this.MAIN_X + this.MAIN_WIDTH / 2 + this.FONT_HALF_SIZE * 10,
          this.LINE_HEIGHT * 6
        )
      } else if (comment.match(/(Ali|Abi)$/)) {
        let race = this.PreSelect['valueAry'][0][this.PreSelect['select'][0]]
        let sex = this.PreSelect['valueAry'][1][this.PreSelect['select'][1]]
        let ali
        if (comment == 'createAli') {
          ali = valueAry[select]
        } else {
          ali = this.PreSelect['valueAry'][2][this.PreSelect['select'][2]]
        }
        let abi = null
        if (comment == 'createAbi') {
          abi = []
          let count = 0
          for (let i = 0; i < GameData['ABILITY'].length; i++) {
            if (i >= 10) {
              break
            }
            if (i > 0 && GameData['ABILITY_NOT_DISPLAY'][i]) {
              abi.push(
                GameData['RACE_ABI'][race][i] + GameData['ABILITY_SEX'][sex][i]
              )
            } else {
              abi.push(selAry[count])
              count++
            }
          }
        }
        let classAry = []
        for (let i = 0; i < GameData['PC_CLASS'].length; i++) {
          if (enableChangeClass(i, -1, race, sex, ali, abi) == 2) {
            classAry.push(i)
          }
        }
        let str = ''
        for (let i = 0; i < 9; i++) {
          if (i >= classAry.length) {
            break
          }
          if (i > 0) {
            str += '\n'
          }
          for (let j = 0; j < 4; j++) {
            let k = i + j * 9
            if (k >= classAry.length) {
              break
            }
            if (j > 0) {
              str += '  '
            }
            str += this.strFitLength(GameData['PC_CLASS_ABBR'][classAry[k]], 4)
          }
        }
        this.drawTextFrame(
          this.TextSurface[textSurfaceNum],
          str,
          this.MAIN_X + this.MAIN_WIDTH / 2 + this.FONT_HALF_SIZE * 6,
          this.LINE_HEIGHT * 14,
          22,
          9
        )
      }
    } else if (comment == 'changeClass') {
      if (GameData['HELP_COMMENT']) {
        let str = GameData['CLASS_COMMENT'][TempVariable['classAry'][select]]
        if (str != '') {
          let commentColor = 'white'
          if (!TempVariable['classChangeAry'][select]) {
            commentColor = 'gray'
          }
          this.drawTextFrame(
            this.TextSurface[textSurfaceNum],
            str,
            this.MAIN_X + this.MAIN_WIDTH / 2 - this.FONT_HALF_SIZE * 25,
            this.LINE_HEIGHT * 7,
            26,
            0,
            'left',
            commentColor
          )
        }
      }
    } else if (comment == 'spellLv') {
      let str = ''
      let pcNum = PlayData['StatusNum']
      let mode = 0
      if (GameState == 'inspectCast') {
        mode = 1
      } else if (GameState == 'battleCommandSpell') {
        mode = 2
      } else if (GameState.indexOf('battleBoxCast') > -1) {
        mode = 3
      }
      let ary = PC[pcNum].getLearnedSpell(mode, select, selectF)
      TempVariable['spellList'] = ary.slice()
      let commentColor = []
      for (let i = 0; i < ary.length; i++) {
        if (i > 0) {
          str += '\n'
        }
        let strAry = GameData['SPELL'][select][selectF][ary[i]].split('<>')
        str += strAry[0]
        if (
          PC[pcNum].Mp[select][selectF] >=
          GameData['SPELL_CONSUMPTION_MP'][select][selectF][ary[i]]
        ) {
          commentColor.push('white')
        } else {
          commentColor.push('gray')
        }
      }
      this.drawTextFrame(
        this.TextSurface[textSurfaceNum],
        str,
        this.MAIN_X + this.MAIN_WIDTH / 2 - this.FONT_HALF_SIZE * 12,
        this.LINE_HEIGHT * (7 + GameData['SPELL_KIND']),
        24,
        6,
        'left',
        commentColor
      )
    } else if (comment == 'spell') {
      if (GameData['HELP_COMMENT']) {
        let kind = this.PreSelect['select'][2]
        let lv = this.PreSelect['selectF'][2]
        if (valueAry.length > 0) {
          let spell = Number(valueAry[select])
          let pcNum = PlayData['StatusNum']
          let str = GameData['SPELL_COMMENT'][kind][lv][spell]
          let strAry = str.split('<+>')
          if (strAry.length == 4) {
            str = strAry[PC[pcNum].Sex]
          } else if (strAry.length == 3) {
            str = strAry[PC[pcNum].Alignment]
          }
          if (str != '') {
            this.drawTextFrame(
              this.TextSurface[textSurfaceNum],
              str,
              'center',
              this.LINE_HEIGHT * 19,
              54,
              5
            )
          }
        }
      }
    } else if (comment == 'haveItem') {
      if (GameData['HELP_COMMENT']) {
        this.TopSurface.clear()
        if (
          GameState.match(/^inspectItem(Inspect|Use)$/) &&
          GameData['EQUIP_COMMENT']
        ) {
          this.clearTextSurface(MP.TextSurfaceNum + 1)
        }
        let pcNum = PlayData['StatusNum']
        let haveNum = Number(valueAry[select])
        if (haveNum > -1) {
          if (PC[pcNum].ItemDecided[haveNum] == 1) {
            if (GameState.match(/^inspectItem(Inspect|Use)$/)) {
              let equipStr = ITEM[PC[pcNum].Item[haveNum]].getEquipComment()
              if (GameData['EQUIP_COMMENT'] && equipStr != '') {
                this.drawTextFrame(
                  this.TextSurface[textSurfaceNum + 1],
                  equipStr,
                  this.MAIN_X + this.FONT_HALF_SIZE * 2,
                  this.LINE_HEIGHT * 0.5,
                  20,
                  18
                )
              }
            }
            let str = ITEM[PC[pcNum].Item[haveNum]].COMMENT
            if (str != '') {
              if (GameState.match(/^inspectItem(Inspect|Use)$/)) {
                this.drawTextFrame(
                  this.TextSurface[textSurfaceNum],
                  str,
                  'center',
                  this.LINE_HEIGHT * 19,
                  54,
                  5
                )
              } else {
                this.drawTextFrame(
                  this.TopSurface,
                  str,
                  'center',
                  this.LINE_HEIGHT * 19,
                  54,
                  5
                )
              }
            }
          }
        }
      }
    } else if (comment.match(/^(item|itemMinus|itemCatalog)$/)) {
      if (GameData['HELP_COMMENT'] || comment == 'itemCatalog') {
        this.TopSurface.clear()
        let itemNum = Number(valueAry[select])
        if (itemNum > -1) {
          if (comment.match(/^item(Minus|Catalog)$/)) {
            itemNum--
          }
          let str = ITEM[itemNum].COMMENT
          if (str != '') {
            let scroll = ''
            if (comment == 'itemCatalog') {
              if (ITEM[itemNum].COMMENT.indexOf('<p>') > -1) {
                scroll = 'down'
              }
            }
            this.drawTextFrame(
              this.TopSurface,
              str,
              'center',
              this.LINE_HEIGHT * 19,
              54,
              5,
              '',
              '',
              -1,
              '',
              scroll
            )
          }
        }
      }
    } else if (comment == 'itemSort') {
      let pcNum = PlayData['StatusNum']
      let str = ''
      for (let i = 0; i < TempVariable['itemList2'].length; i++) {
        if (i > 0) {
          str += '\n'
        }
        str += ITEM[TempVariable['itemList2'][i][0]].getName(
          TempVariable['itemList2'][i][1],
          TempVariable['itemList2'][i][2],
          pcNum
        )
      }
      let lineNum = PC[pcNum].ItemMaxNum
      if (lineNum > 12) {
        lineNum = 12
      }
      this.drawTextFrame(
        this.TextSurface[textSurfaceNum],
        str,
        this.MAIN_X + this.MAIN_WIDTH / 2 + this.FONT_HALF_SIZE * 2,
        this.LINE_HEIGHT * 10,
        26,
        lineNum
      )
    } else if (comment == 'itemTrade') {
      let pcNum = TempVariable['targetNum']
      let selF = TempVariable['targetSelectF']
      let str = '<< ' + PC[pcNum].Name[0] + ' >>'
      this.drawTextFrame(
        this.TextSurface[textSurfaceNum],
        str,
        this.MAIN_X + this.MAIN_WIDTH / 2 + this.FONT_HALF_SIZE * 2,
        this.LINE_HEIGHT * 7.8,
        26,
        0,
        'center'
      )
      if (TempVariable['trade'] == 'target') {
        pcNum = PlayData['StatusNum']
        selF = TempVariable['mySelectF']
      }
      let tmpSelAry = [],
        tmpValueAry = [],
        tmpAlign,
        tmpY = this.LINE_HEIGHT,
        tmpSelectF
      let itemMax = PC[pcNum].haveItemNum(-1)
      for (let i = 0; i < itemMax; i++) {
        tmpSelAry.push(PC[pcNum].getItemName(i, 'equip'))
        tmpValueAry.push(String(i))
      }
      if (TempVariable['trade'] == 'my') {
        tmpAlign = this.MAIN_X + this.MAIN_WIDTH / 2 + this.FONT_HALF_SIZE * 2
        tmpY *= 10
        tmpSelectF = TempVariable['targetSelectF']
      } else {
        tmpAlign = this.MAIN_X + this.MAIN_WIDTH / 2 - this.FONT_HALF_SIZE * 28
        tmpY *= 4
        tmpSelectF = TempVariable['mySelectF']
      }
      let tmpLineNum = PC[pcNum].ItemMaxNum
      if (tmpLineNum > 12) {
        tmpLineNum = 12
      }
      this.viewSelectMode(
        textSurfaceNum,
        'normal',
        tmpSelAry,
        tmpValueAry,
        [],
        '',
        tmpAlign,
        tmpY,
        26,
        tmpLineNum,
        'left',
        -1,
        tmpSelectF,
        ''
      )
    } else if (comment == 'itemIdentify') {
      let pcNum = Math.floor(Number(valueAry[select]) / 100)
      let str = '( ' + PC[pcNum].Name[0] + ' )'
      this.drawTextFrame(
        this.TextSurface[textSurfaceNum],
        str,
        'center',
        this.LINE_HEIGHT * 21,
        26,
        0,
        'center'
      )
    } else if (comment == 'inn') {
      if (GameData['HELP_COMMENT'] && select > -1 && select < 5) {
        let ptNum = PlayData['ActiveParty']
        let pcNum = PARTY[ptNum].PartyMember[TempVariable['pcNumInParty']]
        let pc = PC[pcNum]
        let str = getDefaultMessage('HP', 1, 4) + ': '
        str += this.strFitLength(pc.Hp, 5, 'right') + ' -> '
        let healHp = pc.Hp + TempVariable['innHealing'][select]
        if (healHp > pc.HpMax) {
          healHp = pc.HpMax
        }
        str += this.strFitLength(healHp, 5, 'right') + '/'
        str += this.strFitLength(pc.HpMax, 5, 'right')
        this.drawTextFrame(
          this.TextSurface[textSurfaceNum],
          str,
          'center',
          this.LINE_HEIGHT * 19
        )
      }
    } else if (comment == 'haveMoney') {
      this.drawHaveMoney(PC[Number(valueAry[select])])
    }
  }
  viewStatus (mode, pcNum) {
    if (mode == undefined || mode == null || mode == '') {
      return
    }
    this.MainSurface.clear()
    this.drawFrame_Full(this.MainSurface)
    let color = 'white'
    if (GameData['STATUS_COLOR']) {
      color = getStatusColor(pcNum)
    }
    let pc = PC[pcNum]
    let str = this.strFitLength(pc.Title, 7)
    str += this.strFitLength(pc.Name[0], 21)
    str += this.strFitLength(getDefaultMessage('LEVEL', 1), 6, 'right')
    str += this.strFitLength(String(pc.Level), 5)
    str +=
      this.strFitLength(GameData['ALIGNMENT'][pc.Alignment], 8, 'right') + ' '
    if (GameData['RACE_SEX_INSIDE'][pc.Race] < 0) {
      str += GameData['SEX'][pc.Sex]
    }
    this.drawText_FullFrame(this.MainSurface, str, 0, 1, color)
    str =
      GameData['RACE'][pc.Race] + ' [' + GameData['PC_CLASS'][pc.PcClass] + ']'
    this.drawText_FullFrame(this.MainSurface, str, 'center', 2, color)
    str = this.strFitLength(getDefaultMessage('HP', 1), 4, 'right')
    str += this.strFitLength(String(pc.Hp), 8, 'right') + ' /'
    str += this.strFitLength(String(pc.HpMax), 6, 'right')
    if (pc.HpPlus != 0) {
      str += ' ('
      if (pc.HpPlus > 0) {
        str += '+'
      }
      str += String(pc.HpPlus) + ')'
    }
    this.drawText_FullFrame(this.MainSurface, str, 14, 3, color)
    this.drawText_FullFrame(this.MainSurface, pc.getStateStr(), 46, 3, color)
    if (GameState.match(/^inspect(Command|Item|ItemTrade)$/)) {
      this.drawTextFrame(
        this.MainSurface,
        ' <-[SHIFT_LEFT] ',
        this.FULL_FRAME_X + this.FRAME_WIDTH * 1.3,
        this.FONT_SIZE / 1.4 + this.LINE_HEIGHT * 23,
        null,
        null,
        'center',
        GameData['SELECT_OVER_COLOR']
      )
      this.drawTextFrame(
        this.MainSurface,
        '[SHIFT_RIGHT]-> ',
        this.FULL_FRAME_X +
          this.FULL_FRAME_WIDTH -
          this.FONT_HALF_SIZE * 16 -
          this.FRAME_WIDTH * 1.3,
        this.FONT_SIZE / 1.4 + this.LINE_HEIGHT * 23,
        null,
        null,
        'center',
        GameData['SELECT_OVER_COLOR']
      )
    }
    if (mode == 'status') {
      for (let i = 0; i < GameData['ABILITY_DISPLAY'].length; i++) {
        let abi = GameData['ABILITY_DISPLAY'][i]
        str = this.strFitLength(GameData['ABILITY_ABBR'][abi], 6, 'right') + ':'
        this.drawText_FullFrame(this.MainSurface, str, 0, 4 + i)
        let abi0Str = this.strFitLength(pc.Ability0[abi], 3, 'right')
        let abiStr = this.strFitLength(pc.Ability[abi], 3, 'right')
        if (GameData['CORRECTED_ABILITY_IS_NOT_INDICATED']) {
          this.drawText_FullFrame(this.MainSurface, abi0Str, 7, 4 + i)
        } else if (GameData['ABILITY_PARENTHESIS']) {
          this.drawText_FullFrame(this.MainSurface, abi0Str, 7, 4 + i)
          if (abi0Str != abiStr) {
            this.drawText_FullFrame(this.MainSurface, '(', 10, 4 + i)
            this.drawText_FullFrame(
              this.MainSurface,
              abiStr,
              11,
              4 + i,
              'orange'
            )
            this.drawText_FullFrame(this.MainSurface, ')', 14, 4 + i)
          }
        } else {
          if (abi0Str != abiStr) {
            color = 'orange'
          } else {
            color = 'white'
          }
          this.drawText_FullFrame(this.MainSurface, abiStr, 7, 4 + i, color)
        }
      }
      str = this.strFitLength(getDefaultMessage('EXP', 1), 7)
      str += this.strFitLength(this.numberFormat(pc.Exp), 16, 'right')
      this.drawText_FullFrame(this.MainSurface, str, 16, 4)
      str = this.strFitLength(getDefaultMessage('NEXT', 1), 7)
      str += this.strFitLength(this.numberFormat(pc.NextExp), 16, 'right')
      this.drawText_FullFrame(this.MainSurface, str, 16, 5)
      str = this.strFitLength(getDefaultMessage('GOLD', 1), 7)
      str += this.strFitLength(this.numberFormat(pc.Gold), 16, 'right')
      this.drawText_FullFrame(this.MainSurface, str, 16, 6)
      str = getDefaultMessage('MARKS', 1)
      if (str != 'none') {
        str = this.strFitLength(str, 7)
        str += this.strFitLength(this.numberFormat(pc.Marks), 16, 'right')
        this.drawText_FullFrame(this.MainSurface, str, 16, 7)
      }
      str = this.strFitLength(getDefaultMessage('AGE', 1), 6, 'right') + ':'
      if (pc.Age < 1000) {
        str += this.strFitLength(pc.Age, 3, 'right')
      } else {
        str += String(pc.Age)
      }
      this.drawText_FullFrame(this.MainSurface, str, 41, 4)
      str =
        this.strFitLength(
          this.strCut(getDefaultMessage('AC', 1), 4),
          6,
          'right'
        ) + ':'
      let ac1Str = this.strFitLength(pc.Ac1, 3, 'right')
      str += ac1Str
      this.drawText_FullFrame(this.MainSurface, str, 41, 5)
      let acStr = this.strFitLength(pc.Ac, 3, 'right')
      if (ac1Str != acStr) {
        this.drawText_FullFrame(this.MainSurface, '(', 51, 5)
        this.drawText_FullFrame(this.MainSurface, acStr, 52, 5, 'orange')
        this.drawText_FullFrame(this.MainSurface, ')', 55, 5)
      }
      str = getDefaultMessage('RIP', 1)
      if (str != 'none') {
        str = this.strFitLength(str, 6, 'right') + ':'
        str += this.strFitLength(pc.Rip, 3, 'right')
        this.drawText_FullFrame(this.MainSurface, str, 41, 6)
      }
      if (pc.SealSpell) {
        color = 'gray'
      } else {
        color = 'white'
      }
      for (let i = 0; i < GameData['SPELL_KIND']; i++) {
        str =
          this.strFitLength(GameData['SPELL_KIND_NAME'][i], 4, 'right') + ':'
        this.drawText_FullFrame(this.MainSurface, str, 17, 8 + i)
        str = this.strFitLength(pc.Mp[i][0], 2, 'right')
        this.drawText_FullFrame(this.MainSurface, str, 22, 8 + i, color)
        for (let j = 1; j < GameData['SPELL_LVMAX']; j++) {
          this.drawText_FullFrame(
            this.MainSurface,
            '/',
            24 + (j - 1) * 3,
            8 + i
          )
          str = this.strFitLength(pc.Mp[i][j], 2, 'right')
          this.drawText_FullFrame(
            this.MainSurface,
            str,
            25 + (j - 1) * 3,
            8 + i,
            color
          )
        }
      }
      let itemMaxNum = pc.ItemMaxNum
      if (itemMaxNum > 12) {
        itemMaxNum = 12
      }
      if (pc.haveItemNum(-1) > 12) {
        color = 'gray'
      } else {
        color = 'white'
      }
      for (let i = 0; i < itemMaxNum; i++) {
        if (pc.Item[i] < 0) {
          break
        }
        str = pc.getItemName(i, 'equip')
        this.drawText_FullFrame(this.MainSurface, str, 22, 12 + i, color)
      }
      if (GameData['FACE_GRAPHIC_STATUS']) {
        let srcStr
        if (!pc.FaceGraphic.match(/^(| |none)$/)) {
          srcStr = '<>' + pc.FaceGraphic
        } else {
          srcStr = 'graphic/face/' + pc.Name[0]
        }
        if (GraphicData[srcStr] != undefined && GraphicData[srcStr] != null) {
          let x = this.MAIN_TEXT_X + this.FONT_SIZE
          let y = this.MAIN_Y + this.FONT_SIZE / 1.4 + this.LINE_HEIGHT * 14
          let size = this.FONT_SIZE * 10
          this.paintGraphic(
            this.MainSurface,
            GraphicData[srcStr],
            x,
            y,
            size,
            size
          )
          this.drawFrame(
            this.MainSurface,
            x,
            y,
            size,
            size,
            this.FRAME_ARC,
            this.FRAME_WIDTH / 2,
            'white'
          )
        }
      }
    } else if (mode == 'ability') {
      str = '[' + getDefaultMessage('DAMAGE', 1, 14) + ']'
      this.drawText_FullFrame(this.MainSurface, str, 0, 4)
      let strAry = pc.Dmg.split(',')
      let num1 = Math.floor(
        strCalculation(replaceFormula(strAry[0], [['pc', pcNum]], true))
      )
      let num2 = Math.floor(
        strCalculation(replaceFormula(strAry[1], [['pc', pcNum]], true))
      )
      let num3 = Math.floor(
        strCalculation(replaceFormula(strAry[2], [['pc', pcNum]], true))
      )
      str = String(num1) + 'D' + String(num2)
      if (num3 > 0) {
        str += '+' + String(num3)
      } else if (num3 < 0) {
        str += String(num3)
      }
      if (str.length > 14) {
        if (num1 > 9999) {
          num1 = 9999
        }
        if (num2 > 9999) {
          num2 = 9999
        }
        if (num3 > 9999) {
          num3 = 9999
        } else if (num3 < -9999) {
          num3 = -9999
        }
        str = String(num1) + 'D' + String(num2)
        if (num3 > 0) {
          str += '+' + String(num3)
        } else if (num3 < 0) {
          str += String(num3)
        }
      }
      let num = pc.DmgPlus
      if (num != 0) {
        str += '('
        if (num > 0) {
          str += '+'
        }
        str += String(num) + ')'
      }
      this.drawText_FullFrame(this.MainSurface, str, 1, 5)
      num1 = pc.Range[0]
      num2 = pc.Range[1]
      str = ''
      if (num1 == 4 && num2 == 0) {
        str = 'RANGE_NORMAL'
      } else if (num1 == 2 && num2 == 0) {
        str = 'RANGE_SHORT'
      } else if (num1 == 4 && num2 == 2) {
        str = 'RANGE_MIDDLE'
      } else if (num1 == 4 && num2 == 4) {
        str = 'RANGE_LONG'
      } else if (num1 == 0 && num2 == 2) {
        str = 'RANGE_SHORT_INDIRECT'
      } else if (num1 == 0 && num2 == 4) {
        str = 'RANGE_LONG_INDIRECT'
      } else if (num1 == 2 && num2 == 2) {
        str = 'RANGE_SHORT_SHORT'
      } else if (num1 == 2 && num2 == 4) {
        str = 'RANGE_SHORT_LONG'
      }
      if (str != '') {
        str = getDefaultMessage(str, 1, 20)
        this.drawText_FullFrame(this.MainSurface, str, 1, 6)
      }
      str = getDefaultMessage('HIT_MODIFY', 1, 14) + ':'
      str += String(pc.Hit) + '\n'
      str += getDefaultMessage('AT_NUM', 1, 14) + ':'
      str += String(pc.At)
      this.drawText_FullFrame(this.MainSurface, str, 0, 7)
      str = '[' + getDefaultMessage('AT_ADD', 1, 14) + ']'
      this.drawText_FullFrame(this.MainSurface, str, 0, 10)
      let stack = []
      for (let i = 0; i < ATTACK_ADD_LENGTH; i++) {
        if (pc.AttackAdd[i]) {
          stack.push(i)
        }
      }
      if (pc.AttackPoison > 0) {
        stack.push(5)
      }
      if (stack.length > 0) {
        str = ''
        for (let i = 0; i < stack.length; i++) {
          if (i == 0) {
            str += ' '
          } else if (i == 3) {
            str += '\n '
          } else {
            str += ','
          }
          num = stack[i]
          let strTmp = ''
          if (num == 0) {
            strTmp = 'AT_ADD_ASLEEP'
          } else if (num == 1) {
            strTmp = 'AT_ADD_PARALYSIS'
          } else if (num == 2) {
            strTmp = 'AT_ADD_STONE'
          } else if (num == 3) {
            strTmp = 'AT_ADD_KNOCK_OUT'
          } else if (num == 4) {
            strTmp = 'AT_ADD_CRITICAL'
          } else if (num == 5) {
            strTmp = 'AT_ADD_POISON'
          }
          str += getDefaultMessage(strTmp, 1, 6)
        }
      } else {
        str = ' ' + getDefaultMessage('NONE', 1, 14)
      }
      this.drawText_FullFrame(this.MainSurface, str, 0, 11)
      str = getDefaultMessage('SPELL_CANCEL', 1, 14) + ':'
      str += String(pc.SpellCancel) + '%'
      this.drawText_FullFrame(this.MainSurface, str, 0, 14)
      str = getDefaultMessage('HEALING', 1, 14) + ':'
      num = pc.Healing
      if (num > 0) {
        str += '+'
      }
      str += String(num)
      this.drawText_FullFrame(this.MainSurface, str, 0, 15)
      str = '[' + getDefaultMessage('SPELL_EFFECT', 1, 14) + ']'
      this.drawText_FullFrame(this.MainSurface, str, 0, 17)
      str = this.viewStatusSpellEffect(pc)
      if (str == '') {
        str = '\n ' + getDefaultMessage('NONE', 1, 14)
      }
      this.drawText_FullFrame(this.MainSurface, str, 0, 17)
      str = '[' + getDefaultMessage('RESIST', 1, 12) + ']'
      str = this.strFitLength(str, 14, 'right')
      this.drawText_FullFrame(this.MainSurface, str, 23, 5)
      str = ''
      for (let i = 0; i < 9; i++) {
        let strTmp = getDefaultMessage(RESIST_ATTRIBUTE_STR[i], 1, 12)
        str += '\n' + this.strFitLength(strTmp, 12, 'right') + ':'
        if (pc.Resist[i]) {
          str += '*'
        } else {
          str += '-'
        }
      }
      this.drawText_FullFrame(this.MainSurface, str, 23, 5)
      str = '[' + this.strCut(getDefaultMessage('RESIST_ATTRIBUTE'), 12) + ']'
      str = this.strFitLength(str, 14, 'right')
      this.drawText_FullFrame(this.MainSurface, str, 23, 16)
      str = ''
      for (let i = 10; i < RESIST_LENGTH; i++) {
        let strTmp = this.strCut(getDefaultMessage(RESIST_ATTRIBUTE_STR[i]), 12)
        str += '\n' + this.strFitLength(strTmp, 12, 'right') + ':'
        if (pc.Resist[i]) {
          str += '*'
        } else {
          str += '-'
        }
      }
      this.drawText_FullFrame(this.MainSurface, str, 23, 16)
      str = '[' + getDefaultMessage('ATTACK_EFFECT', 1, 12) + ']'
      str = this.strFitLength(str, 14, 'right')
      this.drawText_FullFrame(this.MainSurface, str, 39, 5)
      str = '[' + getDefaultMessage('DEFENSE_EFFECT', 1, 12) + ']'
      str = this.strFitLength(str, 17, 'right')
      this.drawText_FullFrame(this.MainSurface, str, 39, 6)
      let monsterStr = [
        'FIGHTER',
        'MAGE',
        'PRIEST',
        'THIEF',
        'SPRITE',
        'GIANT',
        'MYTH',
        'DRAGON',
        'ANIMAL',
        'BEASTMAN',
        'UNDEAD',
        'DEMON',
        'INSECT',
        'CREATURE',
        'MYSTERY'
      ]
      str = ''
      for (let i = 0; i < MONSTER_TYPE; i++) {
        let strTmp = getDefaultMessage(monsterStr[i], 1, 12)
        str += '\n' + this.strFitLength(strTmp, 12, 'right') + ':'
        if (pc.Attack[i]) {
          str += '*'
        } else {
          str += '-'
        }
        str += ' '
        if (pc.Defense[i]) {
          str += '*'
        } else {
          str += '-'
        }
      }
      this.drawText_FullFrame(this.MainSurface, str, 39, 6)
    }
  }
  viewStatusSpellEffect (cm, battle) {
    if (battle == undefined || battle == null) {
      battle = false
    }
    let str = '',
      count = 0,
      line = 0,
      num,
      turn
    let spAry = [0, 3, 4, 2, 1, 8, 6, 7, 5]
    let spStrAry = [
      'SPELL_EF_PROTECT',
      'SPELL_EF_SPELL_RESIST',
      'SPELL_EF_BREATH_RESIST',
      'SPELL_EF_SPELL_CANCEL',
      'SPELL_EF_HIT_RATE',
      'SEPLL_EF_ATTACK_COUNT',
      'SPELL_EF_ADDITIONAL_DAMAGE',
      'SPELL_EF_TEMPORARY_CHANGE_MAX_HP',
      'SPELL_EF_HEAL'
    ]
    for (let i = 0; i < spAry.length; i++) {
      num = cm.SpellEffectPlus[spAry[i]]
      if (battle) {
        num += cm.BtSpellEffectPlus[spAry[i]]
        if (cm.PartyNum > -1) {
          num += PARTY[cm.PartyNum].SpellEffectPlus[spAry[i]]
        }
        if (num > 9999) {
          num = 9999
        } else if (num < -9999) {
          num = -9999
        }
        turn = cm.BtSpellEffectTurn[spAry[i]]
      }
      if (num != 0) {
        let strTmp = this.viewStatusMessage(spStrAry[i], battle)
        if (strTmp != '') {
          count++
          if (battle) {
            str = strPlus(str, strTmp, num, turn, count, true)
            if (count >= 2) {
              count = 0
              line++
              if (line >= 15) {
                return str
              }
            }
          } else {
            str +=
              strTmp + this.viewStatusEffectTime(cm.SpellEffectRate[spAry[i]])
            if (count >= 6) {
              return str
            }
          }
        }
      }
    }
    if (battle) {
      num = cm.BtOnlySpellEffectPlus[0]
      if (num > 9999) {
        num = 9999
      }
      turn = cm.BtOnlySpellEffectTurn[0]
      if (num > 0) {
        let strTmp = this.viewStatusMessage('SPELL_EF_BREATH_BARRIER', battle)
        if (strTmp != '') {
          count++
          str = strPlus(str, strTmp, num, turn, count)
          if (count >= 2) {
            count = 0
            line++
            if (line >= 15) {
              return str
            }
          }
        }
      }
      num = cm.CD_Turn.length
      if (num > 0) {
        let strTmp = this.viewStatusMessage(
          'SPELL_EF_CONTINUING_DAMAGE',
          battle
        )
        if (strTmp != '') {
          count++
          str = strPlus(str, strTmp, num, -1, count)
          if (count >= 2) {
            count = 0
            line++
            if (line >= 15) {
              return str
            }
          }
        }
      }
    }
    for (let i = 0; i < ATTACK_ADD_LENGTH + 1; i++) {
      let ck = cm.AttackAddPlus[i]
      if (battle) {
        if (cm.Bt_attackAddPlus[i]) {
          ck = true
        }
        if (cm.PartyNum > -1) {
          if (PARTY[cm.PartyNum].AttackAddPlus[i]) {
            ck = true
          }
        }
        turn = cm.AttackAddTurn[i]
      }
      if (ck) {
        let strTmp = this.viewStatusMessage(
          'SPELL_EF_ENCHANTED_' + ATTACK_ADD_STR[i],
          battle
        )
        if (strTmp != '') {
          count++
          if (battle) {
            if (count == 1) {
              str += '\n  '
            } else {
              str += ', '
            }
            str += strTmp
            turn++
            if (turn > 999) {
              turn = 999
            }
            if (turn > 0) {
              str += ':(' + String(turn) + ')'
            }
            if (count >= 2) {
              count = 0
              line++
              if (line >= 15) {
                return str
              }
            }
          } else {
            str += strTmp + this.viewStatusEffectTime(cm.AttackAddRate[i])
            if (count >= 6) {
              return str
            }
          }
        }
      }
    }
    for (let i = 0; i < RESIST_LENGTH; i++) {
      if (i == 9) {
        continue
      }
      let ck = false
      if (cm.ResistPlus[i] > -2) {
        ck = true
      }
      if (battle) {
        if (cm.Bt_resistPlus[i] > -2) {
          ck = true
        }
        if (cm.PartyNum > -1) {
          if (PARTY[cm.PartyNum].ResistPlus[i] > -2) {
            ck = true
          }
        }
        turn = cm.ResistTurn[i]
      }
      if (ck) {
        let strTmp = ''
        if (cm.Resist[i]) {
          strTmp = this.viewStatusMessage(
            'SPELL_EF_RESIST_' + RESIST_STR[i],
            battle
          )
        } else if (cm.WeakPoint[i]) {
          strTmp = this.viewStatusMessage(
            'SPELL_EF_WEAKPOINT_' + RESIST_STR[i],
            battle
          )
        } else {
          strTmp = this.viewStatusMessage(
            'SPELL_EF_NON_RESIST_' + RESIST_STR[i],
            battle
          )
        }
        if (strTmp != '') {
          count++
          if (battle) {
            if (count == 1) {
              str += '\n  '
            } else {
              str += ', '
            }
            str += strTmp
            turn++
            if (turn > 999) {
              turn = 999
            }
            if (turn > 0) {
              str += ':(' + String(turn) + ')'
            }
            if (count >= 2) {
              count = 0
              line++
              if (line >= 15) {
                return str
              }
            }
          } else {
            str += strTmp + this.viewStatusEffectTime(cm.ResistRate[i])
            if (count >= 6) {
              return str
            }
          }
        }
      }
    }
    let abiStr = getDefaultMessage('SPELL_EF_ABILITY', 1)
    if (abiStr != '' && abiStr != 'none') {
      for (let i = 0; i < GameData['ABILITY'].length; i++) {
        if (
          GameData['ABILITY_NOT_DISPLAY'][i] &&
          GameData['MODIFYING_EFFECTS_ON_HIDDEN_ABILITY_ARE_NOT_DISPLAYED']
        ) {
          continue
        }
        num = cm.AbiPlus[i]
        if (battle) {
          num += cm.Bt_abiPlus[i]
          if (cm.PartyNum > -1) {
            num += PARTY[cm.PartyNum].AbiPlus[i]
          }
          if (num > 9999) {
            num = 9999
          } else if (num < -9999) {
            num = -9999
          }
          turn = cm.AbiTurn[i]
        }
        if (num != 0) {
          let strTmp = GameData['ABILITY'][i]
          if (this.strCount(strTmp) > 14) {
            strTmp = GameData['ABILITY_ABBR'][i]
          }
          count++
          if (battle) {
            str = strPlus(str, strTmp, num, turn, count, true)
            if (count >= 3) {
              count = 0
              line++
              if (line >= 15) {
                return str
              }
            }
          } else {
            strTmp = '\n ' + this.strFitLength(strTmp, 14)
            str += strTmp + this.viewStatusEffectTime(cm.AbiRate[i])
            if (count >= 6) {
              return str
            }
          }
        }
      }
    }
    return str
    function strPlus (str, strTmp, num, turn, count, plusSymbol) {
      if (plusSymbol == undefined || plusSymbol == null) {
        plusSymbol = false
      }
      if (count == 1) {
        str += '\n  '
      } else {
        str += ', '
      }
      str += strTmp + ':'
      if (plusSymbol && num > 0) {
        str += '+'
      }
      str += String(num)
      turn++
      if (turn > 999) {
        turn = 999
      }
      if (turn > 0) {
        str += '(' + String(turn) + ')'
      }
      return str
    }
  }
  viewStatusMessage (str, battle) {
    if (battle == undefined || battle == null) {
      battle = false
    }
    str = getDefaultMessage(str, 1, 14)
    if (str == '' || str == 'none') {
      return ''
    }
    if (!battle) {
      str = '\n ' + MP.strFitLength(str, 14)
    }
    return str
  }
  viewStatusEffectTime (num) {
    let str = ''
    if (GameData['EFFECT_TIME_IS_INDICATED']) {
      if (num == 1001 || num == -1001) {
        str = getDefaultMessage('EFFECT_TIME_ONLY_FLOOR', 1, 5)
      } else if ((num > 0 && num <= 1000) || (num < 0 && num >= -1000)) {
        if (num < 0) {
          num *= -1
        }
        str = String(num)
      }
      if (str != '') {
        str = '(' + str + ')'
        str = MP.strFitLength(str, 7, 'right')
      }
    }
    return str
  }
  zenkaku2hankaku (str) {
    return str.replace(/[---]/g, function (s) {
      return String.fromCharCode(s.charCodeAt(0) - 0xfee0)
    })
  }
}
