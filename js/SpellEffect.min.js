class SpellEffect {
  constructor () {
    this.clearSpellEffect()
  }
  activateCheck (efTarget, useSituation, useChar, targetChar) {
    if (useChar == undefined || useChar == null) {
      useChar = ''
    }
    if (targetChar == undefined || targetChar == null) {
      targetChar = ''
    }
    if (useSituation.indexOf(this.SituationAbbr) < 0) {
      return false
    }
    if (useChar.match(/^(p|pc)$/) && this.CastChar['type'] != 'pc') {
      return false
    }
    if (targetChar.match(/^(f|friend)$/)) {
      if (!((efTarget >= 1 && efTarget <= 3) || efTarget == 9)) {
        return false
      }
    } else if (targetChar.match(/^(e|enemy)$/)) {
      if (!(efTarget >= 4 && efTarget <= 8)) {
        return false
      }
    } else if (targetChar.match(/^(p|pc|pn)$/)) {
      if (targetChar == 'pn' && efTarget == 0) {
        return true
      } else if (this.CastChar['type'] == 'pc') {
        if (!((efTarget >= 1 && efTarget <= 3) || efTarget == 9)) {
          return false
        }
      } else if (this.CastChar['type'] == 'monster') {
        if (!(efTarget >= 4 && efTarget <= 8)) {
          return false
        }
      } else if (this.CastChar['type'] == 'summon') {
        if (!(efTarget >= 1 && efTarget <= 3)) {
          return false
        }
      } else {
        return false
      }
    }
    return true
  }
  calculationMyAndTarget (
    formula,
    castChar,
    targetChar,
    floorOrCeil,
    limitMin,
    limitMax
  ) {
    if (limitMin == undefined) {
      limitMin = null
    }
    if (limitMax == undefined) {
      limitMax = null
    }
    if (floorOrCeil == undefined || floorOrCeil == null) {
      floorOrCeil = ''
    }
    let ary = []
    if (castChar != undefined && castChar != null) {
      if (formula.indexOf('my.') > -1) {
        formula = formula.replace(/my\./g, castChar['type'] + '.')
      }
      ary.push([castChar['type'], castChar['num2']])
    }
    if (targetChar != undefined && targetChar != null) {
      if (formula.indexOf('target.') > -1) {
        formula = formula.replace(/target\./g, targetChar['type'] + '2.')
      }
      ary.push([targetChar['type'] + '2', targetChar['num2']])
    }
    formula = replaceFormula(formula, ary)
    let result = strCalculation(formula)
    if (floorOrCeil.match(/^(f|floor)$/)) {
      result = Math.floor(result)
    } else if (floorOrCeil.match(/^(c|ceil)$/)) {
      result = Math.ceil(result)
    }
    if (limitMin != null) {
      if (result < limitMin) {
        result = limitMin
      }
    }
    if (limitMax != null) {
      if (result > limitMax) {
        result = limitMax
      }
    }
    return result
  }
  calculationResist (formula, targetChar, minusOk) {
    if (minusOk == undefined || minusOk == null) {
      minusOk = false
    }
    let castChar = this.CastChar
    let plus = targetChar['char'].SrPlus
    formula = formula.replace(/spellPlus/g, plus)
    if (targetChar['char'].Action[0] == 4) {
      printDebugMessage(this.getName(targetChar, true) + ' parry')
      let parryStr = this.replaceMyAndTargetEffect(
        GameData['PARRY_RESIST'],
        targetChar['type']
      )
      parryStr = replaceFormula(parryStr, [
        [targetChar['type'], targetChar['num2']]
      ])
      let parryPlus = Math.floor(strCalculation(parryStr))
      formula = formula.replace(/parryPlus/g, parryPlus)
      plus += parryPlus
    }
    formula = formula.replace(/plus/g, plus)
    let prob
    if (!minusOk) {
      prob = this.calculationMyAndTarget(
        formula,
        castChar,
        targetChar,
        'f',
        0,
        100
      )
      printDebugMessage(
        this.getName(targetChar, true) + ' resist rate: ' + prob + '%'
      )
    } else {
      prob = this.calculationMyAndTarget(formula, castChar, targetChar, 'f')
      if (prob > 100) {
        prob = 100
      } else if (prob < 0 && prob > -99) {
        prob -= 100
      } else if (prob < -200) {
        prob = -200
      }
    }
    return prob
  }
  clearSpellEffect () {
    this.MessageStack = [[], []]
    this.Effect = ''
    this.controlResultChar('clear')
    this.controlNotSpellCancel('clear')
  }
  checkPointTeleport (floor, x, y) {
    let pt = PARTY[PlayData['ActiveParty']]
    if (floor == pt.Floor && x == pt.X && y == pt.Y) {
      return false
    }
    if (
      floor > -1 &&
      floor < DUNGEON.FloorMinMax[pt.DungeonNumber].length &&
      x > -1 &&
      x < DUNGEON.Width[pt.DungeonNumber] &&
      y > -1 &&
      y < DUNGEON.Height[pt.DungeonNumber]
    ) {
      if (DUNGEON.NotWarp[pt.DungeonNumber][floor]) {
        return false
      }
      let space = DUNGEON.Space[pt.DungeonNumber][floor][x][y]
      if (DUNGEON.checkSpaceNotTeleport(space, 'b')) {
        return false
      }
      let ary = this.Effect.split(',')
      if (
        ary[3] == '0' &&
        !PlayData['MapFlag'][pt.DungeonNumber][floor][x][y]
      ) {
        return false
      }
    }
    return true
  }
  checkResultChar () {
    for (let i = 0; i < 6; i++) {
      if (this.ResultChar['pc' + String(i)].length > 0) {
        return i
      }
    }
    for (let i = 0; i < 2; i++) {
      for (let j = 0; j < 9; j++) {
        if (this.ResultChar['summon' + String(i) + String(j)].length > 0) {
          return i * 10 + 70 + j
        }
      }
    }
    for (let i = 0; i < 4; i++) {
      for (let j = 0; j < 9; j++) {
        if (this.ResultChar['monster' + String(i) + String(j)].length > 0) {
          return i * 10 + 20 + j
        }
      }
    }
    return -1
  }
  checkSpellCancel (targetChar) {
    if (this.SituationAbbr != 'b' || this.SpellDataNotCancel) {
      return false
    }
    let castChar = this.CastChar
    if (castChar['type'].match(/^(pc|summon)$/)) {
      if (targetChar['type'] != 'monster') {
        return false
      }
    } else {
      if (!targetChar['type'].match(/^(pc|summon)$/)) {
        return false
      }
    }
    let notSpellCancel = this.controlNotSpellCancel('get', targetChar)
    if (notSpellCancel == 1) {
      return false
    } else if (notSpellCancel == 2) {
      return true
    }
    let prob = this.calculationMyAndTarget(
      GameData['SPELL_CANCEL_PROB'],
      castChar,
      targetChar,
      'f',
      0,
      100
    )
    printDebugMessage(
      this.getName(targetChar, true) +
        ' spell cancel rate: ' +
        String(prob) +
        '%'
    )
    if (prob >= dice(1, 100)) {
      this.controlNotSpellCancel('set', targetChar, 2)
      this.controlResultChar('push', targetChar, 'cancel')
      return true
    } else {
      this.controlNotSpellCancel('set', targetChar, 1)
      return false
    }
  }
  checkSpStack (mode, itemNum) {
    for (let i = 0; i < TempVariable['stack'].length; i++) {
      let num = TempVariable['stack'][i]
      if (mode == 'remove') {
        if (num == itemNum) {
          TempVariable['stack'].splice(i, 1)
          i--
        } else if (num > itemNum) {
          num--
          TempVariable['stack'][i] = num
        }
      } else if (mode == 'change') {
        if (num == itemNum) {
          TempVariable['stack'].splice(i, 1)
          break
        }
      }
    }
  }
  controlHaveItem (mode, charData, num1, num2) {
    let useItem = false,
      battleItem = false
    if (this.Situation.match(/(Item|Sp)$/) && charData != null) {
      if (charData['char'].PC_NUM == this.CastChar['char'].PC_NUM) {
        useItem = true
      }
    }
    if (this.Situation.indexOf('battle') > -1 && charData != null) {
      if (charData['char'].Action[0] == 5) {
        battleItem = true
      }
    }
    if (mode == 'remove') {
      if (num2 == 1) {
        dumpItem(PlayData['ActiveParty'], charData['char'].Item[num1])
      }
      charData['char'].removeHaveItem(num1)
      if (useItem) {
        if (!this.UseItemBreak) {
          if (this.UseHaveNum == num1) {
            this.UseItemBreak = true
          }
        }
        let num = charData['char'].haveItemNum(-1)
        if (num == 0) {
          this.UseHaveNum = -1
        } else if (!this.UseItemBreak) {
          if (num1 < this.UseHaveNum) {
            this.UseHaveNum--
          }
        } else {
          if (this.UseHaveNum >= num) {
            this.UseHaveNum = num - 1
          }
        }
        if (this.Situation.match(/Sp$/)) {
          this.checkSpStack('remove', num1)
        }
      } else if (battleItem) {
        if (charData['char'].Action[1] == num1) {
          charData['char'].Action[0] = -1
        } else if (num1 < charData['char'].Action[1]) {
          charData['char'].Action[1]--
        }
      }
    } else if (mode == 'change') {
      if (useItem) {
        if (!this.UseItemBreak) {
          if (this.UseHaveNum == num1) {
            this.UseItemBreak = true
          }
        }
        if (this.Situation.match(/Sp$/)) {
          this.checkSpStack('change', num1)
        }
      } else if (battleItem) {
        if (charData['char'].Action[1] == num1) {
          charData['char'].Action[0] = -1
        }
      }
      if (num2 == undefined || num2 == null) {
        num2 = 0
      }
      if (num2 >= ITEM.length) {
        num2 = 0
      }
      charData['char'].Item[num1] = num2
      let decided = 0
      if (ITEM[num2].DECIDED == 0) {
        if (GameData['ITEM_DECIDED']) {
          decided = 1
        }
      } else if (ITEM[num2].DECIDED == 1) {
        decided = 1
      }
      if (decided == 1) {
        PlayData['ItemFlag'][num2] = true
      }
      charData['char'].ItemDecided[num1] = decided
      charData['char'].Equip[num1] = 0
    } else if (mode == 'put') {
      if (num1 == undefined || num1 == null) {
        num1 = 0
      }
      if (num1 >= ITEM.length) {
        num1 = 0
      }
      let decided = 0
      if (ITEM[num1].DECIDED == 0) {
        if (GameData['ITEM_DECIDED']) {
          decided = 1
        }
      } else if (ITEM[num1].DECIDED == 1) {
        decided = 1
      }
      let result = charData['char'].putItem(num1, decided)
      if (result > -1) {
        if (decided == 1) {
          PlayData['ItemFlag'][num1] = true
        }
        if (useItem) {
          if (this.UseHaveNum < 0) {
            let num = charData['char'].haveItemNum(-1)
            if (num > 0) {
              this.UseHaveNum = 0
            }
          }
        }
      }
      return result
    } else if (mode == 'partyPut') {
      let ptNum = PlayData['ActiveParty']
      let pt = PARTY[ptNum]
      let memberNum = pt.getMemberNum()
      let result = -1
      if (GameData['ITEM_IS_GOT_IN_TURN']) {
        for (let i = 0; i < memberNum; i++) {
          let pcData = this.setCharData(i)
          if (this.controlHaveItem('put', pcData, num1) > -1) {
            result = i
            break
          }
        }
      } else {
        let stack = []
        for (let i = 0; i < memberNum; i++) {
          let pc = PC[pt.PartyMember[i]]
          if (pt.getItemSpaceNum() > 0) {
            stack.push(i)
          }
        }
        if (stack.length > 0) {
          result = stack[dice(1, stack.length) - 1]
          let pcData = this.setCharData(result)
          this.controlHaveItem('put', pcData, num1)
        }
      }
      return result
    }
  }
  controlNotSpellCancel (mode, targetChar, value) {
    if (mode == 'clear') {
      this.NotSpellCancel = {}
      for (let i = 0; i < 6; i++) {
        this.NotSpellCancel['pc' + String(i)] = 0
      }
      for (let i = 0; i < 2; i++) {
        for (let j = 0; j < 9; j++) {
          this.NotSpellCancel['summon' + String(i) + String(j)] = 0
        }
      }
      for (let i = 0; i < 4; i++) {
        for (let j = 0; j < 9; j++) {
          this.NotSpellCancel['monster' + String(i) + String(j)] = 0
        }
      }
    } else if (mode.match(/^(set|get)$/)) {
      let arySub = targetChar['type']
      if (targetChar['type'] == 'pc') {
        arySub += String(targetChar['numInGroup'][0])
      } else {
        arySub +=
          String(targetChar['numInGroup'][0]) +
          String(targetChar['numInGroup'][1])
      }
      if (mode == 'set') {
        if (value == undefined || value == null) {
          value = 0
        }
        this.NotSpellCancel[arySub] = value
      } else {
        return this.NotSpellCancel[arySub]
      }
    }
  }
  controlResultChar (mode, targetChar, str) {
    if (mode == 'clear') {
      this.ResultChar = {}
      for (let i = 0; i < 6; i++) {
        this.ResultChar['pc' + String(i)] = []
      }
      for (let i = 0; i < 2; i++) {
        for (let j = 0; j < 9; j++) {
          this.ResultChar['summon' + String(i) + String(j)] = []
        }
      }
      for (let i = 0; i < 4; i++) {
        for (let j = 0; j < 9; j++) {
          this.ResultChar['monster' + String(i) + String(j)] = []
        }
      }
    } else if (mode == 'push') {
      let arySub = targetChar['type']
      if (targetChar['type'] == 'pc') {
        arySub += String(targetChar['numInGroup'][0])
      } else {
        arySub +=
          String(targetChar['numInGroup'][0]) +
          String(targetChar['numInGroup'][1])
      }
      this.ResultChar[arySub].push(str)
    }
  }
  dealingWithDeath (targetChar, deathText) {
    if (deathText == undefined || deathText == null) {
      deathText = ''
    }
    let castChar = this.CastChar
    let stateStr
    if (targetChar['char'].State == 5) {
      stateStr = 'ashed'
    } else if (targetChar['char'].State == 6) {
      stateStr = 'lost'
    } else {
      stateStr = 'dead'
    }
    if (deathText != '') {
      stateStr += ',' + deathText
    }
    this.controlResultChar('push', targetChar, stateStr)
    if (targetChar['type'] == 'monster') {
      TempVariable['monsterKill'] = true
      TempVariable['monsterNum'][targetChar['numInGroup'][0]]--
      if (TempVariable['monsterNum'][targetChar['numInGroup'][0]] < 1) {
        hateCheck(200 + targetChar['numInGroup'][0])
      }
    } else if (targetChar['type'] == 'summon') {
      TempVariable['summonNum'][targetChar['numInGroup'][0]]--
      if (TempVariable['summonNum'][targetChar['numInGroup'][0]] < 1) {
        hateCheck(210 + targetChar['numInGroup'][0])
      }
    }
    if (castChar['type'] == 'pc') {
      if (castChar['char'].PC_NUM != targetChar['char'].PC_NUM) {
        castChar['char'].Marks++
      }
    }
    if (
      castChar['type'].match(/^(pc|summon)$/) &&
      targetChar['type'] == 'monster'
    ) {
      TempVariable['getExp'] += targetChar['char'].Exp
      registerInMonsterCatalog(targetChar['numInGroup'][0])
    }
  }
  getHaveNumDeleteItem (itemNum, equip) {
    let ptNum = PlayData['ActiveParty']
    let pt = PARTY[ptNum]
    let memberNum = pt.getMemberNum()
    let usePc = false
    if (!this.NoCastChar && this.CastChar['type'] == 'pc') {
      usePc = true
    }
    let useItem = false
    if (this.Situation.match(/(Item|Sp)$/)) {
      useItem = true
    }
    let result = [-1, -1]
    if (usePc) {
      let useHaveNum = -1
      if (useItem && !this.UseItemBreak) {
        useHaveNum = this.UseHaveNum
      }
      let num = this.CastChar['char'].haveItem(itemNum, equip, useHaveNum)
      if (num > -1) {
        result = [this.CastChar['numInGroup'][0], num]
      } else {
        for (let i = 0; i < memberNum; i++) {
          let pc = PC[pt.PartyMember[i]]
          if (pc.PC_NUM == this.CastChar['char'].PC_NUM) {
            continue
          }
          num = pc.haveItem(itemNum, equip)
          if (num > -1) {
            result = [i, num]
            break
          }
        }
      }
    } else {
      for (let i = 0; i < memberNum; i++) {
        let pc = PC[pt.PartyMember[i]]
        let num = pc.haveItem(itemNum, equip)
        if (num > -1) {
          result = [i, num]
          break
        }
      }
    }
    return result
  }
  getHaveNumSyntheticItem (itemNum, equip, excludeNum) {
    if (excludeNum == undefined || excludeNum == null) {
      excludeNum = [-1, -1]
    }
    let ptNum = PlayData['ActiveParty']
    let pt = PARTY[ptNum]
    let memberNum = pt.getMemberNum()
    let usePc = false
    if (!this.NoCastChar && this.CastChar['type'] == 'pc') {
      usePc = true
    }
    let useItem = false
    if (this.Situation.match(/(Item|Sp)$/)) {
      useItem = true
    }
    let result = [-1, -1]
    if (usePc) {
      let num = -1
      if (useItem && !this.UseItemBreak) {
        if (
          itemNum == this.CastChar['char'].Item[this.UseHaveNum] &&
          (this.CastChar['numInGroup'][0] != excludeNum[0] ||
            this.UseHaveNum != excludeNum[1])
        ) {
          num = this.UseHaveNum
        }
      }
      if (num < 0) {
        let useHaveNum = -1
        if (this.CastChar['numInGroup'][0] == excludeNum[0]) {
          useHaveNum = excludeNum[1]
        }
        num = this.CastChar['char'].haveItem(itemNum, equip, useHaveNum)
      }
      if (num > -1) {
        result = [this.CastChar['numInGroup'][0], num]
      } else {
        for (let i = 0; i < memberNum; i++) {
          let pc = PC[pt.PartyMember[i]]
          if (pc.PC_NUM == this.CastChar['char'].PC_NUM) {
            continue
          }
          let useHaveNum = -1
          if (i == excludeNum[0]) {
            useHaveNum = excludeNum[1]
          }
          num = pc.haveItem(itemNum, equip, useHaveNum)
          if (num > -1) {
            result = [i, num]
            break
          }
        }
      }
    } else {
      for (let i = 0; i < memberNum; i++) {
        let pc = PC[pt.PartyMember[i]]
        let useHaveNum = -1
        if (i == excludeNum[0]) {
          useHaveNum = excludeNum[1]
        }
        num = pc.haveItem(itemNum, equip, useHaveNum)
        if (num > -1) {
          result = [i, num]
          break
        }
      }
    }
    return result
  }
  getPointRandomTeleport (ptNum, onlyFloor, allArea, trap) {
    if (onlyFloor == '1') {
      onlyFloor = true
    } else if (onlyFloor == '0') {
      onlyFloor = false
    }
    if (allArea == '1') {
      allArea = true
    } else if (allArea == '0') {
      allArea = false
    }
    trap = checkNull(trap, false)
    let pt = PARTY[ptNum]
    let start, end
    if (onlyFloor) {
      start = pt.Floor
      end = start + 1
    } else {
      start = 0
      end = DUNGEON.FloorMinMax[pt.DungeonNumber].length
    }
    let stack = []
    let width = DUNGEON.Width[pt.DungeonNumber]
    let height = DUNGEON.Height[pt.DungeonNumber]
    for (let i = start; i < end; i++) {
      if (!trap && DUNGEON.NotWarp[pt.DungeonNumber][i]) {
        continue
      }
      for (let j = 0; j < width; j++) {
        for (let k = 0; k < height; k++) {
          let space = DUNGEON.Space[pt.DungeonNumber][i][j][k]
          if (!DUNGEON.checkSpaceNotTeleport(space, 'b')) {
            if (allArea || PlayData['MapFlag'][pt.DungeonNumber][i][j][k]) {
              if (i != pt.Floor || j != pt.X || k != pt.Y) {
                stack.push(i * 10000 + j * 100 + k)
              }
            }
          }
        }
      }
    }
    let resultAry = []
    if (stack.length > 0) {
      let num = stack[dice(1, stack.length) - 1]
      resultAry.push(Math.floor(num / 10000))
      num %= 10000
      resultAry.push(Math.floor(num / 100))
      num %= 100
      resultAry.push(num)
    } else {
      resultAry.push(pt.Floor)
      resultAry.push(pt.X)
      resultAry.push(pt.Y)
    }
    return resultAry
  }
  getSelectSpellEffect (selectNum, spellEffectLenth) {
    if (selectNum > 10) {
      selectNum = 10
    }
    if (spellEffectLenth > 10) {
      spellEffectLenth = 10
    }
    if (selectNum > spellEffectLenth) {
      selectNum = spellEffectLenth
    }
    let resultAry = []
    let stack = []
    for (let i = 0; i < spellEffectLenth; i++) {
      stack.push(i)
    }
    if (selectNum == spellEffectLenth) {
      resultAry = stack.slice()
    } else {
      for (let i = 0; i < selectNum; i++) {
        resultAry.push(Number(stack.splice(dice(1, stack.length) - 1, 1)))
      }
    }
    return resultAry
  }
  getBattleSpellResult (arySub, targetChar) {
    let resultStr = this.ResultChar[arySub].shift()
    let resultAry = resultStr.split(',')
    let castChar = this.CastChar
    let text = ''
    if (resultAry[0] == 'fullHeal') {
      sePlay('heal')
      text = getDefaultMessage('CAST_HEALED_COMPLETE')
    } else if (resultAry[0] == 'heal') {
      sePlay('heal')
      if (resultAry[1] == '1') {
        text = getDefaultMessage('CAST_HEALED_1')
      } else {
        text = getDefaultMessage('CAST_HEALED')
      }
      text = text.replace(/\[value\]/g, resultAry[1])
    } else if (resultAry[0] == 'healMp') {
      text = getDefaultMessage('CAST_MP_HEALED')
    } else if (resultAry[0] == 'cure') {
      text = getDefaultMessage('CAST_CURED')
    } else if (resultAry[0] == 'revive') {
      text = getDefaultMessage('CAST_REVIVED')
    } else if (resultAry[0] == 'cancel') {
      text = getDefaultMessage('CAST_CANCEL')
    } else if (resultAry[0] == 'asleep') {
      text = getDefaultMessage('BE_ASLEEP')
    } else if (resultAry[0] == 'sleep') {
      text = getDefaultMessage('BE_SLEPT')
    } else if (resultAry[0] == 'notSleep') {
      text = getDefaultMessage('BE_SLEPT_NOT')
    } else if (resultAry[0] == 'paralyze') {
      text = getDefaultMessage('BE_PARALYZED')
    } else if (resultAry[0] == 'stone') {
      text = getDefaultMessage('BE_STONED')
    } else if (resultAry[0] == 'faint') {
      text = getDefaultMessage('CAST_FAINTED')
    } else if (resultAry[0] == 'silence') {
      text = getDefaultMessage('CAST_SILENCE')
    } else if (resultAry[0] == 'notSilence') {
      text = getDefaultMessage('CAST_SILENCE_NOT')
    } else if (resultAry[0] == 'restrained') {
      text = getDefaultMessage('CAST_RESTRAINED')
    } else if (resultAry[0] == 'poison') {
      text = getDefaultMessage('BE_POISONED')
    } else if (resultAry[0] == 'resist') {
      text = getDefaultMessage('CAST_RESIST')
    } else if (resultAry[0] == 'hated') {
      text = getDefaultMessage('CAST_HATED')
    } else if (resultAry[0] == 'none') {
      text = getDefaultMessage('CAST_NO_WORK')
    } else if (
      resultAry[0] == 'dead' ||
      resultAry[0] == 'ashed' ||
      resultAry[0] == 'lost'
    ) {
      let messageFlag = true
      if (resultAry.length > 1) {
        resultAry[1] = resultAry[1].replace(/<\.>/g, ',')
        resultAry[1] = resultAry[1].replace(/^[ ã€€]+$/, '')
        if (resultAry[1] != '') {
          text = resultAry[1]
          messageFlag = false
        }
      }
      if (messageFlag) {
        let str
        if (resultAry[0] == 'ashed') {
          str = 'KILLED_ASHED'
        } else if (resultAry[0] == 'lost') {
          str = 'KILLED_LOST'
        } else {
          str = 'KILLED'
        }
        text = getDefaultMessage(str)
      }
    } else if (resultAry[0] == 'breathCancel') {
      text = getDefaultMessage('BREATH_CANCEL')
    } else if (resultAry[0] == 'mpDamage') {
      text = getDefaultMessage('MP_DAMAGE')
    } else if (resultAry[0] == 'run') {
      text = getDefaultMessage('EXPEL')
    } else if (resultAry[0] == 'summon') {
      if (resultAry.length > 2) {
        let mDataNum = Number(resultAry[1])
        let num = Number(resultAry[2])
        if (num == 1) {
          text = getDefaultMessage('SUMMON_1')
        } else {
          text = getDefaultMessage('SUMMON')
        }
        text = text.replace(/\[monster\]/g, MONSTER_DATA[mDataNum].NAME[1])
        text = text.replace(/\[monsters\]/g, MONSTER_DATA[mDataNum].NAMES[1])
        text = text.replace(/\[value\]/g, String(num))
      }
    } else if (resultAry[0] == 'damage') {
      sePlay('hit')
      text = getDefaultMessage('TAKE_DAMAGE')
      text = text.replace(/\[damage\]/g, resultAry[1])
      if (this.ResultChar[arySub].length > 0) {
        let str = this.ResultChar[arySub][0]
        if (str == 'dead' || str == 'ashed' || str == 'lost') {
          this.ResultChar[arySub].shift()
          if (str == 'ashed') {
            str = 'KILLED_ASHED'
          } else if (str == 'lost') {
            str = 'KILLED_LOST'
          } else {
            str = 'KILLED'
          }
          text += '\n' + getDefaultMessage(str)
        }
      }
    } else if (
      resultAry[0] == 'sealSpell' &&
      !GameData['MODIFIED_MESSAGE_NOT_DISPLAYED']
    ) {
      text = getDefaultMessage('CAST_SEAL_SPELL')
    } else if (
      resultAry[0] == 'resistPlus' &&
      !GameData['MODIFIED_MESSAGE_NOT_DISPLAYED']
    ) {
      if (resultAry.length > 2) {
        let num = Number(resultAry[1])
        let value = Number(resultAry[2])
        if (value > 0) {
          text = getDefaultMessage('RESIST_PLUS')
        } else {
          text = getDefaultMessage('RESIST_MINUS')
        }
        let str
        if (num == 0) {
          str = 'SILENCE'
        } else if (num == 1) {
          str = 'ASLEEP'
        } else if (num == 2) {
          str = 'POISON'
        } else if (num == 3) {
          str = 'PARALYSIS'
        } else if (num == 4) {
          str = 'STONE'
        } else if (num == 5) {
          str = 'DRAIN'
        } else if (num == 6) {
          str = 'KNOCK_OUT'
        } else if (num == 7) {
          str = 'CRITICAL'
        } else if (num == 8) {
          str = 'DEATH_SPELL'
        } else if (num == 10) {
          str = 'BLAZE_ATTRIBUTE'
        } else if (num == 11) {
          str = 'COLD_ATTRIBUTE'
        } else if (num == 12) {
          str = 'ELECTRIC_ATTRIBUTE'
        } else if (num == 13) {
          str = 'HOLY_ATTRIBUTE'
        } else {
          str = 'NONE_ATTRIBUTE'
        }
        str = getDefaultMessage(str)
        text = text.replace(/\[resist\]/g, str)
      }
    } else if (
      resultAry[0] == 'attackAddPlus' &&
      !GameData['MODIFIED_MESSAGE_NOT_DISPLAYED']
    ) {
      if (resultAry.length > 1) {
        let num = Number(resultAry[1])
        text = getDefaultMessage('ENCHANTED_WEAPONS')
        let str
        if (num == 0) {
          str = 'ASLEEP'
        } else if (num == 1) {
          str = 'PARALYSIS'
        } else if (num == 2) {
          str = 'STONE'
        } else if (num == 3) {
          str = 'KNOCK_OUT'
        } else if (num == 4) {
          str = 'CRITICAL'
        } else {
          str = 'POISON'
        }
        str = getDefaultMessage(str)
        text = text.replace(/\[enchanted\]/g, str)
      }
    } else if (
      resultAry[0].match(
        /^(ac|hit|spellCancel|spellResist|breathResist|breathBarrier|addDamage|hpMax|atCount)Plus$/
      ) &&
      !GameData['MODIFIED_MESSAGE_NOT_DISPLAYED']
    ) {
      if (resultAry.length > 1) {
        let value = Number(resultAry[1])
        if (value != 0) {
          let str = 'CAST_'
          if (resultAry[0] == 'acPlus') {
            str += 'AC'
          } else if (resultAry[0] == 'hitPlus') {
            str += 'HIT'
          } else if (resultAry[0] == 'spellCancelPlus') {
            str += 'SPELL_CANCEL'
          } else if (resultAry[0] == 'spellResistPlus') {
            str += 'SPELL_RESIST'
          } else if (resultAry[0] == 'breathResistPlus') {
            str += 'BREATH_RESIST'
          } else if (resultAry[0] == 'breathBarrierPlus') {
            str += 'BREATH_BARRIER'
          } else if (resultAry[0] == 'addDamagePlus') {
            str += 'ADD_DAMAGE'
          } else if (resultAry[0] == 'hpMaxPlus') {
            str += 'HP_MAX'
          } else if (resultAry[0] == 'atCountPlus') {
            str += 'ATTACK_COUNT'
          }
          if (value > 0) {
            str += '_PLUS'
          } else {
            str += '_MINUS'
            value *= -1
          }
          text = getDefaultMessage(str)
          text = text.replace(/\[value\]/g, String(value))
        }
      }
    } else if (
      resultAry[0] == 'abilityPlus' &&
      !GameData['MODIFIED_MESSAGE_NOT_DISPLAYED']
    ) {
      if (resultAry.length > 2) {
        let num = Number(resultAry[1])
        let value = Number(resultAry[2])
        if (value != 0) {
          if (value > 0) {
            text = getDefaultMessage('CAST_ABILITY_PLUS')
          } else {
            text = getDefaultMessage('CAST_ABILITY_MINUS')
            value *= -1
          }
          text = text.replace(/\[ability\]/g, GameData['ABILITY'][num])
          text = text.replace(/\[value\]/g, String(value))
        }
      }
    } else if (resultAry[0] == 'drain') {
      let num = Number(resultAry[1])
      if (num == 1) {
        text = getDefaultMessage('BE_DRAINED_1')
      } else {
        text = getDefaultMessage('BE_DRAINED')
      }
      text = text.replace(/\[value\]/g, String(num))
    }
    text = text.replace(/\[target\]/g, this.getName(targetChar))
    text = text.replace(/\[name\]/g, this.getName(castChar))
    return text
  }
  getName (targetChar, debug) {
    return getNameBattle(
      targetChar['char'],
      targetChar['type'],
      targetChar['numInGroup'],
      debug
    )
  }
  getTarget (efTarget, targetCharNum, deadOk, condition) {
    if (deadOk == undefined || deadOk == null) {
      deadOk = false
    }
    if (condition == undefined || condition == null) {
      condition = ''
    }
    let castChar = this.CastChar
    let ptNum = PlayData['ActiveParty']
    let pt = PARTY[ptNum]
    let ptMemberNum = pt.getMemberNum()
    let resultAry = []
    if (castChar['type'] == 'pc') {
      if (efTarget == 9) {
        resultAry.push(castChar['numInGroup'][0])
      } else if (efTarget == 3) {
        resultAry = resultAry.concat(getPcCharNum(-1, deadOk))
        if (this.SituationAbbr == 'b' && condition != 'pc') {
          resultAry = resultAry.concat(getSummonCharNum(-1, deadOk))
        }
      } else if (efTarget == 1 || efTarget == 2) {
        let stack = []
        if (efTarget == 1 && targetCharNum >= 0 && targetCharNum <= 5) {
          stack = getPcCharNum(targetCharNum, deadOk)
        } else {
          stack = getPcCharNum(-1, deadOk)
        }
        if (stack.length > 0) {
          resultAry.push(stack[dice(1, stack.length) - 1])
        }
      } else if (efTarget == 8) {
        if (this.SituationAbbr == 'b' && condition != 'pc') {
          resultAry = resultAry.concat(getMonsterCharNum(-1, deadOk))
        }
      } else if (efTarget == 6 || efTarget == 7) {
        if (this.SituationAbbr == 'b' && condition != 'pc') {
          let group = 0
          if (efTarget == 6 && targetCharNum >= 10 && targetCharNum <= 13) {
            group = targetCharNum % 10
          } else {
            let stack = []
            for (let i = 0; i < PlayData['MonsterList'].length; i++) {
              if (TempVariable['monsterNum'][i] > 0) {
                stack.push(i)
              }
            }
            if (stack.length > 0) {
              group = stack[dice(1, stack.length) - 1]
            }
          }
          resultAry = resultAry.concat(getMonsterCharNum(group + 10, deadOk))
        }
      } else if (efTarget == 4 || efTarget == 5) {
        if (this.SituationAbbr == 'b' && condition != 'pc') {
          let stack = []
          if (efTarget == 4 && targetCharNum >= 10 && targetCharNum <= 13) {
            stack = getMonsterCharNum(targetCharNum, deadOk, true)
          } else {
            stack = getMonsterCharNum(-1, deadOk)
          }
          if (stack.length > 0) {
            resultAry.push(stack[dice(1, stack.length) - 1])
          }
        }
      }
    } else if (castChar['type'] == 'monster') {
      if (efTarget == 9) {
        if (condition != 'pc') {
          let num =
            castChar['numInGroup'][0] * 10 + 20 + castChar['numInGroup'][1]
          resultAry.push(num)
        }
      } else if (efTarget == 3) {
        if (condition != 'pc') {
          resultAry = resultAry.concat(getMonsterCharNum(-1, deadOk))
        }
      } else if (efTarget == 1 || efTarget == 2) {
        if (condition != 'pc') {
          let stack = []
          if (efTarget == 1 && targetCharNum >= 20 && targetCharNum <= 58) {
            stack = getMonsterCharNum(targetCharNum, deadOk)
          } else if (
            efTarget == 1 &&
            targetCharNum >= 10 &&
            targetCharNum <= 13
          ) {
            stack = getMonsterCharNum(targetCharNum, deadOk)
          } else {
            stack = getMonsterCharNum(-1, deadOk)
          }
          if (stack.length > 0) {
            resultAry.push(stack[dice(1, stack.length) - 1])
          }
        }
      } else if (efTarget == 8) {
        resultAry = resultAry.concat(getPcCharNum(-1, deadOk))
        if (condition != 'pc') {
          resultAry = resultAry.concat(getSummonCharNum(-1, deadOk))
        }
      } else if (efTarget == 6 || efTarget == 7) {
        if (GameData['GROUP_SPELL_OF_MONSTER_AIMS_AT_ALL']) {
          resultAry = resultAry.concat(getPcCharNum(-1, deadOk))
          if (condition != 'pc') {
            resultAry = resultAry.concat(getSummonCharNum(-1, deadOk))
          }
        } else {
          let group = 0
          if (efTarget == 6 && targetCharNum >= 8 && targetCharNum <= 9) {
            group = targetCharNum - 8
          } else if (
            efTarget == 6 &&
            targetCharNum >= 0 &&
            targetCharNum <= 5
          ) {
            if (targetCharNum >= GameData['FRONT_RANK_NUM']) {
              group = 1
            }
          } else if (
            efTarget == 6 &&
            targetCharNum >= 60 &&
            targetCharNum <= 61
          ) {
            group = targetCharNum - 60
          } else {
            let stack = [0]
            if (
              pt.checkBackRank(deadOk) ||
              (condition != 'pc' && TempVariable['summonNum'][1] > 0)
            ) {
              stack.push(1)
            }
            group = stack[dice(1, stack.length) - 1]
          }
          resultAry = resultAry.concat(getPcCharNum(group + 8, deadOk))
          if (condition != 'pc') {
            resultAry = resultAry.concat(getSummonCharNum(group + 60, deadOk))
          }
        }
      } else if (efTarget == 4 || efTarget == 5) {
        let stack = []
        if (efTarget == 4 && targetCharNum >= 0 && targetCharNum <= 5) {
          stack = getPcCharNum(targetCharNum, deadOk)
        } else if (efTarget == 4 && targetCharNum >= 8 && targetCharNum <= 9) {
          stack = stack.concat(getPcCharNum(targetCharNum, deadOk))
          if (condition != 'pc') {
            stack = stack.concat(getSummonCharNum(targetCharNum, deadOk))
          }
        } else if (
          efTarget == 4 &&
          targetCharNum >= 60 &&
          targetCharNum <= 61
        ) {
          if (condition != 'pc') {
            stack = getSummonCharNum(targetCharNum, deadOk, true)
          }
        } else {
          stack = stack.concat(getPcCharNum(-1, deadOk))
          if (condition != 'pc') {
            stack = stack.concat(getSummonCharNum(-1, deadOk))
          }
        }
        if (stack.length > 0) {
          resultAry.push(stack[dice(1, stack.length) - 1])
        }
      }
    } else if (castChar['type'] == 'summon') {
      if (efTarget == 9) {
        if (condition != 'pc') {
          let num =
            castChar['numInGroup'][0] * 10 + 70 + castChar['numInGroup'][1]
          resultAry.push(num)
        }
      } else if (efTarget == 3) {
        resultAry = resultAry.concat(getPcCharNum(-1, deadOk))
        if (condition != 'pc') {
          resultAry = resultAry.concat(getSummonCharNum(-1, deadOk))
        }
      } else if (efTarget == 1 || efTarget == 2) {
        let stack = []
        if (efTarget == 1 && targetCharNum >= 0 && targetCharNum <= 5) {
          stack = getPcCharNum(targetCharNum, deadOk)
        } else if (
          efTarget == 1 &&
          targetCharNum >= 70 &&
          targetCharNum <= 88
        ) {
          if (condition != 'pc') {
            stack = stack.concat(getSummonCharNum(targetCharNum, deadOk))
          }
        } else if (
          efTarget == 1 &&
          targetCharNum >= 60 &&
          targetCharNum <= 61
        ) {
          if (condition != 'pc') {
            stack = getSummonCharNum(targetCharNum, deadOk, true)
          }
        } else {
          stack = stack.concat(getPcCharNum(-1, deadOk))
          if (condition != 'pc') {
            stack = stack.concat(getSummonCharNum(-1, deadOk))
          }
        }
        if (stack.length > 0) {
          resultAry.push(stack[dice(1, stack.length) - 1])
        }
      } else if (efTarget == 8) {
        if (condition != 'pc') {
          resultAry = resultAry.concat(getMonsterCharNum(-1, deadOk))
        }
      } else if (efTarget == 6 || efTarget == 7) {
        if (condition != 'pc') {
          let group = 0
          if (efTarget == 6 && targetCharNum >= 10 && targetCharNum <= 13) {
            group = targetCharNum % 10
          } else if (
            efTarget == 6 &&
            targetCharNum >= 20 &&
            targetCharNum <= 58
          ) {
            let num = Math.floor((targetCharNum - 20) / 10)
            group = num + 10
          } else {
            let stack = []
            for (let i = 0; i < PlayData['MonsterList'].length; i++) {
              if (TempVariable['monsterNum'][i] > 0) {
                stack.push(i)
              }
            }
            if (stack.length > 0) {
              group = stack[dice(1, stack.length) - 1]
            }
          }
          resultAry = resultAry.concat(getMonsterCharNum(group + 10, deadOk))
        }
      } else if (efTarget == 4 || efTarget == 5) {
        if (condition != 'pc') {
          let stack = []
          if (efTarget == 4 && targetCharNum >= 20 && targetCharNum <= 58) {
            stack = getMonsterCharNum(targetCharNum, deadOk)
          } else if (
            efTarget == 4 &&
            targetCharNum >= 10 &&
            targetCharNum <= 13
          ) {
            stack = getMonsterCharNum(targetCharNum, deadOk, true)
          } else {
            stack = getMonsterCharNum(-1, deadOk)
          }
          if (stack.length > 0) {
            resultAry.push(stack[dice(1, stack.length) - 1])
          }
        }
      }
    }
    return resultAry
    function getMonsterCharNum (charNum, deadOk, onlyTheFirstOne) {
      if (onlyTheFirstOne == undefined || onlyTheFirstOne == null) {
        onlyTheFirstOne = false
      }
      let groupStart, groupEnd, numStart
      if (charNum >= 10 && charNum <= 13) {
        ;(groupStart = charNum % 10), (groupEnd = groupStart + 1)
        numStart = 0
      } else if (charNum >= 20 && charNum <= 58) {
        ;(groupStart = Math.floor((charNum - 20) / 10)),
          (groupEnd = groupStart + 1)
        numStart = (charNum - 20) % 10
      } else {
        ;(groupStart = 0), (groupEnd = PlayData['MonsterList'].length)
        numStart = 0
      }
      let resultAry = []
      for (let i = groupStart; i < groupEnd; i++) {
        if (TempVariable['monsterNum'][i] < 1) {
          continue
        }
        let numEnd = PlayData['MonsterList'][i].length
        if (charNum >= 20 && charNum <= 58) {
          numEnd = numStart + 1
        }
        for (let j = numStart; j < numEnd; j++) {
          if (PlayData['MonsterList'][i][j] < 0) {
            continue
          }
          let mon = MONSTER[PlayData['MonsterList'][i][j]]
          if (mon.Hp > 0 || deadOk) {
            resultAry.push(i * 10 + 20 + j)
          }
        }
      }
      if (onlyTheFirstOne && resultAry.length > 1) {
        resultAry = resultAry.slice(0, 1)
      }
      return resultAry
    }
    function getPcCharNum (charNum, deadOk) {
      let ptNum = PlayData['ActiveParty']
      let pt = PARTY[ptNum]
      let ptMemberNum = pt.getMemberNum()
      let start, end
      if (charNum >= 0 && charNum <= 5) {
        start = charNum
        end = start + 1
      } else if (charNum == 8) {
        ;(start = 0), (end = GameData['FRONT_RANK_NUM'])
        if (end > ptMemberNum) {
          end = ptMemberNum
        }
      } else if (charNum == 9) {
        ;(start = GameData['FRONT_RANK_NUM']), (end = ptMemberNum)
      } else {
        start = 0
        end = ptMemberNum
      }
      let resultAry = []
      for (let i = start; i < end; i++) {
        let pc = PC[pt.PartyMember[i]]
        if (pc.State < 4 || deadOk) {
          resultAry.push(i)
        }
      }
      return resultAry
    }
    function getSummonCharNum (charNum, deadOk, onlyTheFirstOne) {
      if (onlyTheFirstOne == undefined || onlyTheFirstOne == null) {
        onlyTheFirstOne = false
      }
      let groupStart, groupEnd, numStart
      if (charNum >= 60 && charNum <= 61) {
        ;(groupStart = charNum % 10), (groupEnd = groupStart + 1)
        numStart = 0
      } else if (charNum >= 70 && charNum <= 88) {
        ;(groupStart = Math.floor((charNum - 70) / 10)),
          (groupEnd = groupStart + 1)
        numStart = (charNum - 70) % 10
      } else if (charNum >= 8 && charNum <= 9) {
        ;(groupStart = charNum - 8), (groupEnd = groupStart + 1)
        numStart = 0
      } else {
        ;(groupStart = 0), (groupEnd = PlayData['SummonList'].length)
        numStart = 0
      }
      let resultAry = []
      for (let i = groupStart; i < groupEnd; i++) {
        if (TempVariable['summonNum'][i] < 1) {
          continue
        }
        let numEnd = PlayData['SummonList'][i].length
        if (charNum >= 70 && charNum <= 88) {
          numEnd = numStart + 1
        }
        for (let j = numStart; j < numEnd; j++) {
          if (PlayData['SummonList'][i][j] < 0) {
            continue
          }
          let summon = SUMMON[PlayData['SummonList'][i][j]]
          if (summon.Hp > 0 || deadOk) {
            resultAry.push(i * 10 + 70 + j)
          }
        }
      }
      if (onlyTheFirstOne && resultAry.length > 1) {
        resultAry = resultAry.slice(0, 1)
      }
      return resultAry
    }
  }
  normalAttackDamage (castChar, targetChar, subWeapon) {
    if (
      castChar['type'] == 'pc' &&
      subWeapon &&
      castChar['char'].DmgSub == ''
    ) {
      return 0
    }
    if (
      castChar['type'] != 'pc' &&
      subWeapon &&
      !castChar['charData'].TWICE_ATTACKS
    ) {
      return 0
    }
    let formula = GameData['HIT_DECISION']
    formula = replaceMyAndTarget(formula, castChar['type'], targetChar['type'])
    if (castChar['char'].Hide) {
      formula = replaceAmbush(formula)
    }
    formula = replaceFormulaMyAndTarget(
      formula,
      castChar['type'],
      castChar['num2'],
      targetChar['type'],
      targetChar['num2']
    )
    let prob = Math.floor(strCalculation(formula))
    if (prob < 0) {
      prob = 0
    } else if (prob > 100) {
      prob = 100
    }
    let debugStr =
      getNameBattle(castChar['char'], castChar['type'], null, true) +
      ' -> ' +
      getNameBattle(targetChar['char'], targetChar['type'], null, true)
    if (castChar['type'] == 'pc') {
      if (subWeapon) {
        debugStr += ' (SubWeapon)'
      } else {
        debugStr += ' (MainWeapon)'
      }
    }
    printDebugMessage(debugStr)
    printDebugMessage(' attack rate: ' + String(prob) + '%')
    let at = castChar['char'].At
    if (castChar['type'] == 'pc' && subWeapon && cm.SubweaponHalf) {
      at = Math.ceil(at / 2)
    }
    let str
    if (castChar['type'] == 'pc') {
      if (!subWeapon) {
        str = castChar['char'].Dmg
      } else {
        str = castChar['char'].DmgSub
      }
      let strAry = str.split(',')
      formula = strAry[0]
      formula = replaceMyAndTarget(formula, 'pc', 'monster')
      if (castChar['char'].Hide) {
        formula = replaceAmbush(formula)
      }
      formula = replaceFormula(
        formula,
        [
          ['pc', castChar['num']],
          ['monster', targetChar['num2']]
        ],
        true
      )
      let num = Math.floor(strCalculation(formula))
      if (num < 0) {
        num = 0
      }
      str = String(num) + 'D'
      formula = strAry[1]
      formula = replaceMyAndTarget(formula, 'pc', 'monster')
      if (castChar['char'].Hide) {
        formula = replaceAmbush(formula)
      }
      formula = replaceFormula(
        formula,
        [
          ['pc', castChar['num']],
          ['monster', targetChar['num2']]
        ],
        true
      )
      num = Math.floor(strCalculation(formula))
      if (num < 0) {
        num = 0
      }
      str += String(num)
      formula = strAry[2]
      formula = replaceMyAndTarget(formula, 'pc', 'monster')
      if (castChar['char'].Hide) {
        formula = replaceAmbush(formula)
      }
      formula = replaceFormula(
        formula,
        [
          ['pc', castChar['num']],
          ['monster', targetChar['num2']]
        ],
        true
      )
      num = Math.floor(strCalculation(formula))
      if (num > 0) {
        str += '+' + String(num)
      } else if (num < 0) {
        str += String(num)
      }
    } else {
      str = castChar['charData'].DMG
      str = replaceMyAndTarget(str, castChar['type'], targetChar['type'])
      str = replaceFormulaMyAndTarget(
        str,
        castChar['type'],
        castChar['num2'],
        targetChar['type'],
        targetChar['num2']
      )
    }
    let dmgFix = GameData['CORRECTION_DMG']
    dmgFix = replaceMyAndTarget(dmgFix, castChar['type'], targetChar['type'])
    if (castChar['type'] == 'pc' && castChar['char'].Hide) {
      dmgFix = replaceAmbush(dmgFix)
    }
    dmgFix = replaceFormulaMyAndTarget(
      dmgFix,
      castChar['type'],
      castChar['num2'],
      targetChar['type'],
      targetChar['num2']
    )
    let dmg = 0,
      hitCount = 0
    for (let i = 0; i < at; i++) {
      if (prob >= dice(1, 100)) {
        hitCount++
        let num = Math.floor(strCalculation(str)) + castChar['char'].DmgPlus
        let dmgFixStr = dmgFix.replace(/damage/g, String(num))
        num = Math.floor(strCalculation(dmgFixStr))
        if (num < 0) {
          num = 0
        }
        dmg += num
      }
    }
    if (!targetChar['char'].possibleToAction() || castChar['char'].Hide) {
      dmg = Math.floor(calTimes(dmg, GameData['NON_MOVE_DMG']))
    }
    if (castChar['type'] == 'pc') {
      if (castChar['char'].Attack[targetChar['charData'].TYPE]) {
        formula = GameData['BATTLE_ATTACK_EFFECT']
        if (castChar['char'].Hide) {
          formula = replaceAmbush(formula)
        }
        formula = replaceFormulaMyAndTarget(
          formula,
          castChar['type'],
          castChar['num2'],
          targetChar['type'],
          targetChar['num2']
        )
        let num = Math.floor(strCalculation(formula))
        if (num < 0) {
          num = 0
        } else if (num > 1000) {
          num = 1000
        }
        num = calDiv(num, 100)
        dmg = Math.floor(calTimes(dmg, num))
      }
    }
    if (targetChar['type'] == 'pc') {
      if (targetChar['char'].Defense[castChar['charData'].TYPE]) {
        formula = GameData['BATTLE_DEFENSE_EFFECT']
        formula = replaceFormulaMyAndTarget(
          formula,
          castChar['type'],
          castChar['num2'],
          targetChar['type'],
          targetChar['num2']
        )
        let num = Math.floor(strCalculation(formula))
        if (num < 0) {
          num = 0
        } else if (num > 1000) {
          num = 1000
        }
        num = calDiv(num, 100)
        dmg = Math.ceil(calTimes(dmg, num))
      }
    }
    if (dmg < 0) {
      dmg = 0
    }
    printDebugMessage(' hit: ' + hitCount + '  damage: ' + dmg)
    return dmg
  }
  replaceMyAndTargetEffect (data, my, target) {
    if (my == undefined || my == null) {
      my = ''
    }
    if (target == undefined || target == null) {
      target = ''
    }
    if (my != '') {
      data = data.replace(/my\./g, my + '.')
    }
    if (target != '') {
      data = data.replace(/target\./g, target + '2.')
    }
    return data
  }
  replaceMyAndTargetEffectAry (dataAry, repAry, my, target) {
    if (my == undefined || my == null) {
      my = ''
    }
    if (target == undefined || target == null) {
      target = ''
    }
    for (let i = 0; i < repAry.length; i++) {
      let num = repAry[i]
      if (num < 0 || num >= dataAry.length) {
        continue
      }
      if (my != '') {
        dataAry[num] = dataAry[num].replace(/my\./g, my + '.')
      }
      if (target != '') {
        dataAry[num] = dataAry[num].replace(/target\./g, target + '2.')
      }
    }
    return dataAry
  }
  setCharData (charNum) {
    let ptNum = PlayData['ActiveParty']
    let pt = PARTY[ptNum]
    let data = {}
    ;(data['type'] = ''), (data['numInGroup'] = [-1, -1])
    ;(data['num'] = -1), (data['num2'] = -1)
    ;(data['char'] = null), (data['charData'] = null)
    if (charNum > -1 && charNum < 6) {
      data['type'] = 'pc'
      data['numInGroup'] = [charNum, -1]
      data['num'] = pt.PartyMember[data['numInGroup'][0]]
      data['num2'] = data['num']
      data['char'] = PC[data['num']]
    } else if (charNum > 19 && charNum < 59) {
      data['type'] = 'monster'
      let num = charNum - 20
      data['numInGroup'] = [Math.floor(num / 10), num % 10]
      data['num'] =
        PlayData['MonsterList'][data['numInGroup'][0]][data['numInGroup'][1]]
      data['num2'] = data['num']
      data['char'] = MONSTER[data['num']]
      data['charData'] = MONSTER_DATA[data['char'].MonsterDataNum]
    } else if (charNum > 69 && charNum < 89) {
      data['type'] = 'summon'
      let num = charNum - 70
      data['numInGroup'] = [Math.floor(num / 10), num % 10]
      data['num'] =
        PlayData['SummonList'][data['numInGroup'][0]][data['numInGroup'][1]]
      data['num2'] = data['num'] + 50
      data['char'] = SUMMON[data['num']]
      data['charData'] = MONSTER_DATA[data['char'].MonsterDataNum]
    }
    return data
  }
  spellEffect (spellData, spellSelNum, situation, castCharNum, targetCharNum) {
    this.clearSpellEffect()
    this.NoCastChar = false
    if (castCharNum == undefined || castCharNum == null) {
      castCharNum = 0
      this.NoCastChar = true
    }
    if (targetCharNum == undefined || targetCharNum == null) {
      targetCharNum = -1
    }
    this.Situation = situation
    if (situation == 'campSp') {
      this.SituationAbbr = 's'
    } else if (situation.indexOf('camp') > -1) {
      this.SituationAbbr = 'c'
    } else if (situation.indexOf('battle') > -1) {
      this.SituationAbbr = 'b'
    } else if (situation.indexOf('box') > -1) {
      this.SituationAbbr = 'o'
    } else if (situation.indexOf('trap') > -1) {
      this.SituationAbbr = 't'
    } else if (situation.indexOf('event') > -1) {
      this.SituationAbbr = 'e'
    } else {
      this.SituationAbbr = ''
    }
    let ptNum = PlayData['ActiveParty']
    let pt = PARTY[ptNum]
    let ptMemberNum = pt.getMemberNum()
    let effectAry = spellData['spellEffect'][spellSelNum]
    let effectCheck = false,
      healingCheck = false,
      success = false,
      fizzle = false
    this.SpellDataNotCancel = spellData['notCancel']
    this.Result = ''
    let castChar = this.setCharData(castCharNum)
    this.CastChar = castChar
    let castKind = -1,
      castLv = -1,
      castSpell = -1,
      useItemNum = -1
    this.UseItemBreak = false
    this.UseHaveNum = -1
    if (situation.indexOf('Spell') > -1) {
      if (situation.indexOf('camp') > -1) {
        castKind = MP.PreSelect['select'][2]
        castLv = MP.PreSelect['selectF'][2]
        castSpell = Number(
          MP.PreSelect['valueAry'][3][MP.PreSelect['select'][3]]
        )
      } else if (situation.indexOf('battle') > -1) {
        let spellAry = decomposeSpellNum(castChar['char'].Action[1])
        castKind = spellAry[0]
        castLv = spellAry[1]
        castSpell = spellAry[2]
      } else if (situation.indexOf('box') > -1) {
        castKind = MP.PreSelect['select'][2]
        castLv = MP.PreSelect['selectF'][2]
        castSpell = Number(MP.SelectMode['valueAry'][MP.SelectMode['select']])
      }
      castChar['char'].Mp[castKind][castLv] -=
        GameData['SPELL_CONSUMPTION_MP'][castKind][castLv][castSpell]
      if (castChar['char'].Mp[castKind][castLv] < 0) {
        castChar['char'].Mp[castKind][castLv] = 0
      }
    } else if (situation.match(/(Item|Sp)$/)) {
      if (situation.match(/camp|box/)) {
        this.UseHaveNum = TempVariable['haveNum']
        useItemNum = castChar['char'].Item[this.UseHaveNum]
      } else if (situation.indexOf('battle') > -1) {
        this.UseHaveNum = castChar['char'].Action[1]
        useItemNum = castChar['char'].Item[this.UseHaveNum]
      }
    }
    let levelLimit = false
    if (castChar['type'] != '') {
      if (castChar['char'].Level < spellData['levelLimit']) {
        levelLimit = true
      }
    }
    let notUseSpell = false
    if (situation.indexOf('Spell') > -1) {
      if (
        castChar['char'].SealSpell ||
        (castChar['char'].Silence != 0 &&
          !GameData['SPELL_EVEN_SILENCE'][castKind][castLv][castSpell])
      ) {
        notUseSpell = true
      }
    }
    this.FirstHp = []
    if (!levelLimit && !notUseSpell) {
      if (situation.match(/^camp(Spell|Item)$/)) {
        for (let i = 0; i < ptMemberNum; i++) {
          let pc = PC[pt.PartyMember[i]]
          this.FirstHp.push(pc.Hp)
        }
      }
    }
    for (let eNum = 0; eNum < effectAry.length; eNum++) {
      if (levelLimit || notUseSpell) {
        break
      }
      if (effectAry[eNum].match(/^(| |none|0)$/)) {
        effectAry[eNum] = '0,0'
      }
      let efAry = effectAry[eNum].split(',')
      let ef = Number(efAry[0])
      let efTarget = Number(efAry[1])
      if (ef == 1) {
        if (!this.activateCheck(efTarget, 'csbte', 'a', 'f')) {
          continue
        }
        printDebugMessage('[SpellEffect] heal')
        efAry = this.replaceMyAndTargetEffectAry(
          efAry,
          [2, 3],
          castChar['type']
        )
        let loopAry = this.getTarget(efTarget, targetCharNum)
        for (let tNum = 0; tNum < loopAry.length; tNum++) {
          effectCheck = true
          let targetChar = this.setCharData(loopAry[tNum])
          let efAry2 = this.replaceMyAndTargetEffectAry(
            efAry,
            [2, 3],
            null,
            targetChar['type']
          )
          let prob = this.calculationResist(efAry2[3], targetChar)
          if (prob >= dice(1, 100)) {
            printDebugMessage(this.getName(targetChar, true) + ' resist succes')
            this.controlResultChar('push', targetChar, 'resist')
            continue
          }
          if (targetChar['type'] == 'pc') {
            healingCheck = true
          }
          let value = this.calculationMyAndTarget(
            efAry2[2],
            castChar,
            targetChar,
            'f'
          )
          if (targetChar['type'].match(/^(monster|summon)$/)) {
            if (targetChar['charData'].INVINCIBILITY && value < 0) {
              value = 0
            }
          }
          targetChar['char'].controlHp(value, true)
          printDebugMessageHp(targetChar, value)
          if (value > -1) {
            let resultStr
            if (targetChar['char'].Hp >= targetChar['char'].HpMax) {
              resultStr = 'fullHeal'
            } else {
              resultStr = 'heal,' + String(value)
            }
            this.controlResultChar('push', targetChar, resultStr)
          } else {
            let dmg = value * -1
            if (this.SituationAbbr == 'b') {
              targetChar['char'].cureAsleepByDamage(dmg)
            }
            this.controlResultChar('push', targetChar, 'damage,' + String(dmg))
            if (targetChar['char'].Hp < 1) {
              this.dealingWithDeath(targetChar)
            }
          }
        }
      } else if (ef == 2) {
        if (!this.activateCheck(efTarget, 'csbte', 'a', 'f')) {
          continue
        }
        printDebugMessage('[SpellEffect] heal state')
        efAry = this.replaceMyAndTargetEffectAry(efAry, [3], castChar['type'])
        let loopAry = this.getTarget(efTarget, targetCharNum)
        for (let tNum = 0; tNum < loopAry.length; tNum++) {
          effectCheck = true
          let targetChar = this.setCharData(loopAry[tNum])
          let efAry2 = this.replaceMyAndTargetEffectAry(
            efAry,
            [3],
            null,
            targetChar['type']
          )
          let prob = this.calculationResist(efAry2[3], targetChar)
          if (prob >= dice(1, 100)) {
            printDebugMessage(this.getName(targetChar, true) + ' resist succes')
            this.controlResultChar('push', targetChar, 'resist')
            continue
          }
          let ck = false
          if (targetChar['char'].Poison > 0 && efAry2[2].indexOf('4') > -1) {
            targetChar['char'].Poison = 0
            ck = true
          }
          if (targetChar['char'].Asleep != 0 && efAry2[2].indexOf('5') > -1) {
            targetChar['char'].Asleep = 0
            ck = true
          }
          if (targetChar['char'].Silence != 0 && efAry2[2].indexOf('6') > -1) {
            targetChar['char'].Silence = 0
            ck = true
          }
          if (targetChar['char'].NoBreath != 0 && efAry2[2].indexOf('7') > -1) {
            targetChar['char'].NoBreath = 0
            ck = true
          }
          if (targetChar['char'].Hate > -1 && efAry2[2].indexOf('8') > -1) {
            targetChar['char'].Hate = -1
            targetChar['char'].HateTurn = -1
            ck = true
          }
          let state = targetChar['char'].State
          if (
            state >= 1 &&
            state <= 3 &&
            efAry2[2].indexOf(String(state)) > -1
          ) {
            targetChar['char'].State = 0
            ck = true
          }
          if (ck) {
            targetChar['char'].check()
            this.controlResultChar('push', targetChar, 'cure')
          }
        }
      } else if (ef == 3) {
        if (!this.activateCheck(efTarget, 'csbte', 'p', 'p')) {
          continue
        }
        printDebugMessage('[SpellEffect] revive')
        efAry = this.replaceMyAndTargetEffectAry(
          efAry,
          [3, 4],
          castChar['type']
        )
        let loopAry = this.getTarget(efTarget, targetCharNum, true, 'pc')
        for (let tNum = 0; tNum < loopAry.length; tNum++) {
          effectCheck = true
          let targetChar = this.setCharData(loopAry[tNum])
          let efAry2 = this.replaceMyAndTargetEffectAry(
            efAry,
            [3, 4],
            null,
            targetChar['type']
          )
          let state = targetChar['char'].State
          let state2 = state - 3
          if (
            state >= 4 &&
            state <= 6 &&
            efAry2[2].indexOf(String(state2)) > -1
          ) {
            let prob = this.calculationMyAndTarget(
              efAry2[3],
              castChar,
              targetChar,
              'f',
              0,
              100
            )
            printDebugMessage('resurrection rate: ' + prob + '%')
            if (prob >= dice(1, 100)) {
              success = true
              targetChar['char'].State = 0
              if (targetChar['char'].Level < 1) {
                targetChar['char'].Level = 1
              }
              if (targetChar['char'].HpMax0 < 1) {
                targetChar['char'].HpMax0 = 1
              }
              for (let i = 0; i < GameData['ABILITY'].length; i++) {
                if (targetChar['char'].Ability0[i] < 1) {
                  targetChar['char'].Ability0[i] = targetChar[
                    'char'
                  ].getAbilityMinMax('min', i)
                }
              }
              targetChar['char'].Hp = this.calculationMyAndTarget(
                efAry2[4],
                castChar,
                targetChar,
                'f',
                1,
                targetChar['char'].HpMax0
              )
              targetChar['char'].check()
              if (this.SituationAbbr == 'b') {
                this.controlResultChar('push', targetChar, 'revive')
              } else {
                healingCheck = true
                this.controlResultChar('push', targetChar, 'heal')
              }
            } else {
              fizzle = true
              if (efAry2[5] != 'true') {
                if (targetChar['char'].State == 4) {
                  targetChar['char'].State = 5
                  this.controlResultChar('push', targetChar, 'ashed')
                } else if (targetChar['char'].State == 5) {
                  targetChar['char'].State = 6
                  this.controlResultChar('push', targetChar, 'lost')
                } else {
                  this.controlResultChar('push', targetChar, 'none')
                }
              } else {
                this.controlResultChar('push', targetChar, 'none')
              }
            }
          } else {
            this.controlResultChar('push', targetChar, 'none')
          }
        }
      } else if (ef == 4) {
        if (!this.activateCheck(efTarget, 'csbte', 'a', 'f')) {
          continue
        }
        printDebugMessage('[SpellEffect] heal mp')
        efAry = this.replaceMyAndTargetEffectAry(
          efAry,
          [4, 5],
          castChar['type']
        )
        let loopAry = this.getTarget(efTarget, targetCharNum)
        for (let tNum = 0; tNum < loopAry.length; tNum++) {
          effectCheck = true
          let targetChar = this.setCharData(loopAry[tNum])
          let efAry2 = this.replaceMyAndTargetEffectAry(
            efAry,
            [4, 5],
            null,
            targetChar['type']
          )
          let prob = this.calculationResist(efAry2[5], targetChar)
          if (prob >= dice(1, 100)) {
            printDebugMessage(this.getName(targetChar, true) + ' resist succes')
            this.controlResultChar('push', targetChar, 'resist')
            continue
          }
          let ck = false
          for (let i = 0; i < GameData['SPELL_KIND']; i++) {
            if (efAry2[2].indexOf(String(i)) < 0) {
              continue
            }
            for (let j = 0; j < GameData['SPELL_LVMAX']; j++) {
              if (efAry2[3].indexOf(String(j)) == -1) {
                continue
              }
              let num = this.calculationMyAndTarget(
                efAry2[4],
                castChar,
                targetChar,
                'f',
                0,
                100
              )
              num = calDiv(num, 100)
              num = Math.ceil(calTimes(targetChar['char'].MpMax[i][j], num))
              targetChar['char'].controlMp(i, j, num, true)
              ck = true
            }
            if (GameData['DEBUG'] && PlayData['DebugView']) {
              let str =
                MP.strFitLength(GameData['SPELL_KIND_NAME'][i], 4) + ': '
              for (let j = 0; j < GameData['SPELL_LVMAX']; j++) {
                if (j > 0) {
                  str += '/'
                }
                str += String(targetChar['char'].Mp[i][j])
              }
              printDebugMessage(this.getName(targetChar, true) + ' ' + str)
            }
          }
          if (ck) {
            this.controlResultChar('push', targetChar, 'healMp')
          }
        }
      } else if (ef == 10) {
        if (!this.activateCheck(efTarget, 'csbte', 'a', 'a')) {
          continue
        }
        printDebugMessage('[SpellEffect] change ability')
        efAry = this.replaceMyAndTargetEffectAry(
          efAry,
          [3, 4],
          castChar['type']
        )
        let loopAry = this.getTarget(efTarget, targetCharNum)
        for (let tNum = 0; tNum < loopAry.length; tNum++) {
          effectCheck = true
          let targetChar = this.setCharData(loopAry[tNum])
          if (this.checkSpellCancel(targetChar)) {
            continue
          }
          let efAry2 = this.replaceMyAndTargetEffectAry(
            efAry,
            [3, 4],
            null,
            targetChar['type']
          )
          let prob = this.calculationResist(efAry2[4], targetChar)
          if (prob >= dice(1, 100)) {
            printDebugMessage(this.getName(targetChar, true) + ' resist succes')
            this.controlResultChar('push', targetChar, 'resist')
            continue
          }
          let abi = Number(efAry2[2])
          if (abi < 0 || abi >= GameData['ABILITY'].length) {
            continue
          }
          let value = this.calculationMyAndTarget(
            efAry2[3],
            castChar,
            targetChar,
            'f',
            -999,
            999
          )
          value += targetChar['char'].Ability0[abi]
          let limit = 999
          if (targetChar['type'] == 'pc') {
            limit = targetChar['char'].getAbilityMinMax('max', abi)
            if (limit < 0) {
              limit = 0
            } else if (limit > 999) {
              limit = 999
            }
          }
          if (value < 0) {
            value = 0
          } else if (value > limit && efAry2[5] != 'true') {
            value = limit
          }
          targetChar['char'].Ability0[abi] = value
          if (value < 1 && !GameData['ABILITY_NO_DEATH'][abi]) {
            if (targetChar['type'] == 'pc') {
              if (targetChar['char'].State < 4) {
                targetChar['char'].controlHp(0)
              }
              targetChar['char'].State = 6
            } else {
              targetChar['char'].controlHp(0)
            }
            this.dealingWithDeath(targetChar)
          }
          targetChar['char'].check()
          printDebugMessage(
            this.getName(targetChar, true) +
              ' ' +
              GameData['ABILITY'][abi] +
              ':' +
              String(targetChar['char'].Ability0[abi])
          )
        }
      } else if (ef == 11 || ef == 12 || ef == 18) {
        if (!this.activateCheck(efTarget, 'csbte', 'p', 'p')) {
          continue
        }
        if (ef == 11) {
          printDebugMessage('[SpellEffect] change max HP')
        } else if (ef == 12) {
          printDebugMessage('[SpellEffect] change state')
        } else if (ef == 18) {
          printDebugMessage('[SpellEffect] increase EXP')
        }
        efAry = this.replaceMyAndTargetEffectAry(
          efAry,
          [2, 3],
          castChar['type']
        )
        let loopAry = this.getTarget(efTarget, targetCharNum, true, 'pc')
        for (let tNum = 0; tNum < loopAry.length; tNum++) {
          effectCheck = true
          let targetChar = this.setCharData(loopAry[tNum])
          let efAry2 = this.replaceMyAndTargetEffectAry(
            efAry,
            [2, 3],
            null,
            targetChar['type']
          )
          let prob = this.calculationResist(efAry2[3], targetChar)
          if (prob >= dice(1, 100)) {
            printDebugMessage(this.getName(targetChar, true) + ' resist succes')
            this.controlResultChar('push', targetChar, 'resist')
            continue
          }
          let value = this.calculationMyAndTarget(
            efAry2[2],
            castChar,
            targetChar,
            'f'
          )
          if (ef == 11) {
            targetChar['char'].HpMax0 += value
            if (targetChar['char'].HpMax0 < 1 && targetChar['char'].State < 6) {
              targetChar['char'].controlHp(0)
              targetChar['char'].State = 6
              this.dealingWithDeath(targetChar)
            }
          } else if (ef == 12) {
            let state = targetChar['char'].State
            if (value > state && value >= 1 && value <= 6) {
              let ck = false
              if (targetChar['char'].State < 4 && value > 3) {
                targetChar['char'].controlHp(0)
                ck = true
              }
              if (value > 1) {
                targetChar['char'].battleReset()
              }
              targetChar['char'].State = value
              targetChar['char'].Asleep = 0
              if (ck) {
                this.dealingWithDeath(targetChar)
              }
            }
          } else if (ef == 18) {
            if (value < 0) {
              value *= -1
            }
            targetChar['char'].Exp += value
          }
          targetChar['char'].check()
        }
      } else if ((ef >= 13 && ef <= 17) || ef == 19 || ef == 29) {
        if (!this.activateCheck(efTarget, 'csbte', 'a', 'p')) {
          continue
        }
        if (ef == 13) {
          printDebugMessage('[SpellEffect] change age')
        } else if (ef == 14) {
          printDebugMessage('[SpellEffect] change sex')
        } else if (ef == 15) {
          printDebugMessage('[SpellEffect] change alignment')
        } else if (ef == 17) {
          printDebugMessage('[SpellEffect] level drain')
        } else if (ef == 16) {
          printDebugMessage('[SpellEffect] change race and class')
        } else if (ef == 19) {
          printDebugMessage('[SpellEffect] change money')
        } else if (ef == 29) {
          printDebugMessage('[SpellEffect] change days')
        }
        efAry = this.replaceMyAndTargetEffectAry(
          efAry,
          [2, 3],
          castChar['type']
        )
        let loopAry = this.getTarget(efTarget, targetCharNum, true, 'pc')
        for (let tNum = 0; tNum < loopAry.length; tNum++) {
          effectCheck = true
          let targetChar = this.setCharData(loopAry[tNum])
          if (this.checkSpellCancel(targetChar)) {
            continue
          }
          let efAry2 = this.replaceMyAndTargetEffectAry(
            efAry,
            [2, 3],
            null,
            targetChar['type']
          )
          let prob = this.calculationResist(efAry2[3], targetChar)
          if (prob >= dice(1, 100)) {
            printDebugMessage(this.getName(targetChar, true) + ' resist succes')
            this.controlResultChar('push', targetChar, 'resist')
            continue
          }
          let value = this.calculationMyAndTarget(
            efAry2[2],
            castChar,
            targetChar,
            'f'
          )
          if (ef == 13) {
            targetChar['char'].Age += value
          } else if (ef == 14) {
            let race = targetChar['char'].Race
            if (GameData['RACE_SEX_INSIDE'][race] > -1) {
              continue
            }
            let changeCk = false
            let sex = targetChar['char'].Sex
            if (value == 2) {
              if (sex < 2) {
                if (sex == 0) {
                  sex = 1
                } else {
                  sex = 0
                }
                if (GameData['RACE_SEX'][race].indexOf(String(sex)) > -1) {
                  changeCk = true
                }
              }
            } else if (value >= 0 && value <= 4) {
              if (value > 2) {
                value--
              }
              sex = value
              if (GameData['RACE_SEX'][race].indexOf(String(sex)) > -1) {
                changeCk = true
              }
            }
            if (changeCk) {
              targetChar['char'].Sex = sex
            } else {
              continue
            }
          } else if (ef == 15) {
            let ali = targetChar['char'].Alignment
            if (value >= 0 && value <= 2) {
              targetChar['char'].Alignment = value
            } else if (value == 3 && ali == 2) {
              targetChar['char'].Alignment = 0
            } else if (value == 4 && ali == 0) {
              targetChar['char'].Alignment = 2
            } else if (value == 5 && ali != 1) {
              if (ali == 0) {
                targetChar['char'].Alignment = 2
              } else if (ali == 2) {
                targetChar['char'].Alignment = 0
              }
            }
          } else if (ef == 16) {
            let value2 = Number(efAry2[4])
            if (
              (value < 0 || value >= GameData['PC_CLASS'].length) &&
              (value2 < 0 || value2 >= GameData['RACE'].length)
            ) {
              continue
            }
            if (value2 > -1 && value2 < GameData['RACE'].length) {
              targetChar['char'].Race = value2
              targetChar['char'].checkSexByRace()
            }
            if (value > -1 && value < GameData['PC_CLASS'].length) {
              targetChar['char'].PcClass = value
              for (let i = 0; i < GameData['SPELL_KIND']; i++) {
                for (let j = 0; j < GameData['SPELL_LVMAX']; j++) {
                  if (GameData['CLASS_LEARNED_SPELL'][value][i][0] != 0) {
                    continue
                  }
                  let count = 0
                  for (let k = 0; k < 6; k++) {
                    if (targetChar['char'].Spell[i][j][k]) {
                      count++
                    }
                  }
                  let formula = replaceFormula(GameData['MPMAX_UP'][i][0], [
                    ['pc', targetChar['char'].PC_NUM]
                  ])
                  let num = Math.floor(strCalculation(formula))
                  num *= count
                  if (targetChar['char'].MpMax[i][j] > num) {
                    if (num > GameData['SPELL_MPMAX']) {
                      num = GameData['SPELL_MPMAX']
                    }
                    targetChar['char'].MpMax[i][j] = num
                  }
                }
              }
            }
            targetChar['char'].removeEquip()
            targetChar['char'].NextUpExp = -1
          } else if (ef == 17) {
            if (
              targetChar['char'].State > 3 ||
              (value > 0 && targetChar['char'].Resist[5])
            ) {
              continue
            }
            if (value < 0) {
              value *= -1
            }
            let preLv = targetChar['char'].Level
            let downLv = value
            value = preLv - value
            if (value < 1) {
              targetChar['char'].controlHp(0)
              targetChar['char'].State = 6
              targetChar['char'].Level = 0
              targetChar['char'].HpMax0 = 1
              targetChar['char'].Exp = 0
              this.dealingWithDeath(targetChar)
            } else {
              targetChar['char'].Level = value
              targetChar['char'].drainCheck(preLv)
              if (
                spellData['target'] != 9 &&
                this.SituationAbbr == 'b' &&
                downLv > 0
              ) {
                this.controlResultChar(
                  'push',
                  targetChar,
                  'drain,' + String(downLv)
                )
              }
            }
          } else if (ef == 19) {
            targetChar['char'].Gold += value
          } else if (ef == 29) {
            let days = targetChar['char'].Age * 365 + targetChar['char'].Days
            days += value
            if (days < 365) {
              days = 365
            } else if (days > 364999) {
              days = 364999
            }
            targetChar['char'].Age = Math.floor(days / 365)
            targetChar['char'].Days = days % 365
          }
          targetChar['char'].check()
        }
      } else if (ef == 20) {
        if (!this.activateCheck(efTarget, 'csbte', 'a', 'p')) {
          continue
        }
        printDebugMessage('[SpellEffect] learn spell')
        efAry = this.replaceMyAndTargetEffectAry(efAry, [4], castChar['type'])
        let loopAry = this.getTarget(efTarget, targetCharNum, true, 'pc')
        for (let tNum = 0; tNum < loopAry.length; tNum++) {
          effectCheck = true
          let targetChar = this.setCharData(loopAry[tNum])
          if (this.checkSpellCancel(targetChar)) {
            continue
          }
          let efAry2 = this.replaceMyAndTargetEffectAry(
            efAry,
            [4],
            null,
            targetChar['type']
          )
          let prob = this.calculationResist(efAry2[4], targetChar)
          if (prob >= dice(1, 100)) {
            printDebugMessage(this.getName(targetChar, true) + ' resist succes')
            this.controlResultChar('push', targetChar, 'resist')
            continue
          }
          let pcClass = targetChar['char'].PcClass
          let kindStr = ''
          if (efAry2[2].indexOf('9') > -1) {
            for (let i = 0; i < GameData['SPELL_KIND']; i++) {
              if (
                efAry2[2].indexOf(String(i)) > -1 &&
                GameData['CLASS_LEARNED_SPELL'][pcClass][i][0] > 0
              ) {
                kindStr += String(i)
              }
            }
          } else {
            kindStr = efAry2[2]
          }
          for (let i = 0; i < GameData['SPELL_KIND']; i++) {
            if (kindStr.indexOf(String(i)) < 0) {
              continue
            }
            if (efAry2[2].indexOf('9') > -1) {
              if (
                GameData['CLASS_LEARNED_SPELL'][pcClass][i][2] == 0 ||
                GameData['CLASS_LEARNED_SPELL'][pcClass][i][3] == 0
              ) {
                continue
              }
            }
            for (let j = 0; j < GameData['SPELL_LVMAX']; j++) {
              if (efAry2[3].indexOf(String(j)) < 0) {
                continue
              }
              if (efAry2[2].indexOf('9') > -1) {
                if (
                  !(
                    j >= GameData['CLASS_LEARNED_SPELL'][pcClass][i][2] - 1 &&
                    j <= GameData['CLASS_LEARNED_SPELL'][pcClass][i][3] - 1
                  )
                ) {
                  continue
                }
              }
              for (let k = 0; k < 6; k++) {
                if (efAry2[5].indexOf(String(k)) < 0) {
                  continue
                }
                if (GameData['SPELL'][i][j][k] != '') {
                  targetChar['char'].Spell[i][j][k] = true
                }
              }
            }
          }
          targetChar['char'].gainedMpMin(true)
        }
      } else if (ef == 21) {
        if (!this.activateCheck(efTarget, 'csbte', 'a', 'pn')) {
          continue
        }
        efAry = this.replaceMyAndTargetEffectAry(efAry, [2], castChar['type'])
        efAry[3] = efAry[3].replace(/ /g, '')
        efAry[4] = efAry[4].replace(/ /g, '')
        if (efAry[3] == '' && efAry[4] == '') {
          if (castChar['type'] != 'pc') {
            continue
          } else if (situation.indexOf('Spell') < 0) {
            continue
          }
          printDebugMessage('[SpellEffect] forget spell')
          effectCheck = true
          let targetChar = this.setCharData(castChar['numInGroup'][0])
          let prob = this.calculationResist(efAry[2], targetChar)
          if (prob >= dice(1, 100)) {
            printDebugMessage(this.getName(targetChar, true) + ' resist succes')
            this.controlResultChar('push', targetChar, 'resist')
            continue
          }
          targetChar['char'].Spell[castKind][castLv][castSpell] = false
        } else {
          printDebugMessage('[SpellEffect] forget spell')
          let loopAry = this.getTarget(efTarget, targetCharNum, true, 'pc')
          for (let tNum = 0; tNum < loopAry.length; tNum++) {
            effectCheck = true
            let targetChar = this.setCharData(loopAry[tNum])
            if (this.checkSpellCancel(targetChar)) {
              continue
            }
            let efAry2 = this.replaceMyAndTargetEffectAry(
              efAry,
              [2],
              null,
              targetChar['type']
            )
            let prob = this.calculationResist(efAry2[2], targetChar)
            if (prob >= dice(1, 100)) {
              printDebugMessage(
                this.getName(targetChar, true) + ' resist succes'
              )
              this.controlResultChar('push', targetChar, 'resist')
              continue
            }
            let pcClass = targetChar['char'].PcClass
            let kindStr = ''
            if (efAry2[3].indexOf('9') > -1) {
              for (let i = 0; i < GameData['SPELL_KIND']; i++) {
                if (
                  efAry2[3].indexOf(String(i)) > -1 &&
                  GameData['CLASS_LEARNED_SPELL'][pcClass][i][0] > 0
                ) {
                  kindStr += String(i)
                }
              }
            } else {
              kindStr = efAry2[3]
            }
            for (let i = 0; i < GameData['SPELL_KIND']; i++) {
              if (kindStr.indexOf(String(i)) < 0) {
                continue
              }
              if (efAry2[3].indexOf('9') > -1) {
                if (
                  GameData['CLASS_LEARNED_SPELL'][pcClass][i][2] == 0 ||
                  GameData['CLASS_LEARNED_SPELL'][pcClass][i][3] == 0
                ) {
                  continue
                }
              }
              for (let j = 0; j < GameData['SPELL_LVMAX']; j++) {
                if (efAry2[4].indexOf(String(j)) < 0) {
                  continue
                }
                if (efAry2[3].indexOf('9') > -1) {
                  if (
                    !(
                      j >= GameData['CLASS_LEARNED_SPELL'][pcClass][i][2] - 1 &&
                      j <= GameData['CLASS_LEARNED_SPELL'][pcClass][i][3] - 1
                    )
                  ) {
                    continue
                  }
                }
                for (let k = 0; k < 6; k++) {
                  if (efAry2[5].indexOf(String(k)) < 0) {
                    continue
                  }
                  if (GameData['SPELL'][i][j][k] != '') {
                    targetChar['char'].Spell[i][j][k] = false
                  }
                }
              }
            }
          }
        }
      } else if (ef == 22) {
        if (!this.activateCheck(efTarget, 'csbte', 'a')) {
          continue
        }
        let itemNum = Number(efAry[2])
        if (itemNum < 0 || itemNum >= ITEM.length) {
          continue
        }
        printDebugMessage('[SpellEffect] add item')
        let num = Number(efAry[3])
        for (let i = 0; i < num; i++) {
          if (!this.NoCastChar && castChar['type'] == 'pc') {
            if (this.controlHaveItem('put', castChar, itemNum) < 0) {
              if (this.controlHaveItem('partyPut', null, itemNum) < 0) {
                break
              }
            }
            effectCheck = true
          } else if (this.controlHaveItem('partyPut', null, itemNum) < 0) {
            break
          } else {
            effectCheck = true
          }
        }
        pt.check()
      } else if (ef == 23) {
        if (!this.activateCheck(efTarget, 'csbte', 'a')) {
          continue
        }
        let itemNum = Number(efAry[2])
        if (itemNum < 0 || itemNum >= ITEM.length) {
          continue
        }
        printDebugMessage('[SpellEffect] delete item')
        let num = Number(efAry[3]),
          equip = Number(efAry[4])
        let dump = Number(efAry[5])
        for (let i = 0; i < num; i++) {
          let ary = this.getHaveNumDeleteItem(itemNum, equip)
          if (ary[0] < 0) {
            break
          }
          effectCheck = true
          this.controlHaveItem('remove', this.setCharData(ary[0]), ary[1], dump)
        }
        pt.check()
      } else if (ef == 24) {
        if (!this.activateCheck(efTarget, 'csbte', 'p') || this.NoCastChar) {
          continue
        }
        let itemNum = Number(efAry[2])
        if (itemNum < 0 || itemNum >= ITEM.length) {
          continue
        }
        printDebugMessage('[SpellEffect] change item')
        let changeItemNum
        if (efAry[3] == '' || efAry[3] == '-1') {
          changeItemNum = -1
        } else {
          efAry[3] = efAry[3].replace(/\./g, ',')
          let ary = MP.getCmNum(efAry[3]).split(',')
          changeItemNum = ary[dice(1, ary.length) - 1]
        }
        let equip = Number(efAry[4]),
          dump = Number(efAry[5])
        let haveNum = -1
        if (situation.match(/(Item|Sp)$/) && !this.UseItemBreak) {
          if (itemNum == castChar['char'].Item[this.UseHaveNum]) {
            haveNum = this.UseHaveNum
          }
        }
        if (haveNum < 0) {
          haveNum = castChar['char'].haveItem(itemNum, equip)
        }
        if (haveNum < 0) {
          continue
        }
        effectCheck = true
        if (changeItemNum < 0) {
          this.controlHaveItem('remove', castChar, haveNum, dump)
        } else {
          if (changeItemNum >= ITEM.length) {
            changeItemNum = 0
          }
          this.controlHaveItem('change', castChar, haveNum, changeItemNum)
        }
        castChar['char'].check()
      } else if (ef == 25) {
        if (!this.activateCheck(efTarget, 'csbte', 'p')) {
          continue
        }
        printDebugMessage('[SpellEffect] synthesis item')
        let itemNum1 = Number(efAry[2])
        if (itemNum1 < 0 || itemNum1 >= ITEM.length) {
          continue
        }
        let itemNum2 = Number(efAry[3])
        if (itemNum2 < 0 || itemNum2 >= ITEM.length) {
          continue
        }
        let changeitemNum = Number(efAry[4])
        if (changeitemNum < 0 || changeitemNum >= ITEM.length) {
          continue
        }
        let equip = Number(efAry[5])
        let resultAry1 = this.getHaveNumSyntheticItem(itemNum1, equip)
        if (resultAry1[0] < 0) {
          continue
        }
        let resultAry2 = this.getHaveNumSyntheticItem(
          itemNum2,
          equip,
          resultAry1
        )
        if (resultAry2[0] < 0) {
          continue
        }
        effectCheck = true
        if (resultAry1[0] == resultAry2[0] && resultAry1[1] < resultAry2[1]) {
          this.controlHaveItem(
            'remove',
            this.setCharData(resultAry2[0]),
            resultAry2[1]
          )
          this.controlHaveItem(
            'remove',
            this.setCharData(resultAry1[0]),
            resultAry1[1]
          )
        } else {
          this.controlHaveItem(
            'remove',
            this.setCharData(resultAry1[0]),
            resultAry1[1]
          )
          this.controlHaveItem(
            'remove',
            this.setCharData(resultAry2[0]),
            resultAry2[1]
          )
        }
        if (!this.NoCastChar && castChar['char'].getItemSpaceNum() > 0) {
          this.controlHaveItem('put', castChar, changeitemNum)
        } else {
          this.controlHaveItem('partyPut', null, changeitemNum)
        }
        pt.check()
      } else if (ef == 26) {
        if (!this.activateCheck(efTarget, 'csbte', 'a', 'p')) {
          continue
        }
        printDebugMessage('[SpellEffect] lost item')
        efAry = this.replaceMyAndTargetEffectAry(efAry, [2], castChar['type'])
        let dump = Number(efAry[3])
        let loopAry = this.getTarget(efTarget, targetCharNum, true, 'pc')
        for (let tNum = 0; tNum < loopAry.length; tNum++) {
          effectCheck = true
          let targetChar = this.setCharData(loopAry[tNum])
          if (this.checkSpellCancel(targetChar)) {
            continue
          }
          let efAry2 = this.replaceMyAndTargetEffectAry(
            efAry,
            [2],
            null,
            targetChar['type']
          )
          let prob = this.calculationMyAndTarget(
            efAry2[2],
            null,
            null,
            'f',
            0,
            100
          )
          for (let i = 0; i < targetChar['char'].haveItemNum(-1); i++) {
            if (prob < dice(1, 100)) {
              continue
            }
            this.controlHaveItem('remove', targetChar, i, dump)
            i--
          }
          targetChar['char'].check()
        }
      } else if (ef == 27 || ef == 28) {
        if (!this.activateCheck(efTarget, 'csbte', 'p', 'p')) {
          continue
        }
        if (ef == 27) {
          printDebugMessage('[SpellEffect] identify item')
        } else if (ef == 28) {
          printDebugMessage('[SpellEffect] uncurse item')
        }
        efAry = this.replaceMyAndTargetEffectAry(efAry, [3], castChar['type'])
        let num = Number(efAry[2])
        let count = 0
        let loopAry = this.getTarget(efTarget, targetCharNum, true, 'pc')
        for (let tNum = 0; tNum < loopAry.length; tNum++) {
          effectCheck = true
          if (count >= num) {
            break
          }
          let targetChar = this.setCharData(loopAry[tNum])
          let efAry2 = this.replaceMyAndTargetEffectAry(
            efAry,
            [3],
            null,
            targetChar['type']
          )
          let prob = this.calculationMyAndTarget(
            efAry2[3],
            null,
            null,
            'f',
            0,
            100
          )
          if (ef == 27) {
            let itemMax = targetChar['char'].haveItemNum(-1)
            for (let i = 0; i < itemMax; i++) {
              if (count >= num) {
                break
              }
              if (targetChar['char'].ItemDecided[i] == 1) {
                continue
              }
              count++
              if (prob < dice(1, 100)) {
                continue
              }
              targetChar['char'].ItemDecided[i] = 1
              PlayData['ItemFlag'][targetChar['char'].Item[i]] = true
            }
          } else if (ef == 28) {
            for (let i = 0; i < targetChar['char'].haveItemNum(-1); i++) {
              if (count >= num) {
                break
              }
              if (targetChar['char'].Equip[i] != 2) {
                continue
              }
              count++
              if (prob < dice(1, 100)) {
                continue
              }
              if (efAry2[4] == '1') {
                this.controlHaveItem('remove', targetChar, i)
                i--
              } else {
                targetChar['char'].Equip[i] = 0
              }
            }
          }
          targetChar['char'].check()
        }
      } else if (ef == 30) {
        if (!this.activateCheck(efTarget, 'csbte', 'a', 'a')) {
          continue
        }
        printDebugMessage('[SpellEffect] fluctuation MP')
        let kind = -1,
          lv = -1
        efAry[2] = efAry[2].replace(/ /g, '')
        if (efAry[2].length >= 1) {
          kind = Number(efAry[2].charAt(0))
        }
        if (efAry[2].length >= 2) {
          lv = Number(efAry[2].charAt(1))
          if (lv >= GameData['SPELL_LVMAX']) {
            lv = -1
          }
        }
        efAry = this.replaceMyAndTargetEffectAry(
          efAry,
          [3, 4],
          castChar['type']
        )
        let loopAry = this.getTarget(efTarget, targetCharNum)
        for (let tNum = 0; tNum < loopAry.length; tNum++) {
          effectCheck = true
          let targetChar = this.setCharData(loopAry[tNum])
          if (this.checkSpellCancel(targetChar)) {
            continue
          }
          let efAry2 = this.replaceMyAndTargetEffectAry(
            efAry,
            [3, 4],
            null,
            targetChar['type']
          )
          let prob = this.calculationResist(efAry2[4], targetChar)
          if (prob >= dice(1, 100)) {
            printDebugMessage(this.getName(targetChar, true) + ' resist succes')
            this.controlResultChar('push', targetChar, 'resist')
            continue
          }
          let num = this.calculationMyAndTarget(
            efAry2[3],
            castChar,
            targetChar,
            'f'
          )
          let kindStart = 0,
            kindEnd = GameData['SPELL_KIND'] + 1
          let lvStart = 0,
            lvEnd = GameData['SPELL_LVMAX']
          if (kind > -1) {
            ;(kindStart = kind), (kindEnd = kindStart + 1)
          }
          if (lv > -1) {
            ;(lvStart = lv), (lvEnd = lvStart + 1)
          }
          for (let i = kindStart; i < kindEnd; i++) {
            if (i == GameData['SPELL_KIND'] && targetChar['type'] == 'pc') {
              continue
            }
            for (let j = lvStart; j < lvEnd; j++) {
              let mpMax = targetChar['char'].MpMax[i][j]
              let mp = targetChar['char'].Mp[i][j] + num
              if (mp < 0) {
                mp = 0
              } else if (mp > mpMax) {
                mp = mpMax
              }
              targetChar['char'].Mp[i][j] = mp
            }
            if (GameData['DEBUG'] && PlayData['DebugView']) {
              let str = MP.strFitLength(GameData['SPELL_KIND_NAME'][i], 4)
              str += ' (MP): '
              for (let j = 0; j < GameData['SPELL_LVMAX']; j++) {
                if (j > 0) {
                  str += '/'
                }
                str += String(targetChar['char'].Mp[i][j])
              }
              printDebugMessage(this.getName(targetChar, true) + ' ' + str)
            }
          }
        }
      } else if (ef == 31) {
        if (!this.activateCheck(efTarget, 'csbte', 'a', 'p')) {
          continue
        }
        printDebugMessage('[SpellEffect] change max MP')
        let kind = -1,
          lv = -1
        efAry[2] = efAry[2].replace(/ /g, '')
        if (efAry[2].length >= 1) {
          kind = Number(efAry[2].charAt(0))
        }
        if (efAry[2].length >= 2) {
          lv = Number(efAry[2].charAt(1))
          if (lv >= GameData['SPELL_LVMAX']) {
            lv = -1
          }
        }
        efAry = this.replaceMyAndTargetEffectAry(
          efAry,
          [3, 4],
          castChar['type']
        )
        let loopAry = this.getTarget(efTarget, targetCharNum, true, 'pc')
        for (let tNum = 0; tNum < loopAry.length; tNum++) {
          effectCheck = true
          let targetChar = this.setCharData(loopAry[tNum])
          if (this.checkSpellCancel(targetChar)) {
            continue
          }
          let efAry2 = this.replaceMyAndTargetEffectAry(
            efAry,
            [3, 4],
            null,
            targetChar['type']
          )
          let prob = this.calculationResist(efAry2[4], targetChar)
          if (prob >= dice(1, 100)) {
            printDebugMessage(this.getName(targetChar, true) + ' resist succes')
            this.controlResultChar('push', targetChar, 'resist')
            continue
          }
          let num = this.calculationMyAndTarget(
            efAry2[3],
            castChar,
            targetChar,
            'f'
          )
          let kindStart = 0,
            kindEnd = GameData['SPELL_KIND'] + 1
          let lvStart = 0,
            lvEnd = GameData['SPELL_LVMAX']
          if (kind > -1) {
            ;(kindStart = kind), (kindEnd = kindStart + 1)
          }
          if (lv > -1) {
            ;(lvStart = lv), (lvEnd = lvStart + 1)
          }
          for (let i = kindStart; i < kindEnd; i++) {
            if (targetChar['type'] == 'pc') {
              if (i >= GameData['SPELL_KIND']) {
                continue
              }
            } else if (i >= GameData['SPELL_KIND'] + 1) {
              continue
            }
            for (let j = lvStart; j < lvEnd; j++) {
              if (j >= GameData['SPELL_LVMAX']) {
                continue
              }
              let mpMax = targetChar['char'].MpMax[i][j] + num
              if (mpMax < 0) {
                mpMax = 0
              } else if (mpMax > 99) {
                mpMax = 99
              }
              targetChar['char'].MpMax[i][j] = mpMax
            }
            if (GameData['DEBUG'] && PlayData['DebugView']) {
              let str = MP.strFitLength(GameData['SPELL_KIND_NAME'][i], 4)
              str += ' (MP MAX): '
              for (let j = 0; j < GameData['SPELL_LVMAX']; j++) {
                if (j > 0) {
                  str += '/'
                }
                str += String(targetChar['char'].MpMax[i][j])
              }
              printDebugMessage(this.getName(targetChar, true) + ' ' + str)
            }
          }
          targetChar['char'].check()
        }
      } else if (ef == 32) {
        if (!this.activateCheck(efTarget, 'csbte', 'a', 'p')) {
          continue
        }
        printDebugMessage('[SpellEffect] remove equipment')
        let removeKind = Number(efAry[2])
        let curseOK = false
        if (efAry[3] == '1') {
          curseOK = true
        }
        let loopAry = this.getTarget(efTarget, targetCharNum, true, 'pc')
        for (let tNum = 0; tNum < loopAry.length; tNum++) {
          effectCheck = true
          let targetChar = this.setCharData(loopAry[tNum])
          if (this.checkSpellCancel(targetChar)) {
            continue
          }
          let kindStart, kindEnd
          if (removeKind < 0) {
            kindStart = 0
            kindEnd = 7
          } else {
            kindStart = removeKind
            kindEnd = kindStart + 1
          }
          for (let i = kindStart; i < kindEnd; i++) {
            for (let j = 0; j < targetChar['char'].ItemMaxNum; j++) {
              let itemNum = targetChar['char'].Item[j]
              if (itemNum < 0) {
                break
              }
              let item = ITEM[itemNum]
              if (item.TYPE != i) {
                continue
              }
              let equip = targetChar['char'].Equip[j]
              if (equip == 1 || equip == 3 || (curseOK && equip == 2)) {
                targetChar['char'].Equip[j] = 0
                printDebugMessage(
                  this.getName(targetChar, true) +
                    ' remove equip [' +
                    item.NAME[1] +
                    ']'
                )
              }
            }
          }
        }
      } else if (ef == 33) {
        if (!this.activateCheck(efTarget, 'csbte', 'a', 'p')) {
          continue
        }
        printDebugMessage('[SpellEffect] forced equipment')
        let equipItemNum = Number(efAry[2])
        let curseOK = false
        if (efAry[3] == '1') {
          curseOK = true
        }
        let loopAry = this.getTarget(efTarget, targetCharNum, true, 'pc')
        for (let tNum = 0; tNum < loopAry.length; tNum++) {
          effectCheck = true
          let targetChar = this.setCharData(loopAry[tNum])
          if (this.checkSpellCancel(targetChar)) {
            continue
          }
          if (equipItemNum < 0) {
            continue
          }
          let equipItemHaveNum = targetChar['char'].haveItem(equipItemNum, 0)
          if (equipItemHaveNum < 0) {
            continue
          }
          let equipItem = ITEM[equipItemNum]
          if (!equipItem.equipCheck(targetChar['num'])) {
            continue
          }
          if (!curseOK && targetChar['char'].kindCursedCheck(equipItem.TYPE)) {
            continue
          }
          if (equipItem.TYPE == 0 && equipItem.WEAPON_TYPE == 2) {
            let subWeaponHaveNum = targetChar['char'].kindEquipedItem(7)
            if (subWeaponHaveNum > -1) {
              let itemNum = targetChar['char'].Item[subWeaponHaveNum]
              if (equipItemNum == itemNum) {
                continue
              }
            }
          } else {
            let itemHaveNum = targetChar['char'].kindEquipedItem(
              equipItem.TYPE,
              true
            )
            if (itemHaveNum > -1) {
              let itemNum = targetChar['char'].Item[itemHaveNum]
              if (equipItemNum == itemNum) {
                continue
              }
            }
          }
          if (equipItem.TYPE == 0) {
            let shieldHaveNum = targetChar['char'].kindEquipedItem(2, true)
            let subWeaponHaveNum = targetChar['char'].kindEquipedItem(7)
            if (
              (equipItem.WEAPON_TYPE == 1 ||
                (equipItem.WEAPON_TYPE == 2 &&
                  targetChar['char'].kindEquipedItem(0) > -1)) &&
              shieldHaveNum > -1
            ) {
              if (!curseOK && targetChar['char'].kindCursedCheck(2)) {
                continue
              }
              targetChar['char'].Equip[shieldHaveNum] = 0
            } else if (equipItem.WEAPON_TYPE == 1 && subWeaponHaveNum > -1) {
              targetChar['char'].Equip[subWeaponHaveNum] = 0
            }
          } else if (equipItem.TYPE == 2) {
            let mainWeaponHaveNum = targetChar['char'].kindEquipedItem(0, true)
            let subWeaponHaveNum = targetChar['char'].kindEquipedItem(7)
            if (mainWeaponHaveNum > -1) {
              let weapon = ITEM[targetChar['char'].Item[mainWeaponHaveNum]]
              if (weapon.WEAPON_TYPE == 1) {
                if (!curseOK && targetChar['char'].kindCursedCheck(0)) {
                  continue
                }
                targetChar['char'].Equip[mainWeaponHaveNum] = 0
              } else if (subWeaponHaveNum > -1) {
                targetChar['char'].Equip[subWeaponHaveNum] = 0
              }
            }
          }
          let equipFlag = false
          if (
            equipItem.TYPE == 0 &&
            equipItem.WEAPON_TYPE == 2 &&
            !equipItem.curseCheck(targetChar['num']) &&
            !targetChar['char'].kindCursedCheck(0)
          ) {
            let subWeaponHaveNum = targetChar['char'].kindEquipedItem(7)
            if (subWeaponHaveNum > -1) {
              targetChar['char'].Equip[subWeaponHaveNum] = 0
            }
            let mainWeaponHaveNum = targetChar['char'].kindEquipedItem(0, true)
            if (mainWeaponHaveNum > -1) {
              let weapon = ITEM[targetChar['char'].Item[mainWeaponHaveNum]]
              if (weapon.WEAPON_TYPE != 1) {
                targetChar['char'].Equip[equipItemHaveNum] = 3
                printDebugMessage(
                  this.getName(targetChar, true) +
                    ' equip (sub)[' +
                    equipItem.NAME[1] +
                    ']'
                )
              } else {
                targetChar['char'].Equip[mainWeaponHaveNum] = 0
                equipFlag = true
              }
            } else {
              equipFlag = true
            }
          } else {
            if (equipItem.TYPE == 0) {
              let subWeaponHaveNum = targetChar['char'].kindEquipedItem(7)
              if (subWeaponHaveNum > -1) {
                targetChar['char'].Equip[subWeaponHaveNum] = 0
              }
            }
            let itemHaveNum = targetChar['char'].kindEquipedItem(
              equipItem.TYPE,
              true
            )
            if (itemHaveNum > -1) {
              targetChar['char'].Equip[itemHaveNum] = 0
            }
            equipFlag = true
          }
          if (equipFlag) {
            if (equipItem.curseCheck(targetChar['num'])) {
              targetChar['char'].Equip[equipItemHaveNum] = 2
              printDebugMessage(
                this.getName(targetChar, true) +
                  ' equip (curse)[' +
                  equipItem.NAME[1] +
                  ']'
              )
            } else {
              targetChar['char'].Equip[equipItemHaveNum] = 1
              printDebugMessage(
                this.getName(targetChar, true) +
                  ' equip [' +
                  equipItem.NAME[1] +
                  ']'
              )
            }
          }
        }
      } else if (
        ef == 50 ||
        ef == 52 ||
        ef == 54 ||
        ef == 56 ||
        ef == 58 ||
        ef == 61 ||
        ef == 64 ||
        ef == 66 ||
        ef == 68 ||
        ef == 70 ||
        ef == 72 ||
        ef == 74
      ) {
        if (!this.activateCheck(efTarget, 'csbte', 'a', 'p')) {
          continue
        }
        let abi = 0
        if (ef == 64) {
          abi = Number(efAry[5])
          if (abi < 0 || abi >= GameData['ABILITY'].length) {
            abi = 0
          }
        }
        if (ef == 50) {
          printDebugMessage('[SpellEffect] correct AC')
        } else if (ef == 52) {
          printDebugMessage('[SpellEffect] correct hit')
        } else if (ef == 54) {
          printDebugMessage('[SpellEffect] correct spell cancel')
        } else if (ef == 56) {
          printDebugMessage('[SpellEffect] correct resist')
        } else if (ef == 58) {
          printDebugMessage('[SpellEffect] correct breath resist')
        } else if (ef == 61) {
          printDebugMessage('[SpellEffect] correct continuing heal')
        } else if (ef == 64) {
          printDebugMessage(
            '[SpellEffect] correct ability ' + GameData['ABILITY'][abi]
          )
        } else if (ef == 66) {
          printDebugMessage('[SpellEffect] correct additional damage')
        } else if (ef == 68) {
          printDebugMessage('[SpellEffect] temporary change max hp')
        } else if (ef == 70) {
          printDebugMessage('[SpellEffect] correct attack count')
        } else if (ef == 72) {
          printDebugMessage('[SpellEffect] resistance is given')
        } else if (ef == 74) {
          printDebugMessage('[SpellEffect] enchanted weapons')
        }
        let duration = Number(efAry[3])
        efAry = this.replaceMyAndTargetEffectAry(
          efAry,
          [2, 4],
          castChar['type']
        )
        if (efTarget == 3) {
          effectCheck = true
          let value = this.calculationMyAndTarget(efAry[2], castChar, null, 'f')
          if (ef == 50) {
            pt.SpellEffectRate[0] = duration
            if (value < -2000) {
              value = -2000
            } else if (value > 2000) {
              value = 2000
            }
            pt.SpellEffectPlus[0] = value
            if (value != 0) {
              printDebugMessage('[Party] acPlus:' + String(value))
              for (let i = 0; i < ptMemberNum; i++) {
                this.controlResultChar(
                  'push',
                  this.setCharData(i),
                  'acPlus,' + String(value)
                )
              }
            }
          } else if (ef == 52) {
            pt.SpellEffectRate[1] = duration
            if (value < -4000) {
              value = -4000
            } else if (value > 4000) {
              value = 4000
            }
            pt.SpellEffectPlus[1] = value
            if (value != 0) {
              printDebugMessage('[Party] hitPlus:' + String(value))
              for (let i = 0; i < ptMemberNum; i++) {
                this.controlResultChar(
                  'push',
                  this.setCharData(i),
                  'hitPlus,' + String(value)
                )
              }
            }
          } else if (ef == 54) {
            pt.SpellEffectRate[2] = duration
            if (value < -2000) {
              value = -2000
            } else if (value > 2000) {
              value = 2000
            }
            pt.SpellEffectPlus[2] = value
            if (value != 0) {
              printDebugMessage('[Party] spellCancelPlus:' + String(value))
              for (let i = 0; i < ptMemberNum; i++) {
                this.controlResultChar(
                  'push',
                  this.setCharData(i),
                  'spellCancelPlus,' + String(value)
                )
              }
            }
          } else if (ef == 56) {
            pt.SpellEffectRate[3] = duration
            if (value < -99999) {
              value = -99999
            } else if (value > 99999) {
              value = 99999
            }
            pt.SpellEffectPlus[3] = value
            if (value != 0) {
              printDebugMessage('[Party] spellResistPlus:' + String(value))
              for (let i = 0; i < ptMemberNum; i++) {
                this.controlResultChar(
                  'push',
                  this.setCharData(i),
                  'spellResistPlus,' + String(value)
                )
              }
            }
          } else if (ef == 58) {
            pt.SpellEffectRate[4] = duration
            if (value < -99999) {
              value = -99999
            } else if (value > 99999) {
              value = 99999
            }
            pt.SpellEffectPlus[4] = value
            if (value != 0) {
              printDebugMessage('[Party] breathResistPlus:' + String(value))
              for (let i = 0; i < ptMemberNum; i++) {
                this.controlResultChar(
                  'push',
                  this.setCharData(i),
                  'breathResistPlus,' + String(value)
                )
              }
            }
          } else if (ef == 61) {
            pt.SpellEffectRate[5] = duration
            if (value < -200000) {
              value = -200000
            } else if (value > 200000) {
              value = 200000
            }
            pt.SpellEffectPlus[5] = value
            printDebugMessage('[Party] continuingHeal:' + String(value))
          } else if (ef == 64) {
            pt.AbiRate[abi] = duration
            if (value < -2000) {
              value = -2000
            } else if (value > 2000) {
              value = 2000
            }
            pt.AbiPlus[abi] = value
            if (value != 0) {
              printDebugMessage(
                '[Party] abilityPlus ' +
                  GameData['ABILITY'][abi] +
                  ':' +
                  String(value)
              )
              if (
                !(
                  GameData['ABILITY_NOT_DISPLAY'][abi] &&
                  GameData[
                    'MODIFYING_EFFECTS_ON_HIDDEN_ABILITY_ARE_NOT_DISPLAYED'
                  ]
                )
              ) {
                for (let i = 0; i < ptMemberNum; i++) {
                  this.controlResultChar(
                    'push',
                    this.setCharData(i),
                    'abilityPlus,' + String(abi) + ',' + String(value)
                  )
                }
              }
            }
          } else if (ef == 66) {
            pt.SpellEffectRate[6] = duration
            if (value < -200000) {
              value = -200000
            } else if (value > 200000) {
              value = 200000
            }
            pt.SpellEffectPlus[6] = value
            if (value != 0) {
              printDebugMessage('[Party] addDamagePlus:' + String(value))
              for (let i = 0; i < ptMemberNum; i++) {
                this.controlResultChar(
                  'push',
                  this.setCharData(i),
                  'addDamagePlus,' + String(value)
                )
              }
            }
          } else if (ef == 68) {
            pt.SpellEffectRate[7] = duration
            if (value < -99999) {
              value = -99999
            } else if (value > 99999) {
              value = 99999
            }
            pt.SpellEffectPlus[7] = value
            if (value != 0) {
              printDebugMessage('[Party] hpMaxPlus:' + String(value))
              for (let i = 0; i < ptMemberNum; i++) {
                this.controlResultChar(
                  'push',
                  this.setCharData(i),
                  'hpMaxPlus,' + String(value)
                )
              }
            }
          } else if (ef == 70) {
            pt.SpellEffectRate[8] = duration
            if (value < -200) {
              value = -200
            } else if (value > 200) {
              value = 200
            }
            pt.SpellEffectPlus[8] = value
            if (value != 0) {
              printDebugMessage('[Party] atCountPlus:' + String(value))
              for (let i = 0; i < ptMemberNum; i++) {
                this.controlResultChar(
                  'push',
                  this.setCharData(i),
                  'atCountPlus,' + String(value)
                )
              }
            }
          } else if (ef == 72) {
            if (value < -2) {
              value = -2
            } else if (value > 1) {
              value = 1
            }
            for (let i = 0; i < 15; i++) {
              if (efAry[5].indexOf(i.toString(16)) > -1) {
                pt.ResistPlus[i] = value
                if (value == -2) {
                  pt.ResistRate[i] = 0
                } else {
                  pt.ResistRate[i] = duration
                }
                if (value > -2) {
                  printDebugMessage(
                    '[Party] resistPlus ' +
                      getDefaultMessage(RESIST_ATTRIBUTE_STR[i], 1) +
                      ':' +
                      String(value)
                  )
                  for (let j = 0; j < ptMemberNum; j++) {
                    this.controlResultChar(
                      'push',
                      this.setCharData(j),
                      'resistPlus,' + String(i) + ',' + String(value)
                    )
                  }
                }
              }
            }
          } else if (ef == 74) {
            let atFlag = false
            if (value > -1) {
              atFlag = true
            }
            for (let i = 0; i < 6; i++) {
              if (efAry[5].indexOf(String(i)) > -1) {
                pt.AttackAddPlus[i] = atFlag
                if (atFlag) {
                  pt.AttackAddRate[i] = duration
                } else {
                  pt.AttackAddRate[i] = 0
                }
                if (i == 5) {
                  if (atFlag) {
                    if (value > 99999) {
                      value = 99999
                    }
                    pt.PoisonPlus = value
                  } else {
                    pt.PoisonPlus = 0
                  }
                }
                if (atFlag) {
                  printDebugMessage(
                    '[Party] attackAddPlus:' +
                      getDefaultMessage(ATTACK_ADD_DEBUG_STR[i], 1)
                  )
                  for (let j = 0; j < ptMemberNum; j++) {
                    this.controlResultChar(
                      'push',
                      this.setCharData(j),
                      'attackAddPlus,' + String(i)
                    )
                  }
                }
              }
            }
          }
          pt.check()
        } else {
          let loopAry = this.getTarget(efTarget, targetCharNum, false, 'pc')
          for (let tNum = 0; tNum < loopAry.length; tNum++) {
            effectCheck = true
            let targetChar = this.setCharData(loopAry[tNum])
            let efAry2 = this.replaceMyAndTargetEffectAry(
              efAry,
              [2, 4],
              null,
              targetChar['type']
            )
            let prob = this.calculationResist(efAry2[4], targetChar)
            if (prob >= dice(1, 100)) {
              printDebugMessage(
                this.getName(targetChar, true) + ' resist succes'
              )
              this.controlResultChar('push', targetChar, 'resist')
              continue
            }
            let value = this.calculationMyAndTarget(
              efAry2[2],
              castChar,
              targetChar,
              'f'
            )
            if (ef == 50) {
              targetChar['char'].SpellEffectRate[0] = duration
              if (value < -2000) {
                value = -2000
              } else if (value > 2000) {
                value = 2000
              }
              targetChar['char'].SpellEffectPlus[0] = value
              if (value != 0) {
                printDebugMessage(
                  this.getName(targetChar, true) + ' acPlus:' + String(value)
                )
                this.controlResultChar(
                  'push',
                  targetChar,
                  'acPlus,' + String(value)
                )
              }
            } else if (ef == 52) {
              targetChar['char'].SpellEffectRate[1] = duration
              if (value < -4000) {
                value = -4000
              } else if (value > 4000) {
                value = 4000
              }
              targetChar['char'].SpellEffectPlus[1] = value
              if (value != 0) {
                printDebugMessage(
                  this.getName(targetChar, true) + ' hitPlus:' + String(value)
                )
                this.controlResultChar(
                  'push',
                  targetChar,
                  'hitPlus,' + String(value)
                )
              }
            } else if (ef == 54) {
              targetChar['char'].SpellEffectRate[2] = duration
              if (value < -2000) {
                value = -2000
              } else if (value > 2000) {
                value = 2000
              }
              targetChar['char'].SpellEffectPlus[2] = value
              if (value != 0) {
                printDebugMessage(
                  this.getName(targetChar, true) +
                    ' spellCancelPlus:' +
                    String(value)
                )
                this.controlResultChar(
                  'push',
                  targetChar,
                  'spellCancelPlus,' + String(value)
                )
              }
            } else if (ef == 56) {
              targetChar['char'].SpellEffectRate[3] = duration
              if (value < -99999) {
                value = -99999
              } else if (value > 99999) {
                value = 99999
              }
              targetChar['char'].SpellEffectPlus[3] = value
              if (value != 0) {
                printDebugMessage(
                  this.getName(targetChar, true) +
                    ' spellResistPlus:' +
                    String(value)
                )
                this.controlResultChar(
                  'push',
                  targetChar,
                  'spellResistPlus,' + String(value)
                )
              }
            } else if (ef == 58) {
              targetChar['char'].SpellEffectRate[4] = duration
              if (value < -99999) {
                value = -99999
              } else if (value > 99999) {
                value = 99999
              }
              targetChar['char'].SpellEffectPlus[4] = value
              if (value != 0) {
                printDebugMessage(
                  this.getName(targetChar, true) +
                    ' breathResistPlus:' +
                    String(value)
                )
                this.controlResultChar(
                  'push',
                  targetChar,
                  'breathResistPlus,' + String(value)
                )
              }
            } else if (ef == 61) {
              targetChar['char'].SpellEffectRate[5] = duration
              if (value < -200000) {
                value = -200000
              } else if (value > 200000) {
                value = 200000
              }
              targetChar['char'].SpellEffectPlus[5] = value
              printDebugMessage(
                this.getName(targetChar, true) +
                  ' continuingHeal:' +
                  String(value)
              )
            } else if (ef == 64) {
              targetChar['char'].AbiRate[abi] = duration
              if (value < -2000) {
                value = -2000
              } else if (value > 2000) {
                value = 2000
              }
              targetChar['char'].AbiPlus[abi] = value
              if (value != 0) {
                printDebugMessage(
                  this.getName(targetChar, true) +
                    ' abilityPlus ' +
                    GameData['ABILITY'][abi] +
                    ':' +
                    String(value)
                )
                if (
                  !(
                    GameData['ABILITY_NOT_DISPLAY'][abi] &&
                    GameData[
                      'MODIFYING_EFFECTS_ON_HIDDEN_ABILITY_ARE_NOT_DISPLAYED'
                    ]
                  )
                ) {
                  this.controlResultChar(
                    'push',
                    targetChar,
                    'abilityPlus,' + String(abi) + ',' + String(value)
                  )
                }
              }
            } else if (ef == 66) {
              targetChar['char'].SpellEffectRate[6] = duration
              if (value < -200000) {
                value = -200000
              } else if (value > 200000) {
                value = 200000
              }
              targetChar['char'].SpellEffectPlus[6] = value
              if (value != 0) {
                printDebugMessage(
                  this.getName(targetChar, true) +
                    ' addDamagePlus:' +
                    String(value)
                )
                this.controlResultChar(
                  'push',
                  targetChar,
                  'addDamagePlus,' + String(value)
                )
              }
            } else if (ef == 68) {
              targetChar['char'].SpellEffectRate[7] = duration
              if (value < -99999) {
                value = -99999
              } else if (value > 99999) {
                value = 99999
              }
              targetChar['char'].SpellEffectPlus[7] = value
              if (value != 0) {
                printDebugMessage(
                  this.getName(targetChar, true) + ' hpMaxPlus:' + String(value)
                )
                this.controlResultChar(
                  'push',
                  targetChar,
                  'hpMaxPlus,' + String(value)
                )
              }
            } else if (ef == 70) {
              targetChar['char'].SpellEffectRate[8] = duration
              if (value < -200) {
                value = -200
              } else if (value > 200) {
                value = 200
              }
              targetChar['char'].SpellEffectPlus[8] = value
              if (value != 0) {
                printDebugMessage(
                  this.getName(targetChar, true) +
                    ' atCountPlus:' +
                    String(value)
                )
                this.controlResultChar(
                  'push',
                  targetChar,
                  'atCountPlus,' + String(value)
                )
              }
            } else if (ef == 72) {
              if (value < -2) {
                value = -2
              } else if (value > 1) {
                value = 1
              }
              for (let i = 0; i < 15; i++) {
                if (efAry2[5].indexOf(i.toString(16)) > -1) {
                  targetChar['char'].ResistPlus[i] = value
                  if (value == -2) {
                    targetChar['char'].ResistRate[i] = 0
                  } else {
                    targetChar['char'].ResistRate[i] = duration
                  }
                  if (value > -2) {
                    printDebugMessage(
                      this.getName(targetChar, true) +
                        ' resistPlus ' +
                        getDefaultMessage(RESIST_ATTRIBUTE_STR[i], 1) +
                        ':' +
                        String(value)
                    )
                    this.controlResultChar(
                      'push',
                      targetChar,
                      'resistPlus,' + String(i) + ',' + String(value)
                    )
                  }
                }
              }
            } else if (ef == 74) {
              let atFlag = false
              if (value > -1) {
                atFlag = true
              }
              for (let i = 0; i < 6; i++) {
                if (efAry2[5].indexOf(String(i)) > -1) {
                  targetChar['char'].AttackAddPlus[i] = atFlag
                  if (atFlag) {
                    targetChar['char'].AttackAddRate[i] = duration
                  } else {
                    targetChar['char'].AttackAddRate[i] = 0
                  }
                  if (i == 5) {
                    if (atFlag) {
                      if (value > 99999) {
                        value = 99999
                      }
                      targetChar['char'].PoisonPlus = value
                    } else {
                      targetChar['char'].PoisonPlus = 0
                    }
                  }
                  if (atFlag) {
                    printDebugMessage(
                      this.getName(targetChar, true) +
                        ' attackAddPlus:' +
                        getDefaultMessage(ATTACK_ADD_DEBUG_STR[i], 1)
                    )
                    this.controlResultChar(
                      'push',
                      targetChar,
                      'attackAddPlus,' + String(i)
                    )
                  }
                }
              }
            }
            targetChar['char'].check()
          }
        }
      } else if (
        ef == 51 ||
        ef == 53 ||
        ef == 55 ||
        ef == 57 ||
        ef == 59 ||
        ef == 62 ||
        ef == 63 ||
        ef == 67 ||
        ef == 69 ||
        ef == 71
      ) {
        if (!this.activateCheck(efTarget, 'b', 'a', 'a')) {
          continue
        }
        if (ef == 51) {
          printDebugMessage('[SpellEffect] correct AC (battle)')
        } else if (ef == 53) {
          printDebugMessage('[SpellEffect] correct hit (battle)')
        } else if (ef == 55) {
          printDebugMessage('[SpellEffect] correct spell cancel (battle)')
        } else if (ef == 57) {
          printDebugMessage('[SpellEffect] correct resist (battle)')
        } else if (ef == 59) {
          printDebugMessage('[SpellEffect] correct breath resist (battle)')
        } else if (ef == 62) {
          printDebugMessage('[SpellEffect] correct continuing heal (battle)')
        } else if (ef == 63) {
          printDebugMessage('[SpellEffect] breath barrier')
        } else if (ef == 67) {
          printDebugMessage('[SpellEffect] correct additional damage (battle)')
        } else if (ef == 69) {
          printDebugMessage('[SpellEffect] temporary change max hp (battle)')
        } else if (ef == 71) {
          printDebugMessage('[SpellEffect] correct attack count (battle)')
        }
        efAry = this.replaceMyAndTargetEffectAry(
          efAry,
          [2, 3, 4, 5, 7],
          castChar['type']
        )
        let loopAry = this.getTarget(efTarget, targetCharNum)
        for (let tNum = 0; tNum < loopAry.length; tNum++) {
          effectCheck = true
          let targetChar = this.setCharData(loopAry[tNum])
          if (this.checkSpellCancel(targetChar)) {
            continue
          }
          let efAry2 = this.replaceMyAndTargetEffectAry(
            efAry,
            [2, 3, 4, 5, 7],
            null,
            targetChar['type']
          )
          let prob = this.calculationResist(efAry2[3], targetChar)
          if (prob >= dice(1, 100)) {
            printDebugMessage(this.getName(targetChar, true) + ' resist succes')
            this.controlResultChar('push', targetChar, 'resist')
            continue
          }
          let value = this.calculationMyAndTarget(
            efAry2[2],
            castChar,
            targetChar,
            'f'
          )
          let ckLimitU = false,
            ckLimitL = false,
            ckRound = false
          let limitU = 0,
            limitL = 0
          if (efAry2[4] != '') {
            ckLimitU = true
            limitU = this.calculationMyAndTarget(
              efAry2[4],
              castChar,
              targetChar,
              'f'
            )
          }
          if (efAry2[5] != '') {
            ckLimitL = true
            limitL = this.calculationMyAndTarget(
              efAry2[5],
              castChar,
              targetChar,
              'f'
            )
          }
          if (efAry2[6] == '1') {
            ckRound = true
          }
          let limitTurn = this.calculationMyAndTarget(
            efAry2[7],
            castChar,
            targetChar,
            'f'
          )
          let num = 0
          if (ef == 51) {
            num = targetChar['char'].BtSpellEffectPlus[0]
          } else if (ef == 53) {
            num = targetChar['char'].BtSpellEffectPlus[1]
          } else if (ef == 55) {
            num = targetChar['char'].BtSpellEffectPlus[2]
          } else if (ef == 57) {
            num = targetChar['char'].BtSpellEffectPlus[3]
          } else if (ef == 59) {
            num = targetChar['char'].BtSpellEffectPlus[4]
          } else if (ef == 62) {
            num = targetChar['char'].BtSpellEffectPlus[5]
          } else if (ef == 63) {
            num = targetChar['char'].BtOnlySpellEffectPlus[0]
          } else if (ef == 67) {
            num = targetChar['char'].BtSpellEffectPlus[6]
          } else if (ef == 69) {
            num = targetChar['char'].BtSpellEffectPlus[7]
          } else if (ef == 71) {
            num = targetChar['char'].BtSpellEffectPlus[8]
          }
          if (ckLimitU || ckLimitL) {
            let oVal = num
            if (!ckRound) {
              if (ckLimitU && ckLimitL) {
                if (num < limitU && num > limitL) {
                  num += value
                }
              } else if (ckLimitU) {
                if (num < limitU) {
                  num += value
                }
              } else if (ckLimitL) {
                if (num > limitL) {
                  num += value
                }
              }
            } else {
              num += value
              if (ckLimitU) {
                if (num > limitU) {
                  num = limitU
                }
              }
              if (ckLimitL) {
                if (num < limitL) {
                  num = limitL
                }
              }
            }
            value = num - oVal
          } else {
            num += value
          }
          if (ef == 51) {
            if (num < -2000) {
              num = -2000
            } else if (num > 2000) {
              num = 2000
            }
            targetChar['char'].BtSpellEffectPlus[0] = num
            targetChar['char'].BtSpellEffectTurn[0] = limitTurn
            if (value != 0) {
              printDebugMessage(
                this.getName(targetChar, true) + ' acPlus:' + String(value)
              )
              this.controlResultChar(
                'push',
                targetChar,
                'acPlus,' + String(value)
              )
            }
          } else if (ef == 53) {
            if (num < -4000) {
              num = -4000
            } else if (num > 4000) {
              num = 4000
            }
            targetChar['char'].BtSpellEffectPlus[1] = num
            targetChar['char'].BtSpellEffectTurn[1] = limitTurn
            if (value != 0) {
              printDebugMessage(
                this.getName(targetChar, true) + ' hitPlus:' + String(value)
              )
              this.controlResultChar(
                'push',
                targetChar,
                'hitPlus,' + String(value)
              )
            }
          } else if (ef == 55) {
            if (num < -2000) {
              num = -2000
            } else if (num > 2000) {
              num = 2000
            }
            targetChar['char'].BtSpellEffectPlus[2] = num
            targetChar['char'].BtSpellEffectTurn[2] = limitTurn
            if (value != 0) {
              printDebugMessage(
                this.getName(targetChar, true) +
                  ' spellCancelPlus:' +
                  String(value)
              )
              this.controlResultChar(
                'push',
                targetChar,
                'spellCancelPlus,' + String(value)
              )
            }
          } else if (ef == 57) {
            if (num < -99999) {
              num = -99999
            } else if (num > 99999) {
              num = 99999
            }
            targetChar['char'].BtSpellEffectPlus[3] = num
            targetChar['char'].BtSpellEffectTurn[3] = limitTurn
            if (value != 0) {
              printDebugMessage(
                this.getName(targetChar, true) +
                  ' spellResistPlus:' +
                  String(value)
              )
              this.controlResultChar(
                'push',
                targetChar,
                'spellResistPlus,' + String(value)
              )
            }
          } else if (ef == 59) {
            if (num < -99999) {
              num = -99999
            } else if (num > 99999) {
              num = 99999
            }
            targetChar['char'].BtSpellEffectPlus[4] = num
            targetChar['char'].BtSpellEffectTurn[4] = limitTurn
            if (value != 0) {
              printDebugMessage(
                this.getName(targetChar, true) +
                  ' breathResistPlus:' +
                  String(value)
              )
              this.controlResultChar(
                'push',
                targetChar,
                'breathResistPlus,' + String(value)
              )
            }
          } else if (ef == 62) {
            if (num < -200000) {
              num = -200000
            } else if (num > 200000) {
              num = 200000
            }
            targetChar['char'].BtSpellEffectPlus[5] = num
            targetChar['char'].BtSpellEffectTurn[5] = limitTurn
            printDebugMessage(
              this.getName(targetChar, true) +
                ' continuingHeal:' +
                String(value)
            )
          } else if (ef == 63) {
            if (num < 0) {
              num = 0
            } else if (num > 99999) {
              num = 99999
            }
            targetChar['char'].BtOnlySpellEffectPlus[0] = num
            targetChar['char'].BtOnlySpellEffectTurn[0] = limitTurn
            if (value != 0) {
              printDebugMessage(
                this.getName(targetChar, true) +
                  ' breathBarrierPlus:' +
                  String(value)
              )
              this.controlResultChar(
                'push',
                targetChar,
                'breathBarrierPlus,' + String(value)
              )
            }
          } else if (ef == 67) {
            if (num < -200000) {
              num = -200000
            } else if (num > 200000) {
              num = 200000
            }
            targetChar['char'].BtSpellEffectPlus[6] = num
            targetChar['char'].BtSpellEffectTurn[6] = limitTurn
            if (value != 0) {
              printDebugMessage(
                this.getName(targetChar, true) +
                  ' addDamagePlus:' +
                  String(value)
              )
              this.controlResultChar(
                'push',
                targetChar,
                'addDamagePlus,' + String(value)
              )
            }
          } else if (ef == 69) {
            if (targetChar['type'] == 'pc') {
              if (num < -99999) {
                num = -99999
              } else if (num > 99999) {
                num = 99999
              }
            } else {
              if (num < -999999999) {
                num = -999999999
              } else if (num > 999999999) {
                num = 999999999
              }
            }
            targetChar['char'].BtSpellEffectPlus[7] = num
            targetChar['char'].BtSpellEffectTurn[7] = limitTurn
            if (value != 0) {
              printDebugMessage(
                this.getName(targetChar, true) + ' hpMaxPlus:' + String(value)
              )
              this.controlResultChar(
                'push',
                targetChar,
                'hpMaxPlus,' + String(value)
              )
            }
          } else if (ef == 71) {
            if (num < -200) {
              num = -200
            } else if (num > 200) {
              num = 200
            }
            targetChar['char'].BtSpellEffectPlus[8] = num
            targetChar['char'].BtSpellEffectTurn[8] = limitTurn
            if (value != 0) {
              printDebugMessage(
                this.getName(targetChar, true) + ' atCountPlus:' + String(value)
              )
              this.controlResultChar(
                'push',
                targetChar,
                'atCountPlus,' + String(value)
              )
            }
          }
          targetChar['char'].check()
        }
      } else if (ef == 60) {
        if (!this.activateCheck(efTarget, 'csbte', 'a', 'p')) {
          continue
        }
        printDebugMessage('[SpellEffect] seal spell')
        efAry = this.replaceMyAndTargetEffectAry(efAry, [3], castChar['type'])
        let loopAry = this.getTarget(efTarget, targetCharNum, false, 'pc')
        for (let tNum = 0; tNum < loopAry.length; tNum++) {
          effectCheck = true
          let targetChar = this.setCharData(loopAry[tNum])
          let efAry2 = this.replaceMyAndTargetEffectAry(
            efAry,
            [3],
            null,
            targetChar['type']
          )
          let prob = this.calculationResist(efAry2[3], targetChar)
          if (prob >= dice(1, 100)) {
            printDebugMessage(this.getName(targetChar, true) + ' resist succes')
            this.controlResultChar('push', targetChar, 'resist')
            continue
          }
          let duration = Number(efAry2[2])
          targetChar['char'].SealSpell = true
          targetChar['char'].SealSpellInt = duration
          printDebugMessage(this.getName(targetChar, true) + ' sealSpell')
          this.controlResultChar('push', targetChar, 'sealSpell')
          targetChar['char'].check()
        }
      } else if (ef == 65) {
        if (!this.activateCheck(efTarget, 'b', 'a', 'a')) {
          continue
        }
        let abi = Number(efAry[4])
        if (abi < 0 || abi >= GameData['ABILITY'].length) {
          abi = 0
        }
        printDebugMessage(
          '[SpellEffect] correct ability ' +
            GameData['ABILITY'][abi] +
            ' (battle)'
        )
        efAry = this.replaceMyAndTargetEffectAry(
          efAry,
          [2, 3, 5, 6, 8],
          castChar['type']
        )
        let loopAry = this.getTarget(efTarget, targetCharNum)
        for (let tNum = 0; tNum < loopAry.length; tNum++) {
          effectCheck = true
          let targetChar = this.setCharData(loopAry[tNum])
          if (this.checkSpellCancel(targetChar)) {
            continue
          }
          let efAry2 = this.replaceMyAndTargetEffectAry(
            efAry,
            [2, 3, 5, 6, 8],
            null,
            targetChar['type']
          )
          let prob = this.calculationResist(efAry2[3], targetChar)
          if (prob >= dice(1, 100)) {
            printDebugMessage(this.getName(targetChar, true) + ' resist succes')
            this.controlResultChar('push', targetChar, 'resist')
            continue
          }
          let value = this.calculationMyAndTarget(
            efAry2[2],
            castChar,
            targetChar,
            'f'
          )
          let ckLimitU = false,
            ckLimitL = false,
            ckRound = false
          let limitU = 0,
            limitL = 0
          if (efAry2[5] != '') {
            ckLimitU = true
            limitU = this.calculationMyAndTarget(
              efAry2[5],
              castChar,
              targetChar,
              'f'
            )
          }
          if (efAry2[6] != '') {
            ckLimitL = true
            limitL = this.calculationMyAndTarget(
              efAry2[6],
              castChar,
              targetChar,
              'f'
            )
          }
          if (efAry2[7] == '1') {
            ckRound = true
          }
          let limitTurn = this.calculationMyAndTarget(
            efAry2[8],
            castChar,
            targetChar,
            'f'
          )
          let num = targetChar['char'].Bt_abiPlus[abi]
          if (ckLimitU || ckLimitL) {
            let oVal = num
            if (!ckRound) {
              if (ckLimitU && ckLimitL) {
                if (num < limitU && num > limitL) {
                  num += value
                }
              } else if (ckLimitU) {
                if (num < limitU) {
                  num += value
                }
              } else if (ckLimitL) {
                if (num > limitL) {
                  num += value
                }
              }
            } else {
              num += value
              if (ckLimitU) {
                if (num > limitU) {
                  num = limitU
                }
              }
              if (ckLimitL) {
                if (num < limitL) {
                  num = limitL
                }
              }
            }
            value = num - oVal
          } else {
            num += value
          }
          if (num < -2000) {
            num = -2000
          } else if (num > 2000) {
            num = 2000
          }
          targetChar['char'].Bt_abiPlus[abi] = num
          targetChar['char'].AbiTurn[abi] = limitTurn
          if (value != 0) {
            printDebugMessage(
              this.getName(targetChar, true) +
                ' abilityPlus ' +
                GameData['ABILITY'][abi] +
                ':' +
                String(value)
            )
            if (
              !(
                GameData['ABILITY_NOT_DISPLAY'][abi] &&
                GameData[
                  'MODIFYING_EFFECTS_ON_HIDDEN_ABILITY_ARE_NOT_DISPLAYED'
                ]
              )
            ) {
              this.controlResultChar(
                'push',
                targetChar,
                'abilityPlus,' + String(abi) + ',' + String(value)
              )
            }
          }
          targetChar['char'].check()
        }
      } else if (ef == 73 || ef == 75) {
        if (!this.activateCheck(efTarget, 'b', 'a', 'a')) {
          continue
        }
        if (ef == 73) {
          printDebugMessage('[SpellEffect] resistance is given (battle)')
        } else if (ef == 75) {
          printDebugMessage('[SpellEffect] enchanted weapons (battle)')
        }
        efAry = this.replaceMyAndTargetEffectAry(
          efAry,
          [2, 3, 5],
          castChar['type']
        )
        let loopAry = this.getTarget(efTarget, targetCharNum)
        for (let tNum = 0; tNum < loopAry.length; tNum++) {
          effectCheck = true
          let targetChar = this.setCharData(loopAry[tNum])
          if (this.checkSpellCancel(targetChar)) {
            continue
          }
          let efAry2 = this.replaceMyAndTargetEffectAry(
            efAry,
            [2, 3, 5],
            null,
            targetChar['type']
          )
          let prob = this.calculationResist(efAry2[3], targetChar)
          if (prob >= dice(1, 100)) {
            printDebugMessage(this.getName(targetChar, true) + ' resist succes')
            this.controlResultChar('push', targetChar, 'resist')
            continue
          }
          let value = this.calculationMyAndTarget(
            efAry2[2],
            castChar,
            targetChar,
            'f'
          )
          let limitTurn = this.calculationMyAndTarget(
            efAry2[5],
            castChar,
            targetChar,
            'f'
          )
          if (ef == 73) {
            if (value < -2) {
              value = -2
            } else if (value > 1) {
              value = 1
            }
            for (let i = 0; i < 15; i++) {
              if (efAry2[4].indexOf(i.toString(16)) > -1) {
                targetChar['char'].Bt_resistPlus[i] = value
                if (value == -2) {
                  targetChar['char'].ResistTurn[i] = -1
                } else {
                  targetChar['char'].ResistTurn[i] = limitTurn
                }
                if (value > -2) {
                  printDebugMessage(
                    this.getName(targetChar, true) +
                      ' resistPlus ' +
                      getDefaultMessage(RESIST_ATTRIBUTE_STR[i], 1) +
                      ':' +
                      String(value)
                  )
                  this.controlResultChar(
                    'push',
                    targetChar,
                    'resistPlus,' + String(i) + ',' + String(value)
                  )
                }
              }
            }
          } else if (ef == 75) {
            let atFlag = false
            if (value > -1) {
              atFlag = true
            }
            for (let i = 0; i < 6; i++) {
              if (efAry2[4].indexOf(String(i)) > -1) {
                targetChar['char'].Bt_attackAddPlus[i] = atFlag
                if (atFlag) {
                  targetChar['char'].AttackAddTurn[i] = limitTurn
                } else {
                  targetChar['char'].AttackAddTurn[i] = -1
                }
                if (i == 5) {
                  if (atFlag) {
                    if (value > 99999) {
                      value = 99999
                    }
                    targetChar['char'].Bt_poisonPlus = value
                  } else {
                    targetChar['char'].Bt_poisonPlus = 0
                  }
                }
                if (atFlag) {
                  printDebugMessage(
                    this.getName(targetChar, true) +
                      ' attackAddPlus:' +
                      getDefaultMessage(ATTACK_ADD_DEBUG_STR[i], 1)
                  )
                  this.controlResultChar(
                    'push',
                    targetChar,
                    'attackAddPlus,' + String(i)
                  )
                }
              }
            }
          }
          targetChar['char'].check()
        }
      } else if (ef == 80) {
        if (!this.activateCheck(efTarget, 'csbte', 'a')) {
          continue
        }
        printDebugMessage('[SpellEffect] clear party spell effect')
        effectCheck = true
        efAry[4] = checkNull(efAry[4], '')
        for (let i = 0; i < 5; i++) {
          if (efAry[2].indexOf(String(i)) > -1) {
            ;(pt.SpellEffectRate[i] = 0), (pt.SpellEffectPlus[i] = 0)
          }
        }
        if (efAry[2].indexOf('5') > -1) {
          ;(pt.Vision = 0), (pt.Light = false), (pt.ViewDarkZone = false)
        }
        if (efAry[2].indexOf('6') > -1) {
          ;(pt.Flying = 0), (pt.FlyingEffect = '')
        }
        for (let i = 6; i < 10; i++) {
          if (efAry[2].indexOf(i.toString(16)) > -1) {
            ;(pt.PtSpellEffectRate[i - 6] = 0),
              (pt.PtSpellEffectPlus[i - 6] = 0)
          }
        }
        if (efAry[2].indexOf('b') > -1) {
          ;(pt.SpellEffectRate[5] = 0), (pt.SpellEffectPlus[5] = 0)
        }
        if (efAry[2].indexOf('c') > -1) {
          for (let i = 0; i < GameData['ABILITY'].length; i++) {
            let abiCk = false
            if (efAry[4].length <= i) {
              abiCk = true
            } else if (efAry[4].charAt(i) == '1') {
              abiCk = true
            }
            if (abiCk) {
              ;(pt.AbiPlus[i] = 0), (pt.AbiRate[i] = 0)
            }
          }
        }
        if (efAry[2].indexOf('d') > -1) {
          ;(pt.PtSpellEffectRate[4] = 0), (pt.PtSpellEffectPlus[4] = 0)
        }
        if (efAry[2].indexOf('e') > -1) {
          ;(pt.SpellEffectRate[6] = 0), (pt.SpellEffectPlus[6] = 0)
        }
        if (efAry[3].indexOf('0') > -1) {
          ;(pt.SpellEffectRate[7] = 0), (pt.SpellEffectPlus[7] = 0)
        }
        if (efAry[3].indexOf('2') > -1) {
          ;(pt.SpellEffectRate[8] = 0), (pt.SpellEffectPlus[8] = 0)
        }
        if (efAry[3].indexOf('3') > -1) {
          for (let i = 0; i < RESIST_LENGTH; i++) {
            ;(pt.ResistPlus[i] = -2), (pt.ResistRate[i] = 0)
          }
        }
        if (efAry[3].indexOf('4') > -1) {
          for (let i = 0; i < ATTACK_ADD_LENGTH + 1; i++) {
            ;(pt.AttackAddPlus[i] = false), (pt.AttackAddRate[i] = 0)
          }
          pt.PoisonPlus = 0
        }
        pt.check()
      } else if (ef == 81) {
        if (!this.activateCheck(efTarget, 'csbte', 'a', 'p')) {
          continue
        }
        printDebugMessage('[SpellEffect] clear spell effect')
        efAry = this.replaceMyAndTargetEffectAry(efAry, [3], castChar['type'])
        let loopAry = this.getTarget(efTarget, targetCharNum, false, 'pc')
        for (let tNum = 0; tNum < loopAry.length; tNum++) {
          effectCheck = true
          let targetChar = this.setCharData(loopAry[tNum])
          if (this.checkSpellCancel(targetChar)) {
            continue
          }
          let efAry2 = this.replaceMyAndTargetEffectAry(
            efAry,
            [3],
            null,
            targetChar['type']
          )
          efAry2[5] = checkNull(efAry2[5], '')
          let prob = this.calculationResist(efAry2[3], targetChar)
          if (prob >= dice(1, 100)) {
            printDebugMessage(this.getName(targetChar, true) + ' resist succes')
            this.controlResultChar('push', targetChar, 'resist')
            continue
          }
          for (let i = 0; i < 5; i++) {
            if (efAry2[2].indexOf(String(i)) > -1) {
              targetChar['char'].SpellEffectRate[i] = 0
              targetChar['char'].SpellEffectPlus[i] = 0
            }
          }
          if (efAry2[2].indexOf('b') > -1) {
            targetChar['char'].SpellEffectRate[5] = 0
            targetChar['char'].SpellEffectPlus[5] = 0
          }
          if (efAry2[2].indexOf('c') > -1) {
            for (let i = 0; i < GameData['ABILITY'].length; i++) {
              let abiCk = false
              if (efAry2[5].length <= i) {
                abiCk = true
              } else if (efAry2[5].charAt(i) == '1') {
                abiCk = true
              }
              if (abiCk) {
                ;(targetChar['char'].AbiPlus[i] = 0),
                  (targetChar['char'].AbiRate[i] = 0)
              }
            }
          }
          if (efAry2[2].indexOf('e') > -1) {
            targetChar['char'].SpellEffectRate[6] = 0
            targetChar['char'].SpellEffectPlus[6] = 0
          }
          if (efAry2[4].indexOf('0') > -1) {
            targetChar['char'].SpellEffectRate[7] = 0
            targetChar['char'].SpellEffectPlus[7] = 0
          }
          if (efAry2[4].indexOf('1') > -1) {
            ;(targetChar['char'].SealSpell = false),
              (targetChar['char'].SealSpellInt = 0)
          }
          if (efAry2[4].indexOf('2') > -1) {
            targetChar['char'].SpellEffectRate[8] = 0
            targetChar['char'].SpellEffectPlus[8] = 0
          }
          if (efAry2[4].indexOf('3') > -1) {
            for (let i = 0; i < RESIST_LENGTH; i++) {
              targetChar['char'].ResistPlus[i] = -2
              targetChar['char'].ResistRate[i] = 0
            }
          }
          if (efAry2[4].indexOf('4') > -1) {
            for (let i = 0; i < ATTACK_ADD_LENGTH + 1; i++) {
              targetChar['char'].AttackAddPlus[i] = false
              targetChar['char'].AttackAddRate[i] = 0
            }
            targetChar['char'].PoisonPlus = 0
          }
          targetChar['char'].check()
        }
      } else if (ef == 82) {
        if (!this.activateCheck(efTarget, 'b', 'a', 'a')) {
          continue
        }
        printDebugMessage('[SpellEffect] clear spell effect battle')
        efAry = this.replaceMyAndTargetEffectAry(efAry, [3], castChar['type'])
        let loopAry = this.getTarget(efTarget, targetCharNum)
        for (let tNum = 0; tNum < loopAry.length; tNum++) {
          effectCheck = true
          let targetChar = this.setCharData(loopAry[tNum])
          if (this.checkSpellCancel(targetChar)) {
            continue
          }
          let efAry2 = this.replaceMyAndTargetEffectAry(
            efAry,
            [3],
            null,
            targetChar['type']
          )
          efAry2[5] = checkNull(efAry2[5], '')
          let prob = this.calculationResist(efAry2[3], targetChar)
          if (prob >= dice(1, 100)) {
            printDebugMessage(this.getName(targetChar, true) + ' resist succes')
            this.controlResultChar('push', targetChar, 'resist')
            continue
          }
          for (let i = 0; i < 5; i++) {
            if (efAry2[2].indexOf(String(i)) > -1) {
              targetChar['char'].BtSpellEffectPlus[i] = 0
              targetChar['char'].BtSpellEffectTurn[i] = -1
            }
          }
          if (efAry2[2].indexOf('b') > -1) {
            targetChar['char'].BtSpellEffectPlus[5] = 0
            targetChar['char'].BtSpellEffectTurn[5] = -1
          }
          if (efAry2[2].indexOf('c') > -1) {
            for (let i = 0; i < GameData['ABILITY'].length; i++) {
              let abiCk = false
              if (efAry2[5].length <= i) {
                abiCk = true
              } else if (efAry2[5].charAt(i) == '1') {
                abiCk = true
              }
              if (abiCk) {
                targetChar['char'].Bt_abiPlus[i] = 0
                targetChar['char'].AbiTurn[i] = -1
              }
            }
          }
          if (efAry2[2].indexOf('e') > -1) {
            targetChar['char'].BtSpellEffectPlus[6] = 0
            targetChar['char'].BtSpellEffectTurn[6] = -1
          }
          if (efAry2[4].indexOf('0') > -1) {
            targetChar['char'].BtSpellEffectPlus[7] = 0
            targetChar['char'].BtSpellEffectTurn[7] = -1
          }
          if (efAry2[4].indexOf('2') > -1) {
            targetChar['char'].BtSpellEffectPlus[8] = 0
            targetChar['char'].BtSpellEffectTurn[8] = -1
          }
          if (efAry2[4].indexOf('3') > -1) {
            for (let i = 0; i < RESIST_LENGTH; i++) {
              targetChar['char'].Bt_resistPlus[i] = -2
              targetChar['char'].ResistTurn[i] = -1
            }
          }
          if (efAry2[4].indexOf('4') > -1) {
            for (let i = 0; i < ATTACK_ADD_LENGTH + 1; i++) {
              targetChar['char'].Bt_attackAddPlus[i] = false
              targetChar['char'].AttackAddTurn[i] = -1
            }
            targetChar['char'].Bt_poisonPlus = 0
          }
          targetChar['char'].check()
        }
      } else if (ef == 100) {
        if (!this.activateCheck(efTarget, 'csbte', 'p')) {
          continue
        }
        printDebugMessage('[SpellEffect] light')
        effectCheck = true
        pt.Vision = Number(efAry[2])
        pt.Light = true
        if (efAry[3] == 'true') {
          pt.ViewDarkZone = true
        } else {
          pt.ViewDarkZone = false
        }
      } else if (ef == 101) {
        if (!this.activateCheck(efTarget, 'csbte', 'p')) {
          continue
        }
        printDebugMessage('[SpellEffect] flying')
        effectCheck = true
        pt.Flying = Number(efAry[3])
        pt.FlyingEffect = efAry[2]
      } else if (ef >= 102 && ef <= 106) {
        if (!this.activateCheck(efTarget, 'csbte', 'p')) {
          continue
        }
        if (ef == 102) {
          printDebugMessage('[SpellEffect] identify monster')
        } else if (ef == 103) {
          printDebugMessage('[SpellEffect] correct preemptive attack rate')
        } else if (ef == 104) {
          printDebugMessage('[SpellEffect] correct secret door find rate')
        } else if (ef == 105) {
          printDebugMessage('[SpellEffect] correct pick rate')
        } else if (ef == 106) {
          printDebugMessage('[SpellEffect] correct encounter rate')
        }
        efAry = this.replaceMyAndTargetEffectAry(efAry, [2], castChar['type'])
        effectCheck = true
        let value = this.calculationMyAndTarget(efAry[2], castChar, null, 'f')
        let duration = Number(efAry[3])
        let subscript = ef - 102
        pt.PtSpellEffectRate[subscript] = duration
        pt.PtSpellEffectPlus[subscript] = value
      } else if (ef == 200) {
        if (!this.activateCheck(efTarget, 'b', 'a', 'e')) {
          continue
        }
        printDebugMessage('[SpellEffect] damage')
        efAry = this.replaceMyAndTargetEffectAry(
          efAry,
          [4, 5],
          castChar['type']
        )
        let loopAry = this.getTarget(efTarget, targetCharNum)
        for (let tNum = 0; tNum < loopAry.length; tNum++) {
          effectCheck = true
          let targetChar = this.setCharData(loopAry[tNum])
          if (this.checkSpellCancel(targetChar)) {
            continue
          }
          let efAry2 = this.replaceMyAndTargetEffectAry(
            efAry,
            [4, 5],
            null,
            targetChar['type']
          )
          if (targetChar['type'].match(/^(monster|summon)$/)) {
            if (
              efAry2[3].indexOf(targetChar['charData'].TYPE.toString(16)) < 0
            ) {
              this.controlResultChar('push', targetChar, 'none')
              continue
            }
          }
          if (efAry2[4].indexOf('attackDamageMain') > -1) {
            let attackDamage = this.normalAttackDamage(
              castChar,
              targetChar,
              false
            )
            efAry2[4] = efAry2[4].replace(
              /attackDamageMain/g,
              String(attackDamage)
            )
          }
          if (efAry2[4].indexOf('attackDamageSub') > -1) {
            let attackDamage = this.normalAttackDamage(
              castChar,
              targetChar,
              true
            )
            efAry2[4] = efAry2[4].replace(
              /attackDamageSub/g,
              String(attackDamage)
            )
          }
          let dmg = this.calculationMyAndTarget(
            efAry2[4],
            castChar,
            targetChar,
            'f'
          )
          let attribute = Number(efAry2[2]) + 10
          if (attribute == 15) {
            attribute = 0
          }
          if (
            attribute != 0 &&
            targetChar['char'].Resist[attribute] &&
            !targetChar['char'].WeakPoint[attribute]
          ) {
            dmg = Math.ceil(calTimes(dmg, GameData['SPELL_RESIST']))
            printDebugMessage(
              this.getName(targetChar, true) + ' resist by attribute'
            )
          } else if (
            attribute != 0 &&
            !targetChar['char'].Resist[attribute] &&
            targetChar['char'].WeakPoint[attribute]
          ) {
            dmg = Math.ceil(calTimes(dmg, GameData['SPELL_WEAK']))
            printDebugMessage(
              this.getName(targetChar, true) + ' weak point by attribute'
            )
          }
          let prob = this.calculationResist(efAry2[5], targetChar)
          if (prob >= dice(1, 100)) {
            printDebugMessage(this.getName(targetChar, true) + ' resist succes')
            dmg = Math.ceil(dmg / 2)
          }
          if (targetChar['type'].match(/^(monster|summon)$/)) {
            if (targetChar['charData'].INVINCIBILITY && dmg > 0) {
              dmg = 0
            }
          }
          dmg *= -1
          targetChar['char'].controlHp(dmg, true)
          if (targetChar['type'] == 'pc') {
            if (targetChar['char'].Hp < 1) {
              let stateOfDeath = Number(efAry2[6])
              if (stateOfDeath == 1) {
                targetChar['char'].State = 5
              } else if (stateOfDeath == 2) {
                targetChar['char'].State = 6
              }
            }
          }
          printDebugMessageHp(targetChar, dmg)
          if (dmg > 0) {
            let resultStr
            if (targetChar['char'].Hp >= targetChar['char'].HpMax) {
              resultStr = 'fullHeal'
            } else {
              resultStr = 'heal,' + String(dmg)
            }
            this.controlResultChar('push', targetChar, resultStr)
          } else {
            dmg *= -1
            targetChar['char'].cureAsleepByDamage(dmg)
            this.controlResultChar('push', targetChar, 'damage,' + String(dmg))
            if (targetChar['char'].Hp < 1) {
              this.dealingWithDeath(targetChar)
            }
          }
        }
      } else if (ef == 201) {
        if (!this.activateCheck(efTarget, 'b', 'a', 'e')) {
          continue
        }
        if (efAry[2] == '0') {
          printDebugMessage('[SpellEffect] punish')
        } else if (efAry[2] == '1') {
          printDebugMessage('[SpellEffect] death')
        } else if (efAry[2] == '2') {
          printDebugMessage('[SpellEffect] HP drain')
        }
        efAry = this.replaceMyAndTargetEffectAry(efAry, [4], castChar['type'])
        let loopAry = this.getTarget(efTarget, targetCharNum)
        for (let tNum = 0; tNum < loopAry.length; tNum++) {
          effectCheck = true
          let targetChar = this.setCharData(loopAry[tNum])
          if (this.checkSpellCancel(targetChar)) {
            continue
          }
          let efAry2 = this.replaceMyAndTargetEffectAry(
            efAry,
            [4],
            null,
            targetChar['type']
          )
          if (targetChar['type'].match(/^(monster|summon)$/)) {
            if (
              efAry2[3].indexOf(targetChar['charData'].TYPE.toString(16)) < 0
            ) {
              this.controlResultChar('push', targetChar, 'none')
              continue
            }
          }
          let prob = this.calculationResist(efAry2[4], targetChar, true)
          if (efAry2[2] == '1') {
            if (
              targetChar['char'].Resist[8] &&
              !targetChar['char'].WeakPoint[8] &&
              prob > -1
            ) {
              prob = 100
            } else if (
              !targetChar['char'].Resist[8] &&
              targetChar['char'].WeakPoint[8]
            ) {
              prob = 0
            }
            if (prob <= -100 && prob >= -200) {
              prob = (prob + 100) * -1
            }
          }
          if (prob < 0) {
            prob = 0
          } else if (prob > 100) {
            prob = 100
          }
          if (targetChar['type'].match(/^(monster|summon)$/)) {
            if (targetChar['charData'].INVINCIBILITY) {
              prob = 100
            }
          }
          printDebugMessage(
            this.getName(targetChar, true) + ' resist rate: ' + prob + '%'
          )
          if (prob >= dice(1, 100)) {
            printDebugMessage(this.getName(targetChar, true) + ' resist succes')
            this.controlResultChar('push', targetChar, 'resist')
            continue
          }
          if (efAry2[2] == '0') {
            let hp = targetChar['char'].Hp
            if (hp > 9) {
              let newHp = dice(1, 9)
              hp -= newHp
              targetChar['char'].controlHp(newHp)
              this.controlResultChar('push', targetChar, 'damage,' + String(hp))
              printDebugMessageHp(targetChar, hp * -1)
            } else {
              this.controlResultChar('push', targetChar, 'none')
            }
          } else if (efAry2[2] == '1') {
            targetChar['char'].controlHp(0)
            if (targetChar['type'] == 'pc') {
              let stateOfDeath = Number(efAry2[6])
              if (stateOfDeath == 1) {
                targetChar['char'].State = 5
              } else if (stateOfDeath == 2) {
                targetChar['char'].State = 6
              }
            }
            this.dealingWithDeath(targetChar, efAry2[5])
          } else if (efAry2[2] == '2') {
            let hp = targetChar['char'].Hp
            if (hp > 9) {
              let newHp = dice(1, 9)
              hp -= newHp
              targetChar['char'].controlHp(newHp)
              this.controlResultChar('push', targetChar, 'damage,' + String(hp))
              printDebugMessageHp(targetChar, hp * -1)
              if (castChar['char'].Hp > 0) {
                castChar['char'].controlHp(hp, true)
                let resultStr
                if (castChar['char'].Hp >= castChar['char'].HpMax) {
                  resultStr = 'fullHeal'
                } else {
                  resultStr = 'heal,' + String(hp)
                }
                this.controlResultChar('push', castChar, resultStr)
                printDebugMessageHp(castChar, hp)
              }
            } else {
              this.controlResultChar('push', targetChar, 'none')
            }
          }
        }
      } else if (ef == 202) {
        if (!this.activateCheck(efTarget, 'b', 'a', 'e')) {
          continue
        }
        printDebugMessage('[SpellEffect] breath')
        let loopAry = this.getTarget(efTarget, targetCharNum)
        for (let tNum = 0; tNum < loopAry.length; tNum++) {
          effectCheck = true
          let targetChar = this.setCharData(loopAry[tNum])
          if (this.checkSpellCancel(targetChar)) {
            continue
          }
          if (targetChar['char'].BtOnlySpellEffectPlus[0] > 0) {
            targetChar['char'].BtOnlySpellEffectPlus[0]--
            this.controlResultChar('push', targetChar, 'breathCancel')
            continue
          }
          let dmg = this.calculationMyAndTarget(
            GameData['BREATH_DMG'],
            castChar,
            targetChar,
            'f'
          )
          let breathType = Number(efAry[2]) + 10
          if (
            targetChar['char'].Resist[breathType] &&
            !targetChar['char'].WeakPoint[breathType]
          ) {
            dmg = Math.ceil(calTimes(dmg, GameData['SPELL_RESIST']))
            printDebugMessage(
              this.getName(targetChar, true) + ' resist by attribute'
            )
          } else if (
            !targetChar['char'].Resist[breathType] &&
            targetChar['char'].WeakPoint[breathType]
          ) {
            dmg = Math.ceil(calTimes(dmg, GameData['SPELL_WEAK']))
            printDebugMessage(
              this.getName(targetChar, true) + ' weak point by attribute'
            )
          }
          if (targetChar['type'].match(/^(monster|summon)$/)) {
            if (targetChar['charData'].INVINCIBILITY) {
              dmg = 0
            }
          }
          let plus = targetChar['char'].BrPlus
          let formula = GameData['BREATH_RESIST_PROB'].replace(
            /spellPlus/g,
            plus
          )
          if (targetChar['char'].Action[0] == 4) {
            printDebugMessage(this.getName(targetChar, true) + ' parry')
            let parryStr = this.replaceMyAndTargetEffect(
              GameData['PARRY_RESIST'],
              targetChar['type']
            )
            parryStr = replaceFormula(parryStr, [
              [targetChar['type'], targetChar['num2']]
            ])
            let parryPlus = Math.floor(strCalculation(parryStr))
            formula = formula.replace(/parryPlus/g, parryPlus)
            plus += parryPlus
          }
          formula = formula.replace(/plus/g, plus)
          let prob
          prob = this.calculationMyAndTarget(
            formula,
            castChar,
            targetChar,
            'f',
            0,
            100
          )
          printDebugMessage(
            this.getName(targetChar, true) + ' resist rate: ' + prob + '%'
          )
          if (prob >= dice(1, 100)) {
            dmg = Math.ceil(dmg / 2)
            printDebugMessage(
              this.getName(targetChar, true) + ' resist success'
            )
          }
          dmg *= -1
          targetChar['char'].controlHp(dmg, true)
          if (targetChar['type'] == 'pc') {
            if (targetChar['char'].Hp < 1) {
              let stateOfDeath = Number(efAry[3])
              if (stateOfDeath == 1) {
                targetChar['char'].State = 5
              } else if (stateOfDeath == 2) {
                targetChar['char'].State = 6
              }
            }
          }
          printDebugMessageHp(targetChar, dmg)
          if (dmg > 0) {
            let resultStr
            if (targetChar['char'].Hp >= targetChar['char'].HpMax) {
              resultStr = 'fullHeal'
            } else {
              resultStr = 'heal,' + String(dmg)
            }
            this.controlResultChar('push', targetChar, resultStr)
          } else {
            dmg *= -1
            targetChar['char'].cureAsleepByDamage(dmg)
            this.controlResultChar('push', targetChar, 'damage,' + String(dmg))
            if (targetChar['char'].Hp < 1) {
              this.dealingWithDeath(targetChar)
            }
          }
        }
      } else if (ef == 203) {
        if (!this.activateCheck(efTarget, 'b', 'a', 'a')) {
          continue
        }
        if (efAry[2] == '0') {
          printDebugMessage('[SpellEffect] asleep')
        } else if (efAry[2] == '1') {
          printDebugMessage('[SpellEffect] silence')
        } else if (efAry[2] == '2') {
          printDebugMessage('[SpellEffect] suppress')
        }
        efAry = this.replaceMyAndTargetEffectAry(
          efAry,
          [3, 4],
          castChar['type']
        )
        let loopAry = this.getTarget(efTarget, targetCharNum)
        for (let tNum = 0; tNum < loopAry.length; tNum++) {
          effectCheck = true
          let targetChar = this.setCharData(loopAry[tNum])
          if (this.checkSpellCancel(targetChar)) {
            continue
          }
          let efAry2 = this.replaceMyAndTargetEffectAry(
            efAry,
            [3, 4],
            null,
            targetChar['type']
          )
          let value = this.calculationMyAndTarget(
            efAry2[3],
            castChar,
            targetChar,
            'f'
          )
          let prob = this.calculationResist(efAry2[4], targetChar, true)
          if (efAry2[2] == '0') {
            if (
              targetChar['char'].Resist[1] &&
              !targetChar['char'].WeakPoint[1] &&
              prob > -1
            ) {
              prob = 100
            } else if (
              !targetChar['char'].Resist[1] &&
              targetChar['char'].WeakPoint[1]
            ) {
              prob = 0
            }
            if (prob <= -100 && prob >= -200) {
              prob = (prob + 100) * -1
            }
          } else if (efAry2[2] == '1') {
            if (
              targetChar['char'].Resist[0] &&
              !targetChar['char'].WeakPoint[0] &&
              prob > -1
            ) {
              prob = 100
            } else if (
              !targetChar['char'].Resist[0] &&
              targetChar['char'].WeakPoint[0]
            ) {
              prob = 0
            }
            if (prob <= -100 && prob >= -200) {
              prob = (prob + 100) * -1
            }
          }
          if (prob < 0) {
            prob = 0
          } else if (prob > 100) {
            prob = 100
          }
          if (targetChar['type'].match(/^(monster|summon)$/)) {
            if (targetChar['charData'].INVINCIBILITY) {
              prob = 100
            }
          }
          printDebugMessage(
            this.getName(targetChar, true) + ' resist rate: ' + prob + '%'
          )
          if (prob >= dice(1, 100)) {
            printDebugMessage(this.getName(targetChar, true) + ' resist succes')
            let resistStr
            if (efAry2[2] == '0') {
              if (targetChar['char'].Asleep > 0) {
                resistStr = 'asleep'
              } else if (value > -1) {
                resistStr = 'notSleep'
              } else {
                resistStr = 'resist'
              }
            } else if (efAry2[2] == '1') {
              resistStr = 'notSilence'
            } else {
              resistStr = 'resist'
            }
            this.controlResultChar('push', targetChar, resistStr)
            continue
          }
          if (efAry2[2] == '0') {
            if (targetChar['char'].State > 1) {
              this.controlResultChar('push', targetChar, 'notSleep')
            } else if (value > -1) {
              let asleep = targetChar['char'].Asleep
              if (asleep < 0) {
                this.controlResultChar('push', targetChar, 'faint')
                targetChar['char'].Action[0] = -1
              } else {
                asleep += value
                if (asleep > 99999) {
                  asleep = 99999
                }
                targetChar['char'].Asleep = asleep
                if (asleep == 0) {
                  this.controlResultChar('push', targetChar, 'notSleep')
                } else {
                  this.controlResultChar('push', targetChar, 'sleep')
                  targetChar['char'].Action[0] = -1
                }
              }
            } else {
              targetChar['char'].Asleep = -1
              this.controlResultChar('push', targetChar, 'faint')
              targetChar['char'].Action[0] = -1
            }
          } else if (efAry2[2] == '1') {
            if (value > -1) {
              let silence = targetChar['char'].Silence
              if (silence > -1) {
                silence += value
                if (silence > 99999) {
                  silence = 99999
                }
                targetChar['char'].Silence = silence
              }
              if (silence != 0) {
                this.controlResultChar('push', targetChar, 'silence')
              }
            } else {
              targetChar['char'].Silence = -1
              this.controlResultChar('push', targetChar, 'silence')
            }
          } else {
            if (value < 0) {
              value *= -1
            }
            let noBreath = targetChar['char'].NoBreath
            noBreath += value
            if (noBreath > 99999) {
              noBreath = 99999
            }
            targetChar['char'].NoBreath = noBreath
            if (noBreath != 0) {
              this.controlResultChar('push', targetChar, 'restrained')
            }
          }
        }
      } else if (ef == 204) {
        if (!this.activateCheck(efTarget, 'b', 'a', 'e')) {
          continue
        }
        printDebugMessage('[SpellEffect] damage mp')
        efAry = this.replaceMyAndTargetEffectAry(
          efAry,
          [2, 3],
          castChar['type']
        )
        let loopAry = this.getTarget(efTarget, targetCharNum)
        for (let tNum = 0; tNum < loopAry.length; tNum++) {
          effectCheck = true
          let targetChar = this.setCharData(loopAry[tNum])
          if (this.checkSpellCancel(targetChar)) {
            continue
          }
          let efAry2 = this.replaceMyAndTargetEffectAry(
            efAry,
            [2, 3],
            null,
            targetChar['type']
          )
          let dmg = this.calculationMyAndTarget(
            efAry2[2],
            castChar,
            targetChar,
            'f'
          )
          let prob = this.calculationResist(efAry2[3], targetChar)
          if (prob >= dice(1, 100)) {
            dmg = Math.ceil(dmg / 2)
            printDebugMessage(this.getName(targetChar, true) + ' resist succes')
          }
          if (targetChar['char'].mpDamage(dmg)) {
            this.controlResultChar('push', targetChar, 'mpDamage')
          } else {
            this.controlResultChar('push', targetChar, 'none')
          }
        }
      } else if (ef == 205) {
        if (!this.activateCheck(efTarget, 'b', 'a', 'e')) {
          continue
        }
        printDebugMessage('[SpellEffect] lost spell cancel')
        efAry = this.replaceMyAndTargetEffectAry(efAry, [2], castChar['type'])
        let loopAry = this.getTarget(efTarget, targetCharNum)
        for (let tNum = 0; tNum < loopAry.length; tNum++) {
          effectCheck = true
          let targetChar = this.setCharData(loopAry[tNum])
          if (this.checkSpellCancel(targetChar)) {
            continue
          }
          let efAry2 = this.replaceMyAndTargetEffectAry(
            efAry,
            [2],
            null,
            targetChar['type']
          )
          let prob = this.calculationResist(efAry2[2], targetChar)
          if (prob >= dice(1, 100)) {
            printDebugMessage(this.getName(targetChar, true) + ' resist succes')
            this.controlResultChar('push', targetChar, 'resist')
            continue
          }
          let sc = targetChar['char'].SpellCancel
          if (targetChar['type'] == 'pc') {
            targetChar['char'].NotSpellCancel = true
            targetChar['char'].SpellEffectRate[2] = 0
            targetChar['char'].SpellEffectPlus[2] = 0
            pt.SpellEffectRate[2] = 0
            pt.SpellEffectPlus[2] = 0
          } else {
            targetChar['char'].SpellCancel0 = 0
            targetChar['char'].SpellCancel1 = 0
          }
          targetChar['char'].BtSpellEffectTurn[2] = -1
          targetChar['char'].BtSpellEffectPlus[2] = 0
          targetChar['char'].check()
          printDebugMessage(
            this.getName(targetChar, true) +
              ' spellCancel: ' +
              String(sc) +
              ' -> ' +
              String(targetChar['char'].SpellCancel)
          )
        }
      } else if (ef == 206) {
        if (!this.activateCheck(efTarget, 'csbte', 'a', 'a')) {
          continue
        }
        printDebugMessage('[SpellEffect] poison')
        efAry = this.replaceMyAndTargetEffectAry(
          efAry,
          [2, 3],
          castChar['type']
        )
        let loopAry = this.getTarget(efTarget, targetCharNum)
        for (let tNum = 0; tNum < loopAry.length; tNum++) {
          effectCheck = true
          let targetChar = this.setCharData(loopAry[tNum])
          if (this.checkSpellCancel(targetChar)) {
            continue
          }
          let efAry2 = this.replaceMyAndTargetEffectAry(
            efAry,
            [2, 3],
            null,
            targetChar['type']
          )
          let prob = this.calculationResist(efAry2[3], targetChar, true)
          if (
            targetChar['char'].Resist[2] &&
            !targetChar['char'].WeakPoint[2] &&
            prob > -1
          ) {
            prob = 100
          } else if (
            !targetChar['char'].Resist[2] &&
            targetChar['char'].WeakPoint[2]
          ) {
            prob = 0
          }
          if (prob <= -100 && prob >= -200) {
            prob = (prob + 100) * -1
          }
          if (prob < 0) {
            prob = 0
          } else if (prob > 100) {
            prob = 100
          }
          printDebugMessage(
            this.getName(targetChar, true) + ' resist rate: ' + prob + '%'
          )
          if (prob >= dice(1, 100)) {
            printDebugMessage(this.getName(targetChar, true) + ' resist succes')
            this.controlResultChar('push', targetChar, 'resist')
            continue
          }
          let value = this.calculationMyAndTarget(
            efAry2[2],
            castChar,
            targetChar,
            'f'
          )
          if (value < 0) {
            value *= -1
          }
          value += targetChar['char'].Poison
          targetChar['char'].Poison = value
          if (value > 0) {
            this.controlResultChar('push', targetChar, 'poison')
          }
          targetChar['char'].check()
        }
      } else if (ef == 207) {
        if (!this.activateCheck(efTarget, 'b', 'a', 'a')) {
          continue
        }
        printDebugMessage('[SpellEffect] continuing damage')
        efAry = this.replaceMyAndTargetEffectAry(
          efAry,
          [4, 5, 6],
          castChar['type']
        )
        efAry[4] = replaceFormula(efAry[4], [
          [castChar['type'], castChar['num2']]
        ])
        efAry[5] = replaceFormula(efAry[5], [
          [castChar['type'], castChar['num2']]
        ])
        let loopAry = this.getTarget(efTarget, targetCharNum)
        for (let tNum = 0; tNum < loopAry.length; tNum++) {
          effectCheck = true
          let targetChar = this.setCharData(loopAry[tNum])
          if (this.checkSpellCancel(targetChar)) {
            continue
          }
          let efAry2 = this.replaceMyAndTargetEffectAry(
            efAry,
            [4, 5, 6],
            null,
            targetChar['type']
          )
          if (targetChar['type'].match(/^(monster|summon)$/)) {
            if (
              efAry2[3].indexOf(targetChar['charData'].TYPE.toString(16)) < 0
            ) {
              this.controlResultChar('push', targetChar, 'none')
              continue
            }
          }
          if (targetChar['char'].CD_Turn.length > 99) {
            targetChar['char'].CD_Attribute.shift()
            targetChar['char'].CD_Turn.shift()
            targetChar['char'].CD_Value.shift()
            targetChar['char'].CD_Resist.shift()
          }
          let attribute = Number(efAry2[2]) + 10
          if (attribute == 15) {
            attribute = 0
          }
          targetChar['char'].CD_Attribute.push(attribute)
          let value = this.calculationMyAndTarget(
            efAry2[6],
            castChar,
            targetChar,
            'f',
            -1
          )
          targetChar['char'].CD_Turn.push(value)
          targetChar['char'].CD_Value.push(efAry2[4])
          targetChar['char'].CD_Resist.push(efAry2[5])
        }
      } else if (ef == 208) {
        if (!this.activateCheck(efTarget, 'b', 'a', 'a')) {
          continue
        }
        printDebugMessage('[SpellEffect] clear continuing damage')
        efAry = this.replaceMyAndTargetEffectAry(
          efAry,
          [2, 3],
          castChar['type']
        )
        let loopAry = this.getTarget(efTarget, targetCharNum)
        for (let tNum = 0; tNum < loopAry.length; tNum++) {
          effectCheck = true
          let targetChar = this.setCharData(loopAry[tNum])
          if (this.checkSpellCancel(targetChar)) {
            continue
          }
          let efAry2 = this.replaceMyAndTargetEffectAry(
            efAry,
            [2, 3],
            null,
            targetChar['type']
          )
          let prob = this.calculationResist(efAry2[3], targetChar)
          if (prob >= dice(1, 100)) {
            printDebugMessage(this.getName(targetChar, true) + ' resist succes')
            this.controlResultChar('push', targetChar, 'resist')
            continue
          }
          let value = this.calculationMyAndTarget(
            efAry2[2],
            castChar,
            targetChar,
            'f',
            -1,
            100
          )
          if (value < 0 || value >= targetChar['char'].CD_Turn.length) {
            targetChar['char'].CD_Attribute = []
            targetChar['char'].CD_Turn = []
            targetChar['char'].CD_Value = []
            targetChar['char'].CD_Resist = []
          } else {
            for (let i = 0; i < value; i++) {
              targetChar['char'].CD_Attribute.pop()
              targetChar['char'].CD_Turn.pop()
              targetChar['char'].CD_Value.pop()
              targetChar['char'].CD_Resist.pop()
            }
          }
        }
      } else if (ef == 209) {
        if (!this.activateCheck(efTarget, 'b', 'a', 'e')) {
          continue
        }
        let efKind = Number(efAry[2]) + 3
        if (efKind == 3) {
          printDebugMessage('[SpellEffect] paralyzed')
        } else if (efKind == 4) {
          printDebugMessage('[SpellEffect] stoned')
        }
        efAry = this.replaceMyAndTargetEffectAry(efAry, [3], castChar['type'])
        let loopAry = this.getTarget(efTarget, targetCharNum)
        for (let tNum = 0; tNum < loopAry.length; tNum++) {
          effectCheck = true
          let targetChar = this.setCharData(loopAry[tNum])
          if (this.checkSpellCancel(targetChar)) {
            continue
          }
          let efAry2 = this.replaceMyAndTargetEffectAry(
            efAry,
            [3],
            null,
            targetChar['type']
          )
          let prob = this.calculationResist(efAry2[3], targetChar, true)
          if (
            targetChar['char'].Resist[efKind] &&
            !targetChar['char'].WeakPoint[efKind] &&
            prob > -1
          ) {
            prob = 100
          } else if (
            !targetChar['char'].Resist[efKind] &&
            targetChar['char'].WeakPoint[efKind]
          ) {
            prob = 0
          }
          if (prob <= -100 && prob >= -200) {
            prob = (prob + 100) * -1
          }
          if (prob < 0) {
            prob = 0
          } else if (prob > 100) {
            prob = 100
          }
          printDebugMessage(
            this.getName(targetChar, true) + ' resist rate: ' + prob + '%'
          )
          if (prob >= dice(1, 100)) {
            printDebugMessage(this.getName(targetChar, true) + ' resist succes')
            this.controlResultChar('push', targetChar, 'resist')
            continue
          }
          let efKind2 = efKind - 1
          if (targetChar['char'].State < efKind2) {
            targetChar['char'].State = efKind2
            targetChar['char'].Asleep = 0
            targetChar['char'].Action[0] = -1
            let resultStr
            if (efKind2 == 2) {
              resultStr = 'paralyze'
            } else if (efKind2 == 3) {
              resultStr = 'stone'
            }
            this.controlResultChar('push', targetChar, resultStr)
          }
          targetChar['char'].check()
        }
      } else if (ef == 210) {
        if (!this.activateCheck(efTarget, 'b', 'p', 'e')) {
          continue
        }
        printDebugMessage('[SpellEffect] expel monster')
        efAry = this.replaceMyAndTargetEffectAry(efAry, [3], castChar['type'])
        let loopAry = this.getTarget(efTarget, targetCharNum)
        for (let tNum = 0; tNum < loopAry.length; tNum++) {
          effectCheck = true
          let targetChar = this.setCharData(loopAry[tNum])
          if (this.checkSpellCancel(targetChar)) {
            continue
          }
          if (efAry[2].indexOf(targetChar['charData'].TYPE.toString(16)) < 0) {
            this.controlResultChar('push', targetChar, 'none')
            continue
          }
          let efAry2 = this.replaceMyAndTargetEffectAry(
            efAry,
            [3],
            null,
            targetChar['type']
          )
          let prob = this.calculationResist(efAry2[3], targetChar)
          if (prob >= dice(1, 100)) {
            printDebugMessage(this.getName(targetChar, true) + ' resist succes')
            this.controlResultChar('push', targetChar, 'resist')
            continue
          }
          targetChar['char'].controlHp(0)
          TempVariable['monsterNum'][targetChar['numInGroup'][0]]--
          if (TempVariable['monsterNum'][targetChar['numInGroup'][0]] < 1) {
            hateCheck(200 + targetChar['numInGroup'][0])
          }
          this.controlResultChar('push', targetChar, 'run')
        }
      } else if (ef == 211) {
        if (!this.activateCheck(efTarget, 'b', 'p')) {
          continue
        }
        printDebugMessage('[SpellEffect] call monster')
        effectCheck = true
        let monster = this.calculationMyAndTarget(
          efAry[5],
          castChar,
          null,
          'f',
          -1
        )
        if (monster < 0 && efAry[6] != '-1' && efAry[6] != '') {
          efAry[6] = efAry[6].replace(/\./g, ',')
          let strAry = MP.getCmNum(efAry[6]).split(',')
          monster = Number(strAry[dice(1, strAry.length) - 1])
        }
        if (monster < 0 || monster >= MONSTER_DATA.length) {
          monster = -1
        }
        let row = Number(efAry[2])
        if (monster > -1) {
          if (TempVariable['summonNum'][row] > 0) {
            if (efAry[3] == 'true') {
              if (row == 0) {
                row = 1
              } else {
                row = 0
              }
              if (TempVariable['summonNum'][row] > 0) {
                if (efAry[4] != 'true') {
                  monster = -1
                }
              }
            } else if (efAry[4] != 'true') {
              monster = -1
            }
          }
        }
        let num = this.calculationMyAndTarget(
          efAry[7],
          castChar,
          null,
          'f',
          -1,
          9
        )
        if (monster < 0 || num == 0) {
          this.controlResultChar('push', castChar, 'none')
          continue
        }
        for (let i = 0; i < 9; i++) {
          if (PlayData['SummonList'][row][i] > -1) {
            SUMMON[PlayData['SummonList'][row][i]].initialize()
            PlayData['SummonList'][row][i] = -1
          }
        }
        TempVariable['summonNum'][row] = 0
        if (num < 0) {
          let formula = MONSTER_DATA[monster].ENTER_NUM
          let strAry = DUNGEON.BoxTrap[pt.DungeonNumber][pt.Floor].split('<>')
          formula = formula.replace(/trap\.lv/g, strAry[0])
          num = Math.floor(strCalculation(replaceFormula(formula)))
          if (num < 1) {
            num = 1
          } else if (num > 9) {
            num = 9
          }
        }
        for (let i = 0; i < num; i++) {
          let callSummon = getNextSummon()
          SUMMON[callSummon].createMonster(monster, callSummon + 50)
          PlayData['SummonList'][row][i] = callSummon
          TempVariable['summonNum'][row]++
        }
        this.controlResultChar(
          'push',
          castChar,
          'summon,' + String(monster) + ',' + String(num)
        )
      } else if (ef == 212) {
        if (!this.activateCheck(efTarget, 'b', 'a', 'e')) {
          continue
        }
        printDebugMessage('[SpellEffect] taunt')
        efAry = this.replaceMyAndTargetEffectAry(efAry, [2], castChar['type'])
        let loopAry = this.getTarget(efTarget, targetCharNum)
        for (let tNum = 0; tNum < loopAry.length; tNum++) {
          effectCheck = true
          let targetChar = this.setCharData(loopAry[tNum])
          if (this.checkSpellCancel(targetChar)) {
            continue
          }
          let efAry2 = this.replaceMyAndTargetEffectAry(
            efAry,
            [2],
            null,
            targetChar['type']
          )
          let prob = this.calculationResist(efAry2[2], targetChar)
          if (prob >= dice(1, 100)) {
            printDebugMessage(this.getName(targetChar, true) + ' resist succes')
            this.controlResultChar('push', targetChar, 'resist')
            continue
          }
          let limitTurn = this.calculationMyAndTarget(
            efAry2[3],
            castChar,
            targetChar,
            'f'
          )
          targetChar['char'].HateTurn = limitTurn
          let hate
          if (castChar['type'] == 'pc') {
            hate = castChar['num']
          } else {
            hate = castChar['numInGroup'][0]
            if (castChar['type'] == 'monster') {
              hate += 200
            } else {
              hate += 210
            }
          }
          targetChar['char'].Hate = hate
          this.controlResultChar('push', targetChar, 'hated')
          let action = targetChar['char'].Action[0]
          let aTarget = targetChar['char'].Action[2]
          let numInGroup
          if (targetChar['type'] == 'pc') {
            numInGroup = targetChar['num']
          } else {
            numInGroup = targetChar['numInGroup'][0]
          }
          if (targetChar['type'] == 'monster') {
            if (action == 0) {
              let newTarget = getHateTarget(
                targetChar['type'],
                numInGroup,
                targetChar['numInGroup'][1],
                action
              )
              if (newTarget > -1) {
                targetChar['char'].Action[1] = newTarget
                targetChar['char'].Action[2] = newTarget
              }
            } else if (action == 3 || action == 6) {
              let newTarget = -1
              if (
                (aTarget >= 0 && aTarget <= 5) ||
                aTarget == 60 ||
                aTarget == 61
              ) {
                newTarget = getHateTarget(
                  targetChar['type'],
                  numInGroup,
                  targetChar['numInGroup'][1],
                  action
                )
              } else if (aTarget == 8 || aTarget == 9) {
                newTarget = getHateTarget(
                  targetChar['type'],
                  numInGroup,
                  targetChar['numInGroup'][1],
                  action,
                  true
                )
              }
              if (newTarget > -1) {
                targetChar['char'].Action[2] = newTarget
              }
            }
          } else {
            if (action == 0 || action == 2) {
              let newTarget = getHateTarget(
                targetChar['type'],
                numInGroup,
                targetChar['numInGroup'][1],
                action
              )
              if (newTarget > -1) {
                if (targetChar['type'] == 'summon') {
                  targetChar['char'].Action[1] = newTarget
                }
                targetChar['char'].Action[2] = newTarget
              }
            } else if (action == 3 || action == 7) {
              if (aTarget > -1) {
                let newTarget = getHateTarget(
                  targetChar['type'],
                  numInGroup,
                  targetChar['numInGroup'][1],
                  action
                )
                if (newTarget > -1) {
                  targetChar['char'].Action[2] = newTarget
                }
              }
            } else if (action == 5 || action == 6) {
              if (aTarget >= 10 && aTarget <= 13) {
                let newTarget = getHateTarget(
                  targetChar['type'],
                  numInGroup,
                  targetChar['numInGroup'][1],
                  action
                )
                if (newTarget > -1) {
                  targetChar['char'].Action[2] = newTarget
                }
              }
            }
          }
        }
      } else if (ef == 250 || ef == 251) {
        if (!this.activateCheck(efTarget, 'te', 'p', 'p')) {
          continue
        }
        if (ef == 250) {
          printDebugMessage('[SpellEffect] damage in event')
        } else if (ef == 251) {
          printDebugMessage('[SpellEffect] damage mp in event')
        }
        efAry = this.replaceMyAndTargetEffectAry(
          efAry,
          [2, 3],
          castChar['type']
        )
        let loopAry = this.getTarget(efTarget, targetCharNum, false, 'pc')
        for (let tNum = 0; tNum < loopAry.length; tNum++) {
          effectCheck = true
          let targetChar = this.setCharData(loopAry[tNum])
          let efAry2 = this.replaceMyAndTargetEffectAry(
            efAry,
            [2, 3],
            null,
            targetChar['type']
          )
          let dmg = this.calculationMyAndTarget(
            efAry2[2],
            castChar,
            targetChar,
            'f'
          )
          if (dmg < 0) {
            dmg *= -1
          }
          let prob = this.calculationResist(efAry2[3], targetChar)
          if (prob >= dice(1, 100)) {
            printDebugMessage(this.getName(targetChar, true) + ' resist succes')
            dmg = Math.ceil(dmg / 2)
          }
          if (ef == 250) {
            dmg *= -1
            targetChar['char'].controlHp(dmg, true)
            printDebugMessageHp(targetChar, dmg)
          } else if (ef == 251) {
            targetChar['char'].mpDamage(dmg)
          }
        }
      } else if (ef == 400 || ef == 402) {
        if (!this.activateCheck(efTarget, 'ce') || this.Effect != '') {
          continue
        }
        effectCheck = true
        if (ef == 400) {
          printDebugMessage('[SpellEffect] party location')
          this.Effect = 'partyLocation,'
        } else if (ef == 402) {
          printDebugMessage('[SpellEffect] search for PC')
          this.Effect = 'searchForPC,'
        }
        this.Effect += efAry[2] + ',' + efAry[3]
      } else if (ef == 401 || ef == 403) {
        if (!this.activateCheck(efTarget, 'cbt', 'p') || this.Effect != '') {
          continue
        }
        if (ef == 401) {
          printDebugMessage('[SpellEffect] teleport')
          effectCheck = true
          this.Effect = 'teleport'
          for (let i = 2; i < efAry.length; i++) {
            this.Effect += ',' + efAry[i]
          }
        } else if (ef == 403) {
          printDebugMessage('[SpellEffect] return')
          effectCheck = true
          this.Effect = 'return'
        }
      } else if (ef == 404) {
        if (!this.activateCheck(efTarget, 'csbte', 'a')) {
          continue
        }
        printDebugMessage('[SpellEffect] return of other parties')
        effectCheck = true
        let range = Number(efAry[2])
        let target = Number(efAry[3])
        for (let i = 0; i < PARTY.length; i++) {
          if (i == ptNum) {
            continue
          }
          let dungeon = PARTY[i].DungeonNumber
          if (dungeon < 0) {
            continue
          }
          if (range == 1) {
            if (dungeon != pt.DungeonNumber) {
              continue
            }
          } else if (range == 2) {
            if (dungeon != pt.DungeonNumber || PARTY[i].Floor != pt.Floor) {
              continue
            }
          }
          let memberNum = PARTY[i].getMemberNum(true)
          if (target == 1) {
            if (memberNum < 1) {
              continue
            }
          } else if (target == 2) {
            if (memberNum > 0) {
              continue
            }
          }
          PARTY[i].DungeonNumber = -1
          PARTY[i].spellEffectClear(true)
          PARTY[i].DungeonMusic = ''
          memberNum = PARTY[i].getMemberNum()
          for (let j = 0; j < memberNum; j++) {
            let pc = PC[PARTY[i].PartyMember[j]]
            pc.Poison = 0
            pc.SealSpell = false
            pc.SealSpellInt = 0
            pcRecoveryOnReturn(pc)
          }
          PARTY[i].deleteLostPc()
          PARTY[i].check()
          while (PARTY[i].PartyMember[0] > -1) {
            PARTY[i].removeMember(PARTY[i].PartyMember[0])
          }
        }
      } else if (ef == 405) {
        if (!this.activateCheck(efTarget, 'csbt', 'p') || this.Effect != '') {
          continue
        }
        printDebugMessage('[SpellEffect] coordinate teleport')
        effectCheck = true
        this.Effect = 'coordinateTeleport'
        let tp = [
          Number(efAry[2]),
          Number(efAry[3]),
          Number(efAry[4]),
          Number(efAry[5])
        ]
        if (tp[0] >= DUNGEON.DUNGEON_MAX) {
          tp[0] = -1
        }
        if (tp[0] > -1) {
          if (tp[1] >= DUNGEON.FloorMinMax[tp[0]].length) {
            tp[0] = -1
          } else {
            if (
              tp[2] >= DUNGEON.Width[tp[0]] ||
              tp[3] >= DUNGEON.Height[tp[0]]
            ) {
              tp[0] = -1
            }
          }
        }
        for (let i = 0; i < tp.length; i++) {
          this.Effect += ',' + String(tp[i])
        }
      } else if (ef == 410) {
        if (!this.activateCheck(efTarget, 't') || this.Effect != '') {
          continue
        }
        effectCheck = true
        let formula = efAry[2]
        let reg = new RegExp('monsterNum\\[([0-9]+)\\]')
        while (formula.match(reg)) {
          let refStr = RegExp.$1
          let num = Number(refStr)
          let result = 0
          if (num == TempVariable['firstMonster']) {
            result = 1
          }
          let reg2 = new RegExp('monsterNum\\[' + refStr + '\\]', 'g')
          formula = formula.replace(reg2, String(result))
        }
        formula = replaceFormula(formula)
        let alarmNum = Math.floor(strCalculation(formula))
        if (alarmNum < -1 && !efAry[4].match(/^(|-1)$/)) {
          efAry[4].replace(/\./g, ',')
          efAry[4] = MP.getCmNum(efAry[4].replace(/\./g, ','))
          let strAry = efAry[4].split(',')
          alarmNum = Number(strAry[dice(1, strAry.length) - 1])
        }
        if (alarmNum < 0 || alarmNum >= MONSTER_DATA.length) {
          alarmNum = -1
        }
        printDebugMessage('[SpellEffect] alarm (' + alarmNum + ')')
        this.Effect = 'alarm,' + String(alarmNum) + ',' + efAry[3]
      } else if (ef == 411 || ef == 412) {
        if (!this.activateCheck(efTarget, 'csbte', 'a')) {
          continue
        }
        let roomStr = ''
        if (efAry[2] == '-1') {
          roomStr = 'all'
        } else {
          roomStr = efAry[2].replace(/\./g, ',')
        }
        if (ef == 411) {
          printDebugMessage(
            "[SpellEffect] clear monster room's monster [" + roomStr + ']'
          )
        } else if (ef == 412) {
          printDebugMessage(
            "[SpellEffect] relocate monster room's monster [" + roomStr + ']'
          )
        }
        effectCheck = true
        if (roomStr != 'all') {
          roomStr = MP.getCmNum(roomStr)
        }
        if (ef == 411) {
          if (roomStr == 'all') {
            DUNGEON.controlCheckedMonsterRoom(true)
          } else {
            DUNGEON.controlCheckedMonsterRoomNum(roomStr, true)
          }
        } else if (ef == 412) {
          if (roomStr == 'all') {
            DUNGEON.controlCheckedMonsterRoom(false)
          } else {
            DUNGEON.controlCheckedMonsterRoomNum(roomStr, false)
          }
        }
      } else if (ef == 413) {
        if (!this.activateCheck(efTarget, 'c') || this.Effect != '') {
          continue
        }
        printDebugMessage('[SpellEffect] probe space')
        effectCheck = true
        this.Effect = 'probeSpace'
      } else if (ef == 420 || ef == 421) {
        if (!this.activateCheck(efTarget, 'o') || this.Effect != '') {
          continue
        }
        effectCheck = true
        let formula = efAry[2].replace(/trap\.lv/g, TempVariable['trapLv'])
        formula = replaceFormula(formula, [['pc', castChar['num2']]])
        let prob = Math.floor(strCalculation(formula))
        if (prob < 0) {
          prob = 0
        } else if (prob > 100) {
          prob = 100
        }
        if (ef == 420) {
          printDebugMessage('trap inspect success rate: ' + String(prob) + '%')
        } else {
          printDebugMessage('trap disarm rate: ' + String(prob) + '%')
        }
        if (prob >= dice(1, 100)) {
          if (ef == 420) {
            this.Effect = 'boxInspectTrue'
            printDebugMessage('  -> success')
          } else if (ef == 421) {
            this.Effect = 'boxDisarmTrue'
          }
        } else {
          if (ef == 420) {
            this.Effect = 'boxInspectFalse'
          } else if (ef == 421) {
            this.Effect = 'boxDisarmFalse'
          }
        }
      } else if (ef == 422) {
        if (!this.activateCheck(efTarget, 'csbte', 'a')) {
          continue
        }
        let result = this.calculationMyAndTarget(efAry[3], castChar, castChar)
        if (result == 0) {
          continue
        }
        efAry[2] = efAry[2].replace(/<\.>/g, '<>')
        efAry[2] = efAry[2].replace(/\./g, ',')
        printDebugMessage('[SpellEffect] control flag: ' + efAry[2])
        effectCheck = true
        controlFlag(efAry[2])
      } else if (ef == 423) {
        if (!this.activateCheck(efTarget, 'csbte', 'a')) {
          continue
        }
        printDebugMessage('[SpellEffect] change party music')
        effectCheck = true
        let range = Number(efAry[2])
        if (efAry[3].match(/^( |none)$/)) {
          efAry[3] = ''
        }
        if (range == 0) {
          efAry[3] = '0,' + efAry[3]
        } else if (range == 1) {
          efAry[3] = '1,' + efAry[3]
        } else {
          efAry[3] = ''
        }
        pt.DungeonMusic = efAry[3]
        if (this.SituationAbbr == 'e') {
          musicPlay(DUNGEON.getDungeonMusic())
        }
      } else if (ef == 424) {
        if (!this.activateCheck(efTarget, 'csbte', 'a')) {
          continue
        }
        printDebugMessage('[SpellEffect] change music')
        effectCheck = true
        let range = Number(efAry[2])
        if (efAry[3].match(/^( |none)$/)) {
          efAry[3] = ''
        }
        efAry[4] = efAry[4].replace(/[^0-9]/g, '')
        efAry[5] = efAry[5].replace(/[^0-9]/g, '')
        if (range == 0 || range == 4) {
          for (let i = 0; i < DUNGEON.DUNGEON_MAX; i++) {
            let floorMax = DUNGEON.FloorMinMax[i].length
            for (let j = 0; j < floorMax; j++) {
              if (range == 0) {
                PlayData['DungeonNewMusic'][i][j] = efAry[3]
              } else {
                PlayData['DungeonNewMusic'][i][j] = ''
              }
            }
          }
        } else if (range == 1 || range == 5) {
          let i = pt.DungeonNumber
          let floorMax = DUNGEON.FloorMinMax[i].length
          for (let j = 0; j < floorMax; j++) {
            if (range == 1) {
              PlayData['DungeonNewMusic'][i][j] = efAry[3]
            } else {
              PlayData['DungeonNewMusic'][i][j] = ''
            }
          }
        } else if (range == 2 || range == 6) {
          let i = pt.DungeonNumber
          let j = pt.Floor
          if (range == 2) {
            PlayData['DungeonNewMusic'][i][j] = efAry[3]
          } else {
            PlayData['DungeonNewMusic'][i][j] = ''
          }
        } else if (range == 3 || range == 7) {
          if (efAry[4] == '' || efAry[5] == '') {
            continue
          }
          let i = Number(efAry[4])
          let j = Number(efAry[5])
          if (i < 0 || i >= DUNGEON.DUNGEON_MAX) {
            continue
          }
          if (j < 0 || j >= DUNGEON.FloorMinMax[i].length) {
            continue
          }
          if (range == 3) {
            PlayData['DungeonNewMusic'][i][j] = efAry[3]
          } else {
            PlayData['DungeonNewMusic'][i][j] = ''
          }
        }
        if (this.SituationAbbr == 'e') {
          musicPlay(DUNGEON.getDungeonMusic())
        }
      } else if (ef == 425) {
        if (!this.activateCheck(efTarget, 'csbte', 'a', 'p')) {
          continue
        }
        printDebugMessage('[SpellEffect] set title')
        efAry[2] = efAry[2].replace(/<\.\.>/g, '<>')
        efAry[2] = efAry[2].replace(/<\.>/g, ',')
        efAry[3] = efAry[3].replace(/pc\./g, 'pc2.')
        efAry = this.replaceMyAndTargetEffectAry(efAry, [3], castChar['type'])
        let loopAry = this.getTarget(efTarget, targetCharNum, true, 'pc')
        for (let tNum = 0; tNum < loopAry.length; tNum++) {
          let targetChar = this.setCharData(loopAry[tNum])
          let efAry2 = this.replaceMyAndTargetEffectAry(
            efAry,
            [3],
            null,
            targetChar['type']
          )
          let result = this.calculationMyAndTarget(
            efAry2[3],
            castChar,
            targetChar
          )
          if (result == 0) {
            continue
          }
          effectCheck = true
          if (this.checkSpellCancel(targetChar)) {
            continue
          }
          targetChar['char'].controlTitle(efAry2[2])
        }
      } else if (ef == 426) {
        if (!this.activateCheck(efTarget, 'csbte', 'a')) {
          continue
        }
        printDebugMessage('[SpellEffect] control stock')
        let num = Number(efAry[2])
        if (efAry[3] == '-1' || num == 0) {
          continue
        }
        efAry[3] = efAry[3].replace(/\./g, ',')
        let strAry = MP.getCmNum(efAry[3]).split(',')
        for (let i = 0; i < strAry.length; i++) {
          let itemNum = Number(strAry[i])
          if (itemNum >= ITEM.length) {
            continue
          }
          let item = ITEM[itemNum]
          if (item.PRICE < 1 || !item.STOCK_OK) {
            continue
          }
          effectCheck = true
          item.setStock(num, true)
        }
      } else if (ef == 427) {
        let result = this.calculationMyAndTarget(efAry[3], castChar, castChar)
        if (result != 0) {
          efAry[2] = efAry[2].replace(/<\.>/g, ',')
          if (efAry[2].match(/^(| )$/)) {
            continue
          }
          if (this.SituationAbbr == 'b') {
            if (!effectCheck) {
              this.MessageStack[0].push(efAry[2])
            } else {
              this.MessageStack[1].push(efAry[2])
            }
          } else {
            this.MessageStack[0].push(efAry[2])
          }
        }
      } else if (ef == 428) {
        if (!this.activateCheck(efTarget, 'csbte', 'a')) {
          continue
        }
        printDebugMessage('[SpellEffect] registration to a monster catalog')
        if (efAry[3] == '-1') {
          continue
        }
        efAry[3] = efAry[3].replace(/\./g, ',')
        let strAry = MP.getCmNum(efAry[3]).split(',')
        for (let i = 0; i < strAry.length; i++) {
          let monNum = Number(strAry[i])
          if (monNum >= MONSTER_DATA.length) {
            continue
          }
          effectCheck = true
          if (efAry[2] == 'r') {
            PlayData['MonsterFlag'][monNum] = true
          } else if (efAry[2] == 'd') {
            PlayData['MonsterFlag'][monNum] = false
          }
        }
      } else if (ef == 430) {
        let result
        if (targetCharNum >= 0 && targetCharNum < 6) {
          let targetChar = this.setCharData(targetCharNum)
          result = this.calculationMyAndTarget(efAry[2], castChar, targetChar)
        } else if (targetCharNum >= 10 && targetCharNum <= 13) {
          let num = 20
          if (targetCharNum == 11) {
            num = 30
          } else if (targetCharNum == 12) {
            num = 40
          } else if (targetCharNum == 13) {
            num = 50
          }
          let targetChar = this.setCharData(num)
          result = this.calculationMyAndTarget(efAry[2], castChar, targetChar)
        } else if (targetCharNum == 60 || targetCharNum == 61) {
          let num = 70
          if (targetCharNum == 61) {
            num = 80
          }
          let targetChar = this.setCharData(num)
          result = this.calculationMyAndTarget(efAry[2], castChar, targetChar)
        } else if (situation.indexOf('event') > -1) {
          result = this.calculationMyAndTarget(efAry[2], castChar, castChar)
        } else {
          result = this.calculationMyAndTarget(efAry[2], castChar)
        }
        if (result == 0) {
          continue
        }
        let skipNum = Number(efAry[3])
        if (skipNum > 0) {
          eNum += skipNum
        } else {
          if (efAry[4] == ' ') {
            efAry[4] = ''
          }
          for (let i = eNum + 1; i < effectAry.length; i++) {
            let strAry = effectAry[i].split(',')
            let num = Number(strAry[0])
            if (num == 429) {
              if (strAry[2] == ' ') {
                strAry[2] = ''
              }
              if (strAry[2] == efAry[4]) {
                eNum = i
                break
              }
            }
          }
        }
      }
    }
    if (situation.match(/(Item|Sp)$/)) {
      if (!this.UseItemBreak) {
        let item = ITEM[useItemNum]
        let formula = item.BREAK_PROB
        if (situation.match(/Item$/)) {
          formula = formula.replaceAll('itemUse', '1')
          formula = formula.replaceAll('itemSp', '0')
        } else {
          formula = formula.replaceAll('itemUse', '0')
          formula = formula.replaceAll('itemSp', '1')
        }
        formula = replaceFormula(formula, [['pc', castChar['num2']]])
        let prob = Math.floor(strCalculation(formula))
        if (prob < 0) {
          prob = 0
        } else if (prob > 100) {
          prob = 100
        }
        printDebugMessage('break rate: ' + prob + '%')
        if (prob >= dice(1, 100)) {
          if (item.BROKEN_ITEM < 0) {
            this.controlHaveItem('remove', castChar, this.UseHaveNum)
          } else {
            this.controlHaveItem(
              'change',
              castChar,
              this.UseHaveNum,
              item.BROKEN_ITEM
            )
          }
        }
      }
    }
    if (situation == 'campItem') {
      TempVariable['haveNum'] = this.UseHaveNum
    }
    pt.check()
    if (levelLimit) {
      this.Effect = 'levelLimit'
    } else if (notUseSpell) {
      this.Effect = 'notCast'
    } else if (
      !effectCheck &&
      this.MessageStack[0].length < 1 &&
      this.MessageStack[1].length < 1
    ) {
      if (situation.indexOf('battle') > -1 && targetCharNum > -1) {
        this.Effect = 'noTarget'
      } else {
        this.Effect = 'none'
      }
    } else if (this.Effect == '') {
      if (situation.match(/^camp(Spell|Item)$/) && healingCheck) {
        this.Effect = 'heal'
      } else if (!success && fizzle) {
        this.Effect = 'fizzle'
      } else {
        this.Effect = 'done'
      }
    }
  }
}
