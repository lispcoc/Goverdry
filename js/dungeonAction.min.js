function dungeonAction (key) {
  GenericVariable['ReturnAction'] = dungeonAction
  if (key == undefined || key == null) {
    key = ''
    MP.SelectMode['selectF'] = 0
  }
  if (key.match(/^(none|start)$/)) {
    MP.SelectMode['selectF'] = 0
  }
  let value
  if (key == '' || key.match(/^(cancel|escape|start)$/)) {
    value = 0
  } else {
    value = MP.SelectMode['valueAry'][MP.SelectMode['select']]
  }
  let ptNum = PlayData['ActiveParty']
  let pt = PARTY[ptNum]
  if (GameState == 'campStart') {
    MP.clearMainWindow()
    MP.drawFrame_Center_Title(MP.MainSurface, getDefaultMessage('CAMP', 1))
    let formula = DUNGEON.NoMusicCamp[pt.DungeonNumber][pt.Floor]
    formula = replaceFormula(formula)
    if (strCalculation(formula) == 0) {
      musicPlay('camp')
    } else {
      musicPlay(DUNGEON.getDungeonMusic())
    }
    if (GameData['SAVE_CAMP']) {
      saveData('The camp is put')
    }
    GameState = 'camp'
    GameMode = 'camp'
  } else if (GameState == 'submenuStart') {
    MP.clearMainWindow()
    MP.drawFrame_Full_Title(MP.MainSurface, getDefaultMessage('SUB_MENU', 1))
    GameState = 'submenu'
  }
  let selAry = [],
    valueAry = [],
    colorAry = null
  let mode = 'normal',
    comment = ''
  let align = 'center',
    y = MP.LINE_HEIGHT,
    charMin = 0,
    lineNum = 0,
    textAlign = 'left'
  if (GameState == 'move') {
    let noReturn = false
    let space
    if (
      pt.Floor < 0 ||
      pt.Floor >= DUNGEON.FloorMinMax[pt.DungeonNumber].length ||
      pt.X < 0 ||
      pt.Y < 0 ||
      pt.X >= DUNGEON.Width[pt.DungeonNumber] ||
      pt.Y >= DUNGEON.Height[pt.DungeonNumber]
    ) {
      space = 'a'
    } else {
      space = DUNGEON.Space[pt.DungeonNumber][pt.Floor][pt.X][pt.Y]
    }
    if (key == 'cancel') {
      sePlay('enter')
      GameState = 'campStart'
      dungeonAction()
      return
    } else if (key == 'submenu') {
      sePlay('enter')
      GameState = 'submenuStart'
      dungeonAction()
      return
    } else if (key == 'map') {
      if (GameData['AUTO_MAP'] == 0) {
        return
      }
      if (GameData['AUTO_MAP_DARK_ZONE'] && space.charAt(0) == '1') {
        return
      }
      let haveItemFlag = true
      if (GameData['AUTO_MAP_ITEM'] != '') {
        haveItemFlag = false
        let strAry = GameData['AUTO_MAP_ITEM'].split(',')
        for (let i = 0; i < strAry.length; i++) {
          if (pt.haveItemNum(strAry[i]) > 0) {
            haveItemFlag = true
            break
          }
        }
      }
      let mapFlag = true
      if (GameData['AUTO_MAP_FLAG']) {
        mapFlag = false
        if (PlayData['GameFlagS'][1]) {
          mapFlag = true
        }
      }
      if (!haveItemFlag || !mapFlag) {
        return
      }
      if (Config['AutoMapping']) {
        MP.setDrawMap('map')
      } else {
        MP.clearTextSurface('all')
        GameState = 'mapText'
        let x = -1,
          y = -1,
          d = -1
        if (GameData['AUTO_MAP'] != 1 && GameData['AUTO_MAP'] != 4) {
          x = pt.X
          y = pt.Y
        }
        if (GameData['AUTO_MAP'] == 3 || GameData['AUTO_MAP'] == 6) {
          d = pt.Direction
        }
        MP.drawMapText(pt.DungeonNumber, pt.Floor, x, y, d)
      }
      return
    } else if (key == 'status') {
      PlayData['PartyStatusView'] = !PlayData['PartyStatusView']
      if (PlayData['PartyStatusView']) {
        MP.viewPartyStatus()
      } else {
        MP.viewPartyStatus('clear')
      }
      return
    } else if (key.match(/(up|down|right|left|enter)/)) {
      if (key.match(/up|enter/)) {
        let wall = DUNGEON.getWallDataInFront(
          pt.DungeonNumber,
          pt.Floor,
          pt.X,
          pt.Y,
          pt.Direction
        )
        let frontWall = DUNGEON.checkWall(
          wall,
          pt.DungeonNumber,
          pt.Floor,
          pt.Direction
        )
        if (frontWall == 0 && key.match(/up|enter/)) {
          if (wall.charAt(0) == '5') {
            key = 'shutter'
            noReturn = true
          } else {
            key = 'move'
          }
          oneStep(pt, 'forward')
        } else if (frontWall == 2 && key == 'enter') {
          if (wall.charAt(0) == '4') {
            noReturn = true
          }
          key = 'moveKick'
          oneStep(pt, 'forward')
        } else if (frontWall == 3 && key == 'enter') {
          key = 'lockedDoor'
        } else {
          key = 'ouch'
        }
      } else if (key.indexOf('shift') > -1) {
        let direction = pt.Direction
        if (key.indexOf('right') > -1) {
          direction++
          if (direction > 3) {
            direction = 0
          }
        } else if (key.indexOf('left') > -1) {
          direction--
          if (direction < 0) {
            direction = 3
          }
        }
        let wall = DUNGEON.getWallDataInFront(
          pt.DungeonNumber,
          pt.Floor,
          pt.X,
          pt.Y,
          direction
        )
        let frontWall = DUNGEON.checkWall(
          wall,
          pt.DungeonNumber,
          pt.Floor,
          direction
        )
        if (frontWall == 0) {
          if (key.indexOf('right') > -1) {
            oneStep(pt, 'right')
          } else if (key.indexOf('left') > -1) {
            oneStep(pt, 'left')
          }
          if (wall.charAt(0) == '5') {
            key = 'shutter'
            noReturn = true
          } else {
            key = 'move'
          }
        } else {
          key = 'ouch'
        }
      } else if (key.match(/^(right|down)$/)) {
        if (key == 'right') {
          key = 'turn'
        } else if (key == 'down') {
          key = 'turnAround'
        }
        pt.Direction++
        if (pt.Direction > 3) {
          pt.Direction = 0
        }
      } else if (key == 'left') {
        key = 'turn'
        pt.Direction--
        if (pt.Direction < 0) {
          pt.Direction = 3
        }
      }
    }
    if (
      pt.Floor < 0 ||
      pt.Floor >= DUNGEON.FloorMinMax[pt.DungeonNumber].length ||
      pt.X < 0 ||
      pt.Y < 0 ||
      pt.X >= DUNGEON.Width[pt.DungeonNumber] ||
      pt.Y >= DUNGEON.Height[pt.DungeonNumber]
    ) {
      space = 'a'
    } else {
      space = DUNGEON.Space[pt.DungeonNumber][pt.Floor][pt.X][pt.Y]
    }
    let darkzoneFlag = false
    let seName = ''
    if (space.charAt(0) == '1') {
      darkzoneFlag = true
    }
    if (key.match(/^(move|shutter)/)) {
      if (key == 'move') {
        seName = 'walk'
      } else if (key == 'moveKick') {
        seName = 'kickdoor'
      } else if (key == 'shutter') {
        seName = 'shutter'
      }
      pt.healingEffect()
      pt.checkSpellEffectEnd('walk')
      if (space.charAt(0) == '1') {
        pt.checkSpellEffectEnd('darkzone')
      }
      MP.FloorPatternFlag = !MP.FloorPatternFlag
    } else if (key == 'floor') {
      pt.PreX = pt.X
      pt.PreY = pt.Y
      pt.checkSpellEffectEnd('floor')
      DUNGEON.checkMapFlag()
      DUNGEON.controlCheckedMonsterRoom(false)
      controlFlag(DUNGEON.DungeonFlag[pt.DungeonNumber][pt.Floor])
      if (space.charAt(0) == '1') {
        pt.checkSpellEffectEnd('darkzone')
      }
      MP.FloorPatternFlag = !MP.FloorPatternFlag
      if (GameData['SAVE_FLOOR_MOVED']) {
        saveData('The floor is moved')
      }
    } else if (key.match(/^(ouch|lockedDoor)$/)) {
      seName = 'wall'
    } else if (key.match(/^turn/)) {
      seName = 'walk'
    }
    if (pt.checkAnnihilate()) {
      sePlay(seName)
      GameState = 'annihilate'
      MP.viewRip()
      annihilateProcessing()
      return
    }
    MP.DungeonLight = false
    if (
      space != 'a' &&
      pt.DungeonNumber > -1 &&
      pt.DungeonNumber < DUNGEON.DUNGEON_MAX
    ) {
      if (DUNGEON.Light[pt.DungeonNumber][pt.Floor] || pt.Light) {
        MP.DungeonLight = true
      }
    }
    if (space != 'a' && key != 'none') {
      MP.setDungeonView(key)
      DUNGEON.checkMapFlag()
    }
    MP.clearMainWindow()
    if (space == 'a') {
      MP.drawFrame_Center(MP.MainSurface)
    } else {
      MP.paintDungeon(MP.DungeonMode)
    }
    if (PlayData['PartyStatusView']) {
      MP.viewPartyStatus()
    }
    if (key == 'turnAround') {
      sePlay(seName)
      GenericVariable['KeyInvalid'] = true
      GenericVariable['TimeEventCountMax'] = TIME_COUNT[1]
      GenericVariable['TimeEventCount'] = 0
      GenericVariable['TimeEvent'] = 'turnAround'
      return
    }
    let offLimits = checkOffLimits(ptNum)
    if (offLimits != '') {
      sePlay(seName)
      let text = getDefaultMessage('OFF_LIMITS').replace(
        /\[target\]/g,
        offLimits
      )
      text = MP.strChangeLine(text, 42, 12, true)
      MP.drawTextFrame(
        MP.TextSurface[MP.TextSurfaceNum],
        text,
        'center',
        MP.LINE_HEIGHT * 3,
        42,
        0,
        'center'
      )
      TempVariable['nextDungeon'] = -1
      TempVariable['nextFloor'] = -1
      TempVariable['nextX'] = 0
      TempVariable['nextY'] = 0
      GameState = 'moveFloorInputKeySpellSound'
      return
    }
    if (key.match(/^(step|floor|move|shutter)/) || space.charAt(0) == 'a') {
      if (noReturn && space.charAt(0) != 'd') {
        pt.PreX = pt.X
        pt.PreY = pt.Y
      }
      if (space.charAt(0) != 'd') {
        GenericVariable['KeyInvalid'] = false
      }
      if (space.charAt(0) == '2') {
        sePlay(seName)
        TempVariable['text'] = getDefaultMessage('STAIRS_UP')
        let strAry = space.split(',')
        TempVariable['nextDungeon'] = pt.DungeonNumber
        TempVariable['nextFloor'] = pt.Floor + Number(strAry[1])
        TempVariable['nextX'] = DUNGEON.getPoint(
          pt.DungeonNumber,
          'w',
          Number(strAry[2])
        )
        TempVariable['nextY'] = DUNGEON.getPoint(
          pt.DungeonNumber,
          'h',
          Number(strAry[3])
        )
        GameState = 'moveStairs'
        dungeonAction()
        return
      } else if (space.charAt(0) == '3') {
        sePlay(seName)
        let strAry = space.split('<>')
        TempVariable['elevator'] = []
        for (let i = 1; i < strAry.length; i++) {
          TempVariable['elevator'].push(strAry[i])
        }
        GameState = 'moveElevator'
        dungeonAction()
        return
      } else if (space.charAt(0) == '4') {
        sePlay(seName)
        TempVariable['text'] = getDefaultMessage('STAIRS_DOWN')
        let strAry = space.split(',')
        TempVariable['nextDungeon'] = pt.DungeonNumber
        TempVariable['nextFloor'] = pt.Floor - Number(strAry[1])
        TempVariable['nextX'] = DUNGEON.getPoint(
          pt.DungeonNumber,
          'w',
          Number(strAry[2])
        )
        TempVariable['nextY'] = DUNGEON.getPoint(
          pt.DungeonNumber,
          'h',
          Number(strAry[3])
        )
        GameState = 'moveStairs'
        dungeonAction()
        return
      } else if (space.charAt(0) == '5') {
        if (!(pt.Flying != 0 && pt.FlyingEffect.indexOf('3') > -1)) {
          sePlay(seName)
          MP.paintDungeon('clear')
          pt.Direction = dice(1, 4) - 1
          GenericVariable['KeyInvalid'] = true
          GenericVariable['TimeEventCountMax'] = TIME_COUNT[1]
          GenericVariable['TimeEventCount'] = 0
          GenericVariable['TimeEvent'] = 'turnTable'
          return
        }
      } else if (space.charAt(0) == '6') {
        let strAry = space.split(',')
        if (strAry[1] == '2') {
          key = 'fallingRocks'
        } else {
          key = 'pit'
        }
        if (
          strAry[1] != '2' &&
          pt.Flying != 0 &&
          pt.FlyingEffect.indexOf('1') > -1
        ) {
          key = 'pitFlying'
        } else {
          let pitEvasion = GameData['PIT_EVASION_PROB'].replace(
            /trap\.lv/g,
            strAry[2]
          )
          let pitDamage = GameData['PIT_DAMAGE'].replace(/trap\.lv/g, strAry[3])
          let memberNum = pt.getMemberNum()
          for (let i = 0; i < memberNum; i++) {
            let pcNum = pt.PartyMember[i]
            let pc = PC[pcNum]
            if (pc.State > 3) {
              continue
            }
            let prob = Math.floor(
              strCalculation(replaceFormula(pitEvasion, [['pc', pcNum]]))
            )
            if (prob < dice(1, 100)) {
              let damage = Math.floor(
                strCalculation(replaceFormula(pitDamage, [['pc', pcNum]]))
              )
              pc.controlHp(-1 * damage, true)
            }
          }
          seName = 'hit'
          if (PlayData['PartyStatusView']) {
            MP.viewPartyStatus()
          }
        }
      } else if (space.charAt(0) == '7') {
        let strAry = space.split('<>')
        if (!strAry[1].match(/^(|none)$/)) {
          sePlay(seName)
          GenericVariable['FullKeyInvalid'] = true
          GameState = 'moveReturn'
          if (readGraphicInText(strAry[1], strAry[2])) {
            return
          }
          readEndAction()
          return
        }
      } else if (space.match(/^[89]/)) {
        if (
          space.charAt(0) == '8' &&
          pt.Flaying != 0 &&
          pt.FlyingEffect.indexOf('2') > -1
        ) {
          key = 'chute'
        } else if (
          space.charAt(0) == '9' &&
          pt.Flaying != 0 &&
          pt.FlyingEffect.indexOf('4') > -1
        ) {
          key = 'shaft'
        } else {
          let strAry = space.split(',')
          let message
          TempVariable['nextDungeon'] = pt.DungeonNumber
          if (space.charAt(0) == '8') {
            TempVariable['nextFloor'] = pt.Floor - Number(strAry[1])
            message = 'CHUTE'
            seName = 'chute'
          } else {
            TempVariable['nextFloor'] = pt.Floor + Number(strAry[1])
            message = 'SHAFT'
            seName = 'shaft'
          }
          sePlay(seName)
          TempVariable['nextX'] = DUNGEON.getPoint(
            pt.DungeonNumber,
            'w',
            Number(strAry[2])
          )
          TempVariable['nextY'] = DUNGEON.getPoint(
            pt.DungeonNumber,
            'h',
            Number(strAry[3])
          )
          MP.drawTextFrame(
            MP.TextSurface[MP.TextSurfaceNum],
            getDefaultMessage(message, 1),
            'center',
            MP.LINE_HEIGHT * 8
          )
          GameState = 'moveFloorInputKey'
          return
        }
      } else if (space.charAt(0) == 'a') {
        sePlay(seName)
        let str = 'IN_ROCK'
        if (
          pt.Floor < 0 ||
          pt.Floor >= DUNGEON.FloorMinMax[pt.DungeonNumber].length ||
          pt.X < 0 ||
          pt.Y < 0 ||
          pt.X >= DUNGEON.Width[pt.DungeonNumber] ||
          pt.Y >= DUNGEON.Height[pt.DungeonNumber]
        ) {
          let floor
          if (pt.Floor < 0) {
            let minFloor = DUNGEON.FloorMinMax[pt.DungeonNumber][0]
            floor = minFloor + pt.Floor
            if (minFloor > 0) {
              if (floor <= 0) {
                floor--
              }
            }
          } else if (pt.Floor >= DUNGEON.FloorMinMax[pt.DungeonNumber].length) {
            let maxFloor =
              DUNGEON.FloorMinMax[pt.DungeonNumber][
                DUNGEON.FloorMinMax[pt.DungeonNumber].length - 1
              ]
            floor =
              maxFloor +
              (pt.Floor - (DUNGEON.FloorMinMax[pt.DungeonNumber].length - 1))
            if (maxFloor < 0) {
              if (floor >= 0) {
                floor++
              }
            }
          } else {
            floor = DUNGEON.FloorMinMax[pt.DungeonNumber][pt.Floor]
          }
          if (floor > 1) {
            str = 'FAL_GROUND'
          }
        }
        str = getDefaultMessage(str)
        str = MP.strChangeLine(str, 42, 12, true)
        let lineNum = 8 - Math.floor(MP.strGetLineNum(str) / 2)
        MP.drawTextFrame(
          MP.TextSurface[MP.TextSurfaceNum],
          str,
          'center',
          MP.LINE_HEIGHT * lineNum
        )
        GameState = 'inStone'
        return
      } else if (space.charAt(0) == 'd') {
        let strAry = space.split(',')
        let d = Number(strAry[1])
        if (d > 4 && d < 10) {
          if (key.match(/^(step|floor)$/)) {
            if (d == 5) {
              d = 4
            } else {
              d -= 6
            }
          } else if (
            DUNGEON.getPoint(pt.DungeonNumber, 'h', pt.Y - 1) == pt.PreY
          ) {
            d = 0
          } else if (
            DUNGEON.getPoint(pt.DungeonNumber, 'w', pt.X - 1) == pt.PreX
          ) {
            d = 1
          } else if (
            DUNGEON.getPoint(pt.DungeonNumber, 'h', pt.Y + 1) == pt.PreY
          ) {
            d = 2
          } else if (
            DUNGEON.getPoint(pt.DungeonNumber, 'w', pt.X + 1) == pt.PreX
          ) {
            d = 3
          } else {
            d = 4
          }
        }
        if (d == 4) {
          let stack = []
          for (let i = 0; i < 4; i++) {
            let wall = DUNGEON.getWallDataInFront(
              pt.DungeonNumber,
              pt.Floor,
              pt.X,
              pt.Y,
              i
            )
            if (DUNGEON.checkWall(wall, pt.DungeonNumber, pt.Floor, i) == 0) {
              stack.push(i)
            }
          }
          if (stack.length < 0) {
            d = 0
          } else {
            d = stack[dice(1, stack.length) - 1]
          }
        }
        let frontWall = DUNGEON.getWallDataInFront(
          pt.DungeonNumber,
          pt.Floor,
          pt.X,
          pt.Y,
          d
        )
        if (DUNGEON.checkWall(frontWall, pt.DungeonNumber, pt.Floor, d) == 0) {
          sePlay(seName)
          if (key == 'shutter') {
            MP.drawTextFrame(
              MP.TextSurface[MP.TextSurfaceNum],
              getDefaultMessage('SHUTTER', 1),
              'center',
              MP.LINE_HEIGHT * 8
            )
          }
          pt.PreX = pt.X
          pt.PreY = pt.Y
          if (d == 0) {
            pt.Y = DUNGEON.getPoint(pt.DungeonNumber, 'h', pt.Y + 1)
          } else if (d == 1) {
            pt.X = DUNGEON.getPoint(pt.DungeonNumber, 'w', pt.X + 1)
          } else if (d == 2) {
            pt.Y = DUNGEON.getPoint(pt.DungeonNumber, 'h', pt.Y - 1)
          } else if (d == 3) {
            pt.X = DUNGEON.getPoint(pt.DungeonNumber, 'w', pt.X - 1)
          }
          if (strAry[2] == '1') {
            pt.Direction = d
          }
          GenericVariable['KeyInvalid'] = true
          GenericVariable['TimeEventCountMax'] = TIME_COUNT[2]
          GenericVariable['TimeEventCount'] = 0
          if (frontWall.charAt(0) != '5') {
            GenericVariable['TimeEvent'] = 'slide'
          } else {
            GenericVariable['TimeEvent'] = 'slideShutter'
          }
          return
        } else if (noReturn) {
          pt.PreX = pt.X
          pt.PreY = pt.Y
        }
      } else if (space.charAt(0) == 'E') {
        let strAry = space.split('<>')
        let eventStr = ''
        for (let i = 2; i < strAry.length; i += 2) {
          if (checkCondition(strAry[i])) {
            if (strAry[i + 1] != 'none') {
              eventStr = strAry[i + 1]
            }
            break
          }
        }
        if (eventStr != '') {
          sePlay(seName)
          TempVariable['event'] = eventStr.split('<->')
          GenericVariable['FullKeyInvalid'] = true
          GameState = 'moveEventReturn'
          if (readGraphicInText(eventStr, null)) {
            return
          }
          readEndAction()
          return
        }
      } else if (space.charAt(0) == 'R') {
        sePlay(seName)
        MP.paintDungeon('clear')
        TempVariable['nextDungeon'] = -1
        TempVariable['nextFloor'] = -1
        TempVariable['nextX'] = 0
        TempVariable['nextY'] = 0
        GenericVariable['KeyInvalid'] = true
        GenericVariable['TimeEventCountMax'] = TIME_COUNT[1]
        GenericVariable['TimeEventCount'] = 0
        GenericVariable['TimeEvent'] = 'moveFloor'
        return
      } else if (space.charAt(0) == 'S') {
        let strAry = space.split('<>')
        let strAry2 = strAry[0].split(',')
        pt.spellEffectClear(false)
        let num = Number(strAry2[1])
        if (num > 0) {
          num *= -1
        }
        let memberNum = pt.getMemberNum()
        for (let i = 0; i < memberNum; i++) {
          let pcNum = pt.PartyMember[i]
          let pc = PC[pcNum]
          pc.SealSpell = true
          pc.SealSpellInt = num
        }
        pt.check()
        if (PlayData['PartyStatusView']) {
          MP.viewPartyStatus()
        }
        if (!strAry[1].match(/^(|none)$/)) {
          sePlay(seName)
          GenericVariable['FullKeyInvalid'] = true
          GameState = 'moveReturn'
          if (readGraphicInText(strAry[1], strAry[2])) {
            return
          }
          readEndAction()
          return
        }
      } else if (space.charAt(0) == 'W' && key != 'step') {
        sePlay(seName)
        MP.paintDungeon('clear')
        let strAry = space.split(',')
        TempVariable['nextDungeon'] = pt.DungeonNumber
        TempVariable['nextFloor'] = pt.Floor
        TempVariable['nextX'] = DUNGEON.getPoint(
          pt.DungeonNumber,
          'w',
          Number(strAry[1])
        )
        TempVariable['nextY'] = DUNGEON.getPoint(
          pt.DungeonNumber,
          'h',
          Number(strAry[2])
        )
        GenericVariable['KeyInvalid'] = true
        GenericVariable['TimeEventCountMax'] = TIME_COUNT[1]
        GenericVariable['TimeEventCount'] = 0
        GenericVariable['TimeEvent'] = 'moveFloor'
        return
      }
    }
    sePlay(seName)
    if (pt.checkAnnihilate()) {
      GameState = 'annihilate'
      MP.viewRip()
      annihilateProcessing()
      return
    }
    if (
      key.match(/^(step|move|turn|shutter|encount|pit|pitFlying|fallingRocks)/)
    ) {
      if (checkEncount(ptNum)) {
        return
      }
    }
    if (
      key.match(
        /^(ouch|shutter|lockedDoor|chute|shaft|pit|pitFlying|fallingRocks)$/
      ) ||
      (darkzoneFlag && !pt.ViewDarkZone)
    ) {
      let message = ''
      if (key == 'ouch') {
        message = 'OUCH'
      } else if (key == 'shutter') {
        message = 'SHUTTER'
      } else if (key == 'lockedDoor') {
        message = 'DOOR_LOCKED'
      } else if (key == 'chute') {
        message = 'CHUTE'
      } else if (key == 'shaft') {
        message = 'SHAFT'
      } else if (key.match(/^pit/)) {
        message = 'PIT'
      } else if (key == 'fallingRocks') {
        message = 'FALLING_ROCKS'
      } else if (darkzoneFlag && !pt.ViewDarkZone) {
        message = 'DARK_ZONE'
      }
      MP.drawTextFrame(
        MP.TextSurface[MP.TextSurfaceNum],
        getDefaultMessage(message, 1),
        'center',
        MP.LINE_HEIGHT * 8
      )
      if (key.match(/^(chute|shaft|pitFlying)$/)) {
        MP.drawTextFrame(
          MP.TextSurface[MP.TextSurfaceNum],
          getDefaultMessage('FLYING_AIR', 1),
          'center',
          MP.LINE_HEIGHT * 9.5
        )
      }
    }
    GenericVariable['KeyInvalid'] = false
    return
  } else if (GameState == 'moveStart') {
    if (TempVariable['moveStart'] == undefined) {
      TempVariable['moveStart'] = key
    }
    if (
      Config['Dungeon'] == 'graphic' &&
      DUNGEON.DungeonImageStr !=
        DUNGEON.DungeonImage[pt.DungeonNumber][pt.Floor]
    ) {
      let dungeonImage = DUNGEON.DungeonImage[pt.DungeonNumber][pt.Floor]
      let dungeonAry = dungeonImage.split('<->')
      let dungeonAry2 = dungeonAry.slice()
      while (true) {
        let num = dungeonAry2.indexOf('')
        if (num < 0) {
          break
        } else {
          dungeonAry2.splice(num, 1)
        }
      }
      if (dungeonAry2.length > 0) {
        dungeonAry2 = checkGraphic_Dungeon(dungeonAry2)
        if (dungeonAry2.length > 0) {
          readGraphicFile_Dungeon(dungeonAry2, dungeonAction)
          return
        }
      }
      GraphicData['null'] = null
      GraphicData['none'] = 'none'
      for (let i = 0; i < dungeonAry.length; i++) {
        if (dungeonAry[i] == '') {
          dungeonAry[i] = 'null'
        } else if (dungeonAry[i] != 'none') {
          dungeonAry[i] = 'graphic/dungeon/' + dungeonAry[i]
        }
      }
      MP.setDungeonGraphic(
        GraphicData[dungeonAry[1]],
        GraphicData[dungeonAry[8]],
        GraphicData[dungeonAry[2]],
        GraphicData[dungeonAry[0]],
        GraphicData[dungeonAry[11]],
        GraphicData[dungeonAry[5]],
        GraphicData[dungeonAry[12]],
        GraphicData[dungeonAry[6]],
        GraphicData[dungeonAry[3]],
        GraphicData[dungeonAry[7]],
        GraphicData[dungeonAry[4]],
        GraphicData[dungeonAry[9]],
        GraphicData[dungeonAry[10]]
      )
      DUNGEON.DungeonImageStr = dungeonImage
      for (let i = 1; i < 8; i++) {
        if (i == 6) {
          continue
        }
        for (let j = 0; j < MP.Wall3D[i].length; j++) {
          MP.setTextureWall3D(i, j, 0)
          MP.setTextureWall3D(i, j, 1)
        }
      }
      for (let i = 1; i < 5; i++) {
        for (let j = 0; j < MP.Floor3D[i].length; j++) {
          for (let k = 0; k < MP.Floor3D[i][j].length; k++) {
            for (let l = 0; l < MP.Floor3D[i][j][k].length; l++) {
              MP.setTextureFloor3D(i, j, k, l, 0)
              MP.setTextureFloor3D(i, j, k, l, 1)
            }
          }
        }
      }
      MP.paintMask('clear')
      MP.TopSurface.clear()
      GenericVariable['FullKeyInvalid'] = false
    }
    if (Config['Dungeon'] == 'graphic') {
      if (MP.ImgWall == null) {
        MP.DungeonMode = 'wireFrame'
      } else {
        MP.DungeonMode = 'graphic'
      }
    } else {
      MP.DungeonMode = 'wireFrame'
    }
    musicPlay(DUNGEON.getDungeonMusic())
    GameMode = 'dungeon'
    GameState = 'move'
    dungeonAction(TempVariable['moveStart'])
    delete TempVariable['moveStart']
    return
  } else if (GameState == 'moveStairs') {
    MP.clearTextSurface('all')
    if (key == 'cancel') {
      key = 'enter'
      value = 1
    }
    if (key == 'enter') {
      if (value == 0) {
        MP.paintDungeon('clear')
        TempVariable['nextX'] = DUNGEON.getPoint(
          pt.DungeonNumber,
          'w',
          TempVariable['nextX']
        )
        TempVariable['nextY'] = DUNGEON.getPoint(
          pt.DungeonNumber,
          'h',
          TempVariable['nextY']
        )
        GenericVariable['KeyInvalid'] = true
        GenericVariable['TimeEventCountMax'] = TIME_COUNT[1]
        GenericVariable['TimeEventCount'] = 0
        GenericVariable['TimeEvent'] = 'moveFloor'
      } else {
        GameState = 'move'
        dungeonAction('none')
      }
      return
    }
    let text = MP.strChangeLine(TempVariable['text'], 42, 12, true)
    MP.drawTextFrame(
      MP.TextSurface[MP.TextSurfaceNum],
      text,
      'center',
      MP.LINE_HEIGHT * 3,
      42,
      0
    )
    MP.TextSurfaceNum++
    selAry.push(getDefaultMessage('YES', 1, 12))
    selAry.push(getDefaultMessage('NO', 1, 12))
    let len = MP.strCountAry(selAry)
    align = MP.MAIN_X + MP.MAIN_WIDTH / 2 + (MP.FONT_SIZE / 2) * (18 - len)
    y *= 4 + MP.strGetLineNum(text)
  } else if (GameState == 'moveElevator') {
    MP.clearTextSurface('all')
    if (key == 'cancel') {
      GameState = 'move'
      dungeonAction('none')
      return
    } else if (key == 'enter') {
      value = Number(value)
      let strAry = TempVariable['elevator'][value].split(',')
      TempVariable['nextDungeon'] = pt.DungeonNumber
      TempVariable['nextFloor'] = Number(strAry[0])
      TempVariable['nextX'] = DUNGEON.getPoint(
        pt.DungeonNumber,
        'w',
        Number(strAry[1])
      )
      TempVariable['nextY'] = DUNGEON.getPoint(
        pt.DungeonNumber,
        'h',
        Number(strAry[2])
      )
      MP.paintDungeon('clear')
      GenericVariable['KeyInvalid'] = true
      GenericVariable['TimeEventCountMax'] = TIME_COUNT[1]
      GenericVariable['TimeEventCount'] = 0
      GenericVariable['TimeEvent'] = 'moveFloor'
      return
    }
    let text = MP.strChangeLine(getDefaultMessage('ELEVATOR'), 42, 12, true)
    MP.drawTextFrame(
      MP.TextSurface[MP.TextSurfaceNum],
      text,
      'center',
      MP.LINE_HEIGHT * 3,
      42,
      0
    )
    MP.TextSurfaceNum++
    for (let i = 0; i < TempVariable['elevator'].length; i++) {
      let strAry = TempVariable['elevator'][i].split(',')
      let floor = Number(strAry[0])
      if (pt.Floor == floor) {
        value = String(i)
      }
      selAry.push(DUNGEON.getFloorName(pt.DungeonNumber, floor))
      valueAry.push(String(i))
    }
    let textLineNum = MP.strGetLineNum(text)
    if (textLineNum > 4) {
      let limitNum = 20 - textLineNum
      if (TempVariable['elevator'].length > limitNum) {
        lineNum = limitNum
      }
    }
    let len = MP.strCountAry(selAry)
    align = MP.MAIN_X + MP.MAIN_WIDTH / 2 + (MP.FONT_SIZE / 2) * (18 - len)
    y *= 4 + textLineNum
    textAlign = 'right'
  } else if (GameState == 'moveEvent1') {
    let strAry = TempVariable['event'][0].split('<*>')
    if (!strAry[0].match(/^(|none)$/)) {
      GameState = 'moveEvent2Return'
      MP.setMessage(strAry[0], strAry[1])
    } else {
      GameState = 'moveEvent2'
      dungeonAction()
    }
    return
  } else if (GameState == 'moveEvent2') {
    if (key == 'cancel') {
      key = 'enter'
      value = 1
    }
    if (key == 'enter') {
      if (value == 0) {
        GameState = 'moveEvent3yes'
      } else {
        GameState = 'moveEvent3no'
      }
      dungeonAction()
      return
    }
    MP.clearTextSurface('all')
    let strAry = TempVariable['event'][1].split('<*>')
    if (strAry[0] != '1') {
      GameState = 'moveEvent3yes'
      dungeonAction()
      return
    }
    let text = strAry[1]
    if (text == 'none') {
      text = getDefaultMessage('WILL_YOU_SEARCH')
    }
    text = MP.strChangeLine(text, 38, 12, true)
    MP.drawTextFrame(
      MP.TextSurface[MP.TextSurfaceNum],
      text,
      'center',
      MP.LINE_HEIGHT * 3,
      38,
      0,
      strAry[2]
    )
    MP.TextSurfaceNum++
    value = 0
    selAry.push(getDefaultMessage('YES', 1, 12))
    selAry.push(getDefaultMessage('NO', 1, 12))
    let len = MP.strCountAry(selAry)
    align = MP.MAIN_X + MP.MAIN_WIDTH / 2 + (MP.FONT_SIZE / 2) * (18 - len)
    y *= 4 + MP.strGetLineNum(text)
  } else if (GameState == 'moveEvent3trade2') {
    let pcNum = PlayData['StatusNum']
    let pc = PC[pcNum]
    if (key == 'cancel') {
      MP.SelectMode['valueAry'][MP.SelectMode['select']] = String(
        PlayData['StatusNum']
      )
      GameState = TempVariable['preGameState']
      dungeonAction('none')
      return
    } else if (key == 'enter') {
      let haveNum = Number(value)
      let itemNumStr = String(pc.Item[haveNum])
      if (TempVariable['eventAry'].indexOf(itemNumStr) > -1) {
        pc.removeHaveItem(haveNum)
        pc.check()
        GameState = 'moveEvent4_1'
      } else {
        GameState = 'moveEvent4_2'
      }
      dungeonAction()
      return
    }
    MP.clearTextSurface('all')
    MP.TopSurface.clear()
    for (let i = 0; i < TempVariable['itemList'].length; i++) {
      selAry.push(pc.getItemName(TempVariable['itemList'][i], 'decided'))
      valueAry.push(String(TempVariable['itemList'][i]))
    }
    y *= 4
    charMin = 26
    lineNum = pc.ItemMaxNum
    if (lineNum > 12) {
      lineNum = 12
    }
    comment = 'haveItem'
  } else if (GameState.match(/^moveEvent3/)) {
    if (key == 'cancel') {
      if (PlayData['PartyStatusView']) {
        MP.viewPartyStatus()
      } else {
        MP.viewPartyStatus('clear')
      }
      PlayData['StatusNum'] = -1
      GameState = 'moveEvent4_2'
      dungeonAction()
      return
    } else if (key == 'enter') {
      if (PlayData['PartyStatusView']) {
        MP.viewPartyStatus()
      } else {
        MP.viewPartyStatus('clear')
      }
      let pcNum = Number(MP.SelectMode['valueAry'][MP.SelectMode['select']])
      PlayData['StatusNum'] = pcNum
      let pc = PC[pcNum]
      if (GameState == 'moveEvent3pay') {
        let pay = Math.floor(
          strCalculation(replaceFormula(TempVariable['eventStr']))
        )
        if (pay < 0) {
          pay = 0
        }
        if (pc.Gold < pay) {
          GameState = 'moveEvent4_2'
          dungeonAction()
          return
        }
        pc.Gold -= pay
        GameState = 'moveEvent4_1'
        dungeonAction()
        return
      } else if (GameState == 'moveEvent3trade') {
        TempVariable['itemList'] = []
        let itemMax = pc.haveItemNum(-1)
        for (let i = 0; i < itemMax; i++) {
          if (pc.Equip[i] == 0) {
            TempVariable['itemList'].push(i)
          }
        }
        if (TempVariable['itemList'].length < 1) {
          GameState = TempVariable['preGameState']
        } else {
          GameState = 'moveEvent3trade2'
          dungeonAction()
          return
        }
      } else {
        GameState = 'moveEvent4_1'
        dungeonAction()
        return
      }
    }
    MP.clearTextSurface('all')
    MP.TopSurface.clear()
    let eventStr
    TempVariable['preGameState'] = GameState
    if (GameState == 'moveEvent3yes') {
      eventStr = TempVariable['event'][2]
    } else {
      eventStr = TempVariable['event'][3]
    }
    if (eventStr == 'none') {
      GameState = 'move'
      dungeonAction('none')
      return
    }
    let strAry = eventStr.split('<+>')
    TempVariable['mainEvent'] = strAry.slice()
    let strAry2 = strAry[0].split('<*>')
    if (strAry2[0].match(/^[124]$/)) {
      let str
      if (strAry2[0] == '1') {
        GameState = 'moveEvent3pay'
        str = 'WHO_PAY'
        comment = 'haveMoney'
        TempVariable['eventStr'] = strAry2[1]
      } else if (strAry2[0] == '2') {
        GameState = 'moveEvent3trade'
        str = 'WHO_HAND'
        strAry[0] = strAry[0].replace(/<\*>/g, ',')
        strAry[0] = strAry[0].replace(/^2,/, '')
        strAry[0] = MP.getCmNum(strAry[0])
        TempVariable['eventAry'] = strAry[0].split(',')
      } else if (strAry2[0] == '4') {
        GameState = 'moveEvent3select'
        str = 'WHO_DOES'
        strAry2.splice(0, 1)
        TempVariable['eventAry'] = strAry2.slice()
      }
      MP.drawTextFrame(
        MP.TextSurface[MP.TextSurfaceNum],
        getDefaultMessage(str, 1),
        'center',
        MP.LINE_HEIGHT * 6
      )
      MP.TextSurfaceNum++
      let memberNum = pt.getMemberNum()
      for (let i = 0; i < memberNum; i++) {
        selAry.push(String(i))
        valueAry.push(String(pt.PartyMember[i]))
      }
      mode = 'pcSel'
    } else if (strAry2[0] == '3') {
      GameState = 'moveEvent3inputText'
      strAry[0] = strAry[0].replace(/^3<\*>/, '')
      TempVariable['eventAry'] = strAry[0].split('<*>')
      for (let i = 0; i < TempVariable['eventAry'].length; i++) {
        TempVariable['eventAry'][i] = MP.zenkaku2hankaku(
          TempVariable['eventAry'][i]
        )
      }
      PlayData['StatusNum'] = -1
      GenericVariable['FullKeyInvalid'] = true
      MP.controlInputText('set')
      GenericVariable['ReturnKeyControll'] = 0
      return
    } else {
      PlayData['StatusNum'] = -1
      GameState = 'moveEvent4_1'
      dungeonAction()
      return
    }
  } else if (GameState.match(/^moveEvent4/)) {
    MP.clearTextSurface('all')
    MP.TopSurface.clear()
    let eventStr
    if (GameState == 'moveEvent4_1') {
      eventStr = TempVariable['mainEvent'][1]
    } else {
      eventStr = TempVariable['mainEvent'][2]
    }
    if (eventStr == 'none') {
      GameState = 'move'
      dungeonAction('none')
      return
    }
    TempVariable['event'] = eventStr.split('<*>')
    if (!TempVariable['event'][2].match(/^(none|sound)$/)) {
      sePlay(TempVariable['event'][2])
    }
    if (!TempVariable['event'][0].match(/^(|none)$/)) {
      GameState = 'moveEvent5Return'
      MP.setMessage(TempVariable['event'][0], TempVariable['event'][1])
    } else {
      GameState = 'moveEvent5'
      dungeonAction()
    }
    return
  } else if (GameState == 'moveEvent5') {
    MP.clearTextSurface('all')
    if (!TempVariable['event'][3].match(/^(none|flag)$/)) {
      controlFlag(TempVariable['event'][3].replace(/<\+\+>/g, '<>'))
    }
    let strAry = TempVariable['event'][4].split(',')
    let eventNum = Number(strAry[0])
    if (eventNum == 0) {
      GameState = 'move'
      if (strAry[1] == 'true') {
        dungeonAction('step')
      } else {
        dungeonAction('none')
      }
    } else if (eventNum == 1) {
      let itemNum = Number(strAry[1])
      if (itemNum > -1 && itemNum < ITEM.length) {
        let decided = 0
        if (ITEM[itemNum].DECIDED == 0) {
          if (GameData['ITEM_DECIDED']) {
            decided = 1
          }
        } else if (ITEM[itemNum].DECIDED == 1) {
          decided = 1
        }
        let pcNumInParty = pt.putItem(itemNum, decided)
        let text = ''
        if (pcNumInParty > -1) {
          if (decided == 1) {
            PlayData['ItemFlag'][itemNum] = true
          }
          let pcNum = pt.PartyMember[pcNumInParty]
          let pc = PC[pcNum]
          pc.check()
          if (PlayData['PartyStatusNow']) {
            MP.viewPartyStatus(true, PlayData['PartyStatusNum'])
          }
          text = getDefaultMessage('FOUND_ITEM')
          let str = pc.Name[0]
          text = text.replace(/\[name\]/g, str)
          str = ITEM[itemNum].getName(decided)
          text = text.replace(/\[item\]/g, str)
          align = 'left'
        } else {
          text = getDefaultMessage('CANNOT_CARRY_MORE')
        }
        text = MP.strChangeLine(text, 42, 12, true)
        MP.drawTextFrame(
          MP.TextSurface[MP.TextSurfaceNum],
          text,
          'center',
          MP.LINE_HEIGHT * 3,
          42,
          0,
          align
        )
        if (strAry[2] == 'true') {
          GameState = 'moveReturnInputKeyStep'
        } else {
          GameState = 'moveReturnInputKey'
        }
      } else {
        GameState = 'move'
        if (strAry[2] == 'true') {
          dungeonAction('step')
        } else {
          dungeonAction('none')
        }
      }
    } else if (eventNum == 2) {
      MP.paintDungeon('clear')
      TempVariable['nextDungeon'] = pt.DungeonNumber
      TempVariable['nextFloor'] = Number(strAry[1])
      TempVariable['nextX'] = Number(strAry[2])
      TempVariable['nextY'] = Number(strAry[3])
      GenericVariable['KeyInvalid'] = true
      GenericVariable['TimeEventCountMax'] = TIME_COUNT[1]
      GenericVariable['TimeEventCount'] = 0
      GenericVariable['TimeEvent'] = 'moveFloorInRock'
    } else if (eventNum == 3) {
      MP.paintDungeon('clear')
      TempVariable['nextDungeon'] = -1
      TempVariable['nextFloor'] = -1
      TempVariable['nextX'] = 0
      TempVariable['nextY'] = 0
      GenericVariable['KeyInvalid'] = true
      GenericVariable['TimeEventCountMax'] = TIME_COUNT[1]
      GenericVariable['TimeEventCount'] = 0
      GenericVariable['TimeEvent'] = 'moveFloor'
    } else if (eventNum == 4) {
      let boxProb = '0'
      if (strAry[2] == '-1') {
        strAry[2] = ''
        boxProb = '100'
      } else if (strAry[2] == '-2') {
        strAry[2] = ''
      }
      if (strAry[4] == 'none') {
        strAry[4] = ''
      }
      let eventAgain = false
      if (strAry[5] == 'true') {
        eventAgain = true
      }
      if (strAry[6] == 'none') {
        strAry[6] = ''
      }
      if (strAry[7] == 'none') {
        strAry[7] = ''
      }
      encountMonster(
        strAry[1],
        strAry[2],
        boxProb,
        strAry[3],
        strAry[4],
        strAry[6],
        strAry[7],
        eventAgain
      )
    } else if (eventNum == 5) {
      let eventEffect = strAry[1].replace(/<1>/g, '<->')
      eventEffect = eventEffect.replace(/<2>/g, '<+>')
      eventEffect = eventEffect.replace(/<3>/g, '<*>')
      eventEffect = spellEffectReplace(eventEffect, 4)
      let strTrapAry = DUNGEON.BoxTrap[pt.DungeonNumber][pt.Floor].split('<>')
      let trapLv = Number(strTrapAry[0])
      eventEffect = eventEffect.replace(/trap\.lv/g, String(trapLv))
      let eventTarget = Number(strAry[2])
      SPELL_EF.clearSpellEffect()
      let effect = ''
      if (eventTarget == 0) {
        let pcNum = pt.PartyMember[0]
        let formula = replaceFormula(strAry[3], [['pc', pcNum]])
        let prob = Math.floor(strCalculation(formula))
        if (prob < 0) {
          prob = 0
        } else if (prob > 100) {
          prob = 100
        }
        if (prob >= dice(1, 100)) {
          let spellData = decomposeSpell(eventEffect)
          let spellSelNum = 0
          if (spellData['spellEffect'].length > 1) {
            spellSelNum = dice(1, spellData['spellEffect'].length) - 1
          }
          SPELL_EF.spellEffect(spellData, spellSelNum, 'event')
          effect = SPELL_EF.Effect
        }
      } else {
        let start = 0,
          end = pt.getMemberNum()
        if (eventTarget == 2) {
          if (PlayData['StatusNum'] > -1) {
            start = pt.getMemberForPcNum(PlayData['StatusNum'])
            end = start + 1
          }
        }
        for (let i = start; i < end; i++) {
          let pcNum = pt.PartyMember[i]
          let formula = replaceFormula(strAry[3], [['pc', pcNum]])
          let prob = Math.floor(strCalculation(formula))
          if (prob < 0) {
            prob = 0
          } else if (prob > 100) {
            prob = 100
          }
          if (prob >= dice(1, 100)) {
            let spellData = decomposeSpell(eventEffect, pcNum)
            let spellSelNum = 0
            if (spellData['spellEffect'].length > 1) {
              spellSelNum = dice(1, spellData['spellEffect'].length) - 1
            }
            let charNum = pt.getMemberForPcNum(pcNum)
            SPELL_EF.spellEffect(
              spellData,
              spellSelNum,
              'event',
              charNum,
              charNum
            )
            if (effect == '') {
              effect = SPELL_EF.Effect
            }
          }
        }
      }
      if (effect.indexOf('partyLocation') > -1) {
        if (Config['AutoMapping']) {
          let gameState
          if (strAry[4] == 'true') {
            gameState = 'mapEventStep'
          } else {
            gameState = 'mapEvent'
          }
          let ary = effect.split(',')
          MP.setDrawMap(gameState, ary[1], ary[2])
        } else {
          if (strAry[4] == 'true') {
            GameState = 'moveReturnInputKeyStep'
          } else {
            GameState = 'moveReturnInputKey'
          }
          MP.drawMapText(pt.DungeonNumber, pt.Floor, pt.X, pt.Y, pt.Direction)
        }
        return
      } else if (effect.indexOf('searchForPC') > -1) {
        if (strAry[4] == 'true') {
          GameState = 'searchForPcEventStep'
        } else {
          GameState = 'searchForPcEvent'
        }
        statusAction()
        return
      } else if (SPELL_EF.MessageStack[0].length > 0) {
        if (strAry[4] == 'true') {
          GameState = 'messageInDungeonStep'
        } else {
          GameState = 'messageInDungeon'
        }
        dungeonAction()
        return
      }
      GameState = 'move'
      if (strAry[4] == 'true') {
        dungeonAction('step')
      } else {
        dungeonAction('none')
      }
    } else if (eventNum == 6) {
      let strAry2 = strAry[1].split('</>')
      let text = ''
      let textAlign = ''
      for (let i = 1; i < strAry2.length; i += 3) {
        if (checkCondition(strAry2[i])) {
          if (!strAry2[i + 1].match(/^(|none)$/)) {
            strAry2[i + 1] = strAry2[i + 1].replace(/<1>/g, ',')
            text = strAry2[i + 1]
            textAlign = strAry2[i + 2]
            break
          }
        }
      }
      if (text != '') {
        if (strAry[2] == 'true') {
          GameState = 'moveStepReturn'
        } else {
          GameState = 'moveReturn'
        }
        MP.setMessage(text, textAlign)
      } else {
        GameState = 'move'
        if (strAry[2] == 'true') {
          dungeonAction('step')
        } else {
          dungeonAction('none')
        }
      }
    } else if (eventNum == 7) {
      MP.paintDungeon('clear')
      TempVariable['nextDungeon'] = Number(strAry[4])
      TempVariable['nextFloor'] = Number(strAry[1])
      TempVariable['nextX'] = Number(strAry[2])
      TempVariable['nextY'] = Number(strAry[3])
      GenericVariable['KeyInvalid'] = true
      GenericVariable['TimeEventCountMax'] = TIME_COUNT[1]
      GenericVariable['TimeEventCount'] = 0
      GenericVariable['TimeEvent'] = 'moveFloorInRock'
    } else if (eventNum == 8) {
      let strAry2 = strAry[1].split('</>')
      let stack = []
      for (let i = 0; i < PlayData['GarbageItem'].length; i++) {
        let strAry3 = PlayData['GarbageItem'][i].split(',')
        for (let j = 0; j < strAry2.length; j++) {
          if (strAry2[j] == strAry3[0]) {
            stack.push(String(i) + ',' + strAry3[1])
          }
        }
      }
      let text = ''
      if (stack.length < 1) {
        text = getDefaultMessage('FOUND_NOT')
      } else if (pt.getItemSpaceNum() > 0) {
        let num = Number(strAry[2])
        let getItem
        if (num == 0) {
          getItem = stack[stack.length - 1]
        } else if (num == 1) {
          getItem = stack[0]
        } else {
          getItem = stack[dice(1, stack.length) - 1]
        }
        let strAry3 = getItem.split(',')
        PlayData['GarbageItem'].splice(Number(strAry3[0]), 1)
        let itemNum = Number(strAry3[1])
        if (itemNum < 0 || itemNum >= ITEM.length) {
          itemNum = 0
        }
        let decided = 0
        if (ITEM[itemNum].DECIDED == 0) {
          if (GameData['ITEM_DECIDED']) {
            decided = 1
          }
        } else if (ITEM[itemNum].DECIDED == 1) {
          decided = 1
        }
        let pcNumInParty = pt.putItem(itemNum, decided)
        if (decided == 1) {
          PlayData['ItemFlag'][itemNum] = true
        }
        let pcNum = pt.PartyMember[pcNumInParty]
        let pc = PC[pcNum]
        pc.check()
        if (PlayData['PartyStatusNow']) {
          MP.viewPartyStatus(true, PlayData['PartyStatusNum'])
        }
        text = getDefaultMessage('FOUND_ITEM')
        let str = pc.Name[0]
        text = text.replace(/\[name\]/g, str)
        str = ITEM[itemNum].getName(decided)
        text = text.replace(/\[item\]/g, str)
        align = 'left'
      } else {
        text = getDefaultMessage('CANNOT_CARRY_MORE')
      }
      text = MP.strChangeLine(text, 42, 12, true)
      MP.drawTextFrame(
        MP.TextSurface[MP.TextSurfaceNum],
        text,
        'center',
        MP.LINE_HEIGHT * 3,
        42,
        0,
        align
      )
      if (strAry[3] == 'true') {
        GameState = 'moveReturnInputKeyStep'
      } else {
        GameState = 'moveReturnInputKey'
      }
    } else if (eventNum == 9) {
      strAry[2] = strAry[2].replace(/addPc\[([0-9]+)\]/g, '$1')
      strAry[2] = strAry[2].replace(/\./g, ',')
      if (GameData['READDATA_VERSION'] < 1.016) {
        strAry[2] = MP.getCmNum(strAry[2])
        strAry[2] = strAry[2].replace(/,/g, '<>')
      } else {
        strAry[2] = strAry[2].replace(/-/g, '<>')
      }
      let addCheck = false
      let addMode = Number(strAry[1])
      let newPt = -1,
        newDungeon = -1,
        newFloor = -1,
        newX = -1,
        newY = -1
      if (addMode == 2) {
        newPt = getNewParty()
        if (strAry.length > 4) {
          let strAry3 = strAry[4].split('.')
          if (strAry3.length > 0) {
            if (strAry3[0] != '') {
              newDungeon = Number(strAry3[0])
            }
          }
          if (strAry3.length > 1) {
            if (strAry3[1] != '') {
              newFloor = Number(strAry3[1])
            }
          }
          if (strAry3.length > 2) {
            if (strAry3[2] != '') {
              newX = Number(strAry3[2])
            }
          }
          if (strAry3.length > 3) {
            if (strAry3[3] != '') {
              newY = Number(strAry3[3])
            }
          }
        }
        if (newDungeon >= DUNGEON.DUNGEON_MAX) {
          newDungeon = -1
        }
        if (newDungeon < 0) {
          newDungeon = dice(1, DUNGEON.DUNGEON_MAX) - 1
        }
        if (newFloor >= DUNGEON.FloorMinMax[newDungeon].length) {
          newFloor = -1
        }
        if (newFloor < 0) {
          newFloor = dice(1, DUNGEON.FloorMinMax[newDungeon].length) - 1
        }
        if (newX >= DUNGEON.Width[newDungeon]) {
          newX = -1
        }
        if (newX < 0) {
          newX = dice(1, DUNGEON.Width[newDungeon]) - 1
        }
        if (newY >= DUNGEON.Height[newDungeon]) {
          newY = -1
        }
        if (newY < 0) {
          newY = dice(1, DUNGEON.Height[newDungeon]) - 1
        }
        PARTY[newPt].DungeonNumber = newDungeon
        PARTY[newPt].Floor = newFloor
        PARTY[newPt].X = newX
        PARTY[newPt].Y = newY
        PARTY[newPt].Direction = dice(1, 4) - 1
      }
      let strAry2 = strAry[2].split('<>')
      for (let i = 0; i < strAry2.length; i++) {
        if (PlayData['PcMax'] >= GameData['PC_ENTRY_MAX']) {
          break
        }
        if (strAry2[i] == '') {
          continue
        }
        let strAry3 = strAry2[i].split(',')
        let firstPcNum = Number(strAry3[0])
        let state = 0,
          poison = 0
        if (strAry3.length > 1) {
          state = Number(strAry3[1])
          if (state > 6) {
            state = 0
          }
        }
        if (strAry3.length > 2) {
          poison = Number(strAry3[2])
          if (poison >= 100000) {
            poison -= 100000
            poison *= -1
          }
        }
        if (firstPcNum >= GameData['FIRST_PC'].length) {
          continue
        }
        let pcNum = getNextPcNum()
        setFirstPc(GameData['FIRST_PC'][firstPcNum], pcNum)
        PlayData['PcList'][PlayData['PcMax'] - 1] = pcNum
        if (state > 3) {
          PC[pcNum].controlHp(0)
        }
        PC[pcNum].State = state
        if (addMode == 0) {
          if (pt.getMemberNum() >= GameData['PARTY_MEMBER_MAX']) {
            addMode = 1
          }
        }
        if (addMode != 1 && state < 4) {
          if (poison < 0) {
            poison *= -1
            poison = Math.ceil(calTimes(PC[pcNum].HpMax, calDiv(poison, 100)))
          }
          if (poison > 0) {
            PC[pcNum].Poison = poison
            PC[pcNum].check()
          }
        }
        if (addMode == 0) {
          pt.addMember(pcNum)
          addCheck = true
        } else if (addMode == 2) {
          if (PARTY[newPt].getMemberNum() >= GameData['PARTY_MEMBER_MAX']) {
            PARTY[newPt].check()
            newPt = getNewParty()
            PARTY[newPt].DungeonNumber = newDungeon
            PARTY[newPt].Floor = newFloor
            PARTY[newPt].X = newX
            PARTY[newPt].Y = newY
            PARTY[newPt].Direction = dice(1, 4) - 1
          }
          PARTY[newPt].addMember(pcNum)
        } else {
        }
      }
      if (addMode == 2) {
        PARTY[newPt].check()
      }
      if (addCheck) {
        pt.check()
      }
      if (PlayData['PartyStatusNow']) {
        MP.viewPartyStatus(true, PlayData['PartyStatusNum'])
      }
      GameState = 'move'
      if (strAry[3] == 'true') {
        dungeonAction('step')
      } else {
        dungeonAction('none')
      }
    }
    return
  } else if (GameState == 'camp') {
    if (key == 'cancel') {
      key = 'enter'
      value = 'leave'
    }
    if (key == 'enter') {
      if (value == 'inspect') {
        GameState = 'campInspect'
        dungeonAction()
        return
      } else if (value == 'reorder') {
        let memberNum = pt.getMemberNum()
        if (memberNum > 1) {
          TempVariable['pcNumList'] = []
          for (let i = 0; i < memberNum; i++) {
            TempVariable['pcNumList'].push(String(pt.PartyMember[i]))
          }
          TempVariable['pcNumNewList'] = []
          GameState = 'campReorder'
          dungeonAction()
          return
        } else {
          value = ''
        }
      } else if (value == 'leave') {
        if (GameData['SAVE_CAMP']) {
          saveData('Camp end')
        }
        deleteTempVariable()
        GameState = 'moveStart'
        dungeonAction('step')
        return
      }
    } else {
      value = ''
    }
    MP.viewPartyStatus()
    MP.clearTextSurface('all')
    let spellStr = getSpellEffectStr(ptNum)
    if (spellStr != '') {
      if (GameData['EFFECT_TIME_IS_INDICATED']) {
        MP.drawTextFrame(
          MP.TextSurface[MP.TextSurfaceNum],
          spellStr,
          'center',
          MP.LINE_HEIGHT * 9
        )
      } else {
        MP.drawTextFrame(
          MP.TextSurface[MP.TextSurfaceNum],
          spellStr,
          MP.MAIN_X + MP.MAIN_WIDTH / 2 + (MP.FONT_SIZE / 2) * 14,
          MP.LINE_HEIGHT * 2
        )
      }
    }
    MP.TextSurfaceNum++
    selAry.push(getDefaultMessage('CAMP_INSPECT', 1))
    valueAry.push('inspect')
    selAry.push(getDefaultMessage('CAMP_REORDER', 1))
    valueAry.push('reorder')
    selAry.push(getDefaultMessage('CAMP_LEAVE', 1))
    valueAry.push('leave')
    y *= 3
  } else if (GameState == 'campInspect') {
    if (key == 'cancel') {
      MP.viewPartyStatus()
      GameState = 'camp'
      dungeonAction()
      return
    } else if (key == 'enter') {
      MP.viewPartyStatus('clear')
      MP.controlPreSelect('clear')
      MP.controlPreSelect('push')
      PlayData['StatusAction'] = 'campInspect'
      GameState = 'inspect'
      statusAction()
      return
    }
    MP.clearTextSurface('all')
    MP.drawTextFrame(
      MP.TextSurface[MP.TextSurfaceNum],
      getDefaultMessage('INSPECT_WHOM', 1),
      'center',
      MP.LINE_HEIGHT * 6
    )
    MP.TextSurfaceNum++
    let memberNum = pt.getMemberNum()
    for (let i = 0; i < memberNum; i++) {
      selAry.push(String(i))
      valueAry.push(String(PARTY[ptNum].PartyMember[i]))
    }
    mode = 'pcSel'
  } else if (GameState == 'campReorder') {
    if (key == 'cancel') {
      if (TempVariable['pcNumNewList'].length < 1) {
        deleteTempVariable()
        GameState = 'camp'
        dungeonAction()
        return
      } else {
        value = TempVariable['pcNumNewList'].pop()
      }
    } else if (key == 'enter') {
      if (TempVariable['pcNumNewList'].indexOf(value) < 0) {
        TempVariable['pcNumNewList'].push(value)
        let memberNum = pt.getMemberNum()
        if (TempVariable['pcNumNewList'].length >= memberNum) {
          for (let i = 0; i < memberNum; i++) {
            pt.PartyMember[i] = Number(TempVariable['pcNumNewList'][i])
          }
          deleteTempVariable()
          GameState = 'camp'
          dungeonAction()
          return
        } else {
          let num = TempVariable['pcNumList'].indexOf(value)
          while (true) {
            num++
            if (num >= memberNum) {
              num = 0
            }
            value = TempVariable['pcNumList'][num]
            if (TempVariable['pcNumNewList'].indexOf(value) < 0) {
              break
            }
          }
        }
      }
    }
    MP.clearTextSurface('all')
    MP.drawTextFrame(
      MP.TextSurface[MP.TextSurfaceNum],
      getDefaultMessage('CAMP_REORDER', 1),
      'center',
      MP.LINE_HEIGHT * 3
    )
    let str = ''
    for (let i = 0; i < GameData['PARTY_MEMBER_MAX']; i++) {
      if (i > 0) {
        str += '\n'
      }
      str += ' ' + String(i + 1) + ': '
      let tmpStr = ''
      if (TempVariable['pcNumNewList'][i] != undefined) {
        tmpStr = PC[TempVariable['pcNumNewList'][i]].Name[0]
      }
      str += MP.strFitLength(tmpStr, 20)
    }
    MP.drawTextFrame(
      MP.TextSurface[MP.TextSurfaceNum],
      str,
      'center',
      MP.LINE_HEIGHT * 5
    )
    MP.TextSurfaceNum++
    let memberNum = pt.getMemberNum()
    for (let i = 0; i < memberNum; i++) {
      selAry.push(String(i))
      valueAry.push(String(PARTY[ptNum].PartyMember[i]))
    }
    mode = 'pcSel'
  } else if (GameState == 'submenu') {
    let wall = DUNGEON.getWallDataInFront(
      pt.DungeonNumber,
      pt.Floor,
      pt.X,
      pt.Y,
      pt.Direction
    )
    MP.clearTextSurface('all')
    if (key == 'cancel') {
      key = 'enter'
      value = 'leave'
    }
    if (key == 'enter') {
      if (value == 'searchDoor') {
        let strTmp = 'NO_DOOR'
        if (wall.match(/^[24]/)) {
          let checkWall = DUNGEON.checkWall(
            wall,
            pt.DungeonNumber,
            pt.Floor,
            pt.Direction
          )
          if (checkWall == 2) {
            strTmp = 'BE_DOOR'
          }
        } else if (wall.charAt(0) == '3') {
          let num = -1
          let strAry = wall.split(',')
          if (strAry.length > 2) {
            num = Number(strAry[2])
            if (num < 0 || num > 511) {
              num = -1
            } else {
              let checkWall = DUNGEON.checkWall(
                wall,
                pt.DungeonNumber,
                pt.Floor,
                pt.Direction
              )
              if (checkWall == 2) {
                strTmp = 'BE_DOOR'
              } else if (checkWall == 4) {
                PlayData['SecretDoor'][pt.DungeonNumber][pt.Floor][num] = true
                MP.DungeonWall[0] = 2
                strTmp = 'FOUND_DOOR'
              }
            }
          }
          if (num == -1) {
            if (MP.DungeonWall[0] == 2) {
              strTmp = 'BE_DOOR'
            } else if (MP.DungeonWall[0] == 3) {
              MP.DungeonWall[0] = 2
              strTmp = 'FOUND_DOOR'
            }
          }
        } else if (wall.charAt(0) == '6') {
          strTmp = 'BE_DOOR'
        }
        MP.drawTextFrame(
          MP.TextSurface[MP.TextSurfaceNum],
          getDefaultMessage(strTmp, 1),
          'center',
          MP.LINE_HEIGHT * 6
        )
        GameState = 'submenuReturn'
        return
      } else if (value == 'pick') {
        let checkWall = DUNGEON.checkWall(
          wall,
          pt.DungeonNumber,
          pt.Floor,
          pt.Direction
        )
        if (checkWall == 3) {
          MP.controlPreSelect('clear')
          MP.controlPreSelect('push')
          GameState = 'submenuPick'
          dungeonAction()
          return
        } else {
          let strTmp = 'NO_DOOR'
          if (MP.DungeonWall[0] == 2) {
            strTmp = 'DOOR_UNLOCKED'
          }
          MP.drawTextFrame(
            MP.TextSurface[MP.TextSurfaceNum],
            getDefaultMessage(strTmp, 1),
            'center',
            MP.LINE_HEIGHT * 6
          )
          GameState = 'submenuReturn'
          return
        }
      } else if (value == 'searchPc') {
        TempVariable['pcList'] = getPcNearActiveParty(ptNum)
        let textAry = []
        let str = getDefaultMessage('PC_SEARCHING', 1, 45)
        textAry.push(str + '.  ')
        textAry.push(str + '.. ')
        textAry.push(str + '...')
        if (TempVariable['pcList'].length < 1) {
          textAry.push(getDefaultMessage('PC_SEARCHING_NO_ONE', 1, 48))
          GameState = 'submenuReturn'
        } else {
          MP.controlPreSelect('clear')
          MP.controlPreSelect('push')
          GameState = 'submenuSearchPc'
        }
        MP.setPassingMessage(textAry, 6, 'left', 30)
        return
      } else if (value == 'remove') {
        if (pt.getMemberNum() > 1) {
          TempVariable['newParty'] = getNewParty()
          MP.controlPreSelect('clear')
          MP.controlPreSelect('push')
          GameState = 'submenuRemove'
          dungeonAction()
          return
        }
      } else if (value == 'quit') {
        if (!GameData['SPELL_EFFECT_CONTINUE']) {
          pt.spellEffectClear(false)
          pt.check()
        }
        PlayData['ActiveParty'] = -1
        saveData('Interruption of adventure')
        GameMode = ''
        GameState = 'castleTownStart'
        townAction()
        return
      } else if (value == 'leave') {
        deleteTempVariable()
        GameState = 'move'
        dungeonAction('none')
        return
      }
    }
    if (DUNGEON.FindDoor) {
      selAry.push(getDefaultMessage('SUB_SEARCH_DOOR', 1))
      valueAry.push('searchDoor')
    }
    if (DUNGEON.PickDoor) {
      selAry.push(getDefaultMessage('SUB_PICK', 1))
      valueAry.push('pick')
    }
    selAry.push(getDefaultMessage('SUB_SEARCH_PC', 1))
    valueAry.push('searchPc')
    selAry.push(getDefaultMessage('REMOVE', 1))
    valueAry.push('remove')
    if (GameData['SAVE_SUB_QUIT']) {
      selAry.push(getDefaultMessage('SUB_QUIT', 1))
      valueAry.push('quit')
    }
    selAry.push(getDefaultMessage('LEAVE', 1))
    valueAry.push('leave')
    y *= 3
  } else if (GameState == 'submenuPick') {
    let wall = DUNGEON.getWallDataInFront(
      pt.DungeonNumber,
      pt.Floor,
      pt.X,
      pt.Y,
      pt.Direction
    )
    let wallAry = wall.split(',')
    let trapLv = Number(wallAry[1])
    trapLv += pt.PtSpellEffectPlus[3]
    if (trapLv < 0) {
      trapLv = 0
    }
    MP.viewPartyStatus('clear')
    MP.clearTextSurface('all')
    if (key == 'cancel') {
      MP.controlPreSelect('pop')
      GameState = 'submenu'
      dungeonAction('return')
      return
    } else if (key == 'enter') {
      let pcNum = Number(value)
      let formula = GameData['PICK_DOOR_PROB'].replace(
        /trap\.lv/g,
        String(trapLv)
      )
      formula = replaceFormula(formula, [['pc', pcNum]])
      let prob = Math.floor(strCalculation(formula))
      if (prob > 100) {
        prob = 100
      } else if (prob < 0) {
        prob = 0
      }
      printDebugMessage('pick rate: ' + String(prob) + '%')
      let textAry = []
      let str = getDefaultMessage('PICKING', 1, 45)
      textAry.push(str + '.  ')
      textAry.push(str + '.. ')
      textAry.push(str + '...')
      if (prob == 0) {
        textAry.push(getDefaultMessage('TOO_HARD', 1, 48))
      } else if (prob >= dice(1, 100)) {
        PlayData['LockedDoor'][pt.DungeonNumber][pt.Floor][
          Number(wallAry[2])
        ] = true
        textAry.push(getDefaultMessage('UNLOCK', 1, 48))
      } else {
        textAry.push(getDefaultMessage('BLUNDER', 1, 48))
      }
      MP.setPassingMessage(textAry, 6, 'left', 30)
      MP.controlPreSelect('pop')
      GameState = 'submenuReturn'
      return
    }
    MP.drawTextFrame(
      MP.TextSurface[MP.TextSurfaceNum],
      getDefaultMessage('WHO_PICKS', 1),
      'center',
      MP.LINE_HEIGHT * 6
    )
    MP.TextSurfaceNum++
    memberNum = pt.getMemberNum()
    for (let i = 0; i < memberNum; i++) {
      selAry.push(String(i))
      valueAry.push(String(pt.PartyMember[i]))
    }
    mode = 'pcSel'
    let ary = pt.getHighProbPc(GameData['PICK_DOOR_PROB'], trapLv)
    value = String(pt.PartyMember[ary[0]])
  } else if (GameState == 'submenuSearchPc') {
    if (key == 'cancel') {
      MP.controlPreSelect('pop')
      GameState = 'submenu'
      dungeonAction('return')
      return
    } else if (key == 'enter') {
      if (pt.getMemberNum() >= GameData['PARTY_MEMBER_MAX']) {
        MP.drawTextFrame(
          MP.TextSurface[MP.TextSurfaceNum],
          getDefaultMessage('PARTY_FULL', 1),
          'center',
          MP.LINE_HEIGHT * 8
        )
        MP.controlPreSelect('pop')
        GameState = 'submenuReturn'
        return
      }
      let pcNum = Number(value)
      let oldPt = PARTY[PC[pcNum].PartyNum]
      oldPt.removeMember(pcNum)
      pt.addMember(pcNum)
      PC[pcNum].check()
      let num = TempVariable['pcList'].indexOf(pcNum)
      TempVariable['pcList'].splice(num, 1)
      if (TempVariable['pcList'].length < 1) {
        MP.controlPreSelect('pop')
        GameState = 'submenu'
        dungeonAction()
        return
      }
      value = MP.controlSelect('delete')
    }
    MP.clearTextSurface('all')
    MP.drawTextFrame(
      MP.TextSurface[MP.TextSurfaceNum],
      getDefaultMessage('PC_FOUND', 1),
      'center',
      MP.LINE_HEIGHT * 3
    )
    MP.TextSurfaceNum++
    for (let i = 0; i < TempVariable['pcList'].length; i++) {
      let pcNum = TempVariable['pcList'][i]
      selAry.push(PC[pcNum].nameListStr(false))
      valueAry.push(String(pcNum))
    }
    y *= 6
    lineNum = 16
  } else if (GameState == 'submenuRemove') {
    MP.viewPartyStatus('clear')
    MP.clearTextSurface('all')
    let newPtNum = TempVariable['newParty']
    let newPt = PARTY[newPtNum]
    if (key == 'cancel') {
      if (newPt.PartyMember[0] > -1) {
        newPt.check()
      }
      MP.controlPreSelect('pop')
      GameState = 'submenu'
      dungeonAction('return')
      return
    } else if (key == 'enter') {
      let pcNum = Number(value)
      pt.removeMember(pcNum)
      value = MP.controlSelect('delete')
      if (newPt.PartyMember[0] < 0) {
        newPt.DungeonNumber = pt.DungeonNumber
        newPt.Floor = pt.Floor
        newPt.X = pt.X
        newPt.Y = pt.Y
        newPt.Direction = pt.Direction
        newPt.DungeonMusic = pt.DungeonMusic
      }
      newPt.addMember(pcNum)
      if (pt.getMemberNum() < 2) {
        MP.controlPreSelect('pop')
        GameState = 'submenu'
        dungeonAction('return')
        return
      }
    }
    MP.drawTextFrame(
      MP.TextSurface[MP.TextSurfaceNum],
      getDefaultMessage('REMOVE_WHOM', 1),
      'center',
      MP.LINE_HEIGHT * 6
    )
    MP.TextSurfaceNum++
    memberNum = pt.getMemberNum()
    for (let i = 0; i < memberNum; i++) {
      selAry.push(String(i))
      valueAry.push(String(pt.PartyMember[i]))
    }
    mode = 'pcSel'
  } else if (GameState.indexOf('messageInDungeon') > -1) {
    MP.clearTextSurface()
    let text = SPELL_EF.MessageStack[0].shift()
    text = text.replace(/<p>/g, '<br>')
    text = MP.strChangeLine(text, 52, 5, true)
    MP.drawTextFrame(
      MP.TextSurface[MP.TextSurfaceNum],
      text,
      'center',
      MP.LINE_HEIGHT * 8,
      52
    )
    if (SPELL_EF.MessageStack[0].length > 0) {
      GameState += 'Return'
    } else if (GameState.indexOf('Step') > -1) {
      GameState = 'moveStepReturn'
    } else {
      GameState = 'moveReturn'
    }
    return
  }
  MP.setSelectMode(
    dungeonAction,
    mode,
    selAry,
    valueAry,
    colorAry,
    comment,
    align,
    y,
    charMin,
    lineNum,
    textAlign,
    value,
    MP.SelectMode['selectF'],
    GameData['SELECT_COLOR']
  )
  function checkEncount (ptNum) {
    let result = false
    let pt = PARTY[ptNum]
    let dungeon = pt.DungeonNumber,
      floor = pt.Floor
    let roomNum = DUNGEON.MonsterRoom[dungeon][floor][pt.X][pt.Y]
    TempVariable['roomNum'] = roomNum
    if (roomNum > -1) {
      if (!DUNGEON.CheckedMonsterRoom[roomNum]) {
        if (DUNGEON.RoomGuardian[dungeon][floor][roomNum] == '') {
          let formula = DUNGEON.MonsterRoomEncounterRate[dungeon][floor]
          let prob = Math.floor(strCalculation(replaceFormula(formula)))
          if (prob < 0) {
            prob = 0
          } else if (prob > 1000) {
            prob = 1000
          }
          printDebugMessage(
            'monster room encount rate: ' + String(prob / 10) + '%'
          )
          if (prob >= dice(1, 1000)) {
            result = true
            encountMonster()
          } else {
            DUNGEON.CheckedMonsterRoom[roomNum] = true
          }
        } else {
          let strAry = DUNGEON.RoomGuardian[dungeon][floor][roomNum].split('<>')
          let strAry2 = []
          if (checkCondition(strAry[0])) {
            if (strAry[9].indexOf('false') > -1) {
              printDebugMessage('monster room guardian [true]')
              strAry2 = [strAry[1], strAry[2], strAry[3], strAry[7]]
            }
          } else {
            if (strAry[10].indexOf('false') > -1) {
              printDebugMessage('monster room guardian [false]')
              strAry2 = [strAry[4], strAry[5], strAry[6], strAry[8]]
            }
          }
          if (strAry2.length < 1) {
            DUNGEON.CheckedMonsterRoom[roomNum] = true
          } else {
            if (strAry2[0] == '-1') {
              strAry2[0] = ''
            }
            let boxProb = '0'
            if (strAry2[1] == '-1') {
              strAry2[1] = ''
              boxProb = '100'
            } else if (strAry2[1] == '-2') {
              strAry2[1] = ''
            }
            if (strAry2[3] == 'none') {
              strAry2[3] = ''
            }
            result = true
            encountMonster(
              strAry2[0],
              strAry2[1],
              boxProb,
              strAry2[2],
              strAry2[3]
            )
          }
        }
      }
    }
    if (!result) {
      let formula = DUNGEON.EncounterRate[dungeon][floor]
      formula = formula.replace(/plus/g, String(pt.PtSpellEffectPlus[4]))
      let prob = Math.floor(strCalculation(replaceFormula(formula)))
      if (prob < 0) {
        prob = 0
      } else if (prob > 1000) {
        prob = 1000
      }
      printDebugMessage('random encount rate: ' + String(prob / 10) + '%')
      if (prob >= dice(1, 1000)) {
        result = true
        encountMonster(null, null, DUNGEON.BoxAppearance[dungeon][floor])
      }
    }
    return result
  }
  function checkOffLimits (ptNum) {
    let pt = PARTY[ptNum]
    if (
      pt.Floor < 0 ||
      pt.Floor >= DUNGEON.FloorMinMax[pt.DungeonNumber].length
    ) {
      return ''
    }
    let aliF = []
    for (let i = 0; i < 3; i++) {
      aliF[i] = false
    }
    let sexF = []
    for (let i = 0; i < 4; i++) {
      sexF[i] = false
    }
    let memberNum = pt.getMemberNum()
    for (let i = 0; i < memberNum; i++) {
      let pcNum = pt.PartyMember[i]
      let pc = PC[pcNum]
      aliF[pc.Alignment] = true
      sexF[pc.Sex] = true
    }
    let ck = false
    let strAry = DUNGEON.EnterLimit[pt.DungeonNumber][pt.Floor].split(',')
    for (let i = 0; i < 3; i++) {
      if (strAry[0].indexOf(String(i)) > -1) {
        if (aliF[i]) {
          ck = true
          break
        }
      }
    }
    if (!ck) {
      for (let i = 0; i < 4; i++) {
        if (strAry[1].indexOf(String(i)) > -1) {
          if (sexF[i]) {
            ck = true
            break
          }
        }
      }
    }
    let result = ''
    if (ck) {
      let str = ''
      for (let i = 0; i < 3; i++) {
        if (strAry[0].indexOf(String(i)) > -1) {
          if (str != '') {
            str += ', '
          }
          str += GameData['ALIGNMENT'][i]
        }
      }
      result += str
      str = ''
      for (let i = 0; i < 4; i++) {
        if (strAry[1].indexOf(String(i)) > -1) {
          if (str != '') {
            str += ', '
          }
          str += GameData['SEX'][i]
        }
      }
      if (result != '') {
        result += '<br>'
      }
      result += str
    }
    return result
  }
  function encountMonster (
    monster,
    haveItem,
    boxProb,
    eventBgm,
    flagWin,
    flagRun,
    flagAnnihilation,
    eventAgain
  ) {
    if (monster == undefined || monster == null) {
      monster = ''
    }
    if (haveItem == undefined || haveItem == null) {
      haveItem = ''
    }
    if (boxProb == undefined || boxProb == null) {
      boxProb = '100'
    }
    if (eventBgm == undefined || eventBgm == null) {
      eventBgm = ''
    }
    if (flagWin == undefined || flagWin == null) {
      flagWin = ''
    }
    if (flagRun == undefined || flagRun == null) {
      flagRun = ''
    }
    if (flagAnnihilation == undefined || flagAnnihilation == null) {
      flagAnnihilation = ''
    }
    if (eventAgain == undefined || eventAgain == null) {
      eventAgain = false
    }
    let ptNum = PlayData['ActiveParty']
    let pt = PARTY[ptNum]
    let dungeon = pt.DungeonNumber
    let floor = pt.Floor
    TempVariable['haveItem'] = haveItem
    TempVariable['eventBgm'] = eventBgm
    TempVariable['flagWin'] = flagWin
    TempVariable['flagRun'] = flagRun
    TempVariable['flagAnnihilation'] = flagAnnihilation
    let flagAry = ['flagWin', 'flagRun', 'flagAnnihilation']
    for (let i = 0; i < flagAry.length; i++) {
      TempVariable[flagAry[i]] = TempVariable[flagAry[i]].replace(/a/g, ',')
      TempVariable[flagAry[i]] = TempVariable[flagAry[i]].replace(/b/g, '<>')
    }
    TempVariable['turn'] = 0
    TempVariable['monsterKill'] = false
    TempVariable['getExp'] = 0
    TempVariable['getGold'] = -1
    TempVariable['alarm'] = false
    TempVariable['nonAlarmItemNum'] = 0
    TempVariable['appearanceChest'] = false
    TempVariable['getChestItem'] = false
    TempVariable['noFriendship'] = DUNGEON.NoFriendship[dungeon][floor]
    TempVariable['eventAgain'] = eventAgain
    TempVariable['partyList'] = []
    let memberNum = pt.getMemberNum()
    for (let i = 0; i < memberNum; i++) {
      TempVariable['partyList'].push(pt.PartyMember[i])
    }
    pt.battleReset()
    setMonster(monster)
    TempVariable['firstMonster'] = TempVariable['setMonster'][0]
    monsterDecidedCheck()
    for (let i = 0; i < 4; i++) {
      TempVariable['monsterDecidedChange'][i] = false
    }
    TempVariable['monsterLineChange'] = [false, false]
    if (TempVariable['haveItem'] == '') {
      if (boxProb.indexOf('monsterNum') > -1) {
        let reg = new RegExp(
          'monsterNum\\[' + String(TempVariable['setMonster'][0]) + '\\]',
          'g'
        )
        boxProb = boxProb.replace(reg, '1')
        boxProb = boxProb.replace(/monsterNum\[[0-9]+\]/g, '0')
      }
      let prob = Math.floor(strCalculation(boxProb))
      if (prob < 0) {
        prob = 0
      } else if (prob > 100) {
        prob = 100
      }
      TempVariable['boxProb'] = prob
    } else {
      TempVariable['boxProb'] = 0
    }
    let friendshipProb = 0
    if (!DUNGEON.NoFriendship[dungeon][floor]) {
      friendshipProb = MONSTER_DATA[TempVariable['setMonster'][0]].FRIENDSHIP
    }
    printDebugMessage('friendship rate: ' + String(friendshipProb) + '%')
    if (friendshipProb >= dice(1, 100)) {
      TempVariable['battleStart'] = 'friendship'
    } else {
      let preemptivePc = false,
        preemptiveMonster = false
      let formula = GameData['PREEMPTIVE_PROB_PC'].replace(
        /plus/g,
        String(pt.PtSpellEffectPlus[1])
      )
      formula = replaceFormula(formula, [
        ['monster', PlayData['MonsterList'][0][0]]
      ])
      prob = Math.floor(strCalculation(formula))
      printDebugMessage('preemptive attack rate (PC): ' + String(prob) + '%')
      if (prob >= dice(1, 100)) {
        preemptivePc = true
      }
      formula = GameData['PREEMPTIVE_PROB_MONSTER'].replace(
        /plus/g,
        String(pt.PtSpellEffectPlus[1])
      )
      formula = replaceFormula(formula, [
        ['monster', PlayData['MonsterList'][0][0]]
      ])
      prob = Math.floor(strCalculation(formula))
      printDebugMessage(
        'preemptive attack rate (Monster): ' + String(prob) + '%'
      )
      if (prob >= dice(1, 100)) {
        preemptiveMonster = true
      }
      if (preemptivePc && !preemptiveMonster) {
        TempVariable['battleStart'] = 'preemptivePc'
      } else if (!preemptivePc && preemptiveMonster) {
        TempVariable['battleStart'] = 'preemptiveMonster'
      } else {
        TempVariable['battleStart'] = 'normal'
      }
    }
    GameState = 'battleStart'
    battleAction()
  }
  function getPcNearActiveParty (activePtNum) {
    let activePt = PARTY[activePtNum]
    let pcList = []
    for (let i = 0; i < PlayData['PcMax']; i++) {
      let pcNum = PlayData['PcList'][i]
      let ptNum = PC[pcNum].PartyNum
      if (ptNum > -1 && ptNum != activePtNum) {
        let pt = PARTY[ptNum]
        if (
          pt.DungeonNumber == activePt.DungeonNumber &&
          pt.Floor == activePt.Floor
        ) {
          pcList.push(pcNum)
        }
      }
    }
    if (pcList.length < 1) {
      return pcList
    }
    let pointStr = String(activePt.X) + ',' + String(activePt.Y)
    let searchArea = getPcNearActivePartySearchArea(
      activePtNum,
      [pointStr],
      [pointStr],
      6
    )
    let resultList = []
    for (let i = 0; i < pcList.length; i++) {
      let pcNum = pcList[i]
      let ptNum = PC[pcNum].PartyNum
      let pt = PARTY[ptNum]
      pointStr = String(pt.X) + ',' + String(pt.Y)
      if (searchArea.indexOf(pointStr) > -1) {
        resultList.push(pcNum)
      }
    }
    return resultList
  }
  function getPcNearActivePartySearchArea (ptNum, checkedAry, pointAry, steps) {
    let pt = PARTY[ptNum]
    let newPointAry = []
    for (let i = 0; i < pointAry.length; i++) {
      for (let j = 0; j < 4; j++) {
        let pointStr = getPcNearActivePartySearchAreaCheckAdvance(
          ptNum,
          pointAry[i],
          j
        )
        let newPointFlag = true
        if (pointStr.indexOf('notNew') > -1) {
          newPointFlag = false
          pointStr = pointStr.replace(/notNew,/g, '')
        }
        if (pointStr != '' && checkedAry.indexOf(pointStr) < 0) {
          checkedAry.push(pointStr)
          if (newPointFlag) {
            newPointAry.push(pointStr)
          }
        }
      }
    }
    steps--
    if (steps > 0 && newPointAry.length > 0) {
      return getPcNearActivePartySearchArea(
        ptNum,
        checkedAry,
        newPointAry,
        steps
      )
    } else {
      return checkedAry
    }
  }
  function getPcNearActivePartySearchAreaCheckAdvance (
    ptNum,
    pointStr,
    direction
  ) {
    let pt = PARTY[ptNum]
    let dungeon = pt.DungeonNumber
    let floor = pt.Floor
    let pointStrAry = pointStr.split(',')
    let x = Number(pointStrAry[0]),
      y = Number(pointStrAry[1])
    let wall = DUNGEON.getWallDataInFront(dungeon, floor, x, y, direction)
    if (DUNGEON.checkWall(wall, dungeon, floor, direction) != 0) {
      return ''
    }
    if (direction == 0) {
      y = DUNGEON.getPoint(dungeon, 'h', y + 1)
    } else if (direction == 1) {
      x = DUNGEON.getPoint(dungeon, 'w', x + 1)
    } else if (direction == 2) {
      y = DUNGEON.getPoint(dungeon, 'h', y - 1)
    } else if (direction == 3) {
      x = DUNGEON.getPoint(dungeon, 'w', x - 1)
    }
    let space = DUNGEON.Space[dungeon][floor][x][y]
    if (space.match(/^[89adRW]/)) {
      return ''
    }
    if (space.match(/^[156ES]/)) {
      return 'notNew,' + String(x) + ',' + String(y)
    }
    return String(x) + ',' + String(y)
  }
  function getSpellEffectStr (ptNum) {
    let pt = PARTY[ptNum]
    let ary = []
    let viewMax = 14
    let effectNum = 35
    let loop = effectNum + GameData['ABILITY'].length
    for (let i = 0; i < loop; i++) {
      let str = ''
      let notDefault = false
      if (i == 0) {
        if (pt.Light) {
          str = 'SPELL_EF_LIGHT'
        }
      } else if (i == 1) {
        if (pt.PtSpellEffectPlus[0] != 0) {
          str = 'SPELL_EF_IDENTIFY'
        }
      } else if (i == 2) {
        if (!pt.FlyingEffect.match(/^(| )$/)) {
          str = 'SPELL_EF_FLYING'
        }
      } else if (i == 3) {
        if (pt.SpellEffectPlus[0] != 0) {
          str = 'SPELL_EF_PROTECT'
        }
      } else if (i == 4) {
        if (pt.SpellEffectPlus[3] != 0) {
          str = 'SPELL_EF_SPELL_RESIST'
        }
      } else if (i == 5) {
        if (pt.SpellEffectPlus[4] != 0) {
          str = 'SPELL_EF_BREATH_RESIST'
        }
      } else if (i == 6) {
        if (pt.SpellEffectPlus[2] != 0) {
          str = 'SPELL_EF_SPELL_CANCEL'
        }
      } else if (i == 7) {
        if (pt.SpellEffectPlus[1] != 0) {
          str = 'SPELL_EF_HIT_RATE'
        }
      } else if (i == 8) {
        if (pt.SpellEffectPlus[8] != 0) {
          str = 'SEPLL_EF_ATTACK_COUNT'
        }
      } else if (i == 9) {
        if (pt.SpellEffectPlus[6] != 0) {
          str = 'SPELL_EF_ADDITIONAL_DAMAGE'
        }
      } else if (i == 10) {
        if (pt.SpellEffectPlus[7] != 0) {
          str = 'SPELL_EF_TEMPORARY_CHANGE_MAX_HP'
        }
      } else if (i == 11) {
        if (pt.SpellEffectPlus[5] != 0) {
          str = 'SPELL_EF_HEAL'
        }
      } else if (i == 12) {
        if (pt.PtSpellEffectPlus[1] != 0) {
          str = 'SPELL_EF_PREEMPTIVE'
        }
      } else if (i == 13) {
        if (pt.PtSpellEffectPlus[2] != 0) {
          str = 'SPELL_EF_DETECT_SECRET_DOOR'
        }
      } else if (i == 14) {
        if (pt.PtSpellEffectPlus[3] != 0) {
          str = 'SPELL_EF_OPEN_LOCKED_DOOR'
        }
      } else if (i == 15) {
        if (pt.PtSpellEffectPlus[4] != 0) {
          str = 'SPELL_EF_ENCOUNTER_RATE'
        }
      } else if (i < 22) {
        let num = i - 16
        if (pt.AttackAddPlus[num]) {
          str = 'SPELL_EF_ENCHANTED_' + ATTACK_ADD_STR[num]
        }
      } else if (i <= effectNum) {
        let num = i - 22
        if (pt.ResistPlus[num] == 1) {
          str = 'SPELL_EF_RESIST_' + RESIST_STR[num]
        } else if (pt.ResistPlus[num] == 0 || pt.ResistPlus[num] == -1) {
          str = 'SPELL_EF_NON_RESIST_' + RESIST_STR[num]
        }
      } else {
        let num = i - effectNum - 1
        if (
          pt.AbiPlus[num] != 0 &&
          !(
            GameData['ABILITY_NOT_DISPLAY'][num] &&
            GameData['MODIFYING_EFFECTS_ON_HIDDEN_ABILITY_ARE_NOT_DISPLAYED']
          )
        ) {
          notDefault = true
          str = GameData['ABILITY'][num]
          if (MP.strCount(str) > 14) {
            str = GameData['ABILITY_ABBR'][num]
          }
        }
      }
      if (str != '' && str != 'none') {
        if (!notDefault) {
          str = getDefaultMessage(str, 1, 14)
        }
        if (GameData['EFFECT_TIME_IS_INDICATED']) {
          str += ' ' + getSpellEffectTime(ptNum, i)
          str = MP.strFitLength(str, 22)
        } else {
          let count = MP.strCount(str)
          if (count < 11) {
            str = MP.strFitLength(str, 10)
          }
        }
        ary.push(str)
        if (ary.length >= viewMax) {
          break
        }
      }
    }
    let result = ''
    if (GameData['EFFECT_TIME_IS_INDICATED']) {
      for (let i = 0; i < ary.length; i++) {
        if (i % 2 == 0) {
          if (i > 0) {
            result += '\n'
          }
          result += ary[i]
        } else {
          result += '  ' + ary[i]
        }
      }
      if (ary.length == 1) {
        result += MP.strFitLength('', 24)
      }
    } else {
      for (let i = 0; i < ary.length; i++) {
        if (i > 0) {
          result += '\n'
        }
        result += ary[i]
      }
    }
    return result
  }
  function getSpellEffectTime (ptNum, effect) {
    let pt = PARTY[ptNum]
    let effectNum = 35
    let effectTime = 0
    if (effect == 0) {
      effectTime = pt.Vision
    } else if (effect == 1) {
      effectTime = pt.PtSpellEffectRate[0]
    } else if (effect == 2) {
      effectTime = pt.Flying
    } else if (effect == 3) {
      effectTime = pt.SpellEffectRate[0]
    } else if (effect == 4) {
      effectTime = pt.SpellEffectRate[3]
    } else if (effect == 5) {
      effectTime = pt.SpellEffectRate[4]
    } else if (effect == 6) {
      effectTime = pt.SpellEffectRate[2]
    } else if (effect == 7) {
      effectTime = pt.SpellEffectRate[1]
    } else if (effect == 8) {
      effectTime = pt.SpellEffectRate[8]
    } else if (effect == 9) {
      effectTime = pt.SpellEffectRate[6]
    } else if (effect == 10) {
      effectTime = pt.SpellEffectRate[7]
    } else if (effect == 11) {
      effectTime = pt.SpellEffectRate[5]
    } else if (effect == 12) {
      effectTime = pt.PtSpellEffectRate[1]
    } else if (effect == 13) {
      effectTime = pt.PtSpellEffectRate[2]
    } else if (effect == 14) {
      effectTime = pt.PtSpellEffectRate[3]
    } else if (effect == 15) {
      effectTime = pt.PtSpellEffectRate[4]
    } else if (effect < 22) {
      let num = effect - 16
      effectTime = pt.AttackAddRate[num]
    } else if (i <= effectNum) {
      let num = effect - 22
      effectTime = pt.ResistRate[num]
    } else {
      let num = effect - effectNum - 1
      effectTime = pt.AbiRate[num]
    }
    let result = ''
    if (effectTime == 1001 || effectTime == -1001) {
      result = getDefaultMessage('EFFECT_TIME_ONLY_FLOOR', 1, 5)
    } else if (
      (effectTime > 0 && effectTime <= 1000) ||
      (effectTime < 0 && effectTime >= -1000)
    ) {
      if (effectTime < 0) {
        effectTime *= -1
      }
      result = String(effectTime)
    }
    if (result != '') {
      result = '(' + result + ')'
    }
    return result
  }
  function oneStep (pt, move) {
    let dungeon = pt.DungeonNumber
    let d = pt.Direction
    pt.PreX = pt.X
    pt.PreY = pt.Y
    if (move == 'forward') {
      if (d == 0) {
        pt.Y = DUNGEON.getPoint(dungeon, 'h', pt.Y + 1)
      } else if (d == 1) {
        pt.X = DUNGEON.getPoint(dungeon, 'w', pt.X + 1)
      } else if (d == 2) {
        pt.Y = DUNGEON.getPoint(dungeon, 'h', pt.Y - 1)
      } else if (d == 3) {
        pt.X = DUNGEON.getPoint(dungeon, 'w', pt.X - 1)
      }
    } else if (move == 'right') {
      if (d == 0) {
        pt.X = DUNGEON.getPoint(dungeon, 'w', pt.X + 1)
      } else if (d == 1) {
        pt.Y = DUNGEON.getPoint(dungeon, 'h', pt.Y - 1)
      } else if (d == 2) {
        pt.X = DUNGEON.getPoint(dungeon, 'w', pt.X - 1)
      } else if (d == 3) {
        pt.Y = DUNGEON.getPoint(dungeon, 'h', pt.Y + 1)
      }
    } else if (move == 'left') {
      if (d == 0) {
        pt.X = DUNGEON.getPoint(dungeon, 'w', pt.X - 1)
      } else if (d == 1) {
        pt.Y = DUNGEON.getPoint(dungeon, 'h', pt.Y + 1)
      } else if (d == 2) {
        pt.X = DUNGEON.getPoint(dungeon, 'w', pt.X + 1)
      } else if (d == 3) {
        pt.Y = DUNGEON.getPoint(dungeon, 'h', pt.Y - 1)
      }
    }
  }
}
