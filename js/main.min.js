enchant()
enchant.Sound.enabledInMobileSafari = true
let GameBody
const VERSION = 'v0.190'
const GAMEDATA_VERSION = 'v1.030'
const FPS = 60
const FRAME_TIME = calDiv(1, FPS)
const LOADING_END_MASK = true
const GRAPHIC_FILE_EXTENSION = ['png', 'jpg', 'jpeg', 'gif', 'bmp']
const SOUND_FILE_EXTENSION = ['mp3', 'wav']
const MUSIC_FILE_EXTENSION = ['mp3']
const CONFIG_NAME = [
  'Bgm',
  'Se',
  'ControllerAlign',
  'GamePad',
  'Dungeon',
  'PerspectiveView',
  'AutoMapping',
  'BgmVolume',
  'SeVolume'
]
const OPTION_NAME = [
  'Music',
  'Se',
  'ControllerAlign',
  'GamePad',
  'Dungeon',
  'Perspective'
]
const OPTION_BUTTON_NAME = [
  'Backup',
  'Recovery',
  'Keyname',
  'Delete option data',
  'Key Config'
]
const KEY_NAME = [
  'KEY_UP',
  'KEY_DOWN',
  'KEY_RIGHT',
  'KEY_LEFT',
  'KEY_SHIFT',
  'KEY_SHIFT_RIGHT',
  'KEY_SHIFT_LEFT',
  'KEY_ENTER',
  'KEY_CANCEL',
  'KEY_STATUS',
  'KEY_SUBMENU',
  'KEY_MAP',
  'KEY_RESET',
  'KEY_DEBUG'
]
const KEYCODE_NAME = [
  ['backspace', 8],
  ['enter', 13],
  ['shift', 16],
  ['control', 17],
  ['alt', 18],
  ['pause', 19],
  ['escape', 27],
  ['space', 32],
  ['page_up', 33],
  ['page_down', 34],
  ['end', 35],
  ['home', 36],
  ['left', 37],
  ['up', 38],
  ['right', 39],
  ['down', 40],
  ['insert', 45],
  ['delete', 46],
  ['0', 48],
  ['1', 49],
  ['2', 50],
  ['3', 51],
  ['4', 52],
  ['5', 53],
  ['6', 54],
  ['7', 55],
  ['8', 56],
  ['9', 57],
  ['colon', 58, 186],
  ['semicolon', 59, 187],
  ['at', 64, 192],
  ['a', 65],
  ['b', 66],
  ['c', 67],
  ['d', 68],
  ['e', 69],
  ['f', 70],
  ['g', 71],
  ['h', 72],
  ['i', 73],
  ['j', 74],
  ['k', 75],
  ['l', 76],
  ['m', 77],
  ['n', 78],
  ['o', 79],
  ['p', 80],
  ['q', 81],
  ['r', 82],
  ['s', 83],
  ['t', 84],
  ['u', 85],
  ['v', 86],
  ['w', 87],
  ['x', 88],
  ['y', 89],
  ['z', 90],
  ['numpad0', 96],
  ['numpad1', 97],
  ['numpad2', 98],
  ['numpad3', 99],
  ['numpad4', 100],
  ['numpad5', 101],
  ['numpad6', 102],
  ['numpad7', 103],
  ['numpad8', 104],
  ['numpad9', 105],
  ['multiply', 106],
  ['add', 107],
  ['subtract', 109],
  ['decimal', 110],
  ['divide', 111],
  ['f1', 112],
  ['f2', 113],
  ['f3', 114],
  ['f4', 115],
  ['f5', 116],
  ['f6', 117],
  ['f7', 118],
  ['f8', 119],
  ['f9', 120],
  ['f10', 121],
  ['f11', 122],
  ['f12', 123],
  ['scroll_lock', 145],
  ['circumflex', 160, 222],
  ['minus', 173, 189],
  ['comma', 188],
  ['period', 190],
  ['slash', 191],
  ['openbracket', 219],
  ['backslash', 220, 226],
  ['closebracket', 221]
]
const GAMEPAD_CODE = [
  '0',
  '1',
  '2',
  '3',
  '4',
  '5',
  'zDown',
  'zUp',
  '6',
  '7',
  '8',
  '9',
  'up',
  'down',
  'left',
  'right'
]
const RACE_CLASS_MAX = 36
const PC_ENTRY_MIN = 36
const RESIST_LENGTH = 15
const RESIST_STR = [
  'SILENCE',
  'ASLEEP',
  'POISONED',
  'PARALYZED',
  'STONED',
  'DRAIN',
  'KNOCK_OUT',
  'CRITICAL',
  'DEATH',
  '',
  'BLAZE',
  'COLD',
  'ELECTRIC',
  'HOLY',
  'NONE'
]
const RESIST_ATTRIBUTE_STR = [
  'SILENCE',
  'ASLEEP',
  'POISON',
  'PARALYSIS',
  'STONE',
  'DRAIN',
  'KNOCK_OUT',
  'CRITICAL',
  'DEATH_SPELL',
  '',
  'BLAZE_ATTRIBUTE',
  'COLD_ATTRIBUTE',
  'ELECTRIC_ATTRIBUTE',
  'HOLY_ATTRIBUTE',
  'NONE_ATTRIBUTE'
]
const ATTACK_ADD_LENGTH = 5
const ATTACK_ADD_STR = [
  'ASLEEP',
  'PARALYZED',
  'STONED',
  'KNOCK_OUT',
  'CRITICAL',
  'POISONED'
]
const ATTACK_ADD_DEBUG_STR = [
  'ASLEEP',
  'PARALYSIS',
  'STONE',
  'KNOCK_OUT',
  'CRITICAL',
  'POISON'
]
const MONSTER_TYPE = 15
const TEXT_MEMORY_LENGTH = 100
const GENERIC_FORMULA_REG = new RegExp('formula\\[([0-9]+)\\]')
const TIME_COUNT = [30, 6, 3, 20, 4]
let AudioPlay = false
let ClickToStart = false,
  ConnectedGamepadIndex = null,
  KeyConfig,
  PreInput = [],
  PreInputType = [],
  ShortcutSuppression,
  GameState = '',
  GameMode = '',
  LoopLoadingID = null,
  Mode = 'normal',
  NowMusic = '',
  NowMusicBg = '',
  SaveName = 'Javardry',
  SoundNotAutoPlay = false,
  SoundPlayLimit = false,
  SoundPlayLimitBgm = false,
  SoundPlayLimitSe = false,
  WebGL_Scale = 0,
  WinAlign,
  WinScale,
  WindowHeightScale,
  WindowWidthScale,
  LoadingFlag = false
let Config = {},
  DefaultMessage = {},
  GameData = {},
  GenericVariable = {},
  GraphicData = {},
  InitialConfigData = {},
  KeyConfigData = {},
  KeyConfigData2 = {},
  LaunchSettings = {},
  MusicData = {},
  PlayData = {},
  Prefetch = {},
  SoundData = {},
  TempVariable = {},
  DirName = {},
  ExtData = {}
let UploadData = '',
  Font,
  LocalLimit,
  PreTimestamp = 0
let SpellName = []
for (let i = 0; i < 4; i++) {
  SpellName[i] = []
  for (let j = 0; j < 10; j++) {
    SpellName[i][j] = []
  }
}
GenericVariable['PrioritizeHR'] = false
GenericVariable['ExpGained'] = 1.0
GenericVariable['DropGained'] = 1.0
TempVariable['loadWebFont'] = false
let GraphicPrefetchMax = {}
GraphicPrefetchMax['monster'] = 40
GraphicPrefetchMax['event'] = 10
GraphicPrefetchMax['dungeon'] = 26
GraphicPrefetchMax['castle'] = 3
window.focus()
document.addEventListener('mousedown', eventMousedown)
document.addEventListener('mousemove', eventMousemove)
document.addEventListener('mouseup', eventMouseup)
document.addEventListener('touchend', eventMouseup)
document.addEventListener('touchmove', eventTouchmove)
document.addEventListener('touchstart', eventTouchstart)
document.addEventListener('visibilitychange', eventVisibilitychange)
document.onblur = eventOnblur
document.oncontextmenu = function (event) {
  if (
    event.target.tagName == 'HTML' ||
    (event.target.tagName == 'INPUT' && event.target.type == 'text')
  ) {
    return true
  }
  return false
}
window.addEventListener('gamepadconnected', gamepadConnected)
window.addEventListener('gamepaddisconnected', gamepadDisconnected)
window.addEventListener('resize', resizeWindow)
window.onload = function () {
  if (document.location.hostname == '') {
    console.log('hostname: none')
    LocalLimit = true
  } else {
    console.log('hostname: ' + document.location.hostname)
    LocalLimit = false
  }
  if (getDevice('OS') == 'iOS') {
    ClickToStart = true
  }
  if (getDevice('OS') == 'iOS') {
    SoundPlayLimit = true
  }
  SoundNotAutoPlay = true
  if (getDevice('OS') == 'iOS' && getDevice('Browser') == 'safari') {
    AudioPlay = true
  }
  let hiddenStr = document.getElementById('hidden').innerHTML
  let hiddenStrAry = hiddenStr.split(',')
  let windowWidth = 800
  WinAlign = 'center'
  LaunchSettings['Controller'] = true
  LaunchSettings['GraphicPrefetch'] = false
  LaunchSettings['SoundPrefetch'] = false
  LaunchSettings['GraphicCache'] = true
  LaunchSettings['SoundCache'] = true
  LaunchSettings['LoadingScreen'] = 0
  LaunchSettings['GraphicLimit'] = true
  LaunchSettings['NotLoadSaveData'] = false
  LaunchSettings['NoSoundAllowed'] = false
  for (let i = 0; i < hiddenStrAry.length; i++) {
    let strAry = hiddenStrAry[i].split(':')
    strAry[0] = strAry[0].replace(/\s/g, '')
    strAry[1] = strAry[1].replace(/\s/g, '')
    if (strAry[0] == 'SaveName') {
      SaveName = strAry[1]
    } else if (strAry[0] == 'Align') {
      WinAlign = strAry[1]
    } else if (strAry[0] == 'Size') {
      windowWidth = Number(strAry[1])
    } else if (strAry[0] == 'LoadingScreen') {
      if (strAry[1].match(/^[0-9]+$/)) {
        LaunchSettings['LoadingScreen'] = Number(strAry[1])
      }
    } else {
      let strAry2 = [
        'Controller',
        'NotLoadSaveData',
        'GraphicPrefetch',
        'SoundPrefetch',
        'GraphicCache',
        'SoundCache',
        'GraphicLimit',
        'NoSoundAllowed'
      ]
      for (let j = 0; j < strAry2.length; j++) {
        if (strAry[0] == strAry2[j]) {
          if (strAry[1].match(/^(on|true)$/)) {
            LaunchSettings[strAry2[j]] = true
          } else if (strAry[1].match(/^(off|false)$/)) {
            LaunchSettings[strAry2[j]] = false
          }
          break
        }
      }
    }
  }
  if (LaunchSettings['NoSoundAllowed']) {
    LaunchSettings['SoundPrefetch'] = false
  }
  setExtensionData('graphic')
  setExtensionData('sound')
  setExtensionData('music')
  DirName['music'] = checkNull(DirName['music'], './music/')
  DirName['sound'] = checkNull(DirName['sound'], './sound/')
  if (windowWidth < 300) {
    windowWidth = 300
  } else if (windowWidth > 3000) {
    windowWidth = 3000
  }
  let windowHeight = windowWidth
  if (LaunchSettings['Controller']) {
    windowHeight += Math.ceil(windowHeight / 1.9)
  } else {
    windowHeight += Math.ceil(windowHeight / 15.5)
  }
  setWindowResize(windowWidth, windowHeight)
  GameBody = new Game(windowWidth, windowHeight)
  setWindowAlign()
  GameBody.start()
  MP = new MainPanel()
  GenericVariable['ClickCancel'] = false
  GenericVariable['OnClick'] = false
  GenericVariable['OnShiftKey'] = false
  GenericVariable['OnTouch'] = false
  GenericVariable['Id'] = ''
  TempVariable['loadingText'] = 'Now Loading'
  GameState = 'webFontLoading'
  TempVariable['localCheckEnd'] = false
  TempVariable['notLoadingGameData'] = false
  TempVariable['stopLoading'] = false
  TempVariable['loadingPreEnd'] = false
  TempVariable['loadingEnd'] = false
  TempVariable['count'] = 0
  MP.StatusSurface.context.globalAlpha = 0.8
  let loadingDungeon
  if (LaunchSettings['LoadingScreen'] == 1) {
    TempVariable['width'] = 10
    TempVariable['height'] = 10
    loadingDungeon =
      '1111111111<+>0000111110<+>0000001110<+>1110110000<+>1110,,4,3,,10000<+>0000001110<+>2110001110<+>000011111,,4,3<+>0000010010<+>0110101100<->1002000000<+>1001101001<+>1001101001<+>1000000002<+>1001101001<+>1001101001<+>1201100000<+>1101101011<+>1101110101<+>1000001010<->000000,,2,1,0,0,,000<+>0000000000<+>0000000000<+>0000000000<+>0000000000<+>0000000000<+>000,,5,,000000<+>0000000000<+>0000000000<+>0000000000'
  } else {
    TempVariable['width'] = 5
    TempVariable['height'] = 16
    loadingDungeon =
      '0000000000000000<+>0000000000002222<+>1112110001100000<+>1112110001100000<+>0000000000002222<->0000000001000000<+>1000000002000000<+>0000000000000000<+>1000000002000000<+>0000000001000000<->00000000,,5,,0000000<+>0000000000000000<+>0000000000000000<+>0000000000000000<+>00000000,,5,,0000000'
  }
  let dunMapAry = loadingDungeon.split('<->')
  TempVariable['westWall'] = []
  let dunMapAry1 = dunMapAry[0].split('<+>')
  for (let x = 0; x < dunMapAry1.length; x++) {
    if (x >= TempVariable['width']) {
      break
    }
    TempVariable['westWall'][x] = []
    let y = 0
    let dunMapAry2 = dunMapAry1[x].split(',,')
    for (let i = 0; i < dunMapAry2.length; i++) {
      if (y >= TempVariable['height']) {
        break
      }
      if (dunMapAry2[i].indexOf(',') > -1) {
        TempVariable['westWall'][x][y] = dunMapAry2[i]
        y++
      } else {
        for (let j = 0; j < dunMapAry2[i].length; j++) {
          if (y >= TempVariable['height']) {
            break
          }
          TempVariable['westWall'][x][y] = dunMapAry2[i].charAt(j)
          y++
        }
      }
    }
  }
  TempVariable['southWall'] = []
  dunMapAry1 = dunMapAry[1].split('<+>')
  for (let x = 0; x < dunMapAry1.length; x++) {
    if (x >= TempVariable['width']) {
      break
    }
    TempVariable['southWall'][x] = []
    let y = 0
    let dunMapAry2 = dunMapAry1[x].split(',,')
    for (let i = 0; i < dunMapAry2.length; i++) {
      if (y >= TempVariable['height']) {
        break
      }
      if (dunMapAry2[i].indexOf(',') > -1) {
        TempVariable['southWall'][x][y] = dunMapAry2[i]
        y++
      } else {
        for (let j = 0; j < dunMapAry2[i].length; j++) {
          if (y >= TempVariable['height']) {
            break
          }
          TempVariable['southWall'][x][y] = dunMapAry2[i].charAt(j)
          y++
        }
      }
    }
  }
  TempVariable['space'] = []
  dunMapAry1 = dunMapAry[2].split('<+>')
  for (let x = 0; x < dunMapAry1.length; x++) {
    if (x >= TempVariable['width']) {
      break
    }
    TempVariable['space'][x] = []
    let y = 0
    let dunMapAry2 = dunMapAry1[x].split(',,')
    for (let i = 0; i < dunMapAry2.length; i++) {
      if (y >= TempVariable['height']) {
        break
      }
      if (dunMapAry2[i].indexOf(',') > -1 || dunMapAry2[i].indexOf('<>') > -1) {
        TempVariable['space'][x][y] = dunMapAry2[i]
        y++
      } else {
        for (let j = 0; j < dunMapAry2[i].length; j++) {
          if (y >= TempVariable['height']) {
            break
          }
          TempVariable['space'][x][y] = dunMapAry2[i].charAt(j)
          y++
        }
      }
    }
  }
  let ptXY
  if (LaunchSettings['LoadingScreen'] == 1) {
    let num = dice(1, 3) - 1
    if (num == 0) {
      ptXY = [0, 4]
    } else if (num == 1) {
      ptXY = [3, 0]
    } else {
      ptXY = [9, 1]
    }
  } else {
    ptXY = [2, 0]
  }
  TempVariable['ptX'] = ptXY[0]
  TempVariable['ptY'] = ptXY[1]
  TempVariable['ptDirection'] = 0
  TempVariable['ptNext'] = ''
  LoopLoadingID = requestAnimationFrame(loopLoading)
}
WebFont.load({
  classes: false,
  custom: { families: ['GameFont'] },
  loading: function () {},
  active: function () {
    TempVariable['loadWebFont'] = true
  },
  inactive: function () {
    TempVariable['loadWebFont'] = true
  }
})
function test () {}
function addKeyEvent () {
  document.addEventListener('keydown', eventKeydown)
  document.addEventListener('keyup', eventKeyup)
  document.onkeydown = shortcutSuppression
}
function addTransmigrationCharacter (data) {
  let dataAry = data.split('<*>')
  if (dataAry.length != 12) {
    return 1
  }
  if (dataAry[0] == '' || MP.strCount(dataAry[0]) > 40) {
    return 1
  }
  let str = GameData['REG_TM_READKEYWORD'].replace(/^ *<>/, '')
  str = str.replace(/<> *$/, '')
  let ck = false
  let strAry
  if (str == '') {
    ck = true
  } else {
    strAry = str.split('<>')
    for (let i = 0; i < strAry.length; i++) {
      strAry[i] = strAry[i].replace(/^ +$/, '')
      if (strAry[i] == dataAry[0]) {
        ck = true
        break
      }
    }
  }
  if (!ck) {
    return 1
  }
  if (dataAry[1] == '' || MP.strCount(dataAry[1]) > 20) {
    return 1
  }
  if (dataAry[2].indexOf('<->') < 0) {
    return 1
  }
  strAry = dataAry[2].split('<->')
  if (strAry.length != 2) {
    return 1
  }
  if (strAry[0] == '' || MP.strCount(strAry[0]) > 20) {
    return 1
  }
  if (strAry[1] == '' || MP.strCount(strAry[1]) > 4) {
    return 1
  }
  if (dataAry[3].indexOf('<->') < 0) {
    return 1
  }
  strAry = dataAry[3].split('<->')
  if (strAry.length != 2) {
    return 1
  }
  if (strAry[0] == '' || MP.strCount(strAry[0]) > 20) {
    return 1
  }
  if (strAry[1] == '' || MP.strCount(strAry[1]) > 4) {
    return 1
  }
  if (!dataAry[4].match(/^[01]$/)) {
    return 1
  }
  if (!dataAry[5].match(/^[0-2]$/)) {
    return 1
  }
  if (!dataAry[6].match(/^[0-9]+$/)) {
    return 1
  }
  let num = Number(dataAry[6])
  if (num < 1 || num > 999) {
    return 1
  }
  if (dataAry[7].indexOf('<->') < 0) {
    return 1
  }
  strAry = dataAry[7].split('<+>')
  for (let i = 0; i < strAry.length; i++) {
    let strAry2 = strAry[i].split('<->')
    if (strAry2[0] == '' || MP.strCount(strAry2[0]) > 20) {
      return 1
    }
    if (strAry2[1] == '' || MP.strCount(strAry2[1]) > 6) {
      return 1
    }
    if (!strAry2[2].match(/^[0-9]+$/)) {
      return 1
    }
    num = Number(strAry2[2])
    if (num > 999) {
      return 1
    }
  }
  if (!dataAry[8].match(/^[0-9]+$/)) {
    return 1
  }
  num = Number(dataAry[8])
  if (num < 1 || num > 99999) {
    return 1
  }
  if (!dataAry[9].match(/^[0-9]+$/)) {
    return 1
  }
  num = Number(dataAry[9])
  if (num < 0 || num > 999999999999) {
    return 1
  }
  if (MP.strCount(dataAry[10]) > 6) {
    return 1
  }
  if (dataAry[11] != '-1') {
    strAry = dataAry[11].split('<->')
    for (let i = 0; i < strAry.length; i++) {
      if (strAry[i] != '-1' && !strAry[i].match(/^[0-9]+$/)) {
        return 1
      }
      num = Number(strAry[i])
      if (num < 0 || num > 9999) {
        return 1
      }
    }
  }
  let pcNum
  for (let i = 0; i < PlayData['PcMax']; i++) {
    pcNum = PlayData['PcList'][i]
    if (PC[pcNum].Transmigrates == data) {
      return 2
    }
  }
  let race = -1
  strAry = dataAry[2].split('<->')
  for (let i = 0; i < GameData['RACE'].length; i++) {
    if (GameData['RACE'][i] == strAry[0]) {
      race = i
      break
    }
  }
  if (race < 0) {
    for (let i = 0; i < GameData['RACE_ABBR'].length; i++) {
      if (GameData['RACE_ABBR'][i] == strAry[1]) {
        race = i
        break
      }
    }
  }
  if (race < 0) {
    race = GameData['REG_TM_RACE']
  }
  let pcClass = -1
  strAry = dataAry[3].split('<->')
  for (let i = 0; i < GameData['PC_CLASS'].length; i++) {
    if (GameData['PC_CLASS'][i] == strAry[0]) {
      pcClass = i
      break
    }
  }
  if (pcClass < 0) {
    for (let i = 0; i < GameData['PC_CLASS_ABBR'].length; i++) {
      if (GameData['PC_CLASS_ABBR'][i] == strAry[1]) {
        pcClass = i
        break
      }
    }
  }
  if (pcClass < 0) {
    pcClass = GameData['REG_TM_CLASS']
  }
  let sex = Number(dataAry[4])
  if (GameData['RACE_SEX_INSIDE'][race] > -1) {
    sex = GameData['RACE_SEX_INSIDE'][race]
  } else if (GameData['RACE_SEX'][race].indexOf(String(sex)) < 0) {
    sex = Number(GameData['RACE_SEX'][race].charAt(0))
  }
  if (
    GameData['REG_TM_SEX'] &&
    !GameData['CLASS_SEX'][pcClass][sex] &&
    GameData['RACE_SEX_INSIDE'][race] < 0
  ) {
    let newSex = -1
    for (let i = 0; i < 4; i++) {
      if (
        GameData['CLASS_SEX'][pcClass][i] &&
        GameData['RACE_SEX'][race].indexOf(String(i)) > -1
      ) {
        newSex = i
        break
      }
    }
    if (newSex > -1) {
      sex = newSex
    }
  }
  let ali = Number(dataAry[5])
  if (GameData['REG_TM_ALI'] && !GameData['CLASS_ALI'][pcClass][ali]) {
    let stack = []
    for (let i = 0; i < 3; i++) {
      if (GameData['CLASS_ALI'][pcClass][i]) {
        stack.push(i)
      }
    }
    num = dice(1, stack.length) - 1
    ali = stack[num]
  }
  let abi = []
  strAry = dataAry[7].split('<+>')
  for (let i = 0; i < GameData['ABILITY'].length; i++) {
    for (let j = 0; j < strAry.length; j++) {
      let strAry2 = strAry[j].split('<->')
      if (GameData['ABILITY'][i] == strAry2[0]) {
        abi[i] = Number(strAry2[2])
        break
      }
    }
    if (abi[i] == undefined) {
      for (let j = 0; j < strAry.length; j++) {
        let strAry2 = strAry[j].split('<->')
        if (GameData['ABILITY_ABBR'][i] == strAry2[1]) {
          abi[i] = Number(strAry2[2])
          break
        }
      }
    }
    if (abi[i] == undefined) {
      abi[i] = GameData['RACE_ABI'][race][i] + GameData['ABILITY_SEX'][sex][i]
    }
  }
  for (let i = 0; i < GameData['ABILITY'].length; i++) {
    str = GameData['REG_TM_ABI'].replace(/abi/g, String(abi[i]))
    num = Math.floor(strCalculation(replaceFormula(str)))
    if (num > 999) {
      num = 999
    }
    if (num < 0) {
      abi[i] = GameData['RACE_ABI'][race][i] + GameData['ABILITY_SEX'][sex][i]
    } else {
      abi[i] = num
    }
  }
  pcNum = getNextPcNum()
  PC[pcNum].initializeVariable()
  PC[pcNum].createPc(dataAry[1], sex, race, pcClass, ali, abi, 14)
  PlayData['PcList'][PlayData['PcMax']] = pcNum
  PlayData['PcMax']++
  TempVariable['name'] = dataAry[1]
  str = GameData['REG_TM_AGE'].replace(/age/g, dataAry[6])
  num = Math.floor(strCalculation(replaceFormula(str)))
  if (num < 1) {
    num = 1
  } else if (num > 999) {
    num = 999
  }
  PC[pcNum].Age = num
  str = GameData['REG_TM_GOLD'].replace(/gold/g, dataAry[9])
  num = Math.floor(strCalculation(replaceFormula(str)))
  if (num < 0) {
    tmpL = 0
  } else if (num > 999999999999) {
    num = 999999999999
  }
  PC[pcNum].Gold = num
  PC[pcNum].Title = dataAry[10]
  PC[pcNum].controlTitle(GameData['REG_TM_TITLE'])
  str = GameData['REG_TM_LV'].replace(/lv/g, dataAry[8])
  num = Math.floor(strCalculation(replaceFormula(str)))
  if (num < 1) {
    num = 1
  } else if (num > 99999) {
    num = 99999
  }
  if (num > 1) {
    PC[pcNum].levelUp(num)
  }
  for (let i = 0; i < GameData['ABILITY'].length; i++) {
    PC[pcNum].Ability0[i] = abi[i]
  }
  if (dataAry[11] != '-1') {
    strAry = dataAry[11].split('<->')
    let strAry2 = GameData['REG_TM_ITEM'].split('<*>')
    let count = 0
    for (let i = 0; i < strAry.length; i++) {
      let item = -2
      for (let j = 0; j < strAry2.length; j++) {
        if (strAry2[j].indexOf('<+>') < 0) {
          continue
        }
        let strAry3 = strAry2[j].split('<+>')
        let strAry4 = strAry3[1].split('<br>')
        for (let k = 0; k < strAry4.length; k++) {
          if (strAry4[k].indexOf('<>') < 0) {
            continue
          }
          let strAry5 = strAry4[k].split('<>')
          strAry5[0] = strAry5[0].replace(/^ +$/, '')
          if (strAry5[0] != '' && strAry5[0] != dataAry[0]) {
            continue
          }
          str = MP.getCmNum(strAry5[1])
          let reg = new RegExp('(^|.+,)' + strAry[i] + '(,.+|$)')
          if (str.match(reg1)) {
            item = Number(strAry3[0])
            break
          }
        }
        if (item > -2) {
          break
        }
      }
      if (item < 0) {
        continue
      }
      PC[pcNum].putItem(item, 1)
      count++
      if (count >= PC[pcNum].ItemMaxNum) {
        break
      }
    }
  }
  PC[pcNum].Transmigrates = data
  PC[pcNum].NextUpExp = -1
  PC[pcNum].check()
  return 0
}
function adjustFaceGraphic () {
  let nowList = []
  for (let i = 0; i < PlayData['PcMax']; i++) {
    let pcNum = PlayData['PcList'][i]
    let faceStr
    if (PC[pcNum].FaceGraphic.match(/^(| |none)$/)) {
      faceStr = 'graphic/face/' + PC[pcNum].Name[0]
    } else {
      faceStr = '<>' + PC[pcNum].FaceGraphic
    }
    nowList.push(faceStr)
  }
  let deleteList = []
  for (let i = 0; i < Prefetch['face'].length; i++) {
    if (nowList.indexOf(Prefetch['face'][i]) < 0) {
      deleteList.push(Prefetch['face'][i])
    }
  }
  for (let i = 0; i < deleteList.length; i++) {
    let num = Prefetch['face'].indexOf(deleteList[i])
    Prefetch['face'].splice(num, 1)
    if (
      Prefetch['face'].indexOf(deleteList[i]) < 0 &&
      Prefetch['event'].indexOf(deleteList[i]) < 0
    ) {
      delete GraphicData[deleteList[i]]
    }
  }
  let resultList = []
  for (let i = 0; i < nowList.length; i++) {
    if (Prefetch['face'].indexOf(nowList[i]) < 0) {
      resultList.push(nowList[i])
      Prefetch['face'].push(nowList[i])
    }
  }
  return resultList
}
function allMusicPlay () {
  for (let key in MusicData) {
    MusicData[key].muted = true
  }
  for (let key in MusicData) {
    musicPlay(key, true)
  }
  musicStop()
  for (let key in MusicData) {
    MusicData[key].muted = false
  }
}
function allSePlay () {
  for (let key in SoundData) {
    SoundData[key].mute(true)
  }
  for (let key in SoundData) {
    SoundData[key].playAll()
  }
  seStop()
  for (let key in SoundData) {
    SoundData[key].mute(false)
  }
}
function annihilateProcessing (inStone) {
  let ptNum = PlayData['ActiveParty']
  let pt = PARTY[ptNum]
  if (inStone == undefined || inStone == null) {
    let space = DUNGEON.Space[pt.DungeonNumber][pt.Floor][pt.X][pt.Y]
    if (space.charAt(0) == 'a') {
      inStone = true
    } else {
      inStone = false
    }
  }
  let memberNum = pt.getMemberNum()
  for (let i = 0; i < memberNum; i++) {
    let pcNum = pt.PartyMember[i]
    let pc = PC[pcNum]
    if (pc.State < 4) {
      pc.controlHp(-99999, true)
    }
  }
  pt.check()
  let returnGround = false
  if (inStone) {
    if (GameData['ROCK_LOST']) {
      while (pt.PartyMember[0] > -1) {
        let pcNum = pt.PartyMember[0]
        pt.removeMember(pcNum)
        deletePc(pcNum)
      }
    } else {
      returnGround = true
    }
  }
  if (GameData['RETURN_PARTY_ANNIHILATION']) {
    returnGround = true
  }
  if (returnGround) {
    pt.dissolution(true)
  }
  deleteTempVariable()
  PlayData['ActiveParty'] = -1
  if (GameData['SAVE_ANNIHILATION']) {
    saveData('Annihilation')
  }
}
function arrayIndexOf (ary, str) {
  for (let i = 0; i < ary.length; i++) {
    if (ary[i].indexOf(str) > -1) {
      return i
    }
  }
  return -1
}
function calDiv (a, b) {
  return BigNumber(a).div(b).toNumber()
}
function calMinus (a, b) {
  return BigNumber(a).minus(b).toNumber()
}
function calPlus (a, b) {
  return BigNumber(a).plus(b).toNumber()
}
function calTimes (a, b) {
  return BigNumber(a).times(b).toNumber()
}
function cancelInputText () {
  GenericVariable['FullKeyInvalid'] = true
  MP.controlInputText('clear')
  if (Mode == 'debug') {
    Mode = 'Normal'
    MP.paintMask('clear')
  } else if (Mode.match(/optionKeyConfig[A-Z_]+/)) {
    MP.ButtonObject['game_window_div'].style.display = 'none'
    if (MP.ButtonObject['escape_div'] != undefined) {
      MP.ButtonObject['escape_div'].style.display = 'none'
    }
    MP.setOptionMode('keyConfig')
  } else if (GameState == 'setFaceGraphic') {
    MP.paintMask('clear')
    MP.TopSurface.clear()
    GameState = 'inspectCommand'
    MP.SelectMode['valueAry'][MP.SelectMode['select']] = 'setFaceGraphic'
    statusAction('return')
  } else if (GameState == 'trainingCreateName') {
    delete TempVariable['name']
    delete TempVariable['abiMin']
    delete TempVariable['abiMax']
    delete TempVariable['classAry']
    GameState = 'trainingStart'
    MP.SelectMode['valueAry'][MP.SelectMode['select']] = 'create'
    townAction('none')
  } else if (GameState == 'trainingChangeName2') {
    MP.controlPreSelect('pop')
    GameState = 'trainingChangeName'
    townAction('return')
  } else if (GameState == 'moveEvent3inputText') {
    GameState = 'moveEvent4_2'
    dungeonAction()
  }
  GenericVariable['ReturnKeyControll'] = 0
}
function changeEquipAction (key, value) {
  TempVariable['value'] = value
  let pcNum = PlayData['StatusNum']
  let pc = PC[pcNum]
  let sel
  if (key == 'enter') {
    sel = GameData['ITEM_EQUIP_LIST'][TempVariable['equipSel']]
    TempVariable['value'] = Number(TempVariable['value'])
    if (TempVariable['value'] < 0) {
      let equiped = pc.kindEquipedItem(sel)
      if (equiped > -1) {
        pc.Equip[equiped] = 0
        if (sel == 0) {
          equiped = pc.kindEquipedItem(7)
          if (equiped > -1) {
            pc.Equip[equiped] = 0
          }
        }
      }
      key = 'next'
    } else {
      let itemNum = pc.Item[TempVariable['value']]
      let item = ITEM[itemNum]
      if (item.equipCheck(pcNum)) {
        if (item.TYPE == 0) {
          let subWeaponNum = pc.kindEquipedItem(7)
          let shieldNum = pc.kindEquipedItem(2, true)
          if (
            (item.WEAPON_TYPE == 1 || (sel == 7 && item.WEAPON_TYPE == 2)) &&
            shieldNum > -1
          ) {
            if (!pc.kindCursedCheck(2)) {
              pc.Equip[shieldNum] = 0
              key = 'next'
            }
          } else if (item.WEAPON_TYPE == 1 && subWeaponNum > -1) {
            pc.Equip[subWeaponNum] = 0
            key = 'next'
          } else {
            key = 'next'
          }
        } else {
          key = 'next'
        }
      }
      if (key == 'next') {
        let equiped = pc.kindEquipedItem(sel)
        if (equiped > -1) {
          pc.Equip[equiped] = 0
        }
        if (item.curseCheck(pcNum)) {
          if (sel == 7) {
            pc.Equip[pc.kindEquipedItem(0)] = 0
          }
          pc.Equip[TempVariable['value']] = 2
          pc.check()
          MP.SelectMode['selAry'][MP.SelectMode['select']] = pc.getItemName(
            TempVariable['value'],
            'equip'
          )
          if (GameState == 'battleCommandExchange') {
            MP.viewPartyStatus()
            MP.TextSurfaceNum++
            MP.clearTextSurface()
            MP.viewSelectMode()
            MP.drawTextFrame(
              MP.TextSurface[MP.TextSurfaceNum],
              getDefaultMessage('CURSED', 1),
              'center',
              MP.LINE_HEIGHT * 7.5
            )
            GameState = 'battleCommandExchangeReturn'
          } else {
            MP.viewStatus(PlayData['StatusNow'], PlayData['StatusNum'])
            MP.clearTextSurface()
            MP.viewSelectMode()
            MP.drawTextFrame(
              MP.TextSurface[MP.TextSurfaceNum],
              getDefaultMessage('CURSED', 1),
              'center',
              MP.LINE_HEIGHT * 6
            )
            GameState = 'inspectEquipReturn'
          }
          return true
        } else {
          if (sel == 7) {
            pc.Equip[TempVariable['value']] = 3
          } else {
            pc.Equip[TempVariable['value']] = 1
          }
        }
      }
    }
    if (key == 'next') {
      pc.check()
      if (GameState == 'battleCommandExchange') {
        MP.viewPartyStatus()
      }
    } else {
      TempVariable['value'] = String(TempVariable['value'])
    }
  }
  if (key == 'next' || key == 'return') {
    TempVariable['value'] = ''
    MP.SelectMode['selectF'] = 0
    while (true) {
      TempVariable['equipSel']++
      if (TempVariable['equipSel'] >= GameData['ITEM_EQUIP_LIST'].length) {
        break
      }
      let eSel = GameData['ITEM_EQUIP_LIST'][TempVariable['equipSel']]
      if (GameState == 'battleCommandExchange') {
        if (eSel != 0 && eSel != 2 && eSel != 7) {
          continue
        }
      }
      let kind = eSel
      if (kind == 7) {
        kind = 0
      }
      if (!pc.haveEquipItem(eSel) || pc.kindCursedCheck(kind)) {
        continue
      }
      if (eSel == 7) {
        let weaponNum = pc.kindEquipedItem(0)
        if (weaponNum < 0) {
          continue
        }
        if (
          ITEM[pc.Item[weaponNum]].WEAPON_TYPE == 1 ||
          pc.kindCursedCheck(2)
        ) {
          continue
        }
      } else if (eSel == 2) {
        let weaponNum = pc.kindEquipedItem(0)
        if (weaponNum > -1) {
          if (
            ITEM[pc.Item[weaponNum]].WEAPON_TYPE == 1 ||
            pc.kindEquipedItem(7) > -1
          ) {
            continue
          }
        }
      }
      break
    }
    if (TempVariable['equipSel'] >= GameData['ITEM_EQUIP_LIST'].length) {
      if (GameState == 'battleCommandExchange') {
        MP.controlPreSelect('pop')
        GameState = 'battleCommand'
        battleAction()
      } else if (PlayData['StatusAction'] == 'campInspect') {
        GameState = 'inspectSP'
        statusAction()
      } else {
        deleteTempVariable()
        MP.controlPreSelect('pop')
        GameState = 'inspectCommand'
        statusAction('return')
      }
      return true
    }
  }
  let hPlus = 0
  if (GameState == 'battleCommandExchange') {
    MP.clearTextSurface(MP.TextSurfaceNum)
    MP.viewPreSelectMode(MP.TextSurfaceNum, 0, 'none')
    hPlus = 1.5
  } else {
    MP.viewStatus(PlayData['StatusNow'], PlayData['StatusNum'])
    MP.clearTextSurface('all')
    MP.viewPreSelectMode(MP.TextSurfaceNum, 1, 'none')
  }
  sel = GameData['ITEM_EQUIP_LIST'][TempVariable['equipSel']]
  let str = ''
  if (sel == 0) {
    str = 'WEAPON'
  } else if (sel == 1) {
    str = 'ARMOR'
  } else if (sel == 2) {
    str = 'SHIELD'
  } else if (sel == 3) {
    str = 'HELM'
  } else if (sel == 4) {
    str = 'GAUNTLETS'
  } else if (sel == 5) {
    str = 'BOOTS'
  } else if (sel == 6) {
    str = 'MISC'
  } else if (sel == 7) {
    str = 'SUBWEAPON'
  }
  str = getDefaultMessage(str, 1)
  str = getDefaultMessage('EQUIP_SELECT', 1).replace(/\[itemKind\]/g, str)
  MP.drawTextFrame(
    MP.TextSurface[MP.TextSurfaceNum],
    str,
    'center',
    MP.LINE_HEIGHT * (1 + hPlus)
  )
  MP.TextSurfaceNum++
  TempVariable['selAry'] = []
  TempVariable['valueAry'] = []
  let itemMax = pc.haveItemNum(-1)
  for (let i = 0; i < itemMax; i++) {
    let item = ITEM[pc.Item[i]]
    let flag = false
    if (sel == 7) {
      if (
        item.TYPE == 0 &&
        item.WEAPON_TYPE == 2 &&
        (pc.Equip[i] == 0 || pc.Equip[i] == 3) &&
        item.EQUIP_REQ_CLASS.indexOf('-') < 0
      ) {
        flag = true
      }
    } else if (item.TYPE == sel && item.EQUIP_REQ_CLASS.indexOf('-') < 0) {
      flag = true
    }
    if (flag) {
      TempVariable['selAry'].push(pc.getItemName(i, 'equip'))
      TempVariable['valueAry'].push(String(i))
    }
  }
  TempVariable['selAry'].push(getDefaultMessage('EQUIP_NONE', 1, 26))
  TempVariable['valueAry'].push('-1')
  if (key == 'next') {
    let equiped = pc.kindEquipedItem(sel)
    if (equiped > -1) {
      TempVariable['value'] = String(equiped)
    }
  }
  return false
}
function checkCondition (formula) {
  formula = replaceFormula(formula)
  if (strCalculation(formula) == 0) {
    return false
  } else {
    return true
  }
}
function checkFileName (str) {
  str = str.replace(/\\/g, '￥')
  str = str.replace(/\//g, '／')
  str = str.replace(/:/g, '：')
  str = str.replace(/\*/g, '＊')
  str = str.replace(/\?/g, '？')
  str = str.replace(/\"/g, '”')
  str = str.replace(/>/g, '＞')
  str = str.replace(/</g, '＜')
  str = str.replace(/\|/g, '｜')
  str = str.replace(/&/g, '＆')
  str = str.replace(/%/g, '％')
  str = str.replace(/\./g, '．')
  return str
}
function checkGraphic_Castle (castle) {
  let result = 'graphic/bg/' + castle
  if (Prefetch['castle'].indexOf(result) > -1) {
    result = ''
  }
  return result
}
function checkGraphic_Dungeon (dungeonAry) {
  let resultAry = []
  for (let i = 0; i < dungeonAry.length; i++) {
    let str = 'graphic/dungeon/' + dungeonAry[i]
    if (Prefetch['dungeon'].indexOf(str) < 0) {
      resultAry.push(str)
    }
  }
  return resultAry
}
function checkGraphic_Event (eventAry) {
  let resultAry = []
  for (let i = 0; i < eventAry.length; i++) {
    let str = 'graphic/' + eventAry[i]
    if (Prefetch['event'].indexOf(str) < 0) {
      resultAry.push(str)
    }
  }
  return resultAry
}
function checkGraphic_Monster (monsterAry) {
  let resultAry = []
  for (let i = 0; i < monsterAry.length; i++) {
    for (let j = 0; j < 2; j++) {
      let str = MONSTER_DATA[monsterAry[i]].ConfirmedCG[j]
      if (str == '' || Prefetch['monster'][j].indexOf(str) < 0) {
        resultAry.push(monsterAry[i])
        break
      }
    }
  }
  return resultAry
}
function checkItemNum (itemNum) {
  if (itemNum < 0 || itemNum >= ITEM.length) {
    return 0
  } else {
    return itemNum
  }
}
function checkNull (a, value) {
  if (typeof a === 'boolean' || Number.isFinite(a)) {
    return a
  }
  if (a == undefined || a == null || a == '') {
    a = value
  }
  return a
}
function checkRadioButton () {
  if (
    MP.OptionParts['Music_0']._element.checked &&
    MP.OptionParts['Music_0']._element.style.visibility == 'visible'
  ) {
    MP.OptionParts['bgm_volume']._element.textContent = Config['BgmVolume']
    MP.OptionParts['bgm_volume']._element.style.visibility = 'visible'
    MP.OptionParts['bgm_volume_up']._element.style.visibility = 'visible'
    MP.OptionParts['bgm_volume_down']._element.style.visibility = 'visible'
  } else {
    MP.OptionParts['bgm_volume']._element.style.visibility = 'hidden'
    MP.OptionParts['bgm_volume_up']._element.style.visibility = 'hidden'
    MP.OptionParts['bgm_volume_down']._element.style.visibility = 'hidden'
  }
  if (
    MP.OptionParts['Se_0']._element.checked &&
    MP.OptionParts['Se_0']._element.style.visibility == 'visible'
  ) {
    MP.OptionParts['se_volume']._element.textContent = Config['SeVolume']
    MP.OptionParts['se_volume']._element.style.visibility = 'visible'
    MP.OptionParts['se_volume_up']._element.style.visibility = 'visible'
    MP.OptionParts['se_volume_down']._element.style.visibility = 'visible'
  } else {
    MP.OptionParts['se_volume']._element.style.visibility = 'hidden'
    MP.OptionParts['se_volume_up']._element.style.visibility = 'hidden'
    MP.OptionParts['se_volume_down']._element.style.visibility = 'hidden'
  }
  if (MP.OptionParts['Dungeon_0']._element.checked) {
    MP.OptionParts['Perspective_0']._element.disabled = false
    MP.OptionParts['Perspective_0']._element.style.cursor = 'pointer'
    MP.OptionParts['Perspective_1']._element.disabled = false
    MP.OptionParts['Perspective_1']._element.style.cursor = 'pointer'
  } else {
    MP.OptionParts['Perspective_0']._element.disabled = true
    MP.OptionParts['Perspective_0']._element.style.cursor = 'default'
    MP.OptionParts['Perspective_1']._element.disabled = true
    MP.OptionParts['Perspective_1']._element.style.cursor = 'default'
  }
}
function checkRadioButtonText () {
  let x = MP.MAIN_X + MP.MAIN_WIDTH / 2 - MP.FONT_HALF_SIZE * 25
  let y = MP.MAIN_Y + MP.LINE_HEIGHT * 3
  let y2 = MP.LINE_HEIGHT * 2.2
  let y3 = y + y2 * 5
  let ctx = MP.TopSurface.context
  ctx.clearRect(
    x + MP.FONT_HALF_SIZE * 23,
    y3,
    MP.FONT_HALF_SIZE * 12,
    MP.FONT_SIZE
  )
  ctx.clearRect(
    x + MP.FONT_HALF_SIZE * 37,
    y3,
    MP.FONT_HALF_SIZE * 12,
    MP.FONT_SIZE
  )
  let color = 'white'
  if (!MP.OptionParts['Dungeon_0']._element.checked) {
    color = 'gray'
  }
  MP.drawText(
    MP.TopSurface,
    x + MP.FONT_HALF_SIZE * 24,
    y3,
    null,
    null,
    'on',
    null,
    null,
    color
  )
  MP.drawText(
    MP.TopSurface,
    x + MP.FONT_HALF_SIZE * 38,
    y3,
    null,
    null,
    'off',
    null,
    null,
    color
  )
}
function checkSaveData (data) {
  let dataAry = data.split(/\n/)
  if (dataAry[0] != GameData['READ_KEYWORD']) {
    return false
  }
  if (!dataAry[1].match(/^[01]$/)) {
    return false
  }
  for (let i = 2; i < 5; i++) {
    if (!dataAry[i].match(/^[01]+$/)) {
      return false
    }
  }
  return true
}
function checkShopItemListFull () {
  let ck = true
  for (let i = 0; i < ITEM.length; i++) {
    if (ITEM[i].PRICE > 0 && ITEM[i].STOCK_OK) {
      if (ITEM[i].Stock < 1) {
        ck = false
        break
      }
    }
  }
  if (ck) {
    PlayData['ShopItemListFull'] = true
  }
}
function configGetStr (config, keyConfig) {
  let configStr = ''
  for (let i = 0; i < CONFIG_NAME.length; i++) {
    if (configStr != '') {
      configStr += '\n'
    }
    if (typeof config[CONFIG_NAME[i]] == 'boolean') {
      configStr += CONFIG_NAME[i] + ' = ' + String(config[CONFIG_NAME[i]])
    } else {
      configStr +=
        CONFIG_NAME[i] + ' = ' + checkNull(config[CONFIG_NAME[i]], '')
    }
  }
  for (let i = 0; i < KEY_NAME.length; i++) {
    configStr += '\n'
    let keyName = KEY_NAME[i].replace('KEY_', '')
    configStr += keyName + ' = ' + keyConfig[KEY_NAME[i]]
  }
  return configStr
}
function configLoad (initialStr) {
  Config = {}
  let configStr = localStorage.getItem(SaveName + 'Config')
  if (configStr == null) {
    if (initialStr == null) {
      configStr = ''
    } else {
      configStr = initialStr
    }
  }
  let textAry = configStr.split(/\r\n|\n|\r/)
  let line = -1
  for (let i = 0; i < textAry.length; i++) {
    if (textAry[i].match(/TextMemory = /)) {
      line = i
      break
    }
    let loopNext = false
    for (let j = 0; j < CONFIG_NAME.length; j++) {
      let reg = new RegExp('^[^a-zA-Z_]*' + CONFIG_NAME[j] + ' *=(.*?)')
      if (!textAry[i].match(reg)) {
        continue
      }
      let str = textAry[i].replace(reg, '$1').replace(/\s/g, '')
      if (str.match(/true|false/)) {
        Config[CONFIG_NAME[j]] = parseStrToBoolean(str)
      } else if (str != '') {
        Config[CONFIG_NAME[j]] = str
      }
      loopNext = true
      break
    }
    if (loopNext) {
      continue
    }
    for (let j = 0; j < KEY_NAME.length; j++) {
      let keyName = KEY_NAME[j].replace('KEY_', '')
      let reg = new RegExp('^[^a-zA-Z_]*' + keyName + ' *=(.*?)')
      if (!textAry[i].match(reg)) {
        continue
      }
      let str = textAry[i].replace(reg, '$1').replace(/^\s+|\s+$/, '')
      if (str != '') {
        KeyConfigData2[KEY_NAME[j]] = str
      }
      break
    }
  }
  for (let i = 0; i < KEY_NAME.length; i++) {
    if (KeyConfigData2[KEY_NAME[i]] != undefined) {
      continue
    }
    if (KeyConfigData[KEY_NAME[i]] != undefined) {
      KeyConfigData2[KEY_NAME[i]] = KeyConfigData[KEY_NAME[i]]
    }
  }
  for (let i = 0; i < CONFIG_NAME.length; i++) {
    if (Config[CONFIG_NAME[i]] != undefined) {
      continue
    }
    if (CONFIG_NAME[i] == 'ControllerAlign') {
      Config[CONFIG_NAME[i]] = 'left'
    } else if (CONFIG_NAME[i] == 'Dungeon') {
      Config[CONFIG_NAME[i]] = 'graphic'
    } else if (CONFIG_NAME[i].match(/Volume/)) {
      Config[CONFIG_NAME[i]] = '75'
    } else {
      Config[CONFIG_NAME[i]] = true
    }
  }
  if (LaunchSettings['NoSoundAllowed']) {
    Config['Bgm'] = false
    Config['Se'] = false
  }
  for (let i = 0; i < KEY_NAME.length; i++) {
    if (KeyConfigData2[KEY_NAME[i]] != undefined) {
      continue
    }
    if (KEY_NAME[i] == 'KEY_UP') {
      KeyConfigData2[KEY_NAME[i]] = 'up, numpad8, gamepad_up'
    } else if (KEY_NAME[i] == 'KEY_DOWN') {
      KeyConfigData2[KEY_NAME[i]] = 'down, numpad2, gamepad_down'
    } else if (KEY_NAME[i] == 'KEY_RIGHT') {
      KeyConfigData2[KEY_NAME[i]] = 'right, numpad6, gamepad_right'
    } else if (KEY_NAME[i] == 'KEY_LEFT') {
      KeyConfigData2[KEY_NAME[i]] = 'left, numpad4, gamepad_left'
    } else if (KEY_NAME[i] == 'KEY_SHIFT') {
      KeyConfigData2[KEY_NAME[i]] = 'shift'
    } else if (KEY_NAME[i] == 'KEY_SHIFT_RIGHT') {
      KeyConfigData2[KEY_NAME[i]] = 'numpad9, gamepad_5, gamepad_zUp'
    } else if (KEY_NAME[i] == 'KEY_SHIFT_LEFT') {
      KeyConfigData2[KEY_NAME[i]] = 'numpad7, gamepad_4, gamepad_zDown'
    } else if (KEY_NAME[i] == 'KEY_ENTER') {
      KeyConfigData2[KEY_NAME[i]] = 'space, z, numpad5, gamepad_0'
    } else if (KEY_NAME[i] == 'KEY_CANCEL') {
      KeyConfigData2[KEY_NAME[i]] = 'backspace, x, numpad0, gamepad_1'
    } else if (KEY_NAME[i] == 'KEY_STATUS') {
      KeyConfigData2[KEY_NAME[i]] = 's, numpad3, gamepad_6'
    } else if (KEY_NAME[i] == 'KEY_SUBMENU') {
      KeyConfigData2[KEY_NAME[i]] = 'a, numpad1, gamepad_2'
    } else if (KEY_NAME[i] == 'KEY_MAP') {
      KeyConfigData2[KEY_NAME[i]] = 'c, m, add, gamepad_3'
    } else if (KEY_NAME[i] == 'KEY_RESET') {
      KeyConfigData2[KEY_NAME[i]] = 'r'
    } else if (KEY_NAME[i] == 'KEY_DEBUG') {
      KeyConfigData2[KEY_NAME[i]] = 'p'
    }
  }
  setKeyConfig(KeyConfigData2)
  for (let i = 0; i < OPTION_NAME.length; i++) {
    if (OPTION_NAME[i] == 'ControllerAlign') {
      if (Config[CONFIG_NAME[i]] == 'right') {
        MP.OptionParts[OPTION_NAME[i] + '_1']._element.checked = true
      } else {
        MP.OptionParts[OPTION_NAME[i] + '_0']._element.checked = true
      }
    } else if (OPTION_NAME[i] == 'Dungeon') {
      if (Config[CONFIG_NAME[i]] == 'graphic') {
        MP.OptionParts[OPTION_NAME[i] + '_0']._element.checked = true
      } else {
        MP.OptionParts[OPTION_NAME[i] + '_1']._element.checked = true
      }
    } else {
      if (Config[CONFIG_NAME[i]]) {
        MP.OptionParts[OPTION_NAME[i] + '_0']._element.checked = true
      } else {
        MP.OptionParts[OPTION_NAME[i] + '_1']._element.checked = true
      }
    }
  }
  checkRadioButton()
  MP.setAlignControlButton(Config['ControllerAlign'])
  Config['TextMemory'] = []
  if (line > -1) {
    for (let i = line + 1; i < textAry.length; i++) {
      if (textAry[i] == '') {
        continue
      }
      Config['TextMemory'].push(textAry[i])
    }
  }
}
function configSave () {
  let configStr = configGetStr(Config, KeyConfigData2)
  configStr += '\n'
  if (Config['TextMemory'].length > 0) {
    configStr += 'TextMemory = \n'
    for (let i = 0; i < Config['TextMemory'].length; i++) {
      configStr += Config['TextMemory'][i] + '\n'
    }
  }
  if (configStr != '') {
    localStorage.setItem(SaveName + 'Config', configStr)
  }
}
function controlFlag (str, repaint) {
  if (str == undefined || str == null) {
    return
  }
  if (repaint == undefined || repaint == null) {
    repaint = true
  }
  str = str.replace(/\s/g, '')
  if (str == '') {
    return
  }
  let wallFlag = false
  let strAry = str.split('<>')
  for (let i = 0; i < strAry.length; i++) {
    let strAry2 = strAry[i].split(',')
    if (strAry2.length < 2) {
      continue
    }
    if (!strAry2[1].match(/^[0-2]$/)) {
      continue
    }
    let control = Number(strAry2[1])
    if (control < 0 || control > 2) {
      continue
    }
    let mode = ''
    if (strAry2[0].match(/^([0-9]+(-[0-9]+)?|f\[[0-9]+(-[0-9]+)?\])$/)) {
      mode = 'flag'
    } else if (strAry2[0].match(/^s\[[0-9]+(-[0-9]+)?\]$/)) {
      mode = 'sp'
    } else if (
      strAry2[0].match(
        /^w\[[0-9]+(-[0-9]+)?\]\[[0-9]+(-[0-9]+)?\]\[[0-9]+(-[0-9]+)?\]$/
      )
    ) {
      mode = 'wall'
    } else if (
      strAry2[0].match(
        /^m\[[0-9]+(-[0-9]+)?\]\[[0-9]+(-[0-9]+)?\]\[[0-9]+(-[0-9]+)?\]\[[0-9]+(-[0-9]+)?\]$/
      )
    ) {
      mode = 'map'
    } else if (
      strAry2[0].match(
        /^h\[[0-9]+(-[0-9]+)?\]\[[0-9]+(-[0-9]+)?\]\[[0-9]+(-[0-9]+)?\]$/
      )
    ) {
      mode = 'hd'
    } else if (
      strAry2[0].match(
        /^l\[[0-9]+(-[0-9]+)?\]\[[0-9]+(-[0-9]+)?\]\[[0-9]+(-[0-9]+)?\]$/
      )
    ) {
      mode = 'ld'
    } else {
      continue
    }
    let strAry3 = strAry2[0].split('][')
    for (let j = 0; j < strAry3.length; j++) {
      strAry3[j] = strAry3[j].replace(/[fmswhl]\[/g, '')
      strAry3[j] = strAry3[j].replace(/\]/g, '')
    }
    let numAry = []
    for (let j = 0; j < strAry3.length; j++) {
      numAry[j] = []
      if (strAry3[j].indexOf('-') > -1) {
        let strAry4 = strAry3[j].split('-')
        let num1 = Number(strAry4[0]),
          num2 = Number(strAry4[1])
        if (num1 > num2) {
          numAry[j].push(num2)
          numAry[j].push(num1)
        } else {
          numAry[j].push(num1)
          numAry[j].push(num2)
        }
      } else {
        let num = Number(strAry3[j])
        numAry[j].push(num)
        numAry[j].push(num)
      }
    }
    let continueFlag = false
    for (let j = 0; j < numAry.length; j++) {
      for (let k = 0; k < 2; k++) {
        if (mode == 'flag') {
          if (numAry[j][k] > 9999) {
            continueFlag = true
            break
          }
        } else if (mode == 'sp') {
          if (numAry[j][k] >= PlayData['GameFlagS'].length) {
            continueFlag = true
            break
          }
        } else if (mode.match(/^(wall|hd|ld)$/)) {
          if (j == 0) {
            if (numAry[j][k] >= 10) {
              continueFlag = true
              break
            }
          } else if (j == 1) {
            if (numAry[j][k] >= 16) {
              continueFlag = true
              break
            }
          } else if (j == 2) {
            if (numAry[j][k] >= 512) {
              continueFlag = true
              break
            }
          }
        } else if (mode == 'map') {
          if (j == 0) {
            if (numAry[j][k] >= 10) {
              continueFlag = true
              break
            }
          } else if (j == 1) {
            if (numAry[j][k] >= 16) {
              continueFlag = true
              break
            }
          } else if (j == 2) {
            if (numAry[j][k] >= 20) {
              continueFlag = true
              break
            }
          } else if (j == 3) {
            if (numAry[j][k] >= 20) {
              continueFlag = true
              break
            }
          }
        }
      }
      if (continueFlag) {
        break
      }
    }
    if (continueFlag) {
      continue
    }
    if (mode == 'flag') {
      for (let j = numAry[0][0]; j < numAry[0][1] + 1; j++) {
        let flag
        if (control == 0) {
          flag = false
        } else if (control == 1) {
          flag = true
        } else if (PlayData['GameFlag'][j]) {
          flag = false
        } else {
          flag = true
        }
        PlayData['GameFlag'][j] = flag
      }
    } else if (mode == 'sp') {
      for (let j = numAry[0][0]; j < numAry[0][1] + 1; j++) {
        let flag
        if (control == 0) {
          flag = false
        } else if (control == 1) {
          flag = true
        } else if (PlayData['GameFlagS'][j]) {
          flag = false
        } else {
          flag = true
        }
        PlayData['GameFlagS'][j] = flag
      }
    } else if (mode.match(/^(wall|hd|ld)$/)) {
      if (mode.match(/^(wall|hd)$/) && !wallFlag) {
        wallFlag = true
      }
      let pdStr = ''
      if (mode == 'wall') {
        pdStr = 'WallFlag'
      } else if (mode == 'hd') {
        pdStr = 'SecretDoor'
      } else if (mode == 'ld') {
        pdStr = 'LockedDoor'
      }
      for (let j = numAry[0][0]; j < numAry[0][1] + 1; j++) {
        for (let k = numAry[1][0]; k < numAry[1][1] + 1; k++) {
          for (let l = numAry[2][0]; l < numAry[2][1] + 1; l++) {
            let flag
            if (control == 0) {
              flag = false
            } else if (control == 1) {
              flag = true
            } else if (PlayData[pdStr][j][k][l]) {
              flag = false
            } else {
              flag = true
            }
            PlayData[pdStr][j][k][l] = flag
          }
        }
      }
    } else if (mode == 'map') {
      for (let j = numAry[0][0]; j < numAry[0][1] + 1; j++) {
        for (let k = numAry[1][0]; k < numAry[1][1] + 1; k++) {
          for (let l = numAry[2][0]; l < numAry[2][1] + 1; l++) {
            for (let m = numAry[3][0]; m < numAry[3][1] + 1; m++) {
              let flag
              if (control == 0) {
                flag = false
              } else if (control == 1) {
                flag = true
              } else if (PlayData['MapFlag'][j][k][l][m]) {
                flag = false
              } else {
                flag = true
              }
              PlayData['MapFlag'][j][k][l][m] = flag
            }
          }
        }
      }
    }
  }
  if (wallFlag && repaint) {
    if (GameState.match(/^move/)) {
      while (MP.Sprite3D.childNodes.length > 0) {
        MP.Sprite3D.removeChild(MP.Sprite3D.childNodes[0])
      }
      MP.MainSurface.clear()
      MP.setDungeonView()
      MP.paintDungeon(MP.DungeonMode)
    }
  }
}
function debugCommand (command) {
  command = MP.hanKana2zenKana(command)
  command = replaceBrackets('en', command)
  let regAry = []
  while (command.match(/\[(.*?)\]/)) {
    regAry.push(RegExp.$1)
    let reg = new RegExp('\\[' + MP.escapeProcessing(RegExp.$1) + '\\]')
    command = command.replace(reg, '<BR>')
  }
  command = command.replace(/  +/g, ' ')
  command = command.replace(/ /g, '<br>')
  for (let i = 0; i < regAry.length; i++) {
    command = command.replace(/<BR>/, '[' + regAry[i] + ']')
  }
  let commandAry = command.split('<br>')
  for (let i = 1; i < 3; i++) {
    if (commandAry[i] == undefined) {
      commandAry[i] = ''
    }
  }
  let ptNum = PlayData['ActiveParty']
  if (ptNum > -1) {
    if (PARTY[ptNum].PartyMember[0] < 0) {
      ptNum = -1
    }
  }
  if (commandAry[0] == 'test') {
  } else if (commandAry[0] == 'view') {
    let str = '[View: '
    if (PlayData['DebugView']) {
      PlayData['DebugView'] = false
      str += 'OFF]'
    } else {
      PlayData['DebugView'] = true
      str += 'ON]'
    }
    console.log(str)
  } else if (commandAry[0].match(/^(cal|calPc|calMon)$/)) {
    let formula = ''
    for (let i = 1; i < commandAry.length; i++) {
      formula += ' ' + commandAry[i]
    }
    if (ptNum > -1) {
      let pcNum = PARTY[ptNum].PartyMember[0]
      formula = replaceFormula(formula, [
        ['pc', pcNum],
        ['monster', 0]
      ])
    } else {
      formula = replaceFormula(formula)
    }
    console.log(strCalculation(formula))
  } else if (commandAry[0] == 'musicClear') {
    for (let i = 0; i < DUNGEON.DUNGEON_MAX; i++) {
      let floorMax = DUNGEON.FloorMinMax[i].length
      for (let j = 0; j < floorMax; j++) {
        PlayData['DungeonNewMusic'][i][j] = ''
      }
    }
    for (let i = 0; i < PARTY.length; i++) {
      PARTY[i].DungeonMusic = ''
    }
    if (GameState.match(/^move/)) {
      musicPlay(DUNGEON.getDungeonMusic())
    }
  } else if (commandAry[0] == 'map') {
    if (commandAry[1].match(/^(on|off)$/)) {
      for (let i = 0; i < 10; i++) {
        for (let j = 0; j < 16; j++) {
          for (let k = 0; k < 20; k++) {
            for (let l = 0; l < 20; l++) {
              if (commandAry[1] == 'on') {
                PlayData['MapFlag'][i][j][k][l] = true
              } else {
                PlayData['MapFlag'][i][j][k][l] = false
              }
            }
          }
        }
      }
    }
  } else if (commandAry[0] == 'flagControl') {
    controlFlag(commandAry[1])
  } else if (commandAry[0].match(/^flagS?$/)) {
    let len
    if (commandAry[0] == 'flag') {
      len = 10000
    } else {
      len = PlayData['GameFlagS'].length
    }
    if (commandAry[1].match(/^[0-9]+$/)) {
      let num = Number(commandAry[1])
      if (num < len) {
        let str
        if (commandAry[0] == 'flag') {
          str = 'Flag['
        } else {
          str = 'FlagS['
        }
        str += String(num) + ']: '
        if (commandAry[0] == 'flag') {
          str += parseStrToBoolean(PlayData['GameFlag'])
        } else {
          str += parseStrToBoolean(PlayData['GameFlagS'])
        }
        console.log(str)
      }
    } else {
      let str = 'Flag whose value is true: '
      let count = 0
      for (let i = 0; i < len; i++) {
        if (commandAry[0] == 'flag') {
          if (PlayData['GameFlag'][i]) {
            if (count > 0) {
              str += ','
            }
            str += String(i)
            count++
          }
        } else {
          if (PlayData['GameFlagS'][i]) {
            if (count > 0) {
              str += ','
            }
            str += String(i)
            count++
          }
        }
      }
      if (count == 0) {
        str += 'none'
      }
      console.log(str)
    }
  } else if (commandAry[0].match(/^(monster|item)Flag$/)) {
    let len
    if (commandAry[0] == 'monsterFlag') {
      len = MONSTER_DATA.length
    } else {
      len = ITEM.length
    }
    if (commandAry[1].match(/^[0-9]+$/) && commandAry[2].match(/^[012]$/)) {
      let num1 = Number(commandAry[1])
      if (num1 < len) {
        let num2 = Number(commandAry[2])
        let flag
        if (num2 == 0) {
          flag = false
        } else if (num2 == 1) {
          flag = true
        } else {
          if (commandAry[0] == 'monsterFlag') {
            if (PlayData['MonsterFlag'][num1]) {
              flag = false
            } else {
              flag = true
            }
          } else {
            if (PlayData['ItemFlag'][num1]) {
              flag = false
            } else {
              flag = true
            }
          }
        }
        if (commandAry[0] == 'monsterFlag') {
          PlayData['MonsterFlag'][num1] = flag
        } else {
          PlayData['ItemFlag'][num1] = flag
        }
      }
    } else if (commandAry[1] == 'all' && commandAry[2].match(/^[012]$/)) {
      let num = Number(commandAry[2])
      for (let i = 0; i < len; i++) {
        let flag
        if (num == 0) {
          flag = false
        } else if (num == 1) {
          flag = true
        } else {
          if (commandAry[0] == 'monsterFlag') {
            if (PlayData['MonsterFlag'][i]) {
              flag = false
            } else {
              flag = true
            }
          } else {
            if (PlayData['ItemFlag'][i]) {
              flag = false
            } else {
              flag = true
            }
          }
        }
        if (commandAry[0] == 'monsterFlag') {
          PlayData['MonsterFlag'][i] = flag
        } else {
          PlayData['ItemFlag'][i] = flag
        }
      }
    }
  } else if (
    commandAry[0].match(/^(item(Flag)?|monster(Flag)?|race|class)List$/)
  ) {
    let numAry, resultStr
    if (commandAry[0].indexOf('item') > -1) {
      numAry = numScope(commandAry[1], ITEM.length)
      if (commandAry[0] == 'itemList') {
        resultStr = '[Item List]'
      } else {
        resultStr = '[ItemFlag List]'
      }
    } else if (commandAry[0].indexOf('monster') > -1) {
      numAry = numScope(commandAry[1], MONSTER_DATA.length)
      if (commandAry[0] == 'monsterList') {
        resultStr = '[Monster List]'
      } else {
        resultStr = '[MonsterFlag List]'
      }
    } else if (commandAry[0].indexOf('race') > -1) {
      numAry = numScope(commandAry[1], GameData['RACE'].length)
      resultStr = '[Race List]'
    } else if (commandAry[0].indexOf('class') > -1) {
      numAry = numScope(commandAry[1], GameData['PC_CLASS'].length)
      resultStr = '[Class List]'
    }
    for (let i = numAry[0]; i < numAry[1]; i++) {
      resultStr += '\n'
      if (commandAry[0].match(/item|monster/)) {
        resultStr += MP.numberDigitMatch(i, 4)
      } else {
        resultStr += MP.numberDigitMatch(i, 2)
      }
      resultStr += ': '
      if (commandAry[0].indexOf('item') > -1) {
        if (commandAry[0] == 'itemList' || PlayData['ItemFlag'][i]) {
          resultStr += ITEM[i].NAME[1] + ' (' + ITEM[i].NAME[0] + ')'
        }
      } else if (commandAry[0].indexOf('monster') > -1) {
        if (commandAry[0] == 'monsterList' || PlayData['MonsterFlag'][i]) {
          resultStr +=
            MONSTER_DATA[i].NAME[1] + ' (' + MONSTER_DATA[i].NAME[0] + ')'
        }
      } else if (commandAry[0].indexOf('race') > -1) {
        resultStr += GameData['RACE'][i] + ' (' + GameData['RACE_ABBR'][i] + ')'
      } else if (commandAry[0].indexOf('class') > -1) {
        resultStr +=
          GameData['PC_CLASS'][i] + ' (' + GameData['PC_CLASS_ABBR'][i] + ')'
      }
    }
    console.log(resultStr)
  } else if (commandAry[0] == 'stock') {
    let numAry = numScope(commandAry[2], ITEM.length)
    for (let i = numAry[0]; i < numAry[1]; i++) {
      if (commandAry[1].match(/^(initialize|init|reset)$/)) {
        if (ITEM[i].STOCK_OK) {
          ITEM[i].setStock()
        }
      } else if (commandAry[1] == 'full') {
        if (ITEM[i].STOCK_OK) {
          ITEM[i].setStock(120)
        }
      } else if (commandAry[1].match(/^[0-9]+$/)) {
        if (ITEM[i].STOCK_OK) {
          let num = Number(commandAry[1])
          if (num < 0) {
            num = 0
          } else if (num > 99) {
            num = 99
          }
          ITEM[i].setStock(num)
        }
      }
    }
  } else if (commandAry[0] == 'collect') {
    for (let i = 0; i < PARTY.length; i++) {
      if (i == ptNum) {
        continue
      } else if (PARTY[i].DungeonNumber < 0) {
        continue
      }
      PARTY[i].dissolution(true)
    }
  } else if (commandAry[0] == 'healAll') {
    for (let i = 0; i < PC.length; i++) {
      healPc(i)
      PC[i].check()
    }
  } else if (commandAry[0] == 'expGained') {
    if (commandAry[1].match(/^[0-9]+(\.[0-9]+)?$/)) {
      GenericVariable['ExpGained'] = Number(commandAry[1])
    }
    let str
    if (Number.isInteger(GenericVariable['ExpGained'])) {
      str = GenericVariable['ExpGained'].toFixed(1)
    } else {
      str = String(GenericVariable['ExpGained'])
    }
    console.log('ExpGained ' + str)
  } else if (commandAry[0] == 'dropGained') {
    if (commandAry[1].match(/^[0-9]+(\.[0-9]+)?$/)) {
      GenericVariable['DropGained'] = Number(commandAry[1])
    }
    let str
    if (Number.isInteger(GenericVariable['DropGained'])) {
      str = GenericVariable['DropGained'].toFixed(1)
    } else {
      str = String(GenericVariable['DropGained'])
    }
    console.log('DropGained ' + str)
  } else if (ptNum > -1) {
    let pt = PARTY[ptNum]
    let ptMemberNum = pt.getMemberNum()
    if (commandAry[0] == 'item') {
      if (commandAry[1].match(/^[0-9]+$/)) {
        let num = Number(commandAry[1])
        if (num < ITEM.length) {
          let decided = true
          if (commandAry[2] == '0') {
            decided = false
          }
          pt.putItem(num, decided)
          if (decided) {
            PlayData['ItemFlag'][num] = true
          }
        }
      }
      pt.check()
    } else if (commandAry[0] == 'spellClear') {
      pt.spellEffectClear(false)
    } else {
      let pcStart = 0,
        pcEnd = ptMemberNum
      if (
        commandAry[0].match(/^(heal|dispell|abi(|[0-1])View)$/) &&
        commandAry[1].match(/^[0-5]$/)
      ) {
        pcStart = Number(commandAry[1])
        pcEnd = pcStart + 1
      } else if (commandAry[2].match(/^[0-5]$/)) {
        pcStart = Number(commandAry[2])
        pcEnd = pcStart + 1
      }
      if (commandAry[0] == 'heal') {
        for (let i = pcStart; i < pcEnd; i++) {
          if (commandAry[1].match(/^(hp|mp|state)$/)) {
            healPc(pt.PartyMember[i], commandAry[1])
          } else {
            healPc(pt.PartyMember[i])
          }
        }
      } else if (commandAry[0].match(/^abi(|[0-1])View$/)) {
        for (let i = pcStart; i < pcEnd; i++) {
          let pc = PC[pt.PartyMember[i]]
          let str = '[' + pc.Name[0] + '] '
          if (commandAry[0] == 'abi0View') {
            str += 'abi0'
          } else if (commandAry[0] == 'abi1View') {
            str += 'abi1'
          } else {
            str += 'abi'
          }
          console.log(str)
          str = ''
          for (let j = 0; j < GameData['ABILITY'].length; j++) {
            if (j != 0 && j % 9 == 0) {
              str += '\n'
            }
            str += GameData['ABILITY_ABBR'][j] + '['
            if (commandAry[0] == 'abi0View') {
              str += pc.Ability0[j]
            } else if (commandAry[0] == 'abi1View') {
              str += pc.Ability1[j]
            } else {
              str += pc.Ability[j]
            }
            str += '] '
          }
          console.log(str)
        }
      } else if (commandAry[0] == 'sleep') {
        if (!GameState.match(/^battle/)) {
          return
        }
        if (!commandAry[1].match(/^-?[0-9]+$/)) {
          return
        }
        let num = Number(commandAry[1])
        for (let i = pcStart; i < pcEnd; i++) {
          let pc = PC[pt.PartyMember[i]]
          if (num == 0) {
            pc.Asleep = 0
          } else {
            pc.Asleep += num
          }
        }
      } else if (commandAry[0] == 'silence') {
        if (!GameState.match(/^battle/)) {
          return
        }
        if (!commandAry[1].match(/^-?[0-9]+$/)) {
          return
        }
        let num = Number(commandAry[1])
        for (let i = pcStart; i < pcEnd; i++) {
          let pc = PC[pt.PartyMember[i]]
          if (num == 0) {
            pc.Silence = 0
          } else {
            pc.Silence += num
          }
        }
      } else if (commandAry[0] == 'restraint') {
        if (!GameState.match(/^battle/)) {
          return
        }
        if (!commandAry[1].match(/^-?[0-9]+$/)) {
          return
        }
        let num = Number(commandAry[1])
        for (let i = pcStart; i < pcEnd; i++) {
          let pc = PC[pt.PartyMember[i]]
          if (num == 0) {
            pc.NoBreath = 0
          } else {
            pc.NoBreath += num
            if (pc.NoBreath < 0) {
              pc.NoBreath = 0
            }
          }
        }
      } else if (commandAry[0] == 'hp') {
        if (!commandAry[1].match(/^-?[0-9]+$/)) {
          return
        }
        let num = Number(commandAry[1])
        for (let i = pcStart; i < pcEnd; i++) {
          PC[pt.PartyMember[i]].controlHp(num, true)
        }
      } else if (commandAry[0] == 'hpMax') {
        if (!commandAry[1].match(/^-?[0-9]+$/)) {
          return
        }
        let num = Number(commandAry[1])
        for (let i = pcStart; i < pcEnd; i++) {
          PC[pt.PartyMember[i]].HpMax0 += num
        }
      } else if (commandAry[0].match(/^(mp|mpMax)$/)) {
        if (!commandAry[1].match(/^([0-9]+,)?-?[0-9]+$/)) {
          return
        }
        let num
        let kindStart = 0,
          kindEnd = GameData['SPELL_KIND']
        let lvStart = 0,
          lvEnd = GameData['SPELL_LVMAX']
        if (commandAry[1].indexOf(',') > -1) {
          let spellAry = commandAry[1].split(',')
          kindStart = Number(spellAry[0].charAt(0))
          if (kindStart >= kindEnd) {
            kindStart = kindEnd - 1
          }
          kindEnd = kindStart + 1
          if (spellAry[0].length > 1) {
            lvStart = Number(spellAry[0].charAt(1))
            if (lvStart >= lvEnd) {
              lvStart = lvEnd - 1
            }
            lvEnd = lvStart + 1
          }
          num = Number(spellAry[1])
        } else {
          num = Number(commandAry[1])
        }
        for (let i = pcStart; i < pcEnd; i++) {
          let pc = PC[pt.PartyMember[i]]
          for (let j = kindStart; j < kindEnd; j++) {
            for (let k = lvStart; k < lvEnd; k++) {
              if (commandAry[0] == 'mp') {
                pc.Mp[j][k] += num
              } else {
                pc.MpMax[j][k] += num
              }
            }
          }
        }
      } else if (commandAry[0] == 'spell') {
        if (!commandAry[1].match(/^([0-9]+,)?[01]$/)) {
          return
        }
        let spellFlag = false
        let kindStart = 0,
          kindEnd = GameData['SPELL_KIND']
        let lvStart = 0,
          lvEnd = GameData['SPELL_LVMAX']
        let spellStart = 0,
          spellEnd = 6
        if (commandAry[1].indexOf(',') > -1) {
          let spellAry = commandAry[1].split(',')
          kindStart = Number(spellAry[0].charAt(0))
          if (kindStart >= kindEnd) {
            kindStart = kindEnd - 1
          }
          kindEnd = kindStart + 1
          if (spellAry[0].length > 1) {
            lvStart = Number(spellAry[0].charAt(1))
            if (lvStart >= lvEnd) {
              lvStart = lvEnd - 1
            }
            lvEnd = lvStart + 1
          }
          if (spellAry[0].length > 2) {
            spellStart = Number(spellAry[0].charAt(2))
            if (spellStart >= spellEnd) {
              spellStart = spellEnd - 1
            }
            spellEnd = spellStart + 1
          }
          if (spellAry[1] == '1') {
            spellFlag = true
          }
        } else if (commandAry[1] == '1') {
          spellFlag = true
        }
        for (let i = pcStart; i < pcEnd; i++) {
          for (let j = kindStart; j < kindEnd; j++) {
            for (let k = lvStart; k < lvEnd; k++) {
              for (let l = spellStart; l < spellEnd; l++) {
                if (GameData['SPELL'][j][k][l] != '') {
                  PC[pt.PartyMember[i]].Spell[j][k][l] = spellFlag
                }
              }
            }
          }
        }
      } else if (commandAry[0] == 'lv') {
        if (!commandAry[1].match(/^-?[0-9]+$/)) {
          return
        }
        let num = Number(commandAry[1])
        for (let i = pcStart; i < pcEnd; i++) {
          let pc = PC[pt.PartyMember[i]]
          let preLv = pc.Level
          let lv = pc.Level + num
          if (lv > 99999) {
            lv = 99999
          } else if (lv < 1) {
            lv = 1
          }
          if (num > 0) {
            pc.levelUp(lv)
          } else if (num < 0) {
            pc.Level = lv
            pc.drainCheck(preLv)
          }
          if (pc.State > 3) {
            pc.Hp = 0
          }
        }
      } else if (commandAry[0] == 'gold') {
        if (!commandAry[1].match(/^-?[0-9]+$/)) {
          return
        }
        let num = Number(commandAry[1])
        for (let i = pcStart; i < pcEnd; i++) {
          PC[pt.PartyMember[i]].Gold += num
        }
      } else if (commandAry[0] == 'exp') {
        if (!commandAry[1].match(/^[0-9]+$/)) {
          return
        }
        let num = Number(commandAry[1])
        for (let i = pcStart; i < pcEnd; i++) {
          PC[pt.PartyMember[i]].Exp += num
        }
      } else if (commandAry[0] == 'age') {
        if (!commandAry[1].match(/^-?[0-9]+$/)) {
          return
        }
        let num = Number(commandAry[1])
        for (let i = pcStart; i < pcEnd; i++) {
          PC[pt.PartyMember[i]].Age += num
        }
      } else if (commandAry[0] == 'rip') {
        if (!commandAry[1].match(/^-?[0-9]+$/)) {
          return
        }
        let num = Number(commandAry[1])
        for (let i = pcStart; i < pcEnd; i++) {
          PC[pt.PartyMember[i]].Rip += num
        }
      } else if (commandAry[0] == 'marks') {
        if (!commandAry[1].match(/^-?[0-9]+$/)) {
          return
        }
        let num = Number(commandAry[1])
        for (let i = pcStart; i < pcEnd; i++) {
          PC[pt.PartyMember[i]].Marks += num
        }
      } else if (commandAry[0] == 'title') {
        if (!commandAry[1].match(/\[.*\]/)) {
          return
        }
        let str = commandAry[1].replace(/^.*\[(.*)\].*$/, '$1')
        str = str.replace(/,|<>/g, '')
        str = str.replace(/ +$/, '')
        str = MP.strCut(str, 6)
        for (let i = pcStart; i < pcEnd; i++) {
          PC[pt.PartyMember[i]].Title = str
        }
      } else if (commandAry[0] == 'abi') {
        if (commandAry[1].match(/^[0-9]+,-?[0-9]+$/)) {
          let strAry = commandAry[1].split(',')
          let num1 = Number(strAry[0]),
            num2 = Number(strAry[1])
          if (num1 >= GameData['ABILITY'].length) {
            num1 = 0
          }
          for (let i = pcStart; i < pcEnd; i++) {
            PC[pt.PartyMember[i]].Ability0[num1] += num2
          }
        } else if (commandAry[1].match(/^-?[0-9]+$/)) {
          let num = Number(commandAry[1])
          for (let i = pcStart; i < pcEnd; i++) {
            let pc = PC[pt.PartyMember[i]]
            for (let j = 0; j < GameData['ABILITY'].length; j++) {
              PC[pt.PartyMember[i]].Ability0[j] += num
            }
          }
        } else if (commandAry[1].match(/^(max|min)$/)) {
          for (let i = pcStart; i < pcEnd; i++) {
            let pc = PC[pt.PartyMember[i]]
            for (let j = 0; j < GameData['ABILITY'].length; j++) {
              if (commandAry[1] == 'max') {
                pc.Ability0[j] = pc.getAbilityMinMax('max', j)
              } else {
                pc.Ability0[j] = pc.getAbilityMinMax('min', j)
              }
            }
          }
        }
      } else if (commandAry[0] == 'race') {
        if (!commandAry[1].match(/^[0-9]+$/)) {
          return
        }
        let num = Number(commandAry[1])
        if (num >= GameData['RACE'].length) {
          return
        }
        for (let i = pcStart; i < pcEnd; i++) {
          let pc = PC[pt.PartyMember[i]]
          pc.Race = num
          pc.NextUpExp = -1
        }
      } else if (commandAry[0] == 'class') {
        if (!commandAry[1].match(/^[0-9]+$/)) {
          return
        }
        let num = Number(commandAry[1])
        if (num >= GameData['PC_CLASS'].length) {
          return
        }
        for (let i = pcStart; i < pcEnd; i++) {
          let pc = PC[pt.PartyMember[i]]
          pc.PcClass = num
          pc.NextUpExp = -1
        }
      } else if (commandAry[0] == 'sex') {
        if (!commandAry[1].match(/^[MFBNmfbn0123]$/)) {
          return
        }
        commandAry[1] = commandAry[1].replace(/[Mm]/, '0')
        commandAry[1] = commandAry[1].replace(/[Ff]/, '1')
        commandAry[1] = commandAry[1].replace(/[Bb]/, '2')
        commandAry[1] = commandAry[1].replace(/[Nn]/, '3')
        let sex = Number(commandAry[1])
        for (let i = pcStart; i < pcEnd; i++) {
          let pc = PC[pt.PartyMember[i]]
          let race = pc.Race
          if (GameData['RACE_SEX_INSIDE'][race] > -1) {
            continue
          }
          if (GameData['RACE_SEX'][race].indexOf(String(sex)) > -1) {
            pc.Sex = sex
          }
        }
      } else if (commandAry[0] == 'ali') {
        if (!commandAry[1].match(/^[GNEgne012]$/)) {
          return
        }
        for (let i = pcStart; i < pcEnd; i++) {
          let pc = PC[pt.PartyMember[i]]
          if (commandAry[1].match(/^[Gg0]$/)) {
            pc.Alignment = 0
          } else if (commandAry[1].match(/^[Nn1]$/)) {
            pc.Alignment = 1
          } else {
            pc.Alignment = 2
          }
        }
      } else if (commandAry[0] == 'state') {
        if (!commandAry[1].match(/^[0-6]$/)) {
          return
        }
        let num = Number(commandAry[1])
        for (let i = pcStart; i < pcEnd; i++) {
          let pc = PC[pt.PartyMember[i]]
          pc.State = num
          if (num > 3) {
            pc.Hp = 0
            pc.Poison = 0
          } else {
            if (pc.HpMax0 < 1) {
              pc.HpMax0 = 1
            }
            if (pc.Hp < 1) {
              pc.Hp = 1
            }
          }
        }
      } else if (commandAry[0] == 'poison') {
        if (!commandAry[1].match(/^-?[0-9]+$/)) {
          return
        }
        let num = Number(commandAry[1])
        for (let i = pcStart; i < pcEnd; i++) {
          let pc = PC[pt.PartyMember[i]]
          if (pc.State < 4) {
            if (num == 0) {
              pc.Poison = 0
            } else {
              pc.Poison += num
            }
          }
        }
      } else if (commandAry[0] == 'dispel') {
        for (let i = pcStart; i < pcEnd; i++) {
          let pc = PC[pt.PartyMember[i]]
          for (let j = 0; j < pc.ItemMaxNum; j++) {
            if (pc.Item[j] < 0) {
              break
            }
            if (pc.Equip[j] == 2) {
              pc.Equip[j] = 0
            }
          }
        }
      }
      pt.check()
    }
  }
  if (PlayData['StatusNow'] != '') {
    MP.viewStatus(PlayData['StatusNow'], PlayData['StatusNum'])
  }
  if (PlayData['PartyStatusNow']) {
    MP.viewPartyStatus(true, PlayData['PartyStatusNum'])
  }
  function numScope (data, max) {
    let a, b
    if (data.match(/^[0-9]+-[0-9]+$/)) {
      let str = data.replace(/([0-9]+)-[0-9]+/, '$1')
      a = Number(str)
      if (a < 0) {
        a = 0
      } else if (a >= max) {
        a = max - 1
      }
      str = data.replace(/[0-9]+-([0-9]+)/, '$1')
      b = Number(str)
      if (b < 0) {
        b = 0
      } else if (b >= max) {
        b = max - 1
      }
      b++
    } else if (data.match(/^[0-9]+-$/)) {
      str = data.replace(/([0-9]+)-/, '$1')
      a = Number(str)
      if (a < 0) {
        a = 0
      } else if (a >= max) {
        a = max - 1
      }
      b = max
    } else if (data.match(/^-[0-9]+$/)) {
      a = 0
      str = data.replace(/-([0-9]+)/, '$1')
      b = Number(str)
      if (b < 0) {
        b = 0
      } else if (b >= max) {
        b = max - 1
      }
      b++
    } else if (data.match(/^[0-9]+$/)) {
      a = Number(data)
      if (a < 0) {
        a = 0
      } else if (a >= max) {
        a = max - 1
      }
      b = a + 1
    } else {
      a = 0
      b = max
    }
    let result = [a, b]
    return result
  }
  function healPc (pcNum, mode) {
    if (PC[pcNum].Name[0].match(/^(| )$/)) {
      return
    }
    if (mode == undefined || mode == null) {
      mode = 'full'
    }
    if (mode.match(/^(state|full)$/)) {
      if (PC[pcNum].State > 3) {
        PC[pcNum].controlHp(1)
      }
      PC[pcNum].State = 0
      PC[pcNum].Poison = 0
      PC[pcNum].SealSpell = false
      PC[pcNum].SealSpellInt = 0
      PC[pcNum].Asleep = 0
      PC[pcNum].Silence = 0
      PC[pcNum].NoBreath = 0
    }
    if (mode.match(/^(mp|full)$/)) {
      for (let i = 0; i < GameData['SPELL_KIND']; i++) {
        for (j = 0; j < GameData['SPELL_LVMAX']; j++) {
          PC[pcNum].Mp[i][j] = PC[pcNum].MpMax[i][j]
        }
      }
    }
    if (mode.match(/^(hp|full)$/)) {
      PC[pcNum].controlHp(99999)
    }
  }
}
function decomposeSpell (spell, pcNum, branch) {
  if (pcNum == undefined || pcNum == null) {
    pcNum = -1
  }
  if (branch == undefined || branch == null) {
    branch = -1
  }
  let result = {}
  let pc = null
  if (pcNum > -1) {
    pc = PC[pcNum]
  }
  if (spell.indexOf('</>') > -1) {
    let strAry = spell.split('</>')
    result['situation'] = Number(strAry[0])
    spell = strAry[1]
  } else {
    result['situation'] = -1
  }
  if (spell.indexOf('<notCancel>') > -1) {
    let strAry = spell.split('<notCancel>')
    result['notCancel'] = true
    spell = strAry[1]
  } else {
    result['notCancel'] = false
  }
  if (spell.indexOf('<->') > -1) {
    let strAry = spell.split('<->')
    result['levelLimit'] = Number(strAry[0])
    spell = strAry[1]
  } else {
    result['levelLimit'] = 1
  }
  if (spell.indexOf('<+>') > -1) {
    let strAry = spell.split('<+>')
    if (strAry.length == 3) {
      if (pc != null) {
        spell = strAry[pc.Alignment]
      } else {
        if (branch < 0) {
          branch = dice(1, 3) - 1
        }
        spell = strAry[branch]
      }
    } else {
      if (pc != null) {
        let sex = pc.Sex
        if (strAry.length == 2) {
          if (sex > 1) {
            sex = 0
          }
        }
        spell = strAry[sex]
      } else {
        if (branch < 0) {
          branch = dice(1, strAry.length) - 1
        }
        spell = strAry[branch]
      }
    }
  }
  result['branch'] = branch
  let sel = 0
  if (spell.indexOf('<*>') > -1) {
    let strAry = spell.split('<*>')
    if (strAry[0] == 'random') {
      result['selectNum'] = 0
    } else {
      let strAry2 = strAry[0].split(',')
      result['selectNum'] = Number(strAry2[0])
      result['selectText'] = []
      for (let i = 1; i < strAry2.length; i++) {
        result['selectText'].push(strAry2[i])
      }
    }
    result['spellEffect'] = []
    for (let i = 1; i < strAry.length; i++) {
      let spellBase
      if (strAry[i].match(/spell\[[0-9]+\]/)) {
        let num = Number(strAry[i].replace(/spell\[([0-9]+)\]/, '$1'))
        spellBase = GameData['SPELL_BASE'][num]
      } else {
        spellBase = strAry[i]
      }
      result['spellEffect'].push(spellBase.split('<>'))
    }
    result['hamanTarget'] = []
    for (let i = 0; i < result['spellEffect'].length; i++) {
      let hamanSel = 0
      for (let j = 0; j < result['spellEffect'][i].length; j++) {
        if (result['spellEffect'][i][j].indexOf(',') > -1) {
          strAry = result['spellEffect'][i][j].split(',')
        } else {
          strAry = ['0', '0']
        }
        hamanSel = Number(strAry[1])
        if (hamanSel == 1 || hamanSel == 4 || hamanSel == 6) {
          break
        }
      }
      result['hamanTarget'].push(hamanSel)
    }
  } else {
    result['selectNum'] = 0
    result['selectText'] = []
    result['spellEffect'] = []
    let spellBase
    if (spell.match(/spell\[[0-9]+\]/)) {
      let num = Number(spell.replace(/spell\[([0-9]+)\]/, '$1'))
      spellBase = GameData['SPELL_BASE'][num]
    } else {
      spellBase = spell
    }
    result['spellEffect'].push(spellBase.split('<>'))
    for (let i = 0; i < result['spellEffect'][0].length; i++) {
      let strAry
      if (result['spellEffect'][0][i].indexOf(',') > -1) {
        strAry = result['spellEffect'][0][i].split(',')
      } else {
        strAry = ['0', '0']
      }
      sel = Number(strAry[1])
      if (sel == 1 || sel == 4 || sel == 6) {
        break
      }
    }
  }
  result['target'] = sel
  return result
}
function decomposeSpellNum (spellNum) {
  let resultAry = []
  resultAry.push(Math.floor(spellNum / 100))
  spellNum %= 100
  resultAry.push(Math.floor(spellNum / 10))
  spellNum %= 10
  resultAry.push(spellNum)
  return resultAry
}
function deleteLineFeedCode (str) {
  str = str.replace(/\n|\r|<br>|<p>/g, '')
  return str
}
function deletePc (pcNum) {
  if (GameData['FACE_GRAPHIC_STATUS'] || GameData['FACE_GRAPHIC_BATTLE']) {
    let faceStr
    if (PC[pcNum].FaceGraphic.match(/^(| |none)$/)) {
      faceStr = PC[pcNum].Name[0]
    } else {
      faceStr = '<>' + PC[pcNum].FaceGraphic
    }
    readGraphicFile_Face(faceStr)
  }
  if (PC[pcNum].PartyNum > -1) {
    PARTY[PC[pcNum].PartyNum].removeMember(pcNum)
  }
  PC[pcNum].initialize()
  for (let i = 0; i < PlayData['PcMax']; i++) {
    if (PlayData['PcList'][i] == pcNum) {
      PlayData['PcList'].splice(i, 1)
      break
    }
  }
  PlayData['PcList'].push(-1)
  PlayData['PcMax']--
}
function deleteTempVariable () {
  for (let key in TempVariable) {
    delete TempVariable[key]
  }
}
function dice (n, d) {
  ;(n = Math.floor(n)), (d = Math.floor(d))
  if (n < 1 || n == undefined || n == null) {
    n = 0
  }
  if (d < 1 || d == undefined || d == null) {
    d = 1
  }
  let result = 0
  for (let i = 0; i < n; i++) {
    result += Math.floor(Math.random() * d) + 1
  }
  return result
}
function downloadTextFile (fileName, text) {
  let a = document.createElement('a')
  a.href = 'data:text/plain,' + encodeURIComponent(text)
  a.download = fileName
  a.style.display = 'none'
  document.body.appendChild(a)
  a.click()
  document.body.removeChild(a)
}
function dumpItem (ptNum, itemNum) {
  let dungeonNum = -1
  if (ptNum > -1) {
    dungeonNum = PARTY[ptNum].DungeonNumber
  }
  if (PlayData['GarbageItem'].length >= 1000) {
    PlayData['GarbageItem'].splice(0, 1)
  }
  PlayData['GarbageItem'].push(String(dungeonNum) + ',' + String(itemNum))
}
function enableChangeClass (pcClass, pcNum, race, sex, ali, abi) {
  let formula = GameData['CLASS_CONDITION'][pcClass]
  if (pcClass > 0) {
    if (pcNum < 0) {
      formula = enableChangeClassReplace(formula, race, sex, ali, abi)
      formula = replaceFormula(formula, null, true)
    } else {
      formula = replaceFormula(formula, [['pc', pcNum]], true)
    }
    if (strCalculation(formula) == 0) {
      return 0
    }
  }
  if (pcNum > -1) {
    if (PC[pcNum].PcClass == pcClass) {
      return 1
    }
    sex = PC[pcNum].Sex
    ali = PC[pcNum].Alignment
    abi = []
    for (let i = 0; i < GameData['ABILITY'].length; i++) {
      if (i >= 10) {
        break
      }
      abi.push(PC[pcNum].Ability0[i])
    }
  } else if (abi == undefined || abi == null) {
    abi = []
    for (let i = 0; i < GameData['ABILITY'].length; i++) {
      if (i >= 10) {
        break
      }
      abi.push(999)
    }
  } else {
    for (let i = 0; i < GameData['ABILITY'].length; i++) {
      if (i >= 10) {
        break
      }
      if (abi[i] == undefined || abi[i] == null || Number.isNaN(abi[i])) {
        abi[i] = GameData['RACE_ABI'][race][i] + GameData['ABILITY_SEX'][sex][i]
      }
    }
  }
  if (!GameData['CLASS_SEX'][pcClass][sex]) {
    return 1
  }
  if (!GameData['CLASS_ALI'][pcClass][ali]) {
    return 1
  }
  for (let i = 0; i < GameData['ABILITY'].length; i++) {
    if (i >= 10) {
      break
    }
    if (GameData['CLASS_ABI'][pcClass][i] > abi[i]) {
      return 1
    }
  }
  if (pcNum > -1) {
    let itemMaxNum =
      GameData['RACE_ITEM'][PC[pcNum].Race] + GameData['CLASS_ITEM'][pcClass]
    if (itemMaxNum < 1) {
      itemMaxNum = 1
    } else if (itemMaxNum > 99) {
      itemMaxNum = 99
    }
    let num = PC[pcNum].haveItemNum(-1)
    if (num > itemMaxNum) {
      return 1
    }
  }
  return 2
}
function enableChangeClassReplace (formula, race, sex, ali, abi, raceComment) {
  if (raceComment != undefined && raceComment != null) {
    formula = replaceBrackets('en', formula)
  }
  if (formula.indexOf('pc.Race') > -1) {
    let reg = new RegExp('pc\\.Race\\[' + String(race) + '\\]', 'g')
    formula = formula.replace(reg, '1')
    reg = new RegExp('pc\\.Race\\[[0-9]+\\]', 'g')
    formula = formula.replace(reg, '0')
  }
  if (formula.indexOf('pc.Sex') > -1) {
    let reg = new RegExp('pc\\.Sex\\[' + String(sex) + '\\]', 'g')
    formula = formula.replace(reg, '1')
    reg = new RegExp('pc\\.Sex\\[[0-9]+\\]', 'g')
    formula = formula.replace(reg, '0')
  }
  if (formula.indexOf('pc.Alignment') > -1) {
    let reg = new RegExp('pc\\.Alignment\\[' + String(ali) + '\\]', 'g')
    formula = formula.replace(reg, '1')
    reg = new RegExp('pc\\.Alignment\\[[0-9]+\\]', 'g')
    formula = formula.replace(reg, '0')
  }
  if (formula.indexOf('pc.Ali') > -1) {
    let reg = new RegExp('pc\\.Ali\\[' + String(ali) + '\\]', 'g')
    formula = formula.replace(reg, '1')
    reg = new RegExp('pc\\.Ali\\[[0-9]+\\]', 'g')
    formula = formula.replace(reg, '0')
  }
  if (formula.indexOf('pc.abi0') > -1 && abi != undefined && abi != null) {
    let str = 'pc\\.abi0\\[([0-9]+)\\]'
    let reg = new RegExp(str)
    while (formula.match(reg)) {
      let num = Number(RegExp.$1)
      let result = String(abi[num])
      if (result == 'undefined' || result == 'null') {
        result = '0'
      }
      let str2 = 'pc\\.abi0\\[' + String(num) + '\\]'
      let reg2 = new RegExp(str2, 'g')
      formula = formula.replace(reg2, result)
    }
  }
  if (formula.indexOf('pc.abi1') > -1 && abi != undefined && abi != null) {
    let str = 'pc\\.abi1\\[([0-9]+)\\]'
    let reg = new RegExp(str)
    while (formula.match(reg)) {
      let num = Number(RegExp.$1)
      let result = String(abi[num])
      if (result == 'undefined' || result == 'null') {
        result = '0'
      }
      let str2 = 'pc\\.abi1\\[' + String(num) + '\\]'
      let reg2 = new RegExp(str2, 'g')
      formula = formula.replace(reg2, result)
    }
  }
  if (formula.indexOf('pc.abi') > -1 && abi != undefined && abi != null) {
    let str = 'pc\\.abi\\[([0-9]+)\\]'
    let reg = new RegExp(str)
    while (formula.match(reg)) {
      let num = Number(RegExp.$1)
      let result = String(abi[num])
      if (result == 'undefined' || result == 'null') {
        result = '0'
      }
      let str2 = 'pc\\.abi\\[' + String(num) + '\\]'
      let reg2 = new RegExp(str2, 'g')
      formula = formula.replace(reg2, result)
    }
  }
  if (
    formula.indexOf('pc.raceCommentNum') > -1 &&
    raceComment != undefined &&
    raceComment != null
  ) {
    let str = 'pc\\.raceCommentNum\\[([^\\[\\]]+)\\]'
    let reg = new RegExp(str)
    while (formula.match(reg)) {
      let str2 = RegExp.$1
      let str3 = replaceBrackets('de', str2)
      let raceCommentStr = MP.zenkaku2hankaku(str3)
      let text = deleteLineFeedCode(GameData['RACE_COMMENT'][race])
      text = MP.zenkaku2hankaku(text)
      let result = '0'
      if (text.indexOf(raceCommentStr) > -1) {
        result = '1'
      }
      str3 = 'pc\\.raceCommentNum\\[' + MP.escapeProcessing(str2) + '\\]'
      let reg2 = new RegExp(str3, 'g')
      formula = formula.replace(reg2, result)
    }
    formula = replaceBrackets('de', formula)
  }
  return formula
}
function eventChangeRadioButton () {
  let change = ''
  for (let i = 0; i < OPTION_NAME.length; i++) {
    let flag = false
    if (MP.OptionParts[OPTION_NAME[i] + '_0']._element.checked) {
      flag = true
    }
    if (i == 2) {
      if (Config[CONFIG_NAME[i]] == 'left' && !flag) {
        Config[CONFIG_NAME[i]] = 'right'
        change = CONFIG_NAME[i]
        break
      } else if (Config[CONFIG_NAME[i]] == 'right' && flag) {
        Config[CONFIG_NAME[i]] = 'left'
        change = CONFIG_NAME[i]
        break
      }
    } else if (i == 4) {
      if (Config[CONFIG_NAME[i]] == 'graphic' && !flag) {
        Config[CONFIG_NAME[i]] = 'wireFrame'
        change = CONFIG_NAME[i]
        break
      } else if (Config[CONFIG_NAME[i]] == 'wireFrame' && flag) {
        Config[CONFIG_NAME[i]] = 'graphic'
        change = CONFIG_NAME[i]
        break
      }
    } else {
      if (Config[CONFIG_NAME[i]] != flag) {
        Config[CONFIG_NAME[i]] = flag
        change = CONFIG_NAME[i]
        break
      }
    }
  }
  configSave()
  if (change == 'Bgm') {
    if (Config[change]) {
      let nameAry = [],
        srcAry = []
      for (let i = 0; i < GameData['MUSIC_NAME'].length; i++) {
        if (MusicData[GameData['MUSIC_NAME'][i]] == undefined) {
          nameAry.push(GameData['MUSIC_NAME'][i])
          srcAry.push(GameData['MUSIC_SRC'][i])
        }
      }
      if (nameAry.length > 0) {
        GenericVariable['FullKeyInvalid'] = true
        MP.TopSurface.clear()
        MP.setOptionMode('partsClear')
        LoadingFlag = true
        readMusicFile(nameAry, srcAry, readEndAction)
      } else {
        musicPlay(NowMusic)
      }
    } else {
      let nowMusic = NowMusic
      musicStop()
      NowMusic = nowMusic
    }
    checkRadioButton()
  } else if (change == 'Se') {
    if (Config[change]) {
      let nameAry = [],
        srcAry = []
      for (let i = 0; i < GameData['SOUND_NAME'].length; i++) {
        if (SoundData[GameData['SOUND_NAME'][i]] == undefined) {
          nameAry.push(GameData['SOUND_NAME'][i])
          srcAry.push(GameData['SOUND_SRC'][i])
        }
      }
      if (nameAry.length > 0) {
        GenericVariable['FullKeyInvalid'] = true
        MP.TopSurface.clear()
        MP.setOptionMode('partsClear')
        LoadingFlag = true
        readSoundFile(nameAry, srcAry, readEndAction)
      }
    } else {
      seStop()
    }
    checkRadioButton()
  } else if (change == 'ControllerAlign') {
    MP.setAlignControlButton(Config['ControllerAlign'])
    resizeWindow()
  } else if (change == 'Dungeon' || change == 'PerspectiveView') {
    if (change == 'Dungeon') {
      checkRadioButton()
      checkRadioButtonText()
    }
    if (GameState.match(/^move/)) {
      let pt = PARTY[PlayData['ActiveParty']]
      if (
        Config['Dungeon'] == 'graphic' &&
        DUNGEON.DungeonImageStr !=
          DUNGEON.DungeonImage[pt.DungeonNumber][pt.Floor]
      ) {
        let dungeonImage = DUNGEON.DungeonImage[pt.DungeonNumber][pt.Floor]
        let dungeonAry = dungeonImage.split('<->')
        let dungeonAry2 = dungeonAry.slice()
        while (true) {
          let num = dungeonAry2.indexOf('')
          if (num < 0) {
            break
          } else {
            dungeonAry2.splice(num, 1)
          }
        }
        if (dungeonAry2.length > 0) {
          dungeonAry2 = checkGraphic_Dungeon(dungeonAry2)
          if (dungeonAry2.length > 0) {
            MP.TopSurface.clear()
            MP.setOptionMode('partsClear')
            readGraphicFile_Dungeon(dungeonAry2, readEndAction)
          } else {
            readEndAction('graphic')
          }
        } else {
          readEndAction('graphic')
        }
      } else {
        if (Config['Dungeon'] == 'wireFrame' || MP.ImgWall == null) {
          MP.DungeonMode = 'wireFrame'
        } else {
          MP.DungeonMode = 'graphic'
        }
        MP.paintDungeon(MP.DungeonMode)
      }
    }
  }
}
function eventClickBackup () {
  if (GenericVariable['FullKeyInvalid']) {
    return
  }
  let dataStr = localStorage.getItem(SaveName + 'Save')
  if (dataStr == null) {
    dataStr = getSaveDataStr()
  }
  let fileName = GameData['GAME_TITLE']
  if (fileName == '') {
    fileName = 'Javardry'
  }
  fileName = checkFileName(fileName)
  fileName += '_SaveData'
  let today = new Date()
  fileName += String(today.getFullYear())
  fileName += MP.numberDigitMatch(today.getMonth() + 1, 2)
  fileName += MP.numberDigitMatch(today.getDate(), 2)
  fileName += '_' + MP.numberDigitMatch(today.getHours(), 2)
  fileName += MP.numberDigitMatch(today.getMinutes(), 2)
  fileName += MP.numberDigitMatch(today.getSeconds(), 2)
  fileName += '.dat'
  downloadTextFile(fileName, dataStr)
}
function eventClickDeleteOption () {
  if (GenericVariable['FullKeyInvalid']) {
    return
  }
  let result = confirm(getDefaultMessage('SYSTEM_DELETE_OPTION', 1))
  if (result) {
    localStorage.removeItem(SaveName + 'Config')
  }
}
function eventClickKeyConfig () {
  if (GenericVariable['FullKeyInvalid']) {
    return
  }
  if (this.name == undefined || this.name == null || this.name == '') {
    MP.setOptionMode('partsClear')
    MP.setOptionMode('keyConfig')
  } else {
    GenericVariable['FullKeyInvalid'] = true
    Mode = 'optionKeyConfig' + this.name
    MP.ButtonObject['keyConfigCancel_div'].style.display = 'none'
    MP.setOptionMode('partsClear')
    MP.TopSurface.clear()
    MP.drawOptionFrame()
    let x = MP.MAIN_X + MP.MAIN_WIDTH / 2 - (MP.FONT_SIZE / 2) * 25
    let y = MP.MAIN_Y + MP.LINE_HEIGHT * 3 + MP.LINE_HEIGHT * 1.5 * 2
    MP.drawText(MP.TopSurface, x, y, 50, 1, '[' + this.name + ']', 'center')
    MP.controlInputText('set')
    MP.OptionParts['text']._element.value = KeyConfigData2['KEY_' + this.name]
    GenericVariable['FullKeyInvalid'] = false
  }
}
function eventClickKeyname () {
  if (GenericVariable['FullKeyInvalid']) {
    return
  }
  if (Mode != 'option') {
    return
  }
  MP.setOptionMode('partsClear')
  MP.setOptionMode('keyname')
}
function eventClickRecovery () {
  if (GenericVariable['FullKeyInvalid']) {
    return
  }
  uploadTextFile('dat', recoverySaveData)
}
function eventKeydown (event) {
  let keyName = getKeyName(event.which)
  if (keyName == 'alt') {
    keyName = ''
  }
  if (Mode == 'optionKeyname') {
    MP.setOptionMode('keyname', keyName)
  } else {
    let key = getKey(keyName)
    if (key == 'shift') {
      GenericVariable['OnShiftKey'] = true
      key = ''
    } else {
      preInput('keyboard', key)
    }
  }
}
function eventKeydownInputText (event) {
  if (event.which == 38) {
    keyActionInputText('up')
  } else if (event.which == 40) {
    keyActionInputText('down')
  } else if (event.which == 13) {
    keyActionInputText('real_enter')
  } else if (event.which == 27) {
    keyActionInputText('escape')
  }
}
function eventKeyup (event) {
  if (Mode != 'optionKeyname') {
    let key = getKey(getKeyName(event.which))
    if (key == 'shift') {
      GenericVariable['OnShiftKey'] = false
    }
    PreInputType = []
    PreInput = []
  }
}
function eventMousedown (event) {
  if (GameState.match(/^(stopLoading|webFontLoadingEnd)$/)) {
    keyAction('game_window')
  } else if (GameState == 'stopStart') {
    let id = event.target.id
    if (id == 'game_window') {
      if (SoundPlayLimit) {
        if (Config['Se']) {
          allSePlay()
          SoundPlayLimitSe = true
        }
        if (Config['Bgm']) {
          allMusicPlay()
          SoundPlayLimitBgm = true
        }
      }
      main('mainLoopStart')
    }
  } else if (GenericVariable['ClickCancel']) {
    GenericVariable['ClickCancel'] = false
  } else {
    GenericVariable['OnClick'] = true
    GenericVariable['OnTouch'] = false
    let id = event.target.id
    GenericVariable['Id'] = id
    if (SoundPlayLimit && Mode == 'option') {
      if (id == 'option' || id == 'controller') {
        if (Config['Se'] && !SoundPlayLimitSe) {
          allSePlay()
          SoundPlayLimitSe = true
        }
        if (Config['Bgm'] && !SoundPlayLimitBgm) {
          let nowMusic = NowMusic
          allMusicPlay()
          SoundPlayLimitBgm = true
          NowMusic = nowMusic
          musicPlay(NowMusic)
        }
        MP.setOptionMode('clear')
        GenericVariable['OnClick'] = false
      }
    }
  }
}
function eventMousemove (event) {
  if (GenericVariable['OnClick']) {
    GenericVariable['Id'] = event.target.id
  }
}
function eventMouseout (img, key) {
  let appImg = MP.ButtonObject[key].normalAppearance
  img.getContext('2d').clearRect(0, 0, img.width, img.height)
  if (appImg != null) {
    img.getContext('2d').drawImage(appImg, 0, 0)
  }
}
function eventMouseover (img, key) {
  let appImg = MP.ButtonObject[key].onMouseAppearance
  img.getContext('2d').clearRect(0, 0, img.width, img.height)
  if (appImg != null) {
    img.getContext('2d').drawImage(appImg, 0, 0)
  }
}
function eventMouseup (event) {
  GenericVariable['OnClick'] = false
  GenericVariable['OnTouch'] = false
  PreInputType = []
  PreInput = []
}
function eventOnblur () {
  GenericVariable['OnShiftKey'] = false
  GenericVariable['OnClick'] = false
  GenericVariable['OnTouch'] = false
  PreInputType = []
  PreInput = []
}
function eventTouchmove (event) {
  GenericVariable['Id'] = event.target.id
}
function eventTouchstart (event) {
  if (GameState.match(/^(stopLoading|webFontLoadingEnd)$/)) {
    keyAction('game_window')
  } else if (GameState == 'stopStart') {
    let id = event.target.id
    if (id == 'game_window') {
      if (SoundPlayLimit) {
        if (Config['Se']) {
          allSePlay()
          SoundPlayLimitSe = true
        }
        if (Config['Bgm']) {
          allMusicPlay()
          SoundPlayLimitBgm = true
        }
      }
      main('mainLoopStart')
    }
  } else {
    GenericVariable['ClickCancel'] = true
    GenericVariable['OnTouch'] = true
    GenericVariable['OnClick'] = false
    let id = event.target.id
    GenericVariable['Id'] = id
    if (SoundPlayLimit && Mode == 'option') {
      if (id == 'option' || id == 'controller') {
        if (Config['Se'] && !SoundPlayLimitSe) {
          allSePlay()
          SoundPlayLimitSe = true
        }
        if (Config['Bgm'] && !SoundPlayLimitBgm) {
          let nowMusic = NowMusic
          allMusicPlay()
          SoundPlayLimitBgm = true
          NowMusic = nowMusic
          musicPlay(NowMusic)
        }
        MP.setOptionMode('clear')
        GenericVariable['OnTouch'] = false
      }
    }
  }
}
function eventVisibilitychange () {
  if (getDevice() == 'sp') {
    if (document.hidden) {
      NowMusicBg = NowMusic
      musicStop()
      seStop()
    } else {
      musicPlay(NowMusicBg)
    }
  }
}
function gamepadConnected (event) {
  ConnectedGamepadIndex = event.gamepad.index
}
function gamepadDisconnected (event) {
  ConnectedGamepadIndex = null
}
function getDefaultMessage (key, lineLimit, charLimit) {
  if (key == undefined || key == null) {
    return ''
  }
  if (lineLimit == undefined || lineLimit == null) {
    lineLimit = 0
  }
  if (charLimit == undefined || charLimit == null) {
    lineLimit = 0
  }
  let result = DefaultMessage[key]
  if (result == undefined || result == null || result == '') {
    if (key == 'PLEASE_READ_BY_NEW_ENGINE') {
      result =
        'The scenario data could not be loaded.<br><br>The data is corrupt or unsupported data.'
    } else if (key == 'SCENARIO_DOES_NOT_EXIST') {
      result = "The scenario data doesn't exist."
    } else if (key == 'SYSTEM_CLICK_SCREEN') {
      result = 'Click on this screen.'
    } else if (key == 'SYSTEM_RECOVERY_COMPLETED') {
      result = 'Loading saved data completed.'
    } else if (key == 'SYSTEM_RECOVERY_FAILED') {
      result = '* Failed to load saved data. *'
    } else if (key == 'SYSTEM_DELETE_OPTION') {
      result = 'Do you want to delete the option saved data?'
    } else if (key == 'SYSTEM_TOUCH_SCREEN') {
      result = 'Touch this screen'
    } else {
      result = ''
    }
  }
  if (result == '') {
    return result
  }
  if (lineLimit > 0 || charLimit > 0) {
    let strAry = result.split(/<br>|<p>|\r\n|\n|\r/)
    if (lineLimit > 0 && strAry.length > lineLimit) {
      strAry.splice(lineLimit)
    }
    if (charLimit > 0) {
      for (let i = 0; i < strAry.length; i++) {
        strAry[i] = MP.strCut(strAry[i], charLimit)
      }
    }
    result = ''
    for (let i = 0; i < strAry.length; i++) {
      if (i > 0) {
        result + ~'\n'
      }
      result += strAry[i]
    }
  }
  return result
}
function getDevice (mode) {
  let ua = navigator.userAgent.toLowerCase()
  if (mode == 'OS') {
    if (ua.match(/windows/)) {
      return 'Windows'
    } else if (ua.match(/iphone|ipad|ipod/)) {
      return 'iOS'
    } else if (ua.match(/mac/) && typeof document.ontouchstart != undefined) {
      return 'iOS'
    } else if (ua.match(/mac/)) {
      return 'macOS'
    } else if (ua.match(/linux/)) {
      return 'Linux'
    } else if (ua.match(/x11/)) {
      return 'UNIX'
    } else if (ua.match(/android/)) {
      return 'Android'
    } else {
      return 'others'
    }
  } else if (mode == 'Browser') {
    if (ua.indexOf('msie') > -1 || ua.indexOf('trident') > -1) {
      return 'ie'
    } else if (ua.match(/edge|edg/)) {
      return 'edge'
    } else if (ua.match(/opera|opr/)) {
      return 'opera'
    } else if (ua.indexOf('chrome') > -1) {
      return 'chrome'
    } else if (ua.indexOf('safari') > -1) {
      return 'safari'
    } else if (ua.indexOf('waterfox') > -1) {
      let str = ua.replace(/^.+waterfox\/([0-9]+)\.[0-9]+[0-9\.]*$/, '$1')
      let num = Number(str)
      if (isNaN(num)) {
        return 'waterfox'
      } else if (num <= 56) {
        return 'waterfoxClassic'
      } else {
        return 'waterfox'
      }
    } else if (ua.indexOf('firefox') > -1) {
      let str = ua.replace(/^.+firefox\/([0-9]+)\.[0-9]+[0-9\.]*$/, '$1')
      let num = Number(str)
      if (isNaN(num)) {
        return 'firefox'
      } else if (num < 100) {
        return 'firefoxOld'
      } else {
        return 'firefox'
      }
    } else {
      return 'others'
    }
  } else {
    if (
      ua.indexOf('iphone') > -1 ||
      ua.indexOf('ipod') > -1 ||
      (ua.indexOf('android') > -1 && ua.indexOf('mobile') > -1)
    ) {
      return 'sp'
    } else if (
      ua.indexOf('ipad') > -1 ||
      ua.indexOf('android') > -1 ||
      (ua.match(/mac/) && typeof document.ontouchstart != undefined)
    ) {
      return 'tab'
    } else {
      return 'pc'
    }
  }
}
function getHateTarget (cmName, cmNum1, cmNum2, action, group) {
  group = checkNull(group, false)
  let result = -1
  let ptNum = PlayData['ActiveParty']
  let pt = PARTY[ptNum]
  if (cmName == 'monster') {
    let monNum = PlayData['MonsterList'][cmNum1][cmNum2]
    let monster = MONSTER[monNum]
    let mData = MONSTER_DATA[TempVariable['setMonster'][cmNum1]]
    let hate = monster.Hate
    let hateTarget = getHateTargetNum(hate)
    if (hateTarget < 0) {
      return result
    }
    if (action == 0) {
      let rank = 0
      if (cmNum1 > 1) {
        rank = 1
      }
      if (hate < 200) {
        if (pt.frontRankCheck(hateTarget)) {
          if (mData.RANGE[rank] > 0) {
            result = hateTarget
          }
        } else if (mData.RANGE[rank] > 2) {
          result = hateTarget
        }
      } else if (hate >= 210) {
        if (hateTarget == 0) {
          if (mData.RANGE[rank] > 0) {
            result = 60 + hateTarget
          }
        } else if (mData.RANGE[rank] > 2) {
          result = 60 + hateTarget
        }
      }
    } else if (action == 3 || action == 6) {
      if (!group) {
        if (hate < 200) {
          result = hateTarget
        } else if (hate >= 210) {
          if (hateTarget == 0) {
            result = 60
          } else {
            result = 61
          }
        }
      } else {
        if (hate < 200) {
          if (hateTarget < GameData['FRONT_RANK_NUM']) {
            result = 8
          } else {
            result = 9
          }
        } else if (hate >= 210) {
          if (hateTarget == 0) {
            result = 8
          } else {
            result = 9
          }
        }
      }
    }
  } else if (cmName == 'summon') {
    let summonNum = PlayData['SummonList'][cmNum1][cmNum2]
    let summon = SUMMON[summonNum]
    let mData = MONSTER_DATA[summon.MonsterDataNum]
    let hate = summon.Hate
    let hateTarget = getHateTargetNum(hate)
    if (hateTarget < 0) {
      return result
    }
    if (action == 0) {
      if (hateTarget < 2) {
        if (mData.RANGE[cmNum1] > 0) {
          result = 10 + hateTarget
        }
      } else if (mData.RANGE[cmNum1] > 2) {
        result = 10 + hateTarget
      }
    }
    if (action == 3 || action == 6) {
      result = 10 + hateTarget
    }
  } else if (cmName == 'pc') {
    let pcNum = cmNum1
    let numInPt = pt.getMemberForPcNum(pcNum)
    let pc = PC[pcNum]
    let hate = pc.Hate
    let hateTarget = getHateTargetNum(hate)
    if (hateTarget < 0) {
      return result
    }
    if (action == 0) {
      let rank = 0
      if (!pt.frontRankCheck(numInPt)) {
        rank = 1
      }
      if (hateTarget < 2) {
        if (pc.Range[rank] > 0) {
          result = 10 + hateTarget
        }
      } else if (pc.Range[rank] > 2) {
        result = 10 + hateTarget
      }
    } else if (
      action == 2 ||
      action == 3 ||
      action == 5 ||
      action == 6 ||
      action == 7
    ) {
      result = 10 + hateTarget
    }
  }
  return result
}
function getHateTargetNum (hate) {
  let result = -1
  if (hate >= 0 && hate <= 119) {
    if (PC[hate].Hp < 1) {
      return result
    }
    result = PARTY[PlayData['ActiveParty']].getMemberForPcNum(hate)
  } else if (hate >= 200 && hate <= 203) {
    hate -= 200
    if (TempVariable['monsterNum'][hate] > 0) {
      result = hate
    }
  } else if (hate >= 210 && hate <= 211) {
    hate -= 210
    if (TempVariable['summonNum'][hate] > 0) {
      result = hate
    }
  }
  return result
}
function getKey (keyName) {
  if (keyName == 'enter') {
    return 'real_enter'
  } else if (keyName == 'escape' || keyName == '') {
    return keyName
  }
  let result = ''
  for (let key in KeyConfig) {
    for (let i = 0; i < KeyConfig[key].length; i++) {
      if (KeyConfig[key][i] == keyName) {
        result = key
        break
      }
    }
    if (result != '') {
      break
    }
  }
  if (keyName.indexOf('gamepad') < 0 && GenericVariable['OnShiftKey']) {
    if (result == 'right') {
      result = 'shift_right'
    } else if (result == 'left') {
      result = 'shift_left'
    }
  }
  return result
}
function getKeycode (keyName) {
  let keycode = []
  for (let i = 0; i < KEYCODE_NAME.length; i++) {
    if (KEYCODE_NAME[i][0] == keyName) {
      for (let j = 1; j < KEYCODE_NAME[i].length; j++) {
        keycode[j - 1] = KEYCODE_NAME[i][j]
      }
      break
    }
  }
  return keycode
}
function getMonsterName (groupNum, plural) {
  let result = ''
  if (plural == undefined || plural == null) {
    plural = false
  }
  if (groupNum < 0 || groupNum > 3) {
    return result
  }
  let mDataNum = TempVariable['setMonster'][groupNum]
  if (mDataNum < 0) {
    return result
  }
  if (TempVariable['monsterDecided'][groupNum]) {
    if (plural) {
      result = MONSTER_DATA[mDataNum].NAMES[1]
    } else {
      result = MONSTER_DATA[mDataNum].NAME[1]
    }
  } else {
    if (plural) {
      result = MONSTER_DATA[mDataNum].NAMES[0]
    } else {
      result = MONSTER_DATA[mDataNum].NAME[0]
    }
  }
  return result
}
function getMonsterRank (monNum) {
  let result = 0
  let listName = 'MonsterList'
  if (monNum >= 50) {
    monNum -= 50
    listName = 'SummonList'
  }
  for (let i = 0; i < PlayData[listName].length; i++) {
    for (let j = 0; j < PlayData[listName][i].length; j++) {
      if (PlayData[listName][i][j] == monNum) {
        result = i + 1
        break
      }
    }
    if (result > 0) {
      break
    }
  }
  if (result == 0) {
    result = 1
  }
  return result
}
function getNameBattle (charModel, charType, numInGroup, debug) {
  let result = ''
  if (debug) {
    result += '['
  }
  if (charType == 'pc') {
    result += charModel.Name[0]
  } else if (charType == 'summon') {
    if (debug) {
      result += 'SUMMON '
    }
    result += charModel.Name[1]
    if (debug && numInGroup != null) {
      result += '[' + String(numInGroup[0]) + '][' + String(numInGroup[1]) + ']'
    }
  } else if (charType == 'monster') {
    if (numInGroup == null) {
      result += charModel.Name[1]
    } else {
      result += getMonsterName(numInGroup[0])
    }
    if (debug && numInGroup != null) {
      result += '[' + String(numInGroup[0]) + '][' + String(numInGroup[1]) + ']'
    }
  }
  if (debug) {
    result += ']'
  }
  return result
}
function getNextMonster () {
  let result = -1
  for (let i = 0; i < MONSTER.length; i++) {
    if (MONSTER[i].MonsterNum < 0) {
      result = i
      break
    }
  }
  return result
}
function getNextPcNum () {
  let result = -1
  for (let i = 0; i < PC.length; i++) {
    if (PC[i].Name[0].match(/^(| )$/)) {
      result = i
      break
    }
  }
  return result
}
function getNextSummon () {
  let result = -1
  for (let i = 0; i < SUMMON.length; i++) {
    if (SUMMON[i].MonsterNum < 0) {
      result = i
      break
    }
  }
  return result
}
function getNewParty () {
  let result = -1
  for (let i = 0; i < PARTY.length; i++) {
    if (PARTY[i].PartyMember[0] < 0) {
      result = i
      break
    }
  }
  return result
}
function getKeyName (keycode) {
  let keyName = ''
  for (let i = 0; i < KEYCODE_NAME.length; i++) {
    for (let j = 1; j < KEYCODE_NAME[i].length; j++) {
      if (KEYCODE_NAME[i][j] == keycode) {
        keyName = KEYCODE_NAME[i][0]
        break
      }
    }
    if (keyName != '') {
      break
    }
  }
  return keyName
}
function getSaveDataStr () {
  let data = ''
  data += GameData['READ_KEYWORD']
  data += '\n'
  PlayData['ShopItemListFull'] ? (data += '1') : (data += '0')
  data += '\n'
  let num = PlayData['GameFlag'].lastIndexOf(true)
  if (num < 0) {
    num = 0
  } else if (num > 9999) {
    num = 9999
  }
  num++
  for (let i = 0; i < num; i++) {
    PlayData['GameFlag'][i] ? (data += '1') : (data += '0')
  }
  data += '\n'
  num = PlayData['ItemFlag'].lastIndexOf(true)
  if (num < 0) {
    num = 0
  } else if (num > 9999) {
    num = 9999
  }
  num++
  for (let i = 0; i < num; i++) {
    PlayData['ItemFlag'][i] ? (data += '1') : (data += '0')
  }
  data += '\n'
  num = PlayData['MonsterFlag'].lastIndexOf(true)
  if (num < 0) {
    num = 0
  } else if (num > 9999) {
    num = 9999
  }
  num++
  for (let i = 0; i < num; i++) {
    PlayData['MonsterFlag'][i] ? (data += '1') : (data += '0')
  }
  data += '\n'
  data += String(PlayData['PcMax'])
  data += '\n'
  data += String(PlayData['ActiveParty'])
  data += '\n'
  let pEyMax = GameData['PC_ENTRY_MAX']
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PlayData['PcList'][i])
  }
  data += '\n'
  for (let i = 0; i < PlayData['GarbageItem'].length; i++) {
    if (i > 0) {
      data += '<>'
    }
    data += PlayData['GarbageItem'][i]
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    PC[i].SealSpell ? (data += '1') : (data += '0')
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    data += String(PC[i].Sex)
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PC[i].Race)
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    data += String(PC[i].Alignment)
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PC[i].PcClass)
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PC[i].State)
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PC[i].PartyNum)
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PC[i].Age)
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PC[i].Days)
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PC[i].HpMax0)
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PC[i].Hp)
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PC[i].SealSpellInt)
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PC[i].Level)
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PC[i].Rip)
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PC[i].Poison)
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PC[i].SpellEffectRate[0])
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PC[i].SpellEffectPlus[0])
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PC[i].SpellEffectRate[1])
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PC[i].SpellEffectPlus[1])
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PC[i].SpellEffectRate[5])
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PC[i].SpellEffectPlus[5])
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PC[i].SpellEffectRate[2])
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PC[i].SpellEffectPlus[2])
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PC[i].SpellEffectRate[3])
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PC[i].SpellEffectPlus[3])
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PC[i].SpellEffectRate[4])
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PC[i].SpellEffectPlus[4])
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PC[i].Exp)
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PC[i].Gold)
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PC[i].Marks)
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += '<>'
    }
    data += PC[i].Name[0]
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += '<>'
    }
    data += PC[i].Title
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += '<>'
    }
    data += PC[i].Transmigrates
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PARTY[i].DungeonNumber)
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PARTY[i].Floor)
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PARTY[i].X)
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PARTY[i].Y)
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    data += String(PARTY[i].Direction)
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PARTY[i].Vision)
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PARTY[i].PtSpellEffectRate[0])
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PARTY[i].PtSpellEffectPlus[0])
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PARTY[i].SpellEffectRate[0])
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PARTY[i].SpellEffectPlus[0])
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PARTY[i].Flying)
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PARTY[i].SpellEffectRate[1])
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PARTY[i].SpellEffectPlus[1])
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PARTY[i].SpellEffectRate[5])
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PARTY[i].SpellEffectPlus[5])
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PARTY[i].SpellEffectRate[2])
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PARTY[i].SpellEffectPlus[2])
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PARTY[i].SpellEffectRate[3])
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PARTY[i].SpellEffectPlus[3])
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PARTY[i].SpellEffectRate[4])
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PARTY[i].SpellEffectPlus[4])
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PARTY[i].PtSpellEffectRate[1])
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PARTY[i].PtSpellEffectPlus[1])
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PARTY[i].PtSpellEffectRate[2])
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PARTY[i].PtSpellEffectPlus[2])
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PARTY[i].PtSpellEffectRate[3])
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PARTY[i].PtSpellEffectPlus[3])
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    PARTY[i].Light ? (data += '1') : (data += '0')
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += '<>'
    }
    data += PARTY[i].FlyingEffect
  }
  data += '\n'
  for (let i = 0; i < PC_ENTRY_MIN; i++) {
    for (let j = 0; j < 99; j++) {
      data += String(PC[i].Equip[j])
    }
  }
  data += '\n'
  for (let i = 0; i < PC_ENTRY_MIN; i++) {
    for (let j = 0; j < 99; j++) {
      data += String(PC[i].ItemDecided[j])
    }
  }
  data += '\n'
  for (let i = 0; i < PC_ENTRY_MIN; i++) {
    for (let j = 0; j < 99; j++) {
      if (i > 0 || j > 0) {
        data += ','
      }
      data += String(PC[i].Item[j])
    }
  }
  data += '\n'
  for (let i = 0; i < PC_ENTRY_MIN; i++) {
    for (let j = 0; j < 10; j++) {
      if (i > 0 || j > 0) {
        data += ','
      }
      if (j < GameData['ABILITY'].length) {
        data += String(PC[i].Ability0[j])
      } else {
        data += '-1'
      }
    }
  }
  for (let i = 0; i < PC_ENTRY_MIN; i++) {
    for (let j = 10; j < 36; j++) {
      data += ','
      if (j < GameData['ABILITY'].length) {
        data += String(PC[i].Ability0[j])
      } else {
        data += '-1'
      }
    }
  }
  data += '\n'
  for (let i = 0; i < PC_ENTRY_MIN; i++) {
    for (let j = 0; j < 4; j++) {
      for (let k = 0; k < 10; k++) {
        if (i > 0 || j > 0 || k > 0) {
          data += ','
        }
        data += String(PC[i].Mp[j][k])
      }
    }
  }
  data += '\n'
  for (let i = 0; i < PC_ENTRY_MIN; i++) {
    for (let j = 0; j < 4; j++) {
      for (let k = 0; k < 10; k++) {
        if (i > 0 || j > 0 || k > 0) {
          data += ','
        }
        data += String(PC[i].MpMax[j][k])
      }
    }
  }
  data += '\n'
  for (let i = 0; i < PC_ENTRY_MIN; i++) {
    for (let j = 0; j < 4; j++) {
      for (let k = 0; k < 10; k++) {
        for (let l = 0; l < 6; l++) {
          PC[i].Spell[j][k][l] ? (data += '1') : (data += '0')
        }
      }
    }
  }
  data += '\n'
  for (let i = 0; i < PC_ENTRY_MIN; i++) {
    for (let j = 0; j < 6; j++) {
      if (i > 0 || j > 0) {
        data += ','
      }
      data += String(PARTY[i].PartyMember[j])
    }
  }
  data += '\n'
  for (let i = 0; i < ITEM.length; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(ITEM[i].Stock)
  }
  data += '\n'
  for (let i = 0; i < 10; i++) {
    for (let j = 0; j < 16; j++) {
      for (let k = 0; k < 20; k++) {
        for (let l = 0; l < 20; l++) {
          PlayData['MapFlag'][i][j][k][l] ? (data += '1') : (data += '0')
        }
      }
    }
  }
  data += '\n'
  for (let i = 0; i < 10; i++) {
    for (let j = 0; j < 16; j++) {
      for (let k = 0; k < 64; k++) {
        PlayData['SecretDoor'][i][j][k] ? (data += '1') : (data += '0')
      }
    }
  }
  for (let i = 0; i < 10; i++) {
    for (let j = 0; j < 16; j++) {
      for (let k = 64; k < 512; k++) {
        PlayData['SecretDoor'][i][j][k] ? (data += '1') : (data += '0')
      }
    }
  }
  data += '\n'
  for (let i = 0; i < 10; i++) {
    for (let j = 0; j < 16; j++) {
      for (let k = 0; k < 64; k++) {
        PlayData['LockedDoor'][i][j][k] ? (data += '1') : (data += '0')
      }
    }
  }
  for (let i = 0; i < 10; i++) {
    for (let j = 0; j < 16; j++) {
      for (let k = 64; k < 512; k++) {
        PlayData['LockedDoor'][i][j][k] ? (data += '1') : (data += '0')
      }
    }
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += '<>'
    }
    data += PARTY[i].DungeonMusic
  }
  data += '\n'
  for (let i = 0; i < 10; i++) {
    if (i > 0) {
      data += '<>'
    }
    for (let j = 0; j < 16; j++) {
      if (j > 0) {
        data += ','
      }
      data += PlayData['DungeonNewMusic'][i][j]
    }
  }
  data += '\n'
  for (let i = 0; i < PC_ENTRY_MIN; i++) {
    for (let j = 0; j < 10; j++) {
      if (i > 0 || j > 0) {
        data += ','
      }
      data += String(PC[i].AbiPlus[j])
    }
  }
  for (let i = 0; i < PC_ENTRY_MIN; i++) {
    for (let j = 10; j < 36; j++) {
      data += ',' + String(PC[i].AbiPlus[j])
    }
  }
  data += '\n'
  for (let i = 0; i < PC_ENTRY_MIN; i++) {
    for (let j = 0; j < 10; j++) {
      if (i > 0 || j > 0) {
        data += ','
      }
      data += String(PC[i].AbiRate[j])
    }
  }
  for (let i = 0; i < PC_ENTRY_MIN; i++) {
    for (let j = 10; j < 36; j++) {
      data += ',' + String(PC[i].AbiRate[j])
    }
  }
  data += '\n'
  for (let i = 0; i < PC_ENTRY_MIN; i++) {
    for (let j = 0; j < 10; j++) {
      if (i > 0 || j > 0) {
        data += ','
      }
      data += String(PARTY[i].AbiPlus[j])
    }
  }
  for (let i = 0; i < PC_ENTRY_MIN; i++) {
    for (let j = 10; j < 36; j++) {
      data += ',' + String(PARTY[i].AbiPlus[j])
    }
  }
  data += '\n'
  for (let i = 0; i < PC_ENTRY_MIN; i++) {
    for (let j = 0; j < 10; j++) {
      if (i > 0 || j > 0) {
        data += ','
      }
      data += String(PARTY[i].AbiRate[j])
    }
  }
  for (let i = 0; i < PC_ENTRY_MIN; i++) {
    for (let j = 10; j < 36; j++) {
      data += ',' + String(PARTY[i].AbiRate[j])
    }
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PARTY[i].PtSpellEffectRate[4])
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PARTY[i].PtSpellEffectPlus[4])
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PARTY[i].SpellEffectRate[6])
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PARTY[i].SpellEffectPlus[6])
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PC[i].SpellEffectRate[6])
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PC[i].SpellEffectPlus[6])
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PARTY[i].SpellEffectPlus[7])
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PARTY[i].SpellEffectRate[7])
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PC[i].SpellEffectPlus[7])
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PC[i].SpellEffectRate[7])
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    PARTY[i].ViewDarkZone ? (data += '1') : (data += '0')
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PC[i].SpellEffectPlus[8])
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PC[i].SpellEffectRate[8])
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PARTY[i].SpellEffectPlus[8])
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PARTY[i].SpellEffectRate[8])
  }
  data += '\n'
  for (let i = 0; i < 10; i++) {
    for (let j = 0; j < 16; j++) {
      for (let k = 0; k < 64; k++) {
        PlayData['WallFlag'][i][j][k] ? (data += '1') : (data += '0')
      }
    }
  }
  for (let i = 0; i < 10; i++) {
    for (let j = 0; j < 16; j++) {
      for (let k = 64; k < 512; k++) {
        PlayData['WallFlag'][i][j][k] ? (data += '1') : (data += '0')
      }
    }
  }
  data += '\n'
  for (let i = 0; i < PC_ENTRY_MIN; i++) {
    for (let j = 0; j < RESIST_LENGTH; j++) {
      if (j == 9) {
        continue
      }
      if (i > 0 || j > 0) {
        data += ','
      }
      data += String(PC[i].ResistPlus[j])
    }
  }
  data += '\n'
  for (let i = 0; i < PC_ENTRY_MIN; i++) {
    for (let j = 0; j < RESIST_LENGTH; j++) {
      if (j == 9) {
        continue
      }
      if (i > 0 || j > 0) {
        data += ','
      }
      data += String(PC[i].ResistRate[j])
    }
  }
  data += '\n'
  for (let i = 0; i < PC_ENTRY_MIN; i++) {
    for (let j = 0; j < RESIST_LENGTH; j++) {
      if (j == 9) {
        continue
      }
      if (i > 0 || j > 0) {
        data += ','
      }
      data += String(PARTY[i].ResistPlus[j])
    }
  }
  data += '\n'
  for (let i = 0; i < PC_ENTRY_MIN; i++) {
    for (let j = 0; j < RESIST_LENGTH; j++) {
      if (j == 9) {
        continue
      }
      if (i > 0 || j > 0) {
        data += ','
      }
      data += String(PARTY[i].ResistRate[j])
    }
  }
  data += '\n'
  for (let i = 0; i < PC_ENTRY_MIN; i++) {
    for (let j = 0; j < ATTACK_ADD_LENGTH + 1; j++) {
      PC[i].AttackAddPlus[j] ? (data += '1') : (data += '0')
    }
  }
  data += '\n'
  for (let i = 0; i < PC_ENTRY_MIN; i++) {
    for (let j = 0; j < ATTACK_ADD_LENGTH + 1; j++) {
      if (i > 0 || j > 0) {
        data += ','
      }
      data += String(PC[i].AttackAddRate[j])
    }
  }
  data += '\n'
  for (let i = 0; i < PC_ENTRY_MIN; i++) {
    for (let j = 0; j < ATTACK_ADD_LENGTH + 1; j++) {
      PARTY[i].AttackAddPlus[j] ? (data += '1') : (data += '0')
    }
  }
  data += '\n'
  for (let i = 0; i < PC_ENTRY_MIN; i++) {
    for (let j = 0; j < ATTACK_ADD_LENGTH + 1; j++) {
      if (i > 0 || j > 0) {
        data += ','
      }
      data += String(PARTY[i].AttackAddRate[j])
    }
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PC[i].PoisonPlus)
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += String(PARTY[i].PoisonPlus)
  }
  data += '\n'
  for (let i = 0; i < PlayData['GameFlagS'].length; i++) {
    PlayData['GameFlagS'][i] ? (data += '1') : (data += '0')
  }
  data += '\n'
  for (let i = 0; i < pEyMax; i++) {
    if (i > 0) {
      data += ','
    }
    data += PC[i].FaceGraphic
  }
  for (let j = 0; j < 99; j++) {
    data += '\n'
    for (let i = PC_ENTRY_MIN; i < pEyMax; i++) {
      data += String(PC[i].Equip[j])
    }
  }
  for (let j = 0; j < 99; j++) {
    data += '\n'
    for (let i = PC_ENTRY_MIN; i < pEyMax; i++) {
      data += String(PC[i].ItemDecided[j])
    }
  }
  for (let j = 0; j < 99; j++) {
    data += '\n'
    for (let i = PC_ENTRY_MIN; i < pEyMax; i++) {
      if (i > PC_ENTRY_MIN) {
        data += ','
      }
      data += String(PC[i].Item[j])
    }
  }
  for (let j = 0; j < 36; j++) {
    data += '\n'
    for (let i = PC_ENTRY_MIN; i < pEyMax; i++) {
      if (i > PC_ENTRY_MIN) {
        data += ','
      }
      if (j < GameData['ABILITY'].length) {
        data += String(PC[i].Ability0[j])
      } else {
        data += '-1'
      }
    }
  }
  for (let k = 0; k < 10; k++) {
    for (let j = 0; j < 4; j++) {
      data += '\n'
      for (let i = PC_ENTRY_MIN; i < pEyMax; i++) {
        if (i > PC_ENTRY_MIN) {
          data += ','
        }
        data += String(PC[i].Mp[j][k])
      }
    }
  }
  for (let k = 0; k < 10; k++) {
    for (let j = 0; j < 4; j++) {
      data += '\n'
      for (let i = PC_ENTRY_MIN; i < pEyMax; i++) {
        if (i > PC_ENTRY_MIN) {
          data += ','
        }
        data += String(PC[i].MpMax[j][k])
      }
    }
  }
  for (let l = 0; l < 6; l++) {
    for (let k = 0; k < 10; k++) {
      for (let j = 0; j < 4; j++) {
        data += '\n'
        for (let i = PC_ENTRY_MIN; i < pEyMax; i++) {
          PC[i].Spell[j][k][l] ? (data += '1') : (data += '0')
        }
      }
    }
  }
  for (let j = 0; j < 6; j++) {
    data += '\n'
    for (let i = PC_ENTRY_MIN; i < pEyMax; i++) {
      if (i > PC_ENTRY_MIN) {
        data += ','
      }
      data += String(PARTY[i].PartyMember[j])
    }
  }
  for (let j = 0; j < 36; j++) {
    data += '\n'
    for (let i = PC_ENTRY_MIN; i < pEyMax; i++) {
      if (i > PC_ENTRY_MIN) {
        data += ','
      }
      data += String(PC[i].AbiPlus[j])
    }
  }
  for (let j = 0; j < 36; j++) {
    data += '\n'
    for (let i = PC_ENTRY_MIN; i < pEyMax; i++) {
      if (i > PC_ENTRY_MIN) {
        data += ','
      }
      data += String(PC[i].AbiRate[j])
    }
  }
  for (let j = 0; j < 36; j++) {
    data += '\n'
    for (let i = PC_ENTRY_MIN; i < pEyMax; i++) {
      if (i > PC_ENTRY_MIN) {
        data += ','
      }
      data += String(PARTY[i].AbiPlus[j])
    }
  }
  for (let j = 0; j < 36; j++) {
    data += '\n'
    for (let i = PC_ENTRY_MIN; i < pEyMax; i++) {
      if (i > PC_ENTRY_MIN) {
        data += ','
      }
      data += String(PARTY[i].AbiRate[j])
    }
  }
  for (let j = 0; j < RESIST_LENGTH; j++) {
    if (j == 9) {
      continue
    }
    data += '\n'
    for (let i = PC_ENTRY_MIN; i < pEyMax; i++) {
      if (i > PC_ENTRY_MIN) {
        data += ','
      }
      data += String(PC[i].ResistPlus[j])
    }
  }
  for (let j = 0; j < RESIST_LENGTH; j++) {
    if (j == 9) {
      continue
    }
    data += '\n'
    for (let i = PC_ENTRY_MIN; i < pEyMax; i++) {
      if (i > PC_ENTRY_MIN) {
        data += ','
      }
      data += String(PC[i].ResistRate[j])
    }
  }
  for (let j = 0; j < RESIST_LENGTH; j++) {
    if (j == 9) {
      continue
    }
    data += '\n'
    for (let i = PC_ENTRY_MIN; i < pEyMax; i++) {
      if (i > PC_ENTRY_MIN) {
        data += ','
      }
      data += String(PARTY[i].ResistPlus[j])
    }
  }
  for (let j = 0; j < RESIST_LENGTH; j++) {
    if (j == 9) {
      continue
    }
    data += '\n'
    for (let i = PC_ENTRY_MIN; i < pEyMax; i++) {
      if (i > PC_ENTRY_MIN) {
        data += ','
      }
      data += String(PARTY[i].ResistRate[j])
    }
  }
  for (let j = 0; j < ATTACK_ADD_LENGTH + 1; j++) {
    data += '\n'
    for (let i = PC_ENTRY_MIN; i < pEyMax; i++) {
      PC[i].AttackAddPlus[j] ? (data += '1') : (data += '0')
    }
  }
  for (let j = 0; j < ATTACK_ADD_LENGTH + 1; j++) {
    data += '\n'
    for (let i = PC_ENTRY_MIN; i < pEyMax; i++) {
      if (i > PC_ENTRY_MIN) {
        data += ','
      }
      data += String(PC[i].AttackAddRate[j])
    }
  }
  for (let j = 0; j < ATTACK_ADD_LENGTH + 1; j++) {
    data += '\n'
    for (let i = PC_ENTRY_MIN; i < pEyMax; i++) {
      PARTY[i].AttackAddPlus[j] ? (data += '1') : (data += '0')
    }
  }
  for (let j = 0; j < ATTACK_ADD_LENGTH + 1; j++) {
    data += '\n'
    for (let i = PC_ENTRY_MIN; i < pEyMax; i++) {
      if (i > PC_ENTRY_MIN) {
        data += ','
      }
      data += String(PARTY[i].AttackAddRate[j])
    }
  }
  return base64.encode(data, 1)
}
function getSituation () {
  let result = 4
  if (GameMode == 'dungeon') {
    result = 0
  } else if (GameMode == 'camp') {
    result = 1
  } else if (GameMode == 'battle') {
    result = 2
  } else if (GameMode == 'box') {
    result = 3
  }
  return result
}
function getSpecifiedSpellEffect (spellEffectList, spellEffectNum) {
  let result = ''
  if (spellEffectList == '') {
    return result
  }
  let spellEffectListAry = spellEffectList.split('<>')
  for (let i = 0; i < spellEffectListAry.length; i++) {
    let strAry = spellEffectListAry[i].split(',')
    if (spellEffectNum == Number(strAry[0])) {
      if (spellEffectNum == 83) {
        result = strAry[2]
      } else {
        result = spellEffectListAry[i]
      }
      break
    }
  }
  return result
}
function getSpellEffectList (spellEffect) {
  let result = ''
  if (spellEffect == '') {
    return result
  }
  if (spellEffect.indexOf('<notCancel>') > -1) {
    let strAry = spellEffect.split('<notCancel>')
    spellEffect = strAry[1]
  }
  if (spellEffect.indexOf('<->') > -1) {
    let strAry = spellEffect.split('<->')
    spellEffect = strAry[1]
  }
  let spellEffectAry
  if (spellEffect.indexOf('<+>') > -1) {
    spellEffectAry = spellEffect.split('<+>')
  } else {
    spellEffectAry = [spellEffect]
  }
  for (let i = 0; i < spellEffectAry.length; i++) {
    if (spellEffectAry[i].indexOf('<*>') > -1) {
      let strAry = spellEffectAry[i].split('<*>')
      for (let j = 1; j < strAry.length; j++) {
        if (result != '') {
          result += '<>'
        }
        result += strAry[j]
      }
    } else {
      if (result != '') {
        result += '<>'
      }
      result += spellEffectAry[i]
    }
  }
  return result
}
function getStatusColor (pcNum) {
  let result
  let pc = PC[pcNum]
  if (pc.State == 6) {
    result = getDefaultMessage('_STATUS_COLOR_LOST', 1)
  } else if (pc.State == 5) {
    result = getDefaultMessage('_STATUS_COLOR_ASHED', 1)
  } else if (pc.State == 4) {
    result = getDefaultMessage('_STATUS_COLOR_DEAD', 1)
  } else if (pc.State == 3) {
    result = getDefaultMessage('_STATUS_COLOR_STONED', 1)
  } else if (pc.State == 2) {
    result = getDefaultMessage('_STATUS_COLOR_PARALYZED', 1)
  } else if (pc.Asleep < 0) {
    result = getDefaultMessage('_STATUS_COLOR_FAINTED', 1)
  } else if (pc.Asleep > 0) {
    result = getDefaultMessage('_STATUS_COLOR_ASLEEP', 1)
  } else if (pc.NoBreath > 0) {
    result = getDefaultMessage('_STATUS_COLOR_RESTRAINED', 1)
  } else if (pc.State == 1) {
    result = getDefaultMessage('_STATUS_COLOR_AFRAID', 1)
  } else if (pc.SealSpell) {
    result = getDefaultMessage('_STATUS_COLOR_SEAL_SPELL', 1)
  } else if (pc.Silence != 0) {
    result = getDefaultMessage('_STATUS_COLOR_SILENCE', 1)
  } else if (pc.Poison > 0) {
    result = getDefaultMessage('_STATUS_COLOR_POISONED', 1)
  } else if (pc.Hate > -1) {
    result = getDefaultMessage('_STATUS_COLOR_HATED', 1)
  } else {
    let num
    if (pc.HpMax < 1) {
      num = 0.0
    } else {
      num = strCalculation(String(pc.Hp) + '/' + String(pc.HpMax))
    }
    if (num <= 0.1) {
      result = getDefaultMessage('_STATUS_COLOR_HP_10_PERCENTOR_OR_UNDER', 1)
    } else if (num <= 0.2) {
      result = getDefaultMessage('_STATUS_COLOR_HP_20_PERCENTOR_OR_UNDER', 1)
    } else if (num <= 0.3) {
      result = getDefaultMessage('_STATUS_COLOR_HP_30_PERCENTOR_OR_UNDER', 1)
    } else if (num <= 0.4) {
      result = getDefaultMessage('_STATUS_COLOR_HP_40_PERCENTOR_OR_UNDER', 1)
    } else if (num <= 0.5) {
      result = getDefaultMessage('_STATUS_COLOR_HP_50_PERCENTOR_OR_UNDER', 1)
    } else if (num <= 0.6) {
      result = getDefaultMessage('_STATUS_COLOR_HP_60_PERCENTOR_OR_UNDER', 1)
    } else if (num <= 0.7) {
      result = getDefaultMessage('_STATUS_COLOR_HP_70_PERCENTOR_OR_UNDER', 1)
    } else if (num <= 0.8) {
      result = getDefaultMessage('_STATUS_COLOR_HP_80_PERCENTOR_OR_UNDER', 1)
    } else if (num <= 0.9) {
      result = getDefaultMessage('_STATUS_COLOR_HP_90_PERCENTOR_OR_UNDER', 1)
    } else {
      result = 'ffffff'
    }
  }
  if (
    result.match(
      /^[0-9a-zA-Z][0-9a-zA-Z][0-9a-zA-Z][0-9a-zA-Z][0-9a-zA-Z][0-9a-zA-Z]$/
    )
  ) {
    result = '#' + result
  }
  return result
}
function getSummonReference (mode, num) {
  let result = false
  for (let i = 0; i < 2; i++) {
    if (result) {
      break
    }
    for (let j = 0; j < 9; j++) {
      if (PlayData['SummonList'][i][j] < 0) {
        continue
      }
      let summon = SUMMON[PlayData['SummonList'][i][j]]
      if (summon.Hp < 1) {
        continue
      }
      if (mode == 'state') {
        if (num < 0) {
          result = true
          break
        } else if (num == 0) {
          if (
            summon.State == 0 &&
            summon.Silence == 0 &&
            summon.Asleep == 0 &&
            summon.NoBreath == 0 &&
            summon.Poison == 0
          ) {
            result = true
            break
          }
        } else if (num == 2 || num == 3) {
          if (summon.State == num) {
            result = true
            break
          }
        } else if (num == 7) {
          if (summon.Silence != 0) {
            result = true
            break
          }
        } else if (num == 8) {
          if (summon.Asleep > 0) {
            result = true
            break
          }
        } else if (num == 9) {
          if (summon.Asleep < 0) {
            result = true
            break
          }
        } else if (num == 10) {
          if (summon.NoBreath > 0) {
            result = true
            break
          }
        } else if (num == 12) {
          if (summon.Poison > 0) {
            result = true
            break
          }
        }
      } else if (mode == 'type') {
        if (num < 0 || num == MONSTER_DATA[summon.MonsterDataNum].TYPE) {
          result = true
        }
        break
      }
    }
  }
  return result
}
function hateCheck (deadNum) {
  if (deadNum < 200 || deadNum >= 210) {
    for (let i = 0; i < 4; i++) {
      for (let j = 0; j < 9; j++) {
        if (PlayData['MonsterList'][i][j] < 0) {
          break
        }
        let monster = MONSTER[PlayData['MonsterList'][i][j]]
        if (monster.Hate == deadNum) {
          monster.Hate = -1
          monster.HateTurn = -1
        }
      }
    }
  } else {
    let ptNum = PlayData['ActiveParty']
    let pt = PARTY[ptNum]
    let memberNum = pt.getMemberNum()
    for (let i = 0; i < memberNum; i++) {
      let pc = PC[pt.PartyMember[i]]
      if (pc.Hp < 1) {
        continue
      }
      if (pc.Hate == deadNum) {
        pc.Hate = -1
        pc.HateTurn = -1
      }
    }
    for (let i = 0; i < 2; i++) {
      for (let j = 0; j < 9; j++) {
        if (PlayData['SummonList'][i][j] < 0) {
          break
        }
        let summon = SUMMON[PlayData['SummonList'][i][j]]
        if (summon.Hate == deadNum) {
          summon.Hate = -1
          summon.HateTurn = -1
        }
      }
    }
  }
}
function initializeFirstPc () {
  let count = 0
  for (let i = 0; i < GameData['FIRST_PC'].length; i++) {
    let strAry = GameData['FIRST_PC'][i].split('<>')
    if (strAry[13] == 'true') {
      continue
    }
    setFirstPc(GameData['FIRST_PC'][i], count)
    count++
    if (count >= GameData['PC_ENTRY_MAX']) {
      break
    }
  }
}
function initializePlayData () {
  PlayData['ShopItemListFull'] = false
  ;(PlayData['ItemFlag'] = []), (PlayData['MonsterFlag'] = [])
  PlayData['GameFlag'] = []
  for (let i = 0; i < 10000; i++) {
    PlayData['GameFlag'][i] = false
  }
  PlayData['GameFlagS'] = []
  for (let i = 0; i < 2; i++) {
    PlayData['GameFlagS'][i] = false
  }
  PlayData['DebugView'] = false
  PlayData['PcMax'] = 0
  PlayData['PcList'] = []
  for (let i = 0; i < GameData['PC_ENTRY_MAX']; i++) {
    PlayData['PcList'].push(i)
  }
  PlayData['MonsterList'] = []
  for (let i = 0; i < 4; i++) {
    PlayData['MonsterList'][i] = new Array(9)
  }
  PlayData['SummonList'] = []
  for (let i = 0; i < 2; i++) {
    PlayData['SummonList'][i] = new Array(9)
  }
  PlayData['GarbageItem'] = []
  PlayData['PartyStatusView'] = true
  PlayData['PartyStatusNow'] = false
  PlayData['PartyStatusNum'] = -1
  PlayData['StatusNow'] = ''
  PlayData['StatusNum'] = -1
  PlayData['StatusAction'] = ''
  for (let i = 0; i < PC.length; i++) {
    PC[i].initialize()
  }
  for (let i = 0; i < PARTY.length; i++) {
    PARTY[i].initialize()
  }
  for (let i = 0; i < MONSTER.length; i++) {
    MONSTER[i].initialize()
  }
  for (let i = 0; i < SUMMON.length; i++) {
    SUMMON[i].initialize()
  }
  for (let i = 0; i < ITEM.length; i++) {
    ITEM[i].setStock()
  }
  PlayData['MapFlag'] = []
  for (let i = 0; i < 10; i++) {
    PlayData['MapFlag'][i] = []
    for (let j = 0; j < 16; j++) {
      PlayData['MapFlag'][i][j] = []
      for (let k = 0; k < 20; k++) {
        PlayData['MapFlag'][i][j][k] = []
        for (let l = 0; l < 20; l++) {
          PlayData['MapFlag'][i][j][k][l] = false
        }
      }
    }
  }
  for (let i = 0; i < DUNGEON.CheckedSpacePreCheck.length; i++) {
    let preCheck = DUNGEON.CheckedSpacePreCheck[i]
    if (preCheck == 'all') {
      for (let j = 0; j < DUNGEON.FloorMinMax[i].length; j++) {
        for (let k = 0; k < DUNGEON.Width[i]; k++) {
          for (let l = 0; l < DUNGEON.Height[i]; l++) {
            PlayData['MapFlag'][i][j][k][l] = true
          }
        }
      }
    } else if (preCheck != '') {
      let strAry = preCheck.split('<>')
      for (let j = 0; j < strAry.length; j++) {
        if (strAry[j].indexOf(',') < 0) {
          continue
        }
        let strAry2 = strAry[j].split(',')
        let floor = Number(strAry2[0])
        if (strAry2[1] == 'all') {
          for (let k = 0; k < DUNGEON.Width[i]; k++) {
            for (let l = 0; l < DUNGEON.Height[i]; l++) {
              PlayData['MapFlag'][i][floor][k][l] = true
            }
          }
        } else {
          let x = Number(strAry2[1])
          let y = Number(strAry2[2])
          PlayData['MapFlag'][i][floor][x][y] = true
        }
      }
    }
  }
  ;(PlayData['SecretDoor'] = []),
    (PlayData['LockedDoor'] = []),
    (PlayData['WallFlag'] = [])
  PlayData['DungeonNewMusic'] = []
  for (let i = 0; i < 10; i++) {
    ;(PlayData['SecretDoor'][i] = []), (PlayData['LockedDoor'][i] = [])
    PlayData['WallFlag'][i] = []
    PlayData['DungeonNewMusic'][i] = []
    for (let j = 0; j < 16; j++) {
      ;(PlayData['SecretDoor'][i][j] = []), (PlayData['LockedDoor'][i][j] = [])
      PlayData['WallFlag'][i][j] = []
      PlayData['DungeonNewMusic'][i][j] = ''
      for (let k = 0; k < 512; k++) {
        PlayData['SecretDoor'][i][j][k] = false
        PlayData['LockedDoor'][i][j][k] = false
        PlayData['WallFlag'][i][j][k] = true
      }
    }
  }
  controlFlag(GameData['INITIAL_FLAG'])
  GenericVariable['TextMemoryNum'] = -1
  GenericVariable['Message'] = []
  GenericVariable['MessageCountMax'] = -1
  GenericVariable['MessageCount'] = 0
  GenericVariable['MessageLine'] = 3
  GenericVariable['MessageAlign'] = 'left'
  GenericVariable['MessageThrough'] = false
  GenericVariable['TimeEvent'] = ''
  GenericVariable['TimeEventCountMax'] = 0
  GenericVariable['TimeEventCount'] = 0
  GenericVariable['MonsterGraphic'] = false
}
function isLocalhost () {
  let str = (window.location.protocolstrAry = ['file:'])
  for (let i = 0; i < strAry.length; i++) {
    if (strAry[i] === str) {
      return true
    }
  }
  return false
}
function keyAction (key) {
  if (key == '') {
    key = 'none'
  }
  if (GameState == 'webFontLoadingEnd') {
    GameState = 'launchLoading'
    LoopLoadingID = requestAnimationFrame(loopLoading)
    main('webFont')
  } else if (GameState == 'stopLoading') {
    if (key == 'game_window') {
      GameState = 'launchLoading'
      LoopLoadingID = requestAnimationFrame(loopLoading)
      main('init')
    }
  } else if (GenericVariable['FullKeyInvalid']) {
    return
  } else if (key == 'reset') {
    GenericVariable['Reset'] = true
  } else if (GenericVariable['KeyInvalid']) {
    return
  } else if (key.match(/_volume_/)) {
    let name, configName
    if (key.match(/bgm_/)) {
      name = 'bgm_volume'
      configName = 'BgmVolume'
    } else {
      name = 'se_volume'
      configName = 'SeVolume'
    }
    let num = Number(Config[configName])
    if (key.match(/_up/)) {
      if (num < 100) {
        num += 5
      }
    } else {
      if (num > 0) {
        num -= 5
      }
    }
    Config[configName] = String(num)
    MP.OptionParts[name]._element.textContent = Config[configName]
    configSave()
    if (key.match(/bgm_/)) {
      if (NowMusic != '') {
        if (
          MusicData[NowMusic] != undefined &&
          MusicData[NowMusic] != null &&
          Config['Bgm']
        ) {
          MusicData[NowMusic].volume = calTimes(
            Number(Config['BgmVolume']),
            0.01
          )
        }
      }
    }
  } else if (Mode == 'optionKeyname') {
    MP.setOptionMode('option')
  } else if (Mode == 'optionKeyConfig') {
    if (key == 'option' || key == 'controller' || key == 'keyConfigCancel') {
      MP.setOptionMode('clear')
      MP.setOptionMode('option')
    }
  } else if (Mode == 'option') {
    if (!SoundPlayLimit && (key == 'option' || key == 'controller')) {
      MP.setOptionMode('clear')
    }
  } else if (key == 'option') {
    if (MP.OptionParts['text']._element.style.visibility == 'hidden') {
      MP.setOptionMode('option')
    }
  } else if (
    GameState == 'battleCommand' &&
    key == 'status' &&
    GameData['SPELL_EFFECT_INDICATED'][0]
  ) {
    let pcNum = PlayData['StatusNum']
    if (pcNum > -1) {
      TempVariable['viewStatus'] =
        PARTY[PlayData['ActiveParty']].getMemberForPcNum(pcNum)
      GameState = 'battleStatus'
      battleAction()
    }
  } else if (GameState == 'battleStatus') {
    if (key.match(/(up|down|right|left)/)) {
      let pt = PARTY[PlayData['ActiveParty']]
      let memberNum = pt.getMemberNum()
      let mGroup = 1
      for (let i = 3; i > 0; i--) {
        if (TempVariable['monsterNum'][i] > 0) {
          mGroup = i + 1
          break
        }
      }
      let num = TempVariable['viewStatus']
      if (key == 'up') {
        num = Math.floor(num / 10) + 1
        if (num > mGroup) {
          num = 0
        } else {
          num *= 10
        }
      } else if (key == 'down') {
        num = Math.floor(num / 10) - 1
        if (num < 0) {
          num = mGroup * 10
        } else if (num > 0) {
          num *= 10
        }
      } else if (key.match(/right/)) {
        if (num < 10) {
          num++
          if (num >= memberNum) {
            num = 0
          }
        } else {
          let numAry = [Math.floor((num - 10) / 10), num % 10]
          numAry[1]++
          if (numAry[1] >= TempVariable['monsterNum'][numAry[0]]) {
            numAry[1] = 0
          }
          num = 10 + numAry[0] * 10 + numAry[1]
        }
      } else if (key.match(/left/)) {
        if (num < 10) {
          num--
          if (num < 0) {
            num = memberNum - 1
          }
        } else {
          let numAry = [Math.floor((num - 10) / 10), num % 10]
          numAry[1]--
          if (numAry[1] < 0) {
            numAry[1] = TempVariable['monsterNum'][numAry[0]] - 1
          }
          num = 10 + numAry[0] * 10 + numAry[1]
        }
      }
      TempVariable['viewStatus'] = num
      battleAction()
    } else if (key.match(/(enter|cancel|escape|status)/)) {
      MP.StatusTopSurface.clear()
      GameState = 'battleCommand'
    }
  } else if (GameState == 'inStone') {
    if (key.match(/(enter|cancel|escape)/)) {
      GameState = 'annihilate'
      MP.viewRip()
      annihilateProcessing(true)
    }
  } else if (GameState == 'annihilate') {
    if (key.match(/(enter|cancel|escape)/)) {
      GameState = 'castleTownStart'
      townAction()
    }
  } else if (key == 'debug' && GameData['DEBUG']) {
    if (
      Mode != 'option' &&
      MP.OptionParts['text']._element.style.visibility == 'hidden'
    ) {
      GenericVariable['FullKeyInvalid'] = true
      Mode = 'debug'
      MP.paintMask()
      MP.controlInputText('set')
      GenericVariable['ReturnKeyControll'] = 0
    }
  } else if (MP.OptionParts['text']._element.style.visibility == 'visible') {
    keyActionInputText(key)
  } else if (MP.SelectMode['run']) {
    selectKeyAction(key)
  } else if (GameState.match(/InputKey/)) {
    if (!key.match(/^(controller|game_window|none)$/)) {
      let enterOrCancel = false
      if (key.indexOf('enter') > -1 || key.match(/^(cancel|escape)$/)) {
        enterOrCancel = true
      }
      if (GameState.match(/^moveFloorInputKey/)) {
        if (GameState.match(/SpellSound$/)) {
          sePlay('spell')
        }
        MP.paintDungeon('clear')
        MP.clearTextSurface('all')
        GenericVariable['KeyInvalid'] = true
        GenericVariable['TimeEventCountMax'] = TIME_COUNT[1]
        GenericVariable['TimeEventCount'] = 0
        GenericVariable['TimeEvent'] = 'moveFloor'
      } else if (GameState.match(/^moveReturnInputKey/)) {
        if (enterOrCancel) {
          let mode = 'none'
          if (GameState.match(/Step$/)) {
            mode = 'step'
          }
          GameState = 'move'
          dungeonAction(mode)
        }
      } else if (GameState == 'battleStartInputKey') {
        if (enterOrCancel) {
          GameState = 'battleStart2'
          battleAction()
        }
      } else {
        GameState = GameState.replace(/InputKey$/, '')
        GenericVariable['ReturnAction']()
      }
    }
  } else if (GameState.match(/Return$/)) {
    if (!key.match(/^(controller|game_window|none)$/)) {
      if (GenericVariable['Message'].length > 0) {
        if (
          !GenericVariable['MessageThrough'] &&
          key.indexOf('enter') < 0 &&
          !key.match(/^(cancel|escape)$/)
        ) {
          return
        }
        GenericVariable['Message'].splice(0, 1)
      }
      if (GenericVariable['Message'].length > 0) {
        MP.clearTextSurface()
        MP.drawTextFrame(
          MP.TextSurface[MP.TextSurfaceNum],
          GenericVariable['Message'][0],
          'center',
          MP.LINE_HEIGHT * 3,
          38,
          0,
          GenericVariable['MessageAlign']
        )
      } else {
        let ck = false
        if (GameState.match(/NotEnterReturn$/)) {
          if (key.indexOf('enter') > -1 || key.match(/^(cancel|escape)$/)) {
            if (GenericVariable['TimeEvent'].indexOf('mapLocation') > -1) {
              GenericVariable['TimeEvent'] = ''
            }
            ck = true
          }
        } else {
          ck = true
        }
        if (ck) {
          GameState = GameState.replace(/NotEnterReturn$/, '')
          GameState = GameState.replace(/Return$/, '')
          if (GameState.match(/^trainingCreate/)) {
            GameState = 'training'
            MP.SelectMode['valueAry'][MP.SelectMode['select']] = 'create'
            townAction('enter')
          } else if (GameState.match(/Clear$/)) {
            GameState = GameState.replace(/Clear$/, '')
            GenericVariable['ReturnAction']()
          } else if (GameState == 'move') {
            dungeonAction('none')
          } else if (GameState == 'moveStep') {
            GameState = 'move'
            dungeonAction('step')
          } else {
            GenericVariable['ReturnAction']('return')
          }
        }
      }
    }
  } else if (GameState == 'move') {
    if (!key.match(/^(controller|game_window|none)$/)) {
      if (key == 'escape') {
        key = 'cancel'
      } else if (key == 'real_enter') {
        key = 'enter'
      }
      dungeonAction(key)
    }
  } else if (GameState == 'mapText') {
    if (!key.match(/^(controller|game_window|none)$/)) {
      if (!key.match(/up|down|right|left/)) {
        MP.clearTextSurface()
        GameState = 'move'
        dungeonAction('none')
      }
    }
  } else if (GameState.match(/^map/)) {
    if (!key.match(/^(controller|game_window|none)$/)) {
      if (key == 'escape') {
        key = 'cancel'
      } else if (key == 'real_enter') {
        key = 'enter'
      } else if (key.indexOf('shift') > -1) {
        key = key.replace(/shift_/, '')
      }
      if (!key.match(/^(up|down|right|left)$/)) {
        MP.StatusSurface.clear()
        GenericVariable['TimeEvent'] = ''
        if (GameState == 'map') {
          GameState = 'move'
          dungeonAction('none')
        } else if (GameState.match(/^mapCamp/)) {
          PlayData['StatusNow'] = 'status'
          if (GameState == 'mapCampSpell') {
            GameState = 'inspectCastResult'
          } else {
            GameState = 'inspectItemUseResult'
          }
          statusAction()
        } else if (GameState.match(/^mapEvent/)) {
          let mode
          if (GameState == 'mapEventStep') {
            mode = 'step'
          } else {
            mode = 'none'
          }
          GameState = 'move'
          dungeonAction(mode)
        }
      } else if (key.match(/^(up|down)$/)) {
        let viewFlag = false
        if (key == 'up') {
          if (TempVariable['floor'] < TempVariable['mapViewFloor'].length - 1) {
            TempVariable['floor']++
            viewFlag = true
          }
        } else if (key == 'down') {
          if (TempVariable['floor'] > 0) {
            TempVariable['floor']--
            viewFlag = true
          }
        }
        if (viewFlag) {
          let viewFloor = TempVariable['mapViewFloor'][TempVariable['floor']]
          let x = -1,
            y = -1,
            d = -1
          let pt = PARTY[PlayData['ActiveParty']]
          if (
            viewFloor == pt.Floor &&
            TempVariable['x'] > -1 &&
            TempVariable['y'] > -1
          ) {
            x = TempVariable['x']
            y = TempVariable['y']
            d = TempVariable['direction']
          } else {
            MP.StatusSurface.clear()
            GenericVariable['TimeEvent'] = ''
          }
          MP.drawMap(
            pt.DungeonNumber,
            viewFloor,
            x,
            y,
            d,
            GameData['AUTO_MAP_TRAP'],
            GameData['AUTO_MAP_EVENT']
          )
        }
      }
    }
  } else if (GameState.match(/^teleportText/)) {
    if (key.match(/(enter|cancel|escape|up|down|right|left)/)) {
      let ary = SPELL_EF.Effect.split(',')
      if (key.match(/^(cancel|escape)$/)) {
        sePlay('cancel')
        TempVariable['select'] = 0
        TempVariable['floor'] = 0
        TempVariable['x'] = 0
        TempVariable['y'] = 0
      } else if (key.indexOf('enter') > -1) {
        let pt = PARTY[PlayData['ActiveParty']]
        let floor = pt.Floor + TempVariable['floor']
        let x = pt.X + TempVariable['x']
        let y = pt.Y + TempVariable['y']
        if (SPELL_EF.checkPointTeleport(floor, x, y)) {
          sePlay('spell')
          TempVariable['nextDungeon'] = pt.DungeonNumber
          TempVariable['nextFloor'] = floor
          TempVariable['nextX'] = x
          TempVariable['nextY'] = y
          GenericVariable['KeyInvalid'] = true
          GenericVariable['TimeEventCountMax'] = TIME_COUNT[1]
          GenericVariable['TimeEventCount'] = 0
          GenericVariable['TimeEvent'] = 'moveFloorInRockFromCamp'
        } else {
          PlayData['StatusNow'] = 'status'
          if (GameState.indexOf('Spell') > -1) {
            GameState = 'inspectCastResult'
          } else {
            GameState = 'inspectItemUseResult'
          }
          GameState += 'Fizzle'
          statusAction()
        }
        return
      } else if (key == 'up') {
        sePlay('select')
        TempVariable['select']--
        if (TempVariable['select'] < 0) {
          TempVariable['select'] = 2
        }
      } else if (key == 'down') {
        sePlay('select')
        TempVariable['select']++
        if (TempVariable['select'] > 2) {
          TempVariable['select'] = 0
        }
      } else if (key.indexOf('right') > -1) {
        sePlay('select')
        if (TempVariable['select'] == 0) {
          TempVariable['x']++
          if (TempVariable['x'] > 19) {
            TempVariable['x'] = -19
          }
        } else if (TempVariable['select'] == 1) {
          TempVariable['y']++
          if (TempVariable['y'] > 19) {
            TempVariable['y'] = -19
          }
        } else if (TempVariable['select'] == 2 && ary[1] == '0') {
          TempVariable['floor']++
          if (TempVariable['floor'] > 15) {
            TempVariable['floor'] = -15
          }
        }
      } else if (key.indexOf('left') > -1) {
        sePlay('select')
        if (TempVariable['select'] == 0) {
          TempVariable['x']--
          if (TempVariable['x'] < -19) {
            TempVariable['x'] = 19
          }
        } else if (TempVariable['select'] == 1) {
          TempVariable['y']--
          if (TempVariable['y'] < -19) {
            TempVariable['y'] = 19
          }
        } else if (TempVariable['select'] == 2 && ary[1] == '0') {
          TempVariable['floor']--
          if (TempVariable['floor'] < -15) {
            TempVariable['floor'] = 15
          }
        }
      }
      MP.drawPartyTeleport(
        TempVariable['select'],
        TempVariable['x'],
        TempVariable['y'],
        TempVariable['floor']
      )
    }
  } else if (GameState.match(/^teleport(Spell|Item)$/)) {
    if (key.match(/(enter|cancel|escape|up|down|right|left)/)) {
      let pt = PARTY[PlayData['ActiveParty']]
      if (key.match(/^(cancel|escape)$/)) {
        sePlay('cancel')
        if (TempVariable['mapViewFloor'].length < 2) {
          if (GameData['TELEPORT_START_ZERO']) {
            TempVariable['x'] = 0
            TempVariable['y'] = 0
          } else {
            TempVariable['x'] = pt.X
            TempVariable['y'] = pt.Y
          }
        } else {
          MP.StatusSurface.clear()
          GenericVariable['TimeEvent'] = ''
          if (GameState.indexOf('Spell') > -1) {
            GameState = 'teleportFloorSpell'
          } else {
            GameState = 'teleportFloorItem'
          }
          statusAction()
          return
        }
      } else if (key.indexOf('enter') > -1) {
        if (
          SPELL_EF.checkPointTeleport(
            TempVariable['floor'],
            TempVariable['x'],
            TempVariable['y']
          )
        ) {
          sePlay('spell')
          TempVariable['nextDungeon'] =
            PARTY[PlayData['ActiveParty']].DungeonNumber
          TempVariable['nextFloor'] = TempVariable['floor']
          TempVariable['nextX'] = TempVariable['x']
          TempVariable['nextY'] = TempVariable['y']
          GenericVariable['KeyInvalid'] = true
          GenericVariable['TimeEventCountMax'] = TIME_COUNT[1]
          GenericVariable['TimeEventCount'] = 0
          GenericVariable['TimeEvent'] = 'moveFloorFromCamp'
        } else {
          GenericVariable['TimeEvent'] = ''
          PlayData['StatusNow'] = 'status'
          if (GameState.indexOf('Spell') > -1) {
            GameState = 'inspectCastResult'
          } else {
            GameState = 'inspectItemUseResult'
          }
          GameState += 'Fizzle'
          statusAction()
        }
        return
      } else if (key.match(/up|down|right|left/)) {
        let width = DUNGEON.Width[pt.DungeonNumber]
        let height = DUNGEON.Height[pt.DungeonNumber]
        sePlay('select')
        if (key == 'up') {
          TempVariable['y']++
          if (TempVariable['y'] >= height) {
            TempVariable['y'] = 0
          }
        } else if (key == 'down') {
          TempVariable['y']--
          if (TempVariable['y'] < 0) {
            TempVariable['y'] = height - 1
          }
        } else if (key.indexOf('right') > -1) {
          TempVariable['x']++
          if (TempVariable['x'] >= width) {
            TempVariable['x'] = 0
          }
        } else if (key.indexOf('left') > -1) {
          TempVariable['x']--
          if (TempVariable['x'] < 0) {
            TempVariable['x'] = width - 1
          }
        }
      }
      MP.StatusSurface.clear()
      GenericVariable['TimeEvent'] = 'mapLocation'
      GenericVariable['TimeEventCount'] = TIME_COUNT[0]
    }
  } else {
    console.log('no keyAction')
  }
}
function keyActionInputText (key) {
  if (key == 'up') {
    GenericVariable['TextMemoryNum']++
    if (GenericVariable['TextMemoryNum'] >= Config['TextMemory'].length) {
      GenericVariable['TextMemoryNum'] = Config['TextMemory'].length - 1
    }
    if (GenericVariable['TextMemoryNum'] > -1) {
      let num =
        Config['TextMemory'].length - GenericVariable['TextMemoryNum'] - 1
      MP.OptionParts['text']._element.value = Config['TextMemory'][num]
      GenericVariable['TimeEventCountMax'] = 1
      GenericVariable['TimeEventCount'] = 0
      GenericVariable['TimeEvent'] = 'textMemory'
    }
  } else if (key == 'down') {
    if (GenericVariable['TextMemoryNum'] > -1) {
      GenericVariable['TextMemoryNum']--
    }
    if (GenericVariable['TextMemoryNum'] >= Config['TextMemory'].length) {
      GenericVariable['TextMemoryNum'] = Config['TextMemory'].length - 1
    }
    if (GenericVariable['TextMemoryNum'] < 0) {
      MP.OptionParts['text']._element.value = ''
    } else {
      let num =
        Config['TextMemory'].length - GenericVariable['TextMemoryNum'] - 1
      MP.OptionParts['text']._element.value = Config['TextMemory'][num]
    }
  } else if (key.indexOf('enter') > -1) {
    let str = MP.OptionParts['text']._element.value
    if (str == '') {
      if (!Mode.match(/debug|optionKeyConfig[A-Z_]+/)) {
        sePlay('cancel')
      }
      cancelInputText()
    } else {
      GenericVariable['TextMemoryNum'] = -1
      MP.OptionParts['text']._element.value = ''
      if (Mode == 'debug') {
        str = str.replace(/^\s+|\s+$/, '')
        str = str.replace(/<BR>|<br>/g, '')
        if (str == '') {
          return
        }
      } else if (Mode.match(/optionKeyConfig[A-Z_]+/)) {
        str = str.replace(/^\s+|\s+$/, '')
        str = str.replace(/<BR>|<br>/g, '')
        str = str.replace(/=/g, '')
        if (str == '') {
          MP.OptionParts['text']._element.value = ''
          return
        }
      } else if (Mode == 'setFaceGraphic') {
        str = str.replace(/^\s+|\s+$/, '')
        str = str.replace(/<>|[,"]/g, '')
        if (str != '') {
          sePlay('enter')
        } else {
          return
        }
      } else {
        str = str.replace(/<>|<BR>|<br>/g, '')
        str = str.replace(/\s+$/, '')
        if (str != '') {
          sePlay('enter')
        } else {
          return
        }
      }
      let pushOk = true
      if (Config['TextMemory'].length > 0) {
        let preStr = Config['TextMemory'][Config['TextMemory'].length - 1]
        if (str == preStr) {
          pushOk = false
        }
      }
      if (pushOk) {
        Config['TextMemory'].push(str)
      }
      while (Config['TextMemory'].length > TEXT_MEMORY_LENGTH) {
        Config['TextMemory'].splice(0, 1)
      }
      configSave()
      if (Mode == 'debug') {
        debugCommand(str)
      } else if (Mode.match(/optionKeyConfig[A-Z_]+/)) {
        let mode = Mode.replace(/optionKeyConfig/, '')
        str = MP.zenkaku2hankaku(str)
        str = str.replace(/[、，]/g, ',')
        if (KeyConfigData2['KEY_' + mode] != str) {
          KeyConfigData2['KEY_' + mode] = str
          setKeyConfig(KeyConfigData2)
          configSave()
        }
        MP.controlInputText('clear')
        MP.ButtonObject['game_window_div'].style.display = 'none'
        if (MP.ButtonObject['escape_div'] != undefined) {
          MP.ButtonObject['escape_div'].style.display = 'none'
        }
        MP.setOptionMode('keyConfig')
      } else {
        PlayData['InputText'] = str
        GenericVariable['FullKeyInvalid'] = true
        MP.controlInputText('clear')
        if (GameState.match(/^training/)) {
          townAction('enter')
        } else if (GameState == 'moveEvent3inputText') {
          str = MP.zenkaku2hankaku(str)
          if (TempVariable['eventAry'].indexOf(str) > -1) {
            GameState = 'moveEvent4_1'
          } else {
            GameState = 'moveEvent4_2'
          }
          dungeonAction()
        } else if (GameState == 'setFaceGraphic') {
          if (str == 'none') {
            str = ''
          }
          let pcNum = PlayData['StatusNum']
          let oldFaceGraphic = PC[pcNum].FaceGraphic
          if (PC[pcNum].FaceGraphic != str) {
            PC[pcNum].FaceGraphic = str
            let oldFile, newFile
            if (oldFaceGraphic.match(/^(| |none)$/)) {
              oldFile = PC[pcNum].Name[0]
            } else {
              oldFile = '<>' + oldFaceGraphic
            }
            if (str.match(/^(| |none)$/)) {
              newFile = PC[pcNum].Name[0]
            } else {
              newFile = '<>' + str
            }
            readGraphicFile_Face(oldFile, newFile, readEndAction)
            return
          }
          MP.paintMask('clear')
          MP.TopSurface.clear()
          GameState = 'inspectCommand'
          MP.SelectMode['valueAry'][MP.SelectMode['select']] = 'setFaceGraphic'
          statusAction('return')
        }
        GenericVariable['ReturnKeyControll'] = 0
      }
    }
  } else if (key.match(/^(cancel|escape)$/)) {
    if (!Mode.match(/debug|optionKeyConfig[A-Z_]+/)) {
      sePlay('cancel')
    }
    cancelInputText()
  }
}
function loadData () {
  let dataStr = localStorage.getItem(SaveName + 'Save')
  if (dataStr == null) {
    return false
  }
  let data = base64.decode(dataStr, 1)
  if (!checkSaveData(data)) {
    return false
  }
  let dataAry = data.split(/\n/)
  let ptList = [],
    ary
  if (dataAry.length >= 79) {
    ary = dataAry[78].split(',')
    for (let i = 0; i < PC_ENTRY_MIN; i++) {
      let pm = Number(ary[i * 6])
      if (pm > -1) {
        ptList.push(i)
      }
    }
    if (dataAry.length >= 771) {
      ary = dataAry[770].split(',')
      let len
      if (dataAry[770] == '') {
        len = 0
      } else {
        len = ary.length
      }
      for (let i = 0; i < len; i++) {
        let pm = Number(ary[i])
        if (pm > -1) {
          ptList.push(i + PC_ENTRY_MIN)
        }
      }
    }
  }
  if (dataAry.length < 2) {
    return false
  }
  data = dataAry[1]
  data == '1'
    ? (PlayData['ShopItemListFull'] = true)
    : (PlayData['ShopItemListFull'] = false)
  if (dataAry.length < 3) {
    return false
  }
  data = dataAry[2]
  for (let i = 0; i < data.length; i++) {
    data.charAt(i) == '1'
      ? (PlayData['GameFlag'][i] = true)
      : (PlayData['GameFlag'][i] = false)
  }
  if (dataAry.length < 4) {
    return false
  }
  data = dataAry[3]
  for (let i = 0; i < data.length; i++) {
    data.charAt(i) == '1'
      ? (PlayData['ItemFlag'][i] = true)
      : (PlayData['ItemFlag'][i] = false)
  }
  if (dataAry.length < 5) {
    return false
  }
  data = dataAry[4]
  for (let i = 0; i < data.length; i++) {
    data.charAt(i) == '1'
      ? (PlayData['MonsterFlag'][i] = true)
      : (PlayData['MonsterFlag'][i] = false)
  }
  let pEyMax = GameData['PC_ENTRY_MAX']
  if (dataAry.length < 6) {
    return false
  }
  data = dataAry[5]
  PlayData['PcMax'] = Number(data)
  if (PlayData['PcMax'] > pEyMax) {
    PlayData['PcMax'] = pEyMax
  }
  let pcMax = PlayData['PcMax']
  if (dataAry.length < 7) {
    return false
  }
  data = dataAry[6]
  let num = ptList.indexOf(Number(data))
  PlayData['ActiveParty'] = num
  if (dataAry.length < 8) {
    return false
  }
  data = dataAry[7]
  ary = data.split(',')
  let pcList = []
  for (let i = 0; i < ary.length; i++) {
    pcList.push(Number(ary[i]))
  }
  if (dataAry.length < 9) {
    return false
  }
  data = dataAry[8]
  ary = data.split('<>')
  for (let i = 0; i < ary.length; i++) {
    PlayData['GarbageItem'][i] = ary[i]
  }
  if (dataAry.length < 10) {
    return false
  }
  data = dataAry[9]
  for (let i = 0; i < pEyMax; i++) {
    if (i >= pcList.length || i >= pcMax) {
      break
    }
    if (data.charAt(pcList[i]) == 1) {
      PC[i].SealSpell = true
    }
  }
  if (dataAry.length < 11) {
    return false
  }
  data = dataAry[10]
  for (let i = 0; i < pEyMax; i++) {
    if (i >= pcList.length || i >= pcMax) {
      break
    }
    PC[i].Sex = Number(data.charAt(pcList[i]))
  }
  if (dataAry.length < 12) {
    return false
  }
  data = dataAry[11]
  ary = data.split(',')
  for (let i = 0; i < pEyMax; i++) {
    if (i >= pcList.length || i >= pcMax) {
      break
    }
    PC[i].Race = Number(ary[pcList[i]])
  }
  if (dataAry.length < 13) {
    return false
  }
  data = dataAry[12]
  for (let i = 0; i < pEyMax; i++) {
    if (i >= pcList.length || i >= pcMax) {
      break
    }
    PC[i].Alignment = Number(data.charAt(pcList[i]))
  }
  if (dataAry.length < 14) {
    return false
  }
  data = dataAry[13]
  ary = data.split(',')
  for (let i = 0; i < pEyMax; i++) {
    if (i >= pcList.length || i >= pcMax) {
      break
    }
    PC[i].PcClass = Number(ary[pcList[i]])
  }
  if (dataAry.length < 15) {
    return false
  }
  data = dataAry[14]
  ary = data.split(',')
  for (let i = 0; i < pEyMax; i++) {
    if (i >= pcList.length || i >= pcMax) {
      break
    }
    PC[i].State = Number(ary[pcList[i]])
  }
  if (dataAry.length < 16) {
    return false
  }
  data = dataAry[15]
  ary = data.split(',')
  for (let i = 0; i < pEyMax; i++) {
    if (i >= pcList.length || i >= pcMax) {
      break
    }
    let pn = ptList.indexOf(Number(ary[pcList[i]]))
    if (pn < pEyMax) {
      PC[i].PartyNum = pn
    } else {
      PC[i].PartyNum = -1
    }
  }
  if (dataAry.length < 17) {
    return false
  }
  data = dataAry[16]
  ary = data.split(',')
  for (let i = 0; i < pEyMax; i++) {
    if (i >= pcList.length || i >= pcMax) {
      break
    }
    PC[i].Age = Number(ary[pcList[i]])
  }
  if (dataAry.length < 18) {
    return false
  }
  data = dataAry[17]
  ary = data.split(',')
  for (let i = 0; i < pEyMax; i++) {
    if (i >= pcList.length || i >= pcMax) {
      break
    }
    PC[i].Days = Number(ary[pcList[i]])
  }
  if (dataAry.length < 19) {
    return false
  }
  data = dataAry[18]
  ary = data.split(',')
  for (let i = 0; i < pEyMax; i++) {
    if (i >= pcList.length || i >= pcMax) {
      break
    }
    PC[i].HpMax0 = Number(ary[pcList[i]])
  }
  if (dataAry.length < 20) {
    return false
  }
  data = dataAry[19]
  ary = data.split(',')
  for (let i = 0; i < pEyMax; i++) {
    if (i >= pcList.length || i >= pcMax) {
      break
    }
    PC[i].Hp = Number(ary[pcList[i]])
  }
  if (dataAry.length < 21) {
    return false
  }
  data = dataAry[20]
  ary = data.split(',')
  for (let i = 0; i < pEyMax; i++) {
    if (i >= pcList.length || i >= pcMax) {
      break
    }
    PC[i].SealSpellInt = Number(ary[pcList[i]])
  }
  if (dataAry.length < 22) {
    return false
  }
  data = dataAry[21]
  ary = data.split(',')
  for (let i = 0; i < pEyMax; i++) {
    if (i >= pcList.length || i >= pcMax) {
      break
    }
    PC[i].Level = Number(ary[pcList[i]])
  }
  if (dataAry.length < 23) {
    return false
  }
  data = dataAry[22]
  ary = data.split(',')
  for (let i = 0; i < pEyMax; i++) {
    if (i >= pcList.length || i >= pcMax) {
      break
    }
    PC[i].Rip = Number(ary[pcList[i]])
  }
  if (dataAry.length < 24) {
    return false
  }
  data = dataAry[23]
  ary = data.split(',')
  for (let i = 0; i < pEyMax; i++) {
    if (i >= pcList.length || i >= pcMax) {
      break
    }
    PC[i].Poison = Number(ary[pcList[i]])
  }
  if (dataAry.length < 25) {
    return false
  }
  data = dataAry[24]
  ary = data.split(',')
  for (let i = 0; i < pEyMax; i++) {
    if (i >= pcList.length || i >= pcMax) {
      break
    }
    PC[i].SpellEffectRate[0] = Number(ary[pcList[i]])
  }
  if (dataAry.length < 26) {
    return false
  }
  data = dataAry[25]
  ary = data.split(',')
  for (let i = 0; i < pEyMax; i++) {
    if (i >= pcList.length || i >= pcMax) {
      break
    }
    PC[i].SpellEffectPlus[0] = Number(ary[pcList[i]])
  }
  if (dataAry.length < 27) {
    return false
  }
  data = dataAry[26]
  ary = data.split(',')
  for (let i = 0; i < pEyMax; i++) {
    if (i >= pcList.length || i >= pcMax) {
      break
    }
    PC[i].SpellEffectRate[1] = Number(ary[pcList[i]])
  }
  if (dataAry.length < 28) {
    return false
  }
  data = dataAry[27]
  ary = data.split(',')
  for (let i = 0; i < pEyMax; i++) {
    if (i >= pcList.length || i >= pcMax) {
      break
    }
    PC[i].SpellEffectPlus[1] = Number(ary[pcList[i]])
  }
  if (dataAry.length < 29) {
    return false
  }
  data = dataAry[28]
  ary = data.split(',')
  for (let i = 0; i < pEyMax; i++) {
    if (i >= pcList.length || i >= pcMax) {
      break
    }
    PC[i].SpellEffectRate[5] = Number(ary[pcList[i]])
  }
  if (dataAry.length < 30) {
    return false
  }
  data = dataAry[29]
  ary = data.split(',')
  for (let i = 0; i < pEyMax; i++) {
    if (i >= pcList.length || i >= pcMax) {
      break
    }
    PC[i].SpellEffectPlus[5] = Number(ary[pcList[i]])
  }
  if (dataAry.length < 31) {
    return false
  }
  data = dataAry[30]
  ary = data.split(',')
  for (let i = 0; i < pEyMax; i++) {
    if (i >= pcList.length || i >= pcMax) {
      break
    }
    PC[i].SpellEffectRate[2] = Number(ary[pcList[i]])
  }
  if (dataAry.length < 32) {
    return false
  }
  data = dataAry[31]
  ary = data.split(',')
  for (let i = 0; i < pEyMax; i++) {
    if (i >= pcList.length || i >= pcMax) {
      break
    }
    PC[i].SpellEffectPlus[2] = Number(ary[pcList[i]])
  }
  if (dataAry.length < 33) {
    return false
  }
  data = dataAry[32]
  ary = data.split(',')
  for (let i = 0; i < pEyMax; i++) {
    if (i >= pcList.length || i >= pcMax) {
      break
    }
    PC[i].SpellEffectRate[3] = Number(ary[pcList[i]])
  }
  if (dataAry.length < 34) {
    return false
  }
  data = dataAry[33]
  ary = data.split(',')
  for (let i = 0; i < pEyMax; i++) {
    if (i >= pcList.length || i >= pcMax) {
      break
    }
    PC[i].SpellEffectPlus[3] = Number(ary[pcList[i]])
  }
  if (dataAry.length < 35) {
    return false
  }
  data = dataAry[34]
  ary = data.split(',')
  for (let i = 0; i < pEyMax; i++) {
    if (i >= pcList.length || i >= pcMax) {
      break
    }
    PC[i].SpellEffectRate[4] = Number(ary[pcList[i]])
  }
  if (dataAry.length < 36) {
    return false
  }
  data = dataAry[35]
  ary = data.split(',')
  for (let i = 0; i < pEyMax; i++) {
    if (i >= pcList.length || i >= pcMax) {
      break
    }
    PC[i].SpellEffectPlus[4] = Number(ary[pcList[i]])
  }
  if (dataAry.length < 37) {
    return false
  }
  data = dataAry[36]
  ary = data.split(',')
  for (let i = 0; i < pEyMax; i++) {
    if (i >= pcList.length || i >= pcMax) {
      break
    }
    PC[i].Exp = Number(ary[pcList[i]])
  }
  if (dataAry.length < 38) {
    return false
  }
  data = dataAry[37]
  ary = data.split(',')
  for (let i = 0; i < pEyMax; i++) {
    if (i >= pcList.length || i >= pcMax) {
      break
    }
    PC[i].Gold = Number(ary[pcList[i]])
  }
  if (dataAry.length < 39) {
    return false
  }
  data = dataAry[38]
  ary = data.split(',')
  for (let i = 0; i < pEyMax; i++) {
    if (i >= pcList.length || i >= pcMax) {
      break
    }
    PC[i].Marks = Number(ary[pcList[i]])
  }
  if (dataAry.length < 40) {
    return false
  }
  data = dataAry[39]
  ary = data.split('<>')
  for (let i = 0; i < pEyMax; i++) {
    if (i >= pcList.length || i >= pcMax) {
      break
    }
    if (ary[pcList[i]] == ' ') {
      ary[pcList[i]] = ''
    }
    PC[i].Name[0] = ary[pcList[i]]
  }
  if (dataAry.length < 41) {
    return false
  }
  data = dataAry[40]
  ary = data.split('<>')
  for (let i = 0; i < pEyMax; i++) {
    if (i >= pcList.length || i >= pcMax) {
      break
    }
    PC[i].Title = ary[pcList[i]]
  }
  if (dataAry.length < 42) {
    return false
  }
  data = dataAry[41]
  ary = data.split('<>')
  for (let i = 0; i < pEyMax; i++) {
    if (i >= pcList.length || i >= pcMax) {
      break
    }
    PC[i].Transmigrates = ary[pcList[i]]
  }
  if (dataAry.length < 43) {
    return false
  }
  data = dataAry[42]
  ary = data.split(',')
  for (let i = 0; i < ptList.length; i++) {
    if (i >= ary.length || i >= pEyMax) {
      break
    }
    PARTY[i].DungeonNumber = Number(ary[ptList[i]])
  }
  if (dataAry.length < 44) {
    return false
  }
  data = dataAry[43]
  ary = data.split(',')
  for (let i = 0; i < ptList.length; i++) {
    if (i >= ary.length || i >= pEyMax) {
      break
    }
    PARTY[i].Floor = Number(ary[ptList[i]])
  }
  if (dataAry.length < 45) {
    return false
  }
  data = dataAry[44]
  ary = data.split(',')
  for (let i = 0; i < ptList.length; i++) {
    if (i >= ary.length || i >= pEyMax) {
      break
    }
    PARTY[i].X = Number(ary[ptList[i]])
  }
  if (dataAry.length < 46) {
    return false
  }
  data = dataAry[45]
  ary = data.split(',')
  for (let i = 0; i < ptList.length; i++) {
    if (i >= ary.length || i >= pEyMax) {
      break
    }
    PARTY[i].Y = Number(ary[ptList[i]])
  }
  if (dataAry.length < 47) {
    return false
  }
  data = dataAry[46]
  for (let i = 0; i < ptList.length; i++) {
    if (i >= data.length || i >= pEyMax) {
      break
    }
    PARTY[i].Direction = Number(data.charAt(ptList[i]))
  }
  if (dataAry.length < 48) {
    return false
  }
  data = dataAry[47]
  ary = data.split(',')
  for (let i = 0; i < ptList.length; i++) {
    if (i >= ary.length || i >= pEyMax) {
      break
    }
    PARTY[i].Vision = Number(ary[ptList[i]])
  }
  if (dataAry.length < 49) {
    return false
  }
  data = dataAry[48]
  ary = data.split(',')
  for (let i = 0; i < ptList.length; i++) {
    if (i >= ary.length || i >= pEyMax) {
      break
    }
    PARTY[i].PtSpellEffectRate[0] = Number(ary[ptList[i]])
  }
  if (dataAry.length < 50) {
    return false
  }
  data = dataAry[49]
  ary = data.split(',')
  for (let i = 0; i < ptList.length; i++) {
    if (i >= ary.length || i >= pEyMax) {
      break
    }
    PARTY[i].PtSpellEffectPlus[0] = Number(ary[ptList[i]])
  }
  if (dataAry.length < 51) {
    return false
  }
  data = dataAry[50]
  ary = data.split(',')
  for (let i = 0; i < ptList.length; i++) {
    if (i >= ary.length || i >= pEyMax) {
      break
    }
    PARTY[i].SpellEffectRate[0] = Number(ary[ptList[i]])
  }
  if (dataAry.length < 52) {
    return false
  }
  data = dataAry[51]
  ary = data.split(',')
  for (let i = 0; i < ptList.length; i++) {
    if (i >= ary.length || i >= pEyMax) {
      break
    }
    PARTY[i].SpellEffectPlus[0] = Number(ary[ptList[i]])
  }
  if (dataAry.length < 53) {
    return false
  }
  data = dataAry[52]
  ary = data.split(',')
  for (let i = 0; i < ptList.length; i++) {
    if (i >= ary.length || i >= pEyMax) {
      break
    }
    PARTY[i].Flying = Number(ary[ptList[i]])
  }
  if (dataAry.length < 54) {
    return false
  }
  data = dataAry[53]
  ary = data.split(',')
  for (let i = 0; i < ptList.length; i++) {
    if (i >= ary.length || i >= pEyMax) {
      break
    }
    PARTY[i].SpellEffectRate[1] = Number(ary[ptList[i]])
  }
  if (dataAry.length < 55) {
    return false
  }
  data = dataAry[54]
  ary = data.split(',')
  for (let i = 0; i < ptList.length; i++) {
    if (i >= ary.length || i >= pEyMax) {
      break
    }
    PARTY[i].SpellEffectPlus[1] = Number(ary[ptList[i]])
  }
  if (dataAry.length < 56) {
    return false
  }
  data = dataAry[55]
  ary = data.split(',')
  for (let i = 0; i < ptList.length; i++) {
    if (i >= ary.length || i >= pEyMax) {
      break
    }
    PARTY[i].SpellEffectRate[5] = Number(ary[ptList[i]])
  }
  if (dataAry.length < 57) {
    return false
  }
  data = dataAry[56]
  ary = data.split(',')
  for (let i = 0; i < ptList.length; i++) {
    if (i >= ary.length || i >= pEyMax) {
      break
    }
    PARTY[i].SpellEffectPlus[5] = Number(ary[ptList[i]])
  }
  if (dataAry.length < 58) {
    return false
  }
  data = dataAry[57]
  ary = data.split(',')
  for (let i = 0; i < ptList.length; i++) {
    if (i >= ary.length || i >= pEyMax) {
      break
    }
    PARTY[i].SpellEffectRate[2] = Number(ary[ptList[i]])
  }
  if (dataAry.length < 59) {
    return false
  }
  data = dataAry[58]
  ary = data.split(',')
  for (let i = 0; i < ptList.length; i++) {
    if (i >= ary.length || i >= pEyMax) {
      break
    }
    PARTY[i].SpellEffectPlus[2] = Number(ary[ptList[i]])
  }
  if (dataAry.length < 60) {
    return false
  }
  data = dataAry[59]
  ary = data.split(',')
  for (let i = 0; i < ptList.length; i++) {
    if (i >= ary.length || i >= pEyMax) {
      break
    }
    PARTY[i].SpellEffectRate[3] = Number(ary[ptList[i]])
  }
  if (dataAry.length < 61) {
    return false
  }
  data = dataAry[60]
  ary = data.split(',')
  for (let i = 0; i < ptList.length; i++) {
    if (i >= ary.length || i >= pEyMax) {
      break
    }
    PARTY[i].SpellEffectPlus[3] = Number(ary[ptList[i]])
  }
  if (dataAry.length < 62) {
    return false
  }
  data = dataAry[61]
  ary = data.split(',')
  for (let i = 0; i < ptList.length; i++) {
    if (i >= ary.length || i >= pEyMax) {
      break
    }
    PARTY[i].SpellEffectRate[4] = Number(ary[ptList[i]])
  }
  if (dataAry.length < 63) {
    return false
  }
  data = dataAry[62]
  ary = data.split(',')
  for (let i = 0; i < ptList.length; i++) {
    if (i >= ary.length || i >= pEyMax) {
      break
    }
    PARTY[i].SpellEffectPlus[4] = Number(ary[ptList[i]])
  }
  if (dataAry.length < 64) {
    return false
  }
  data = dataAry[63]
  ary = data.split(',')
  for (let i = 0; i < ptList.length; i++) {
    if (i >= ary.length || i >= pEyMax) {
      break
    }
    PARTY[i].PtSpellEffectRate[1] = Number(ary[ptList[i]])
  }
  if (dataAry.length < 65) {
    return false
  }
  data = dataAry[64]
  ary = data.split(',')
  for (let i = 0; i < ptList.length; i++) {
    if (i >= ary.length || i >= pEyMax) {
      break
    }
    PARTY[i].PtSpellEffectPlus[1] = Number(ary[ptList[i]])
  }
  if (dataAry.length < 66) {
    return false
  }
  data = dataAry[65]
  ary = data.split(',')
  for (let i = 0; i < ptList.length; i++) {
    if (i >= ary.length || i >= pEyMax) {
      break
    }
    PARTY[i].PtSpellEffectRate[2] = Number(ary[ptList[i]])
  }
  if (dataAry.length < 67) {
    return false
  }
  data = dataAry[66]
  ary = data.split(',')
  for (let i = 0; i < ptList.length; i++) {
    if (i >= ary.length || i >= pEyMax) {
      break
    }
    PARTY[i].PtSpellEffectPlus[2] = Number(ary[ptList[i]])
  }
  if (dataAry.length < 68) {
    return false
  }
  data = dataAry[67]
  ary = data.split(',')
  for (let i = 0; i < ptList.length; i++) {
    if (i >= ary.length || i >= pEyMax) {
      break
    }
    PARTY[i].PtSpellEffectRate[3] = Number(ary[ptList[i]])
  }
  if (dataAry.length < 69) {
    return false
  }
  data = dataAry[68]
  ary = data.split(',')
  for (let i = 0; i < ptList.length; i++) {
    if (i >= ary.length || i >= pEyMax) {
      break
    }
    PARTY[i].PtSpellEffectPlus[3] = Number(ary[ptList[i]])
  }
  if (dataAry.length < 70) {
    return false
  }
  data = dataAry[69]
  for (let i = 0; i < ptList.length; i++) {
    if (i >= data.length || i >= pEyMax) {
      break
    }
    if (data.charAt(ptList[i]) == '1') {
      PARTY[i].Light = true
    }
  }
  if (dataAry.length < 71) {
    return false
  }
  data = dataAry[70]
  ary = data.split('<>')
  for (let i = 0; i < ptList.length; i++) {
    if (i >= ary.length || i >= pEyMax) {
      break
    }
    PARTY[i].FlyingEffect = ary[ptList[i]]
  }
  if (dataAry.length < 72) {
    return false
  }
  data = loadData_dataJoin(dataAry, 'item', 71, 117)
  for (let j = 0; j < 99; j++) {
    for (let i = 0; i < pEyMax; i++) {
      if (i >= data[j].length || i >= pcMax) {
        break
      }
      PC[i].Equip[j] = data[j][pcList[i]]
    }
  }
  if (dataAry.length < 73) {
    return false
  }
  data = loadData_dataJoin(dataAry, 'item', 72, 216)
  for (let j = 0; j < 99; j++) {
    for (let i = 0; i < pEyMax; i++) {
      if (i >= data[j].length || i >= pcMax) {
        break
      }
      PC[i].ItemDecided[j] = data[j][pcList[i]]
    }
  }
  if (dataAry.length < 74) {
    return false
  }
  data = loadData_dataJoin(dataAry, 'item', 73, 315)
  for (let j = 0; j < 99; j++) {
    for (let i = 0; i < pEyMax; i++) {
      if (i >= data[j].length || i >= pcMax) {
        break
      }
      PC[i].Item[j] = data[j][pcList[i]]
    }
  }
  if (dataAry.length < 75) {
    return false
  }
  data = loadData_dataJoin(dataAry, 'abi', 74, 414)
  let abiMax = 36
  if (dataAry[74].split(',').length == 360) {
    abiMax = 10
  }
  for (let j = 0; j < abiMax; j++) {
    for (let i = 0; i < pEyMax; i++) {
      if (i >= data[j].length || i >= pcMax) {
        break
      }
      let abiNum = data[j][pcList[i]]
      if (j < GameData['ABILITY'].length) {
        if (abiNum < 0 || (GameData['ABILITY_VALUE_ZERO'] && abiNum == 0)) {
          abiNum =
            GameData['RACE_ABI'][PC[i].Race][j] +
            GameData['ABILITY_SEX'][PC[i].Sex][j]
        }
      } else {
        abiNum = -1
      }
      PC[i].Ability0[j] = abiNum
    }
  }
  if (dataAry.length < 76) {
    return false
  }
  data = loadData_dataJoin(dataAry, 'mp', 75, 450)
  for (let k = 0; k < 10; k++) {
    for (let j = 0; j < 4; j++) {
      for (let i = 0; i < pEyMax; i++) {
        if (i >= data[j][k].length || i >= pcMax) {
          break
        }
        PC[i].Mp[j][k] = data[j][k][pcList[i]]
      }
    }
  }
  if (dataAry.length < 77) {
    return false
  }
  data = loadData_dataJoin(dataAry, 'mp', 76, 490)
  for (let k = 0; k < 10; k++) {
    for (let j = 0; j < 4; j++) {
      for (let i = 0; i < pEyMax; i++) {
        if (i >= data[j][k].length || i >= pcMax) {
          break
        }
        PC[i].MpMax[j][k] = data[j][k][pcList[i]]
      }
    }
  }
  if (dataAry.length < 78) {
    return false
  }
  data = loadData_dataJoin(dataAry, 'spell', 77, 530)
  for (let l = 0; l < 6; l++) {
    for (let k = 0; k < 10; k++) {
      for (let j = 0; j < 4; j++) {
        for (let i = 0; i < pEyMax; i++) {
          if (i >= data[j][k][l].length || i >= pcMax) {
            break
          }
          if (data[j][k][l][pcList[i]] == 1) {
            PC[i].Spell[j][k][l] = true
          }
        }
      }
    }
  }
  if (dataAry.length < 79) {
    return false
  }
  data = loadData_dataJoin(dataAry, 'partyMember', 78, 770)
  for (let j = 0; j < 6; j++) {
    for (let i = 0; i < ptList.length; i++) {
      if (i >= data[j].length || i >= pEyMax) {
        break
      }
      let pm = pcList.indexOf(data[j][ptList[i]])
      if (j >= GameData['PARTY_MEMBER_MAX']) {
        PARTY[i].PartyMember[j] = -1
        if (pm > -1 && pm < pEyMax) {
          PC[pm].PartyNum = -1
        }
      } else {
        if (pm < pEyMax) {
          PARTY[i].PartyMember[j] = pm
        } else {
          PARTY[i].PartyMember[j] = -1
        }
      }
    }
  }
  if (dataAry.length < 80) {
    return false
  }
  data = dataAry[79]
  ary = data.split(',')
  for (let i = 0; i < ary.length; i++) {
    if (i >= ITEM.length) {
      break
    }
    ITEM[i].Stock = Number(ary[i])
  }
  if (dataAry.length < 81) {
    return false
  }
  data = dataAry[80]
  for (let i = 0; i < 10; i++) {
    for (let j = 0; j < 16; j++) {
      for (let k = 0; k < 20; k++) {
        for (let l = 0; l < 20; l++) {
          if (data.charAt(6400 * i + 400 * j + 20 * k + l) == '1') {
            PlayData['MapFlag'][i][j][k][l] = true
          } else {
            PlayData['MapFlag'][i][j][k][l] = false
          }
        }
      }
    }
  }
  if (dataAry.length < 82) {
    return false
  }
  data = dataAry[81]
  for (let i = 0; i < 10; i++) {
    for (let j = 0; j < 16; j++) {
      for (let k = 0; k < 64; k++) {
        if (data.charAt(1024 * i + 64 * j + k) == '1') {
          PlayData['SecretDoor'][i][j][k] = true
        }
      }
    }
  }
  if (data.length > 10240) {
    for (let i = 0; i < 10; i++) {
      for (let j = 0; j < 16; j++) {
        for (let k = 64; k < 512; k++) {
          if (data.charAt(10240 + i * 7168 + j * 448 + (k - 64)) == '1') {
            PlayData['SecretDoor'][i][j][k] = true
          }
        }
      }
    }
  }
  if (dataAry.length < 83) {
    return false
  }
  data = dataAry[82]
  for (let i = 0; i < 10; i++) {
    for (let j = 0; j < 16; j++) {
      for (let k = 0; k < 64; k++) {
        if (data.charAt(1024 * i + 64 * j + k) == '1') {
          PlayData['LockedDoor'][i][j][k] = true
        }
      }
    }
  }
  if (data.length > 10240) {
    for (let i = 0; i < 10; i++) {
      for (let j = 0; j < 16; j++) {
        for (let k = 64; k < 512; k++) {
          if (data.charAt(10240 + i * 7168 + j * 448 + (k - 64)) == '1') {
            PlayData['LockedDoor'][i][j][k] = true
          }
        }
      }
    }
  }
  if (dataAry.length < 84) {
    return false
  }
  data = dataAry[83]
  ary = data.split('<>')
  for (let i = 0; i < ptList.length; i++) {
    if (i >= ary.length || i >= pEyMax) {
      break
    }
    PARTY[i].DungeonMusic = ary[ptList[i]]
  }
  if (dataAry.length < 85) {
    return false
  }
  data = dataAry[84]
  ary = data.split('<>')
  for (let i = 0; i < ary.length; i++) {
    let ary2 = ary[i].split(',')
    for (let j = 0; j < ary2.length; j++) {
      PlayData['DungeonNewMusic'][i][j] = ary2[j]
    }
  }
  if (dataAry.length < 86) {
    return false
  }
  data = loadData_dataJoin(dataAry, 'abi', 85, 776)
  for (let j = 0; j < abiMax; j++) {
    for (let i = 0; i < pEyMax; i++) {
      if (i >= data[j].length || i >= pcMax) {
        break
      }
      PC[i].AbiPlus[j] = data[j][pcList[i]]
    }
  }
  if (dataAry.length < 87) {
    return false
  }
  data = loadData_dataJoin(dataAry, 'abi', 86, 812)
  for (let j = 0; j < abiMax; j++) {
    for (let i = 0; i < pEyMax; i++) {
      if (i >= data[j].length || i >= pcMax) {
        break
      }
      PC[i].AbiRate[j] = data[j][pcList[i]]
    }
  }
  if (dataAry.length < 88) {
    return false
  }
  data = loadData_dataJoin(dataAry, 'abi', 87, 848)
  for (let j = 0; j < abiMax; j++) {
    for (let i = 0; i < ptList.length; i++) {
      if (i >= data[j].length || i >= pEyMax) {
        break
      }
      PARTY[i].AbiPlus[j] = data[j][ptList[i]]
    }
  }
  if (dataAry.length < 89) {
    return false
  }
  data = loadData_dataJoin(dataAry, 'abi', 88, 884)
  for (let j = 0; j < abiMax; j++) {
    for (let i = 0; i < ptList.length; i++) {
      if (i >= data[j].length || i >= pEyMax) {
        break
      }
      PARTY[i].AbiRate[j] = data[j][ptList[i]]
    }
  }
  if (dataAry.length < 90) {
    return false
  }
  data = dataAry[89]
  ary = data.split(',')
  for (let i = 0; i < ptList.length; i++) {
    if (i >= ary.length || i >= pEyMax) {
      break
    }
    PARTY[i].PtSpellEffectRate[4] = Number(ary[ptList[i]])
  }
  if (dataAry.length < 91) {
    return false
  }
  data = dataAry[90]
  ary = data.split(',')
  for (let i = 0; i < ptList.length; i++) {
    if (i >= ary.length || i >= pEyMax) {
      break
    }
    PARTY[i].PtSpellEffectPlus[4] = Number(ary[ptList[i]])
  }
  if (dataAry.length < 92) {
    return false
  }
  data = dataAry[91]
  ary = data.split(',')
  for (let i = 0; i < ptList.length; i++) {
    if (i >= ary.length || i >= pEyMax) {
      break
    }
    PARTY[i].SpellEffectRate[6] = Number(ary[ptList[i]])
  }
  if (dataAry.length < 93) {
    return false
  }
  data = dataAry[92]
  ary = data.split(',')
  for (let i = 0; i < ptList.length; i++) {
    if (i >= ary.length || i >= pEyMax) {
      break
    }
    PARTY[i].SpellEffectPlus[6] = Number(ary[ptList[i]])
  }
  if (dataAry.length < 94) {
    return false
  }
  data = dataAry[93]
  ary = data.split(',')
  for (let i = 0; i < pEyMax; i++) {
    if (i >= pcList.length || i >= pcMax) {
      break
    }
    PC[i].SpellEffectRate[6] = Number(ary[pcList[i]])
  }
  if (dataAry.length < 95) {
    return false
  }
  data = dataAry[94]
  ary = data.split(',')
  for (let i = 0; i < pEyMax; i++) {
    if (i >= pcList.length || i >= pcMax) {
      break
    }
    PC[i].SpellEffectPlus[6] = Number(ary[pcList[i]])
  }
  if (dataAry.length < 96) {
    return false
  }
  data = dataAry[95]
  ary = data.split(',')
  for (let i = 0; i < ptList.length; i++) {
    if (i >= ary.length || i >= pEyMax) {
      break
    }
    PARTY[i].SpellEffectPlus[7] = Number(ary[ptList[i]])
  }
  if (dataAry.length < 97) {
    return false
  }
  data = dataAry[96]
  ary = data.split(',')
  for (let i = 0; i < ptList.length; i++) {
    if (i >= ary.length || i >= pEyMax) {
      break
    }
    PARTY[i].SpellEffectRate[7] = Number(ary[ptList[i]])
  }
  if (dataAry.length < 98) {
    return false
  }
  data = dataAry[97]
  ary = data.split(',')
  for (let i = 0; i < pEyMax; i++) {
    if (i >= pcList.length || i >= pcMax) {
      break
    }
    PC[i].SpellEffectPlus[7] = Number(ary[pcList[i]])
  }
  if (dataAry.length < 99) {
    return false
  }
  data = dataAry[98]
  ary = data.split(',')
  for (let i = 0; i < pEyMax; i++) {
    if (i >= pcList.length || i >= pcMax) {
      break
    }
    PC[i].SpellEffectRate[7] = Number(ary[pcList[i]])
  }
  if (dataAry.length < 100) {
    return false
  }
  data = dataAry[99]
  for (let i = 0; i < ptList.length; i++) {
    if (i >= data.length || i >= pEyMax) {
      break
    }
    if (data.charAt(ptList[i]) == '1') {
      PARTY[i].ViewDarkZone = true
    }
  }
  if (dataAry.length < 101) {
    return false
  }
  data = dataAry[100]
  ary = data.split(',')
  for (let i = 0; i < pEyMax; i++) {
    if (i >= pcList.length || i >= pcMax) {
      break
    }
    PC[i].SpellEffectPlus[8] = Number(ary[pcList[i]])
  }
  if (dataAry.length < 102) {
    return false
  }
  data = dataAry[101]
  ary = data.split(',')
  for (let i = 0; i < pEyMax; i++) {
    if (i >= pcList.length || i >= pcMax) {
      break
    }
    PC[i].SpellEffectRate[8] = Number(ary[pcList[i]])
  }
  if (dataAry.length < 103) {
    return false
  }
  data = dataAry[102]
  ary = data.split(',')
  for (let i = 0; i < ptList.length; i++) {
    if (i >= ary.length || i >= pEyMax) {
      break
    }
    PARTY[i].SpellEffectPlus[8] = Number(ary[ptList[i]])
  }
  if (dataAry.length < 104) {
    return false
  }
  data = dataAry[103]
  ary = data.split(',')
  for (let i = 0; i < ptList.length; i++) {
    if (i >= ary.length || i >= pEyMax) {
      break
    }
    PARTY[i].SpellEffectRate[8] = Number(ary[ptList[i]])
  }
  if (dataAry.length < 105) {
    return false
  }
  data = dataAry[104]
  for (let i = 0; i < 10; i++) {
    for (let j = 0; j < 16; j++) {
      for (let k = 0; k < 64; k++) {
        if (data.charAt(1024 * i + 64 * j + k) == '0') {
          PlayData['WallFlag'][i][j][k] = false
        }
      }
    }
  }
  if (data.length > 10240) {
    for (let i = 0; i < 10; i++) {
      for (let j = 0; j < 16; j++) {
        for (let k = 64; k < 512; k++) {
          if (data.charAt(10240 + i * 7168 + j * 448 + (k - 64)) == '1') {
            PlayData['WallFlag'][i][j][k] = true
          }
        }
      }
    }
  }
  if (dataAry.length < 106) {
    return false
  }
  data = loadData_dataJoin(dataAry, 'resist', 105, 920)
  for (let j = 0; j < RESIST_LENGTH; j++) {
    if (j == 9) {
      continue
    }
    for (let i = 0; i < pEyMax; i++) {
      if (i >= data[j].length || i >= pcMax) {
        break
      }
      PC[i].ResistPlus[j] = data[j][pcList[i]]
    }
  }
  if (dataAry.length < 107) {
    return false
  }
  data = loadData_dataJoin(dataAry, 'resist', 106, 934)
  for (let j = 0; j < RESIST_LENGTH; j++) {
    if (j == 9) {
      continue
    }
    for (let i = 0; i < pEyMax; i++) {
      if (i >= data[j].length || i >= pcMax) {
        break
      }
      PC[i].ResistRate[j] = data[j][pcList[i]]
    }
  }
  if (dataAry.length < 108) {
    return false
  }
  data = loadData_dataJoin(dataAry, 'resist', 107, 948)
  for (let j = 0; j < RESIST_LENGTH; j++) {
    if (j == 9) {
      continue
    }
    for (let i = 0; i < ptList.length; i++) {
      if (i >= data[j].length || i >= pEyMax) {
        break
      }
      PARTY[i].ResistPlus[j] = data[j][ptList[i]]
    }
  }
  if (dataAry.length < 109) {
    return false
  }
  data = loadData_dataJoin(dataAry, 'resist', 108, 962)
  for (let j = 0; j < RESIST_LENGTH; j++) {
    if (j == 9) {
      continue
    }
    for (let i = 0; i < ptList.length; i++) {
      if (i >= data[j].length || i >= pEyMax) {
        break
      }
      PARTY[i].ResistRate[j] = data[j][ptList[i]]
    }
  }
  if (dataAry.length < 110) {
    return false
  }
  data = loadData_dataJoin(dataAry, 'attackAdd', 109, 976)
  for (let j = 0; j < ATTACK_ADD_LENGTH + 1; j++) {
    for (let i = 0; i < pEyMax; i++) {
      if (i >= data[j].length || i >= pcMax) {
        break
      }
      if (data[j][pcList[i]] == 1) {
        PC[i].AttackAddPlus[j] = true
      }
    }
  }
  if (dataAry.length < 111) {
    return false
  }
  data = loadData_dataJoin(dataAry, 'attackAdd', 110, 982)
  for (let j = 0; j < ATTACK_ADD_LENGTH + 1; j++) {
    for (let i = 0; i < pEyMax; i++) {
      if (i >= data[j].length || i >= pcMax) {
        break
      }
      PC[i].AttackAddRate[j] = data[j][pcList[i]]
    }
  }
  if (dataAry.length < 112) {
    return false
  }
  data = loadData_dataJoin(dataAry, 'attackAdd', 111, 988)
  for (let j = 0; j < ATTACK_ADD_LENGTH + 1; j++) {
    for (let i = 0; i < ptList.length; i++) {
      if (i >= data[j].length || i >= pEyMax) {
        break
      }
      if (data[j][ptList[i]] == 1) {
        PARTY[i].AttackAddPlus[j] = true
      }
    }
  }
  if (dataAry.length < 113) {
    return false
  }
  data = loadData_dataJoin(dataAry, 'attackAdd', 112, 994)
  for (let j = 0; j < ATTACK_ADD_LENGTH + 1; j++) {
    for (let i = 0; i < ptList.length; i++) {
      if (i >= data[j].length || i >= pEyMax) {
        break
      }
      PARTY[i].AttackAddRate[j] = data[j][ptList[i]]
    }
  }
  if (dataAry.length < 114) {
    return false
  }
  data = dataAry[113]
  ary = data.split(',')
  for (let i = 0; i < pEyMax; i++) {
    if (i >= pcList.length || i >= pcMax) {
      break
    }
    PC[i].PoisonPlus = Number(ary[pcList[i]])
  }
  if (dataAry.length < 115) {
    return false
  }
  data = dataAry[114]
  ary = data.split(',')
  for (let i = 0; i < ptList.length; i++) {
    if (i >= ary.length || i >= pEyMax) {
      break
    }
    PARTY[i].PoisonPlus = Number(ary[ptList[i]])
  }
  if (dataAry.length < 116) {
    return false
  }
  data = dataAry[115]
  for (let i = 0; i < data.length; i++) {
    data.charAt(i) == '1'
      ? (PlayData['GameFlagS'][i] = true)
      : (PlayData['GameFlagS'][i] = false)
  }
  if (dataAry.length >= 117) {
    data = dataAry[116]
    if (data != '') {
      ary = data.split(',')
      for (let i = 0; i < pEyMax; i++) {
        if (i >= pcList.length || i >= pcMax) {
          break
        }
        PC[i].FaceGraphic = ary[pcList[i]]
      }
    }
  }
  for (let i = 0; i < pEyMax; i++) {
    let ck = false
    for (let j = 1; j < 6; j++) {
      if (PARTY[i].PartyMember[j] >= 0 && PARTY[i].PartyMember[j - 1] < 0) {
        ck = true
        break
      }
    }
    if (ck) {
      let k = 0
      for (let j = 0; j < 6; j++) {
        if (PARTY[i].PartyMember[j] >= 0) {
          if (k < j) {
            PARTY[i].PartyMember[k] = PARTY[i].PartyMember[j]
            PARTY[i].PartyMember[j] = -1
          }
          k++
        }
      }
    }
  }
  for (let i = 0; i < pcMax; i++) {
    PC[i].NextUpExp = -1
    PC[i].check()
  }
  return true
}
function loadData_dataJoin (dataAry, type, sub1, sub2) {
  let result = []
  if (type.match(/^(item|partyMember|attackAdd)$/)) {
    let typeNum = 0
    if (type == 'item') {
      typeNum = 99
    } else if (type == 'partyMember') {
      typeNum = 6
    } else if (type == 'attackAdd') {
      typeNum = ATTACK_ADD_LENGTH + 1
    }
    for (let j = 0; j < typeNum; j++) {
      result[j] = []
    }
    let ary
    if (dataAry[sub1].indexOf(',') > -1) {
      ary = dataAry[sub1].split(',')
    }
    for (let i = 0; i < PC_ENTRY_MIN; i++) {
      for (let j = 0; j < typeNum; j++) {
        if (dataAry[sub1].indexOf(',') > -1) {
          result[j].push(Number(ary[i * typeNum + j]))
        } else {
          result[j].push(Number(dataAry[sub1].charAt(i * typeNum + j)))
        }
      }
    }
    for (let j = 0; j < typeNum; j++) {
      if (dataAry.length < sub2 + 1) {
        break
      }
      let len
      if (dataAry[sub2].indexOf(',') > -1) {
        ary = dataAry[sub2].split(',')
        len = ary.length
      } else {
        len = dataAry[sub2].length
      }
      for (let i = 0; i < len; i++) {
        if (dataAry[sub2].indexOf(',') > -1) {
          result[j].push(Number(ary[i]))
        } else {
          result[j].push(Number(dataAry[sub2].charAt(i)))
        }
      }
      sub2++
    }
  } else if (type == 'abi') {
    let ary = dataAry[sub1].split(',')
    let abiMax = 36
    if (ary.length == 360) {
      abiMax = 10
    }
    for (let j = 0; j < abiMax; j++) {
      result[j] = []
    }
    for (let i = 0; i < PC_ENTRY_MIN; i++) {
      for (let j = 0; j < 10; j++) {
        result[j].push(Number(ary[i * 10 + j]))
      }
    }
    if (abiMax == 36) {
      for (let i = 0; i < PC_ENTRY_MIN; i++) {
        for (let j = 10; j < 36; j++) {
          result[j].push(Number(ary[360 + i * 26 + (j - 10)]))
        }
      }
    }
    for (let j = 0; j < abiMax; j++) {
      if (dataAry.length < sub2 + 1) {
        break
      }
      ary = dataAry[sub2].split(',')
      let len = 0
      if (dataAry[sub2] != '') {
        len = ary.length
      }
      for (let i = 0; i < len; i++) {
        result[j].push(Number(ary[i]))
      }
      sub2++
    }
  } else if (type == 'mp') {
    for (let j = 0; j < 4; j++) {
      result[j] = []
      for (let k = 0; k < 10; k++) {
        result[j][k] = []
      }
    }
    let ary = dataAry[sub1].split(',')
    for (let i = 0; i < PC_ENTRY_MIN; i++) {
      for (let j = 0; j < 4; j++) {
        for (let k = 0; k < 10; k++) {
          result[j][k].push(Number(ary[i * 40 + j * 10 + k]))
        }
      }
    }
    for (let k = 0; k < 10; k++) {
      for (let j = 0; j < 4; j++) {
        if (dataAry.length < sub2 + 1) {
          break
        }
        ary = dataAry[sub2].split(',')
        let len = 0
        if (dataAry[sub2] != '') {
          len = ary.length
        }
        for (let i = 0; i < len; i++) {
          result[j][k].push(Number(ary[i]))
        }
        sub2++
      }
    }
  } else if (type == 'spell') {
    for (let j = 0; j < 4; j++) {
      result[j] = []
      for (let k = 0; k < 10; k++) {
        result[j][k] = []
        for (let l = 0; l < 6; l++) {
          result[j][k][l] = []
        }
      }
    }
    for (let i = 0; i < PC_ENTRY_MIN; i++) {
      for (let j = 0; j < 4; j++) {
        for (let k = 0; k < 10; k++) {
          for (let l = 0; l < 6; l++) {
            result[j][k][l].push(
              Number(dataAry[sub1].charAt(i * 240 + j * 60 + k * 6 + l))
            )
          }
        }
      }
    }
    for (let l = 0; l < 6; l++) {
      for (let k = 0; k < 10; k++) {
        for (let j = 0; j < 4; j++) {
          if (dataAry.length < sub2 + 1) {
            break
          }
          let len = dataAry[sub2].length
          for (let i = 0; i < len; i++) {
            result[j][k][l].push(Number(dataAry[sub2].charAt(i)))
          }
          sub2++
        }
      }
    }
  } else if (type == 'resist') {
    let ary = dataAry[sub1].split(',')
    let resLen = RESIST_LENGTH
    if (ary.length < 540) {
      resLen--
    }
    for (let j = 0; j < RESIST_LENGTH; j++) {
      result[j] = []
    }
    for (let i = 0; i < PC_ENTRY_MIN; i++) {
      for (let j = 0; j < RESIST_LENGTH; j++) {
        let k = j
        if (ary.length < 540) {
          if (j == 9) {
            continue
          }
          if (j > 9) {
            k--
          }
        }
        result[j].push(Number(ary[resLen * i + k]))
      }
    }
    for (let j = 0; j < RESIST_LENGTH; j++) {
      if (dataAry.length < sub2 + 1) {
        break
      }
      if (j == 9) {
        continue
      }
      ary = dataAry[sub2].split(',')
      let len = 0
      if (dataAry[sub2] != '') {
        len = ary.length
      }
      for (let i = 0; i < len; i++) {
        result[j].push(Number(ary[i]))
      }
      sub2++
    }
  }
  return result
}
function loopLoading () {
  if (GameState == 'webFontLoading') {
    if (TempVariable['loadWebFont']) {
      TempVariable['loadWebFont'] = false
      setFont(Font)
      if (ClickToStart) {
        GameState = 'webFontLoadingEnd'
        MP.clearMainWindow()
        let str = ''
        if (getDevice().match(/^(sp|tab)$/)) {
          str = 'SYSTEM_TOUCH_SCREEN'
        } else {
          str = 'SYSTEM_CLICK_SCREEN'
        }
        MP.drawText_Full(
          MP.MainSurface,
          getDefaultMessage(str),
          'center',
          12,
          'yellow'
        )
      } else {
        GameState = 'launchLoading'
        LoopLoadingID = requestAnimationFrame(loopLoading)
        main('webFont')
      }
    } else {
      LoopLoadingID = requestAnimationFrame(loopLoading)
    }
  } else if (TempVariable['notLoadingGameData']) {
    cancelAnimationFrame(LoopLoadingID)
    MP.clearMainWindow()
    let message = ''
    if (GameDataHTML5 == null || GameDataHTML5 == '') {
      message = 'SCENARIO_DOES_NOT_EXIST'
    } else {
      message = 'PLEASE_READ_BY_NEW_ENGINE'
    }
    message = MP.strChangeLine(getDefaultMessage(message), 60, 25, true)
    let lineNum = 13 - Math.floor(MP.strGetLineNum(message) / 2)
    MP.drawText_Full(MP.MainSurface, message, 'center', lineNum, 'pink')
  } else if (TempVariable['stopLoading']) {
    cancelAnimationFrame(LoopLoadingID)
    TempVariable['stopLoading'] = false
    MP.clearMainWindow()
    let str = ''
    if (getDevice().match(/^(sp|tab)$/)) {
      str = 'SYSTEM_TOUCH_SCREEN'
    } else {
      str = 'SYSTEM_CLICK_SCREEN'
    }
    MP.drawText_Full(
      MP.MainSurface,
      getDefaultMessage(str),
      'center',
      12,
      'yellow'
    )
  } else {
    if (TempVariable['loadingPreEnd'] && !TempVariable['loadingEnd']) {
      TempVariable['loadingEnd'] = true
      if ((Config['Bgm'] || Config['Se']) && SoundNotAutoPlay) {
        GameState = 'stopStart'
        let ctx = MP.MainSurface.context
        ctx.fillStyle = 'black'
        ctx.fillRect(
          0,
          MP.CENTER_FRAME_FILL[1] + MP.FRAME_WIDTH,
          MP.MAIN_WIDTH,
          MP.CENTER_FRAME_FILL[2] - MP.FRAME_WIDTH
        )
        if (LOADING_END_MASK) {
          MP.paintMask()
        }
        let str = ''
        if (getDevice().match(/^(sp|tab)$/)) {
          str = 'SYSTEM_TOUCH_SCREEN'
        } else {
          str = 'SYSTEM_CLICK_SCREEN'
        }
        MP.drawText_Full(
          MP.TopSurface,
          getDefaultMessage(str),
          'center',
          22,
          'pink'
        )
      } else {
        main('mainLoopStart')
        return
      }
    }
    let frame = 30
    if (TempVariable['count'] % frame == 0) {
      TempVariable['count'] = 0
      MP.loadingScreen()
    }
    TempVariable['count']++
    LoopLoadingID = requestAnimationFrame(loopLoading)
  }
}
function loopMain (timestamp) {
  let elapsed = calDiv(calMinus(timestamp, PreTimestamp), 1000)
  if (elapsed <= FRAME_TIME) {
    requestAnimationFrame(loopMain)
    return
  }
  PreTimestamp = timestamp
  if (GenericVariable['OnClick'] || GenericVariable['OnTouch']) {
    if (GenericVariable['OnTouch']) {
      preInput('touch', GenericVariable['Id'])
    } else {
      preInput('click', GenericVariable['Id'])
    }
  } else if (ConnectedGamepadIndex != null && Config['GamePad']) {
    let buttonNum = -1
    let gamepads = navigator.getGamepads()
    for (let i = 0; i < gamepads.length; i++) {
      if (gamepads[i] == undefined) {
        continue
      }
      let gp = gamepads[i]
      for (let j = 0; j < gp.buttons.length; j++) {
        if (gp.buttons[j].pressed) {
          buttonNum = j
          break
        }
      }
      if (buttonNum > -1) {
        break
      }
      for (let j = 0; j < 3; j += 2) {
        if (gp.axes[j] < -0.75) {
          buttonNum = 14
        } else if (gp.axes[j] > 0.75) {
          buttonNum = 15
        } else if (gp.axes[j + 1] < -0.75) {
          buttonNum = 12
        } else if (gp.axes[j + 1] > 0.75) {
          buttonNum = 13
        }
        if (buttonNum > -1) {
          break
        }
      }
      if (buttonNum > -1) {
        break
      }
    }
    if (buttonNum > -1 && buttonNum < GAMEPAD_CODE.length) {
      let buttonName = 'gamepad_' + GAMEPAD_CODE[buttonNum]
      if (Mode == 'optionKeyname') {
        MP.setOptionMode('keyname', buttonName)
      } else {
        let button = getKey(buttonName)
        preInput('gamepad', button)
      }
    } else {
      PreInputType = []
      PreInput = []
    }
  }
  if (GenericVariable['KeyWait'] > -1) {
    GenericVariable['KeyWait']++
    if (GenericVariable['KeyWait'] > 2) {
      GenericVariable['KeyWait'] = -1
    }
  }
  for (let key in MP.ButtonObject) {
    if (MP.ButtonObject[key].clickCount > -1) {
      MP.ButtonObject[key].clickCount++
      if (MP.ButtonObject[key].clickCount >= 14) {
        MP.ButtonObject[key].clickCount = -1
        eventMouseout(MP.ButtonObject[key].firstChild, key)
      }
    }
  }
  if (!AudioPlay) {
    if (NowMusic != '' && Config['Bgm']) {
      if (MusicData[NowMusic] != null) {
        if (MusicData[NowMusic].src == undefined) {
          if (MusicData[NowMusic].muted) {
            MusicData[NowMusic].volume = 0.0
          } else {
            MusicData[NowMusic].volume = calTimes(
              Number(Config['BgmVolume']),
              0.01
            )
          }
          MusicData[NowMusic].play()
        }
      }
    }
  }
  if (GenericVariable['Reset']) {
    reset()
    GenericVariable['Reset'] = false
  }
  if (GenericVariable['ReturnKeyControll'] > -1) {
    MP.OptionParts['text']._element.value = ''
    GenericVariable['ReturnKeyControll']++
    if (GenericVariable['ReturnKeyControll'] > 1) {
      GenericVariable['FullKeyInvalid'] = false
      GenericVariable['ReturnKeyControll'] = -1
    }
  }
  if (GenericVariable['MessageCountMax'] > -1) {
    GenericVariable['MessageCount']++
    if (GenericVariable['MessageCount'] > GenericVariable['MessageCountMax']) {
      GenericVariable['MessageCount'] = 0
      GenericVariable['Message'].splice(0, 1)
      if (GenericVariable['Message'].length < 1) {
        GenericVariable['MessageCountMax'] = -1
        GenericVariable['KeyInvalid'] = false
        if (!GameState.match(/Return$/)) {
          GenericVariable['ReturnAction']()
        }
      } else {
        MP.clearTextSurface()
        MP.drawTextFrame(
          MP.TextSurface[MP.TextSurfaceNum],
          GenericVariable['Message'][0],
          'center',
          MP.LINE_HEIGHT * GenericVariable['MessageLine'],
          0,
          0,
          GenericVariable['MessageAlign']
        )
        if (
          GenericVariable['Message'].length < 2 &&
          GameState.match(/Return$/)
        ) {
          GenericVariable['Message'].splice(0, 1)
          GenericVariable['MessageCountMax'] = -1
          GenericVariable['KeyInvalid'] = false
        }
      }
    }
  }
  if (GenericVariable['TimeEvent'] != '') {
    GenericVariable['TimeEventCount']++
    if (
      GenericVariable['TimeEventCount'] > GenericVariable['TimeEventCountMax']
    ) {
      if (GenericVariable['TimeEvent'] == 'textMemory') {
        GenericVariable['TimeEvent'] = ''
        let len = MP.OptionParts['text']._element.value.length
        MP.OptionParts['text']._element.setSelectionRange(len, len)
      } else if (GenericVariable['TimeEvent'] == 'turnAround') {
        GenericVariable['TimeEvent'] = ''
        dungeonAction('right')
      } else if (GenericVariable['TimeEvent'] == 'turnTable') {
        GenericVariable['TimeEvent'] = ''
        dungeonAction('encount')
      } else if (GenericVariable['TimeEvent'] == 'mapLocation') {
        MP.drawMap_Location(
          TempVariable['x'],
          TempVariable['y'],
          TempVariable['direction']
        )
        GenericVariable['TimeEvent'] = 'mapLocationClear'
        GenericVariable['TimeEventCount'] = 0
      } else if (GenericVariable['TimeEvent'] == 'mapLocationClear') {
        MP.StatusSurface.clear()
        GenericVariable['TimeEvent'] = 'mapLocation'
        GenericVariable['TimeEventCount'] = 0
      } else if (GenericVariable['TimeEvent'].match(/^moveFloor/)) {
        let timeEvent = GenericVariable['TimeEvent']
        GenericVariable['TimeEvent'] = ''
        let pt = PARTY[PlayData['ActiveParty']]
        let outPoint = false
        if (TempVariable['nextDungeon'] < 0) {
          outPoint = true
        } else if (TempVariable['nextDungeon'] >= DUNGEON.DUNGEON_MAX) {
          outPoint = true
        } else if (TempVariable['nextFloor'] < 0) {
          outPoint = true
        } else if (
          TempVariable['nextFloor'] >=
          DUNGEON.FloorMinMax[TempVariable['nextDungeon']].length
        ) {
          outPoint = true
        }
        if (timeEvent.indexOf('InRock') < 0 && outPoint) {
          pt.returnGround()
        } else {
          let nowDungeon = pt.DungeonNumber
          let nowFloor = pt.Floor
          pt.DungeonNumber = TempVariable['nextDungeon']
          pt.Floor = TempVariable['nextFloor']
          pt.X = TempVariable['nextX']
          pt.Y = TempVariable['nextY']
          pt.PreX = pt.X
          pt.PreY = pt.Y
          if (timeEvent.indexOf('FromTrap') > -1) {
            if (GameData['SAVE_BATTLE_END']) {
              saveData('Battle end (It returns to the dungeon)')
            }
          }
          if (outPoint) {
            GameState = 'move'
            dungeonAction('step')
          } else if (timeEvent.match(/From/)) {
            GameState = 'moveStart'
            let mode
            if (
              nowDungeon == TempVariable['nextDungeon'] &&
              nowFloor == TempVariable['nextFloor']
            ) {
              mode = 'step'
            } else {
              mode = 'floor'
            }
            dungeonAction(mode)
          } else if (
            nowDungeon == TempVariable['nextDungeon'] &&
            nowFloor == TempVariable['nextFloor']
          ) {
            GameState = 'move'
            dungeonAction('step')
          } else {
            GameState = 'moveStart'
            dungeonAction('floor')
          }
        }
        GenericVariable['KeyInvalid'] = false
      } else if (GenericVariable['TimeEvent'].match(/^slide/)) {
        if (GenericVariable['TimeEvent'].indexOf('2') > -1) {
          let str = GenericVariable['TimeEvent']
          GenericVariable['TimeEvent'] = ''
          if (str.indexOf('Shutter') > -1) {
            dungeonAction('shutter')
          } else {
            dungeonAction('move')
          }
        } else {
          MP.paintDungeon('clear')
          GenericVariable['TimeEventCount'] = 0
          GenericVariable['TimeEvent'] += '2'
        }
      } else if (GenericVariable['TimeEvent'] == 'battleStart') {
        GenericVariable['TimeEvent'] = ''
        if (TempVariable['battleMusic'] != 'no change') {
          musicStop()
        }
        sePlay('battleStart')
        GenericVariable['KeyInvalid'] = false
        GameState = 'battleStartInputKey'
      } else if (GenericVariable['TimeEvent'] == 'battleSetTurn') {
        GenericVariable['TimeEvent'] = ''
        GameState = 'battleSetTurn3'
        battleAction()
      }
    }
  }
  if (GenericVariable['MonsterGraphic']) {
    TempVariable['monsterViewCount']++
    if (TempVariable['monsterViewCount'] > TIME_COUNT[4]) {
      TempVariable['monsterViewStage']++
      MP.paintMonsterGrahic(
        TempVariable['monsterCG'],
        TempVariable['monsterDecided'],
        TempVariable['monsterView'],
        TempVariable['monsterViewStage']
      )
      if (TempVariable['monsterViewStage'] >= 8) {
        GenericVariable['MonsterGraphic'] = false
        GameState = 'battleSetTurn2'
        battleAction()
      } else {
        TempVariable['monsterViewCount'] = 0
      }
    }
  }
  requestAnimationFrame(loopMain)
}
function main (readEnd) {
  if (readEnd == 'webFont') {
    MP.createOptionParts()
    configLoad(configGetStr(InitialConfigData, KeyConfigData))
    MP.createControlButton(Config['ControllerAlign'])
    addKeyEvent()
    setDefaultMessage()
    Prefetch['event'] = []
    Prefetch['dungeon'] = []
    Prefetch['face'] = []
    Prefetch['castle'] = []
    Prefetch['monster'] = []
    Prefetch['monster'][0] = []
    Prefetch['monster'][1] = []
    let flag = setGameData(GameDataHTML5)
    if (!flag) {
      TempVariable['notLoadingGameData'] = true
    } else {
      if (false) {
        GameState = 'stopLoading'
        TempVariable['stopLoading'] = true
      } else {
        main('init')
      }
    }
  } else if (readEnd == 'init') {
    GameDataHTML5 = ''
    document.title = GameData['GAME_TITLE']
    SPELL_EF = new SpellEffect()
    PC = []
    for (let i = 0; i < GameData['PC_ENTRY_MAX']; i++) {
      PC[i] = new CharactorModel(i)
    }
    PARTY = []
    for (let i = 0; i < GameData['PC_ENTRY_MAX']; i++) {
      PARTY[i] = new PartyModel(i)
    }
    MONSTER = []
    for (let i = 0; i < 36; i++) {
      MONSTER[i] = new CharactorModel()
    }
    SUMMON = []
    for (let i = 0; i < 18; i++) {
      SUMMON[i] = new CharactorModel()
    }
    PlayData['ActiveParty'] = -1
    initializePlayData()
    GenericVariable['ReturnKeyControll'] = -1
    let ckInit = false
    if (LaunchSettings['NotLoadSaveData']) {
      ckInit = true
    } else if (!loadData()) {
      ckInit = true
    }
    if (ckInit) {
      initializePlayData()
      initializeFirstPc()
      checkShopItemListFull()
      saveData()
      if (GameData['DEBUG']) {
        console.log('[SAVE] Initialize')
      }
    } else {
      let ckSave = false
      if (PlayData['ActiveParty'] > -1) {
        let pt = PARTY[PlayData['ActiveParty']]
        if (pt.DungeonNumber == -1 && pt.getMemberNum() > 0) {
          pt.dissolution(false)
          ckSave = true
        }
        PlayData['ActiveParty'] = -1
      }
      for (let i = 0; i < GameData['PC_ENTRY_MAX']; i++) {
        let dissolutionFlag = false
        let pt = PARTY[i]
        if (pt.DungeonNumber < 0) {
          continue
        }
        if (pt.DungeonNumber >= DUNGEON.DUNGEON_MAX) {
          dissolutionFlag = true
        }
        if (!dissolutionFlag) {
          if (
            pt.Floor < 0 ||
            pt.Floor >= DUNGEON.FloorMinMax[pt.DungeonNumber].length
          ) {
            dissolutionFlag = true
          }
        }
        if (!dissolutionFlag) {
          if (
            pt.X < 0 ||
            pt.Y < 0 ||
            pt.X >= DUNGEON.Width[pt.DungeonNumber] ||
            pt.Y >= DUNGEON.Height[pt.DungeonNumber]
          ) {
            dissolutionFlag = true
          }
        }
        if (dissolutionFlag) {
          pt.dissolution(true)
          ckSave = true
        }
      }
      if (ckSave) {
        saveData()
        if (GameData['DEBUG']) {
          console.log('[SAVE] Dissolution of party')
        }
      }
    }
    Prefetch['default'] = [
      'graphic/boxClose',
      'graphic/boxOpen',
      'graphic/restInPeace',
      'graphic/bg/castleTown',
      'graphic/bg/edgeOfTown',
      'graphic/bg/inn',
      'graphic/bg/shop',
      'graphic/bg/tavern',
      'graphic/bg/temple',
      'graphic/bg/trainingGround'
    ]
    let strAry = GameData['TITLE_CG'].split('<>')
    if (!strAry[0].match(/^(| )$/)) {
      Prefetch['default'].push('graphic/' + strAry[0])
    }
    if (GameData['FACE_GRAPHIC_STATUS'] || GameData['FACE_GRAPHIC_BATTLE']) {
      for (let i = 0; i < PlayData['PcMax']; i++) {
        let pcNum = PlayData['PcList'][i]
        let faceStr
        if (PC[pcNum].FaceGraphic.match(/^(| |none)$/)) {
          faceStr = 'graphic/face/' + PC[pcNum].Name[0]
        } else {
          faceStr = '<>' + PC[pcNum].FaceGraphic
        }
        Prefetch['face'].push(faceStr)
      }
    }
    LoadingFlag = true
    if (LaunchSettings['SoundPrefetch'] || Config['Se']) {
      TempVariable['loadingText'] = 'Now Loading\n(SE)'
      readSoundFile(GameData['SOUND_NAME'], GameData['SOUND_SRC'], main)
    } else {
      main('sound')
    }
  } else if (readEnd == 'sound' && LoadingFlag) {
    if (LaunchSettings['SoundPrefetch'] || Config['Bgm']) {
      TempVariable['loadingText'] = 'Now Loading\n(MUSIC)'
      readMusicFile(GameData['MUSIC_NAME'], GameData['MUSIC_SRC'], main)
    } else {
      main('music')
    }
  } else if (readEnd == 'music' && LoadingFlag) {
    LoadingFlag = false
    TempVariable['loadingText'] = 'Now Loading\n(GRAPHIC)'
    let data = Prefetch['default'].slice()
    data = data.concat(Prefetch['face'])
    data = data.concat(Prefetch['dungeon'])
    data = data.concat(Prefetch['event'])
    data = data.concat(Prefetch['castle'])
    readGraphicFile(data, GenericVariable['PrioritizeHR'], main)
  } else if (readEnd == 'graphic') {
    if (LocalLimit && !TempVariable['localCheckEnd']) {
      let img = null
      for (let key in Prefetch['default']) {
        if (
          GraphicData[Prefetch['default'][key]] != undefined &&
          GraphicData[Prefetch['default'][key]] != null
        ) {
          img = GraphicData[Prefetch['default'][key]]
          break
        }
      }
      if (img != null) {
        let localCheck = false
        try {
          let imageData = img.context.getImageData(0, 0, img.width, img.height)
        } catch (error) {
          console.error(error)
          localCheck = true
        }
        if (!localCheck) {
          LocalLimit = false
        }
      }
    }
    if (!TempVariable['localCheckEnd']) {
      if (LocalLimit) {
        Config['Dungeon'] = 'wireFrame'
        MP.OptionParts['Dungeon_1']._element.checked = true
        MP.OptionParts['Dungeon_0']._element.disabled = true
        MP.OptionParts['Dungeon_0']._element.style.cursor = 'default'
        checkRadioButton()
        console.log('[restricted operation]')
      } else {
        console.log('[normal operation]')
      }
      TempVariable['localCheckEnd'] = true
    }
    if (LaunchSettings['GraphicPrefetch']) {
      let monsterAry = []
      for (let i = 0; i < MONSTER_DATA.length; i++) {
        monsterAry.push(i)
      }
      monsterAry = checkGraphic_Monster(monsterAry)
      if (monsterAry.length > 0) {
        readGraphicFile_Monster(monsterAry, main)
        return
      }
      TempVariable['loadingPreEnd'] = true
    } else {
      TempVariable['loadingPreEnd'] = true
    }
  } else if (readEnd == 'mainLoopStart') {
    cancelAnimationFrame(LoopLoadingID)
    MP.clearMainWindow()
    MP.StatusSurface.context.globalAlpha = 1.0
    MP.StatusSurface.clear()
    GenericVariable['FullKeyInvalid'] = true
    GenericVariable['KeyInvalid'] = false
    GenericVariable['KeyWait'] = 0
    deleteTempVariable()
    requestAnimationFrame(loopMain)
    main('start')
  } else if (readEnd == 'start') {
    MP.clearMainWindow()
    Mode = 'normal'
    GameState = 'titleStart'
    titleAction()
    GenericVariable['FullKeyInvalid'] = false
    test()
  }
}
function monsterDecidedCheck () {
  let ptNum = PlayData['ActiveParty']
  let pt = PARTY[ptNum]
  for (let i = 0; i < 4; i++) {
    if (TempVariable['monsterNum'][i] < 1) {
      continue
    } else if (TempVariable['monsterDecided'][i]) {
      continue
    }
    let formula = GameData['DECIDED_PROB'].replace(
      /plus/g,
      String(pt.PtSpellEffectPlus[0])
    )
    formula = replaceFormula(formula, [
      ['monster', PlayData['MonsterList'][i][0]]
    ])
    prob = Math.floor(strCalculation(formula))
    if (prob < 0) {
      prob = 0
    } else if (prob > 100) {
      prob = 100
    }
    printDebugMessage(
      'Monster[' + String(i) + '] decide rate: ' + String(prob) + '%'
    )
    if (prob >= dice(1, 100)) {
      TempVariable['monsterDecided'][i] = true
      TempVariable['monsterDecidedChange'][i] = true
      if (GameData['REGISTRATION_MONSTER_CATALOG'] == 0) {
        let monDataNum = TempVariable['setMonster'][i]
        if (!PlayData['MonsterFlag'][monDataNum]) {
          printDebugMessage(
            String(monDataNum) +
              ':' +
              MONSTER_DATA[monDataNum].NAME[1] +
              ' was registered with a catalog.'
          )
          PlayData['MonsterFlag'][monDataNum] = true
        }
      }
    }
  }
}
function musicPlay (name, mute) {
  if (mute == undefined || mute == null) {
    mute = false
  }
  if (NowMusic != name) {
    musicStop()
  }
  NowMusic = name
  if (
    MusicData[name] == undefined ||
    MusicData[name] == null ||
    !Config['Bgm']
  ) {
    return
  }
  if (mute) {
    MusicData[name].volume = 0.0
  } else {
    MusicData[name].volume = calTimes(Number(Config['BgmVolume']), 0.01)
  }
  MusicData[name].play()
  if (!AudioPlay) {
    if (MusicData[name].src != undefined) {
      MusicData[name].src.loop = true
    }
  }
}
function musicStop () {
  NowMusic = ''
  for (let key in MusicData) {
    if (MusicData[key] == null) {
      continue
    }
    if (AudioPlay) {
      MusicData[key].pause()
      MusicData[key].currentTime = 0
    } else {
      try {
        MusicData[key].stop()
      } catch (e) {}
    }
  }
}
function nextTargetMonster (group, num) {
  let result = -1
  if (group < 0) {
    return result
  }
  num++
  for (let i = num; i < 9; i++) {
    let monNum = PlayData['MonsterList'][group][i]
    if (monNum < 0) {
      break
    }
    if (MONSTER[monNum].Hp > 0) {
      result = i
      break
    }
  }
  return result
}
function nextTargetMonsterGroup (group) {
  let result = -1
  group++
  if (group < 0) {
    return result
  }
  for (let i = group; i < 4; i++) {
    if (TempVariable['monsterNum'][i] > 0) {
      result = i
      break
    }
  }
  return result
}
function nextTargetPc (rank, num) {
  let ptNum = PlayData['ActiveParty']
  let pt = PARTY[ptNum]
  let memberNum = pt.getMemberNum()
  let result = -1,
    lastNum
  if (rank == 'front') {
    num++
    lastNum = GameData['FRONT_RANK_NUM']
    if (lastNum > memberNum) {
      lastNum = memberNum
    }
  } else if (rank == 'back') {
    num++
    if (num < GameData['FRONT_RANK_NUM']) {
      num = GameData['FRONT_RANK_NUM']
    }
    lastNum = memberNum
  } else {
    num++
    lastNum = memberNum
  }
  for (let i = num; i < lastNum; i++) {
    let pcNum = pt.PartyMember[i]
    let pc = PC[pcNum]
    if (pc.Hp > 0) {
      result = i
      break
    }
  }
  return result
}
function nextTargetSummon (group, num) {
  let result = -1
  num++
  for (let i = num; i < 9; i++) {
    let monNum = PlayData['SummonList'][group][i]
    if (monNum < 0) {
      break
    }
    if (SUMMON[monNum].Hp > 0) {
      result = i
      break
    }
  }
  return result
}
function parseStrToBoolean (str, defValue) {
  if (str == 'true' || str == '1') {
    return true
  } else {
    if (str == undefined && (defValue == true || defValue == false)) {
      return defValue
    } else {
      return false
    }
  }
}
function pcRecoveryOnReturn (pc) {
  let state = pc.State
  let recovery = false
  for (let i = 5; i > 0; i--) {
    if (GameData['RECOVERY_ON_RETURN'][i + 1] && state == i) {
      recovery = true
      break
    }
  }
  if (recovery) {
    pc.State = 0
    if (state == 4 || state == 5) {
      pc.controlHp(1)
    }
    state = 0
  }
  if (GameData['RECOVERY_ON_RETURN'][1] && state < 4) {
    for (let i = 0; i < GameData['SPELL_KIND']; i++) {
      for (let j = 0; j < GameData['SPELL_LVMAX']; j++) {
        pc.controlMp(i, j, 99)
      }
    }
  }
  if (GameData['RECOVERY_ON_RETURN'][0]) {
    pc.controlHp(99999)
  }
}
function preInput (type, key) {
  if (GenericVariable['KeyWait'] < 0) {
    GenericVariable['KeyWait'] = 0
    PreInputType.push(type)
    PreInput.push(key)
    if (PreInputType.length > 30) {
      PreInputType.splice(0, 1)
    }
    if (PreInput.length > 30) {
      PreInput.splice(0, 1)
    }
    let count = 0
    if (PreInputType.length > 1 && type != 'keyboard') {
      for (let i = PreInputType.length - 2; i >= 0; i--) {
        if (PreInputType[i] == type && PreInput[i] == key) {
          count++
        } else {
          break
        }
      }
    }
    if (count == 0 || count > 3) {
      let key2 = key + '_div'
      if (key2 == 'real_enter_div') {
        key2 = 'enter_div'
      }
      if (MP.ButtonObject[key2] != undefined) {
        eventMouseover(MP.ButtonObject[key2].firstChild, key2)
        MP.ButtonObject[key2].clickCount = 0
      }
      keyAction(key)
    }
  }
}
function printDebugMessage (str) {
  if (GameData['DEBUG'] && PlayData['DebugView']) {
    console.log(str)
  }
}
function printDebugMessageHp (targetChar, dmg) {
  if (dmg == undefined || dmg == null) {
    dmg = 0
  }
  let str =
    SPELL_EF.getName(targetChar, true) +
    ' HP: ' +
    MP.numberFormat(targetChar['char'].Hp) +
    ' / ' +
    MP.numberFormat(targetChar['char'].HpMax)
  if (dmg != 0) {
    str += ' ('
    if (dmg > -1) {
      str += '+' + String(dmg)
    } else {
      str += String(dmg)
    }
    str += ')'
  }
  printDebugMessage(str)
}
function readEndAction (readEnd) {
  if (Mode == 'option') {
    if (
      readEnd != 'graphic' &&
      !(readEnd.match(/^(music|sound)$/) && LoadingFlag)
    ) {
      return
    }
    if (readEnd == 'graphic') {
      if (PlayData['ActiveParty'] > -1) {
        let pt = PARTY[PlayData['ActiveParty']]
        let dungeonImage = DUNGEON.DungeonImage[pt.DungeonNumber][pt.Floor]
        let dungeonAry = dungeonImage.split('<->')
        GraphicData['null'] = null
        GraphicData['none'] = 'none'
        for (let i = 0; i < dungeonAry.length; i++) {
          if (dungeonAry[i] == '') {
            dungeonAry[i] = 'null'
          } else if (dungeonAry[i] != 'none') {
            dungeonAry[i] = 'graphic/dungeon/' + dungeonAry[i]
          }
        }
        MP.setDungeonGraphic(
          GraphicData[dungeonAry[1]],
          GraphicData[dungeonAry[8]],
          GraphicData[dungeonAry[2]],
          GraphicData[dungeonAry[0]],
          GraphicData[dungeonAry[11]],
          GraphicData[dungeonAry[5]],
          GraphicData[dungeonAry[12]],
          GraphicData[dungeonAry[6]],
          GraphicData[dungeonAry[3]],
          GraphicData[dungeonAry[7]],
          GraphicData[dungeonAry[4]],
          GraphicData[dungeonAry[9]],
          GraphicData[dungeonAry[10]]
        )
        DUNGEON.DungeonImageStr = dungeonImage
        for (let i = 1; i < 8; i++) {
          if (i == 6) {
            continue
          }
          for (let j = 0; j < MP.Wall3D[i].length; j++) {
            MP.setTextureWall3D(i, j, 0)
            MP.setTextureWall3D(i, j, 1)
          }
        }
        for (let i = 1; i < 5; i++) {
          for (let j = 0; j < MP.Floor3D[i].length; j++) {
            for (let k = 0; k < MP.Floor3D[i][j].length; k++) {
              for (let l = 0; l < MP.Floor3D[i][j][k].length; l++) {
                MP.setTextureFloor3D(i, j, k, l, 0)
                MP.setTextureFloor3D(i, j, k, l, 1)
              }
            }
          }
        }
        if (MP.ImgWall == null) {
          MP.DungeonMode = 'wireFrame'
        } else {
          MP.DungeonMode = 'graphic'
        }
        MP.paintDungeon(MP.DungeonMode)
      }
    }
    MP.setOptionMode('option')
    if (readEnd == 'music') {
      musicPlay(NowMusic)
    }
    if (readEnd.match(/^(music|sound)$/)) {
      LoadingFlag = false
    }
    GenericVariable['FullKeyInvalid'] = false
  } else if (GameState == 'reset') {
    main('start')
  } else if (GameState == 'training') {
    MP.SelectMode['run'] = false
    let num = addTransmigrationCharacter(base64.decode(UploadData, 1))
    let str = ''
    if (num == 0) {
      saveData()
      if (GameData['FACE_GRAPHIC_STATUS'] || GameData['FACE_GRAPHIC_BATTLE']) {
        GameState = 'trainingRegistration'
        readGraphicFile_Face(null, TempVariable['name'], readEndAction)
        delete TempVariable['name']
        return
      } else {
        delete TempVariable['name']
        str = getDefaultMessage('REGISTER', 1)
      }
    } else if (num == 1) {
      str = getDefaultMessage('REGISTER_NOT', 1)
    } else if (num == 2) {
      str = getDefaultMessage('REGISTERED', 1)
    }
    MP.drawTextFrame(
      MP.TextSurface[MP.TextSurfaceNum],
      str,
      'center',
      MP.LINE_HEIGHT * 7
    )
    GameState = 'trainingReturn'
    GenericVariable['FullKeyInvalid'] = false
  } else if (GameState.match(/^(training)/)) {
    MP.paintMask('clear')
    MP.TopSurface.clear()
    GenericVariable['FullKeyInvalid'] = false
    if (GameState == 'trainingCreateLast') {
      GameState = 'training'
      townAction('none')
    } else if (GameState == 'trainingRegistration') {
      MP.drawTextFrame(
        MP.TextSurface[MP.TextSurfaceNum],
        getDefaultMessage('REGISTER', 1),
        'center',
        MP.LINE_HEIGHT * 7
      )
      GameState = 'trainingReturn'
    } else if (GameState == 'trainingDeleteInitialize') {
      GameState = 'training'
      townAction('none')
    } else {
      townAction('return')
    }
  } else if (GameState == 'shopCommandReturn') {
    MP.paintMask('clear')
    MP.TopSurface.clear()
    GenericVariable['FullKeyInvalid'] = false
    MP.setMessage(TempVariable['text'], TempVariable['align'])
  } else if (GameState == 'moveReturn') {
    MP.paintMask('clear')
    MP.TopSurface.clear()
    GenericVariable['FullKeyInvalid'] = false
    MP.setMessage(TempVariable['text'], TempVariable['align'], true, false)
  } else if (GameState == 'moveEventReturn') {
    MP.paintMask('clear')
    MP.TopSurface.clear()
    GenericVariable['FullKeyInvalid'] = false
    GameState = 'moveEvent1'
    dungeonAction()
  } else if (GameState == 'setFaceGraphic') {
    MP.paintMask('clear')
    MP.TopSurface.clear()
    GameState = 'inspectCommand'
    MP.SelectMode['valueAry'][MP.SelectMode['select']] = 'setFaceGraphic'
    statusAction('return')
    GenericVariable['FullKeyInvalid'] = false
  }
}
function readGraphicFile (fileName, hr, callbackFunc) {
  let readFileCount = []
  for (let i = 0; i < 3; i++) {
    readFileCount[i] = 0
  }
  let readFileName = []
  if (Array.isArray(fileName)) {
    readFileName[0] = fileName.slice()
  } else {
    readFileName[0] = fileName.split(',')
  }
  readFileName[1] = []
  for (let i = 0; i < readFileName[0].length; i++) {
    readFileName[1][i] = []
    if (readFileName[0][i].match(/^<>/)) {
      readFileName[1][i][0] = readFileName[0][i]
    } else if (hr) {
      readFileName[1][i][0] = readFileName[0][i] + '_HR'
      readFileName[1][i][1] = readFileName[0][i]
    } else {
      readFileName[1][i][0] = readFileName[0][i]
      readFileName[1][i][1] = readFileName[0][i] + '_HR'
    }
  }
  readGraphicFile2(readFileName, readFileCount, callbackFunc)
}
function readGraphicFile2 (readFileName, readFileCount, callbackFunc) {
  if (GraphicData[readFileName[0][readFileCount[0]]] != undefined) {
    if (readFileCount[0] >= readFileName[0].length - 1) {
      callbackFunc('graphic')
    } else {
      readFileCount[0]++
      readFileCount[1] = 0
      readFileCount[2] = 0
      readGraphicFile2(readFileName, readFileCount, callbackFunc)
    }
    return
  }
  if (
    GenericVariable['ReadMonsterMax'] == undefined &&
    readFileCount[1] == 0 &&
    readFileCount[2] == 0
  ) {
    let loadMax = readFileName[0].length
    let loadNum = readFileCount[0]
    let loadPercent = Math.floor((loadNum / loadMax) * 100)
    if (GameState == 'launchLoading') {
      if (loadMax == 1) {
        TempVariable['loadingText'] = 'Now Loading\n(GRAPHIC)'
      } else {
        TempVariable['loadingText'] =
          'Now Loading\n(GRAPHIC' +
          MP.strFitLength(String(loadPercent), 3, 'right') +
          '%)'
      }
    } else {
      MP.TopSurface.clear()
      if (loadMax == 1) {
        MP.drawText_FullFrame(
          MP.TopSurface,
          'Now Loading',
          'left',
          25,
          'yellow'
        )
      } else {
        MP.drawText_FullFrame(
          MP.TopSurface,
          'Now Loading' +
            MP.strFitLength(String(loadPercent), 3, 'right') +
            '%',
          'left',
          25,
          'yellow'
        )
      }
    }
  }
  let img = new Image()
  let str
  let ext = ''
  if (readFileName[1][readFileCount[0]][readFileCount[1]].match(/^<>/)) {
    str = readFileName[1][readFileCount[0]][readFileCount[1]]
    str = str.replace(/^<>/, '')
  } else {
    ext = ExtData['graphic'][readFileCount[2]]
    str = readFileName[1][readFileCount[0]][readFileCount[1]] + '.' + ext
  }
  if (!LaunchSettings['GraphicCache']) {
    str += '?' + new Date().getTime()
  }
  img.src = str
  img.onload = function () {
    if (readFileCount[2] > 0 && ext != '') {
      setExtensionData('graphic', ext)
    }
    if (readFileCount[1] >= 1) {
      GenericVariable['PrioritizeHR'] = !GenericVariable['PrioritizeHR']
    }
    GraphicData[readFileName[0][readFileCount[0]]] = new Surface(
      img.width,
      img.height
    )
    GraphicData[readFileName[0][readFileCount[0]]].context.drawImage(img, 0, 0)
    if (readFileCount[0] >= readFileName[0].length - 1) {
      callbackFunc('graphic')
    } else {
      readFileCount[0]++
      readFileCount[1] = 0
      readFileCount[2] = 0
      readGraphicFile2(readFileName, readFileCount, callbackFunc)
    }
  }
  img.onerror = function () {
    if (
      readFileName[0][readFileCount[0]].match(/^<>/) ||
      (readFileCount[1] >= 1 &&
        readFileCount[2] >= ExtData['graphic'].length - 1)
    ) {
      GraphicData[readFileName[0][readFileCount[0]]] = null
      if (readFileCount[0] >= readFileName[0].length - 1) {
        callbackFunc('graphic')
      } else {
        readFileCount[0]++
        readFileCount[1] = 0
        readFileCount[2] = 0
        readGraphicFile2(readFileName, readFileCount, callbackFunc)
      }
    } else {
      if (readFileCount[2] >= ExtData['graphic'].length - 1) {
        readFileCount[1]++
        readFileCount[2] = 0
      } else {
        readFileCount[2]++
      }
      readGraphicFile2(readFileName, readFileCount, callbackFunc)
    }
  }
}
function readGraphicFile_Castle (castle, callbackFunc) {
  GenericVariable['FullKeyInvalid'] = true
  MP.paintMask()
  if (LaunchSettings['GraphicLimit']) {
    if (Prefetch['castle'].length >= GraphicPrefetchMax['castle']) {
      let str = Prefetch['castle'].shift()
      if (
        Prefetch['default'].indexOf(str) < 0 &&
        Prefetch['event'].indexOf(str) < 0
      ) {
        delete GraphicData[str]
      }
    }
  }
  Prefetch['castle'].push(castle)
  if (GraphicData[castle] == undefined) {
    readGraphicFile(castle, GenericVariable['PrioritizeHR'], callbackFunc)
  } else {
    callbackFunc('graphic')
  }
}
function readGraphicFile_Dungeon (dungeonAry, callbackFunc) {
  GenericVariable['FullKeyInvalid'] = true
  MP.paintMask()
  if (
    dungeonAry.length <= GraphicPrefetchMax['dungeon'] &&
    LaunchSettings['GraphicLimit']
  ) {
    let len =
      Prefetch['dungeon'].length +
      dungeonAry.length -
      GraphicPrefetchMax['dungeon']
    for (let i = 0; i < len; i++) {
      let str = Prefetch['dungeon'].shift()
      if (Prefetch['event'].indexOf(str) < 0) {
        delete GraphicData[str]
      }
    }
  }
  for (let i = 0; i < dungeonAry.length; i++) {
    Prefetch['dungeon'].push(dungeonAry[i])
  }
  let resultAry = []
  for (let i = 0; i < dungeonAry.length; i++) {
    if (GraphicData[dungeonAry[i]] == undefined) {
      resultAry.push(dungeonAry[i])
    }
  }
  if (resultAry.length > 0) {
    readGraphicFile(resultAry, GenericVariable['PrioritizeHR'], callbackFunc)
  } else {
    callbackFunc('graphic')
  }
}
function readGraphicFile_Event (eventAry, callbackFunc) {
  GenericVariable['FullKeyInvalid'] = true
  MP.paintMask()
  if (
    eventAry.length <= GraphicPrefetchMax['event'] &&
    LaunchSettings['GraphicLimit']
  ) {
    let len =
      Prefetch['event'].length + eventAry.length - GraphicPrefetchMax['event']
    for (let i = 0; i < len; i++) {
      let str = Prefetch['event'].shift()
      if (
        Prefetch['default'].indexOf(str) < 0 &&
        Prefetch['dungeon'].indexOf(str) < 0 &&
        Prefetch['monster'][0].indexOf(str) < 0 &&
        Prefetch['monster'][1].indexOf(str) < 0 &&
        Prefetch['face'].indexOf(str) < 0
      ) {
        delete GraphicData[str]
      }
    }
  }
  for (let i = 0; i < eventAry.length; i++) {
    Prefetch['event'].push(eventAry[i])
  }
  let resultAry = []
  for (let i = 0; i < eventAry.length; i++) {
    if (GraphicData[eventAry[i]] == undefined) {
      resultAry.push(eventAry[i])
    }
  }
  if (resultAry.length > 0) {
    readGraphicFile(resultAry, GenericVariable['PrioritizeHR'], callbackFunc)
  } else {
    callbackFunc('graphic')
  }
}
function readGraphicFile_Face (before, after, callbackFunc) {
  if (before != undefined && before != null && before != '') {
    if (!before.match(/^<>/)) {
      before = 'graphic/face/' + before
    }
    let num = Prefetch['face'].indexOf(before)
    if (num > -1) {
      Prefetch['face'].splice(num, 1)
      if (
        Prefetch['face'].indexOf(before) < 0 &&
        Prefetch['event'].indexOf(before) < 0
      ) {
        delete GraphicData[before]
      }
    }
  }
  if (after != undefined && after != null && after != '') {
    GenericVariable['FullKeyInvalid'] = true
    MP.paintMask()
    if (!after.match(/^<>/)) {
      after = 'graphic/face/' + after
    }
    Prefetch['face'].push(after)
    if (GraphicData[after] == undefined) {
      readGraphicFile(after, GenericVariable['PrioritizeHR'], callbackFunc)
    } else {
      callbackFunc('graphic')
    }
  }
}
function readGraphicFile_Monster (monsterAry, callbackFunc) {
  if (GameState == 'launchLoading') {
    if (monsterAry.length == 1) {
      TempVariable['loadingText'] = 'Now Loading\n(MONSTER GRAPHIC)'
    } else {
      TempVariable['loadingText'] = 'Now Loading\n(MONSTER GRAPHIC  0%)'
    }
  } else {
    GenericVariable['FullKeyInvalid'] = true
    MP.paintMask()
    MP.TopSurface.clear()
    if (monsterAry.length == 1) {
      MP.drawText_FullFrame(MP.TopSurface, 'Now Loading', 'left', 25, 'yellow')
    } else {
      MP.drawText_FullFrame(
        MP.TopSurface,
        'Now Loading  0%',
        'left',
        25,
        'yellow'
      )
    }
  }
  GenericVariable['ReadMonsterMax'] = monsterAry.length
  GenericVariable['ReadMonsterAry'] = monsterAry.slice()
  GenericVariable['ReadMonsterCallbackFunc'] = callbackFunc
  GenericVariable['ReadMonsterAutoDetect'] = 0
  GenericVariable['ReadMonsterCG'] = ''
  GenericVariable['ReadMonsterCG_Num'] = 0
  readGraphicFile_Monster2()
}
function readGraphicFile_Monster2 () {
  let num = GenericVariable['ReadMonsterAry'][0]
  let cg = [MONSTER_DATA[num].ConfirmedCG[0], MONSTER_DATA[num].ConfirmedCG[1]]
  if (
    cg[0] != '' &&
    Prefetch['monster'][0].indexOf(cg[0]) > -1 &&
    cg[1] != '' &&
    Prefetch['monster'][1].indexOf(cg[1]) > -1
  ) {
    GenericVariable['ReadMonsterAry'].splice(0, 1)
    if (GenericVariable['ReadMonsterAry'].length > 0) {
      let loadMax = GenericVariable['ReadMonsterMax']
      let loadNum = loadMax - GenericVariable['ReadMonsterAry'].length
      let loadPercent = Math.floor((loadNum / loadMax) * 100)
      if (GameState == 'launchLoading') {
        TempVariable['loadingText'] =
          'Now Loading\n(MONSTER GRAPHIC' +
          MP.strFitLength(String(loadPercent), 3, 'right') +
          '%)'
      } else {
        MP.TopSurface.clear()
        MP.drawText_FullFrame(
          MP.TopSurface,
          'Now Loading' +
            MP.strFitLength(String(loadPercent), 3, 'right') +
            '%',
          'left',
          25,
          'yellow'
        )
      }
      GenericVariable['ReadMonsterAutoDetect'] = 0
      readGraphicFile_Monster2()
    } else {
      if (GameState != 'launchLoading') {
        GenericVariable['FullKeyInvalid'] = false
      }
      GenericVariable['ReadMonsterCallbackFunc']('graphic')
      delete GenericVariable['ReadMonsterMax']
      delete GenericVariable['ReadMonsterAry']
      delete GenericVariable['ReadMonsterCallbackFunc']
      delete GenericVariable['ReadMonsterAutoDetect']
      delete GenericVariable['ReadMonsterCG']
      delete GenericVariable['ReadMonsterCG_Num']
    }
  } else {
    for (let i = 0; i < 2; i++) {
      GenericVariable['ReadMonsterCG_Num'] = i
      if (MONSTER_DATA[num].ConfirmedCG[i] == '') {
        if (MONSTER_DATA[num].CG[i] == 'AutoDetect') {
          let str
          if (GenericVariable['ReadMonsterAutoDetect'] == 0) {
            str = 'monster' + MP.numberDigitMatch(num, 4)
            if (i == 0) {
              str += 'Undecided'
            }
          } else if (GenericVariable['ReadMonsterAutoDetect'] == 1) {
            str = 'type' + MP.numberDigitMatch(MONSTER_DATA[num].TYPE, 2)
            if (i == 0) {
              str += 'Undecided'
            }
          } else {
            str = 'none'
          }
          GenericVariable['ReadMonsterCG'] = 'graphic/monster/' + str
          if (GenericVariable['ReadMonsterAutoDetect'] >= 2) {
            MONSTER_DATA[num].ConfirmedCG[i] = GenericVariable['ReadMonsterCG']
          }
        } else {
          GenericVariable['ReadMonsterCG'] =
            'graphic/monster/' + MONSTER_DATA[num].CG[i]
        }
        if (
          Prefetch['monster'][i].indexOf(GenericVariable['ReadMonsterCG']) > -1
        ) {
          MONSTER_DATA[num].ConfirmedCG[i] = GenericVariable['ReadMonsterCG']
        } else if (GraphicData[GenericVariable['ReadMonsterCG']] != undefined) {
          MONSTER_DATA[num].ConfirmedCG[i] = GenericVariable['ReadMonsterCG']
          Prefetch['monster'][i].push(GenericVariable['ReadMonsterCG'])
        } else {
          GenericVariable['ReadMonsterAutoDetect']++
          readGraphicFile(
            GenericVariable['ReadMonsterCG'],
            GenericVariable['PrioritizeHR'],
            readGraphicFile_Monster3
          )
          return
        }
      } else if (
        Prefetch['monster'][i].indexOf(MONSTER_DATA[num].ConfirmedCG[i]) < 0
      ) {
        if (GraphicData[MONSTER_DATA[num].ConfirmedCG[i]] != undefined) {
          Prefetch['monster'][i].push(MONSTER_DATA[num].ConfirmedCG[i])
        } else {
          GenericVariable['ReadMonsterCG'] = MONSTER_DATA[num].ConfirmedCG[i]
          readGraphicFile(
            GenericVariable['ReadMonsterCG'],
            GenericVariable['PrioritizeHR'],
            readGraphicFile_Monster3
          )
          return
        }
      }
    }
    GenericVariable['ReadMonsterAutoDetect'] = 0
    readGraphicFile_Monster2()
  }
}
function readGraphicFile_Monster3 () {
  let num = GenericVariable['ReadMonsterAry'][0]
  let i = GenericVariable['ReadMonsterCG_Num']
  let flag = false
  if (
    MONSTER_DATA[num].ConfirmedCG[i] != '' &&
    GraphicData[GenericVariable['ReadMonsterCG']] == null
  ) {
    flag = true
  } else if (GraphicData[GenericVariable['ReadMonsterCG']] != null) {
    if (MONSTER_DATA[num].ConfirmedCG[i] == '') {
      MONSTER_DATA[num].ConfirmedCG[i] = GenericVariable['ReadMonsterCG']
    }
    flag = true
  }
  if (flag) {
    if (
      GenericVariable['ReadMonsterMax'] <= GraphicPrefetchMax['monster'] &&
      LaunchSettings['GraphicLimit']
    ) {
      if (Prefetch['monster'][i].length >= GraphicPrefetchMax['monster']) {
        let str = Prefetch['monster'][i].shift()
        let i2 = 0
        if (i == 0) {
          i2 = 1
        }
        if (
          Prefetch['monster'][i2].indexOf(str) < 0 &&
          Prefetch['event'].indexOf(str) < 0
        ) {
          delete GraphicData[str]
        }
      }
    }
    GenericVariable['ReadMonsterAutoDetect'] = 0
    Prefetch['monster'][i].push(GenericVariable['ReadMonsterCG'])
  } else {
    delete GraphicData[GenericVariable['ReadMonsterCG']]
    if (MONSTER_DATA[num].CG[i] != 'AutoDetect') {
      MONSTER_DATA[num].CG[i] = 'AutoDetect'
      GenericVariable['ReadMonsterAutoDetect'] = 0
    }
  }
  readGraphicFile_Monster2()
}
function readGraphicInText (text, align) {
  TempVariable['text'] = text
  TempVariable['align'] = align
  let eventCG = []
  let reg = new RegExp('<img *src="([^>]*?)".*?>')
  while (text.match(reg)) {
    eventCG.push(RegExp.$1)
    text = text.replace(reg, '')
  }
  if (eventCG.length > 0) {
    let newEventCG = checkGraphic_Event(eventCG)
    if (newEventCG.length > 0) {
      readGraphicFile_Event(newEventCG, readEndAction)
      return true
    }
  }
  return false
}
function readMusicFile (name, fileName, callbackFunc) {
  let readFileCount = []
  for (let i = 0; i < 2; i++) {
    readFileCount[i] = 0
  }
  let musicName, readFileName
  if (Array.isArray(name)) {
    musicName = name.slice()
  } else {
    musicName = name.split(',')
  }
  if (Array.isArray(fileName)) {
    readFileName = fileName.slice()
  } else {
    readFileName = fileName.split(',')
  }
  readMusicFile2(musicName, readFileName, readFileCount, callbackFunc)
}
function readMusicFile2 (musicName, readFileName, readFileCount, callbackFunc) {
  if (MusicData[musicName[readFileCount[0]]] != undefined) {
    if (readFileCount[0] >= readFileName.length - 1) {
      callbackFunc('music')
    } else {
      readFileCount[0]++
      readFileCount[1] = 0
      readMusicFile2(musicName, readFileName, readFileCount, callbackFunc)
    }
    return
  }
  if (readFileCount[1] == 0) {
    let loadMax = readFileName.length
    let loadNum = readFileCount[0]
    let loadPercent = Math.floor((loadNum / loadMax) * 100)
    if (GameState == 'launchLoading') {
      TempVariable['loadingText'] =
        'Now Loading\n(MUSIC' +
        MP.strFitLength(String(loadPercent), 3, 'right') +
        '%)'
    } else {
      MP.TopSurface.clear()
      MP.drawText_FullFrame(
        MP.TopSurface,
        'Now Loading' + MP.strFitLength(String(loadPercent), 3, 'right') + '%',
        'left',
        25,
        'yellow'
      )
    }
  }
  let ext = ExtData['music'][readFileCount[1]]
  let src = readFileName[readFileCount[0]] + '.' + ext
  if (!LaunchSettings['SoundCache']) {
    src += '?' + new Date().getTime()
  }
  if (AudioPlay) {
    MusicData[musicName[readFileCount[0]]] = new Audio(src)
    MusicData[musicName[readFileCount[0]]].loop = true
    MusicData[musicName[readFileCount[0]]].load()
    MusicData[musicName[readFileCount[0]]].addEventListener(
      'canplaythrough',
      function () {
        if (readFileCount[1] > 0) {
          setExtensionData('music', ext)
        }
        if (readFileCount[0] >= readFileName.length - 1) {
          callbackFunc('music')
        } else {
          readFileCount[0]++
          readFileCount[1] = 0
          readMusicFile2(musicName, readFileName, readFileCount, callbackFunc)
        }
      },
      false
    )
    MusicData[musicName[readFileCount[0]]].addEventListener(
      'error',
      function () {
        MusicData[musicName[readFileCount[0]]] = null
        if (readFileCount[1] >= ExtData['music'].length - 1) {
          if (readFileCount[0] >= readFileName.length - 1) {
            callbackFunc('music')
          } else {
            readFileCount[0]++
            readFileCount[1] = 0
            readMusicFile2(musicName, readFileName, readFileCount, callbackFunc)
          }
        } else {
          readFileCount[1]++
          readMusicFile2(musicName, readFileName, readFileCount, callbackFunc)
        }
      },
      false
    )
  } else {
    let type = null
    if (ExtData['music'][readFileCount[1]].match(/mp3|MP3/)) {
      type = 'audio/mpeg'
    }
    MusicData[musicName[readFileCount[0]]] = DOMSound.load(
      src,
      type,
      function () {
        if (readFileCount[1] > 0) {
          setExtensionData('music', ext)
        }
        if (readFileCount[0] >= readFileName.length - 1) {
          callbackFunc('music')
        } else {
          readFileCount[0]++
          readFileCount[1] = 0
          readMusicFile2(musicName, readFileName, readFileCount, callbackFunc)
        }
      },
      function () {
        MusicData[musicName[readFileCount[0]]] = null
        if (readFileCount[1] >= ExtData['music'].length - 1) {
          if (readFileCount[0] >= readFileName.length - 1) {
            callbackFunc('music')
          } else {
            readFileCount[0]++
            readFileCount[1] = 0
            readMusicFile2(musicName, readFileName, readFileCount, callbackFunc)
          }
        } else {
          readFileCount[1]++
          readMusicFile2(musicName, readFileName, readFileCount, callbackFunc)
        }
      }
    )
  }
}
function readSoundFile (name, fileName, callbackFunc) {
  let readFileCount = []
  for (let i = 0; i < 2; i++) {
    readFileCount[i] = 0
  }
  let soundName, readFileName
  if (Array.isArray(name)) {
    soundName = name.slice()
  } else {
    soundName = name.split(',')
  }
  if (Array.isArray(fileName)) {
    readFileName = fileName.slice()
  } else {
    readFileName = fileName.split(',')
  }
  readSoundFile2(soundName, readFileName, readFileCount, callbackFunc)
}
function readSoundFile2 (soundName, readFileName, readFileCount, callbackFunc) {
  if (SoundData[soundName[readFileCount[0]]] != undefined) {
    if (readFileCount[0] >= readFileName.length - 1) {
      callbackFunc('sound')
    } else {
      readFileCount[0]++
      readFileCount[1] = 0
      readSoundFile2(soundName, readFileName, readFileCount, callbackFunc)
    }
    return
  }
  if (readFileCount[1] == 0) {
    let loadMax = readFileName.length
    let loadNum = readFileCount[0]
    let loadPercent = Math.floor((loadNum / loadMax) * 100)
    if (GameState == 'launchLoading') {
      TempVariable['loadingText'] =
        'Now Loading\n(SE' +
        MP.strFitLength(String(loadPercent), 3, 'right') +
        '%)'
    } else {
      MP.TopSurface.clear()
      MP.drawText_FullFrame(
        MP.TopSurface,
        'Now Loading' + MP.strFitLength(String(loadPercent), 3, 'right') + '%',
        'left',
        25,
        'yellow'
      )
    }
  }
  let ext = ExtData['sound'][readFileCount[1]]
  let src = readFileName[readFileCount[0]] + '.' + ext
  if (!LaunchSettings['SoundCache']) {
    src += '?' + new Date().getTime()
  }
  if (AudioPlay) {
    let sound = new Audio(src)
    sound.load()
    sound.addEventListener(
      'canplaythrough',
      function () {
        if (readFileCount[1] > 0) {
          setExtensionData('sound', ext)
        }
        SoundData[soundName[readFileCount[0]]] = new SoundEffect(sound)
        if (readFileCount[0] >= readFileName.length - 1) {
          callbackFunc('sound')
        } else {
          readFileCount[0]++
          readFileCount[1] = 0
          readSoundFile2(soundName, readFileName, readFileCount, callbackFunc)
        }
      },
      false
    )
    sound.addEventListener(
      'error',
      function () {
        if (readFileCount[1] >= ExtData['sound'].length - 1) {
          SoundData[soundName[readFileCount[0]]] = null
          if (readFileCount[0] >= readFileName.length - 1) {
            callbackFunc('sound')
          } else {
            readFileCount[0]++
            readFileCount[1] = 0
            readSoundFile2(soundName, readFileName, readFileCount, callbackFunc)
          }
        } else {
          readFileCount[1]++
          readSoundFile2(soundName, readFileName, readFileCount, callbackFunc)
        }
      },
      false
    )
  } else {
    let type = null
    if (ExtData['sound'][readFileCount[1]].match(/mp3|MP3/)) {
      type = 'audio/mpeg'
    } else if (ExtData['sound'][readFileCount[1]].match(/wav|WAV/)) {
      type = 'audio/wav'
    }
    let sound = DOMSound.load(
      src,
      type,
      function () {
        if (readFileCount[1] > 0) {
          setExtensionData('sound', ext)
        }
        SoundData[soundName[readFileCount[0]]] = new SoundEffect(sound)
        if (readFileCount[0] >= readFileName.length - 1) {
          callbackFunc('sound')
        } else {
          readFileCount[0]++
          readFileCount[1] = 0
          readSoundFile2(soundName, readFileName, readFileCount, callbackFunc)
        }
      },
      function () {
        SoundData[soundName[readFileCount[0]]] = null
        if (readFileCount[1] >= ExtData['sound'].length - 1) {
          if (readFileCount[0] >= readFileName.length - 1) {
            callbackFunc('sound')
          } else {
            readFileCount[0]++
            readFileCount[1] = 0
            readSoundFile2(soundName, readFileName, readFileCount, callbackFunc)
          }
        } else {
          readFileCount[1]++
          readSoundFile2(soundName, readFileName, readFileCount, callbackFunc)
        }
      }
    )
  }
}
function recoverySaveData () {
  GenericVariable['FullKeyInvalid'] = false
  let dataStr = UploadData
  UploadData = ''
  if (checkSaveData(base64.decode(dataStr, 1))) {
    localStorage.setItem(SaveName + 'Save', dataStr)
    alert(getDefaultMessage('SYSTEM_RECOVERY_COMPLETED', 1))
    reset()
  } else {
    alert(getDefaultMessage('SYSTEM_RECOVERY_FAILED', 1))
  }
}
function registerInMonsterCatalog (target) {
  let catalog = GameData['REGISTRATION_MONSTER_CATALOG']
  if (
    (catalog == 2 && TempVariable['monsterDecided'][target]) ||
    catalog == 3
  ) {
    let monDataNum = TempVariable['setMonster'][target]
    if (!PlayData['MonsterFlag'][monDataNum]) {
      printDebugMessage(
        String(monDataNum) +
          ':' +
          MONSTER_DATA[monDataNum].NAME[1] +
          ' was registered with a catalog.'
      )
      PlayData['MonsterFlag'][monDataNum] = true
    }
  }
}
function removeKeyEvent () {
  document.removeEventListener('keydown', eventKeydown)
  document.removeEventListener('keyup', eventKeyup)
  document.onkeydown = null
  eventOnblur()
}
function replaceBrackets (mode, str) {
  if (mode.match(/^(encode|en)$/)) {
    str = str.replace(/\\\\/g, '<,>')
    str = str.replace(/\\\[/g, '<->')
    str = str.replace(/\\\]/g, '</>')
    str = str.replace(/\\\(/g, '</1>')
    str = str.replace(/\\\)/g, '</2>')
    str = str.replace(/\\\{/g, '</3>')
    str = str.replace(/\\\}/g, '</4>')
  } else if (mode.match(/^(decode|de)$/)) {
    str = str.replace(/<->/g, '[')
    str = str.replace(/<\/>/g, ']')
    str = str.replace(/<\/1>/g, '(')
    str = str.replace(/<\/2>/g, ')')
    str = str.replace(/<\/3>/g, '{')
    str = str.replace(/<\/4>/g, '}')
    str = str.replace(/<,>/g, '\\')
  }
  return str
}
function replaceFormula (formula, repAry, noDice, noGm) {
  if (repAry == undefined || repAry == null) {
    repAry = []
  }
  if (noDice == undefined || noDice == null) {
    noDice = false
  }
  if (noGm == undefined || noGm == null) {
    noGm = false
  }
  if (!Number.isNaN(formula)) {
    formula = String(formula)
  }
  formula = replaceBrackets('en', formula)
  formula = formula.replace(/\.abi2\[/g, '.abi[')
  formula = formula.replace(/\.Abi2\[/g, '.Abi[')
  formula = formula.replace(/averageLv/g, 'pt.lv')
  formula = formula.replace(/PtSexP\[([0-9]+)\]/g, 'pt.Sex[$1]')
  formula = formula.replace(/PtSex\[([0-9]+)\]/g, 'pt.Sex[$1]')
  formula = formula.replace(/PtAliP\[([0-9]+)\]/g, 'pt.Ali[$1]')
  formula = formula.replace(/PtAli\[([0-9]+)\]/g, 'pt.Ali[$1]')
  formula = formula.replace(/PtAlignmentP\[([0-9]+)\]/g, 'pt.Ali[$1]')
  formula = formula.replace(/PtAlignment\[([0-9]+)\]/g, 'pt.Ali[$1]')
  formula = formula.replace(/PtRaceP\[([0-9]+)\]/g, 'pt.Race[$1]')
  formula = formula.replace(/PtRace\[([0-9]+)\]/g, 'pt.Race[$1]')
  formula = formula.replace(/PtClassP\[([0-9]+)\]/g, 'pt.Class[$1]')
  formula = formula.replace(/PtClass\[([0-9]+)\]/g, 'pt.Class[$1]')
  formula = formula.replace(/PtNum\[([0-9]+)\]/g, 'PtMemberNum[$1]')
  formula = formula.replace(/PtNumP\[([0-9]+)\]/g, 'pt.MemberNum[$1]')
  formula = formula.replace(/DumpItem/g, 'dumpitem')
  formula = formula.replace(/AllItem/g, 'allitem')
  formula = formula.replace(/PtItem/g, 'ptitem')
  formula = formula.replace(/(^|[^\.])Item\[([0-9]+)\]/g, '$1AllItem[$2]')
  formula = formula.replace(/dumpitem/g, 'DumpItem')
  formula = formula.replace(/allitem/g, 'AllItem')
  formula = formula.replace(/ptitem/g, 'PtItem')
  let pt = PlayData['ActiveParty']
  if (formula.indexOf('turn') > -1) {
    let replaceStr = '0'
    if (GameState.match(/^battle/)) {
      replaceStr = String(TempVariable['turn'])
    }
    formula = formula.replace(/turn/g, replaceStr)
  }
  for (let i = 0; i < repAry.length; i++) {
    let cStr = repAry[i][0]
    if (!cStr.match(/pc|monster|summon/)) {
      continue
    }
    let cNum = repAry[i][1],
      cm
    if (cStr.indexOf('pc') > -1) {
      if (cNum > -1 && cNum < GameData['PC_ENTRY_MAX']) {
        cm = PC[cNum]
      } else {
        continue
      }
    } else if (cNum > -1 && cNum < MONSTER.length) {
      cm = MONSTER[cNum]
    } else if (cNum > 49 && cNum < 68) {
      cm = SUMMON[cNum - 50]
    } else {
      continue
    }
    if (cm == undefined) {
      continue
    }
    if (formula.indexOf(cStr + '.itemCommentNum') > -1) {
      if (cStr.match(/pc/)) {
        let str = cStr + '\\.itemCommentNum\\[([^\\[\\]]+)\\]\\[([0-9]+)\\]'
        let reg = new RegExp(str)
        while (formula.match(reg)) {
          let str2 = RegExp.$1
          let num = Number(RegExp.$2)
          let str3 = replaceBrackets('de', str2)
          let result = String(cm.itemCommentNum(str3, num))
          if (result == 'undefined' || result == 'null') {
            result = '0'
          }
          str3 =
            cStr +
            '\\.itemCommentNum\\[' +
            MP.escapeProcessing(str2) +
            '\\]\\[' +
            String(num) +
            '\\]'
          let reg2 = new RegExp(str3, 'g')
          formula = formula.replace(reg2, result)
        }
      } else {
        let reg = new RegExp(
          cStr + '\\.itemCommentNum\\[[^\\[\\]]*\\]\\[[0-9]*\\]',
          'g'
        )
        formula = formula.replace(reg, '0')
      }
    }
    if (formula.indexOf(cStr + '.classCommentNum') > -1 && cStr.match(/pc/)) {
      let str = cStr + '\\.classCommentNum\\[([^\\[\\]]+)\\]'
      let reg = new RegExp(str)
      while (formula.match(reg)) {
        let str2 = RegExp.$1
        let str3 = replaceBrackets('de', str2)
        let result = String(cm.classCommentNum(str3))
        if (result == 'undefined' || result == 'null') {
          result = '0'
        }
        str3 =
          cStr + '\\.classCommentNum\\[' + MP.escapeProcessing(str2) + '\\]'
        let reg2 = new RegExp(str3, 'g')
        formula = formula.replace(reg2, result)
      }
    }
    if (formula.indexOf(cStr + '.raceCommentNum') > -1) {
      let str = cStr + '\\.raceCommentNum\\[([^\\[\\]]+)\\]'
      let reg = new RegExp(str)
      while (formula.match(reg)) {
        let str2 = RegExp.$1
        let str3 = replaceBrackets('de', str2)
        let result = String(cm.raceCommentNum(str3))
        if (result == 'undefined' || result == 'null') {
          result = '0'
        }
        str3 = cStr + '\\.raceCommentNum\\[' + MP.escapeProcessing(str2) + '\\]'
        let reg2 = new RegExp(str3, 'g')
        formula = formula.replace(reg2, result)
      }
    }
    if (formula.indexOf(cStr + '.groupActionableMemberNum') > -1) {
      let reg = new RegExp(cStr + '\\.groupActionableMemberNum', 'g')
      let result = String(cm.getGroupMemberNum(true))
      if (result == 'undefined' || result == 'null') {
        result = '0'
      }
      formula = formula.replace(reg, result)
    }
    if (formula.indexOf(cStr + '.groupMemberNum') > -1) {
      let reg = new RegExp(cStr + '\\.groupMemberNum', 'g')
      let result = String(cm.getGroupMemberNum(false))
      if (result == 'undefined' || result == 'null') {
        result = '0'
      }
      formula = formula.replace(reg, result)
    }
    if (formula.indexOf(cStr + '.groupMember') > -1) {
      let reg = new RegExp(cStr + '\\.groupMember', 'g')
      let result = String(cm.getGroupMember())
      if (result == 'undefined' || result == 'null') {
        result = '0'
      }
      formula = formula.replace(reg, result)
    }
    if (formula.indexOf(cStr + '.mpMax') > -1) {
      let str = cStr + '\\.mpMax\\[([0-9]+)\\]\\[([0-9]+)\\]'
      let reg = new RegExp(str)
      while (formula.match(reg)) {
        let num1 = Number(RegExp.$1)
        let num2 = Number(RegExp.$2)
        let result = String(cm.MpMax[num1][num2])
        if (result == 'undefined' || result == 'null') {
          result = '0'
        }
        let str2 =
          cStr + '\\.mpMax\\[' + String(num1) + '\\]\\[' + String(num2) + '\\]'
        let reg2 = new RegExp(str2, 'g')
        formula = formula.replace(reg2, result)
      }
    }
    if (formula.indexOf(cStr + '.mp') > -1) {
      let str = cStr + '\\.mp\\[([0-9]+)\\]\\[([0-9]+)\\]'
      let reg = new RegExp(str)
      while (formula.match(reg)) {
        let num1 = Number(RegExp.$1)
        let num2 = Number(RegExp.$2)
        let result = String(cm.Mp[num1][num2])
        if (result == 'undefined' || result == 'null') {
          result = '0'
        }
        let str2 =
          cStr + '\\.mp\\[' + String(num1) + '\\]\\[' + String(num2) + '\\]'
        let reg2 = new RegExp(str2, 'g')
        formula = formula.replace(reg2, result)
      }
    }
    if (formula.indexOf(cStr + '.abi0') > -1) {
      let str = cStr + '\\.abi0\\[([0-9]+)\\]'
      let reg = new RegExp(str)
      while (formula.match(reg)) {
        let num = Number(RegExp.$1)
        let result = '0'
        if (num < GameData['ABILITY'].length) {
          result = String(cm.Ability0[num])
          if (result == 'undefined' || result == 'null') {
            result = '0'
          }
        }
        let str2 = cStr + '\\.abi0\\[' + String(num) + '\\]'
        let reg2 = new RegExp(str2, 'g')
        formula = formula.replace(reg2, result)
      }
    }
    if (formula.indexOf(cStr + '.abi1') > -1) {
      let str = cStr + '\\.abi1\\[([0-9]+)\\]'
      let reg = new RegExp(str)
      while (formula.match(reg)) {
        let num = Number(RegExp.$1)
        let result = '0'
        if (num < GameData['ABILITY'].length) {
          result = String(cm.Ability1[num])
          if (result == 'undefined' || result == 'null') {
            result = '0'
          }
        }
        let str2 = cStr + '\\.abi1\\[' + String(num) + '\\]'
        let reg2 = new RegExp(str2, 'g')
        formula = formula.replace(reg2, result)
      }
    }
    if (formula.indexOf(cStr + '.abi') > -1) {
      let str = cStr + '\\.abi\\[([0-9]+)\\]'
      let reg = new RegExp(str)
      while (formula.match(reg)) {
        let num = Number(RegExp.$1)
        let result = '0'
        if (num < GameData['ABILITY'].length) {
          result = String(cm.Ability[num])
          if (result == 'undefined' || result == 'null') {
            result = '0'
          }
        }
        let str2 = cStr + '\\.abi\\[' + String(num) + '\\]'
        let reg2 = new RegExp(str2, 'g')
        formula = formula.replace(reg2, result)
      }
    }
    if (formula.indexOf(cStr + '.Type') > -1 && cStr.match(/mon/)) {
      let str = cStr + '\\.Type\\[([0-9]+)\\]'
      let reg = new RegExp(str)
      while (formula.match(reg)) {
        let num = Number(RegExp.$1)
        let result = '0'
        if (MONSTER_DATA[cm.MonsterDataNum].TYPE == num) {
          result = '1'
        }
        let str2 = cStr + '\\.Type\\[' + String(num) + '\\]'
        let reg2 = new RegExp(str2, 'g')
        formula = formula.replace(reg2, result)
      }
    }
    if (formula.indexOf(cStr + '.Double') > -1 && cStr.match(/pc/)) {
      let str = cStr + '\\.Double\\[([0-9]+)\\]'
      let reg = new RegExp(str)
      while (formula.match(reg)) {
        let num = Number(RegExp.$1)
        let result = '0'
        if (num < MONSTER_TYPE) {
          if (cm.Attack[num]) {
            result = '1'
          }
        }
        let str2 = cStr + '\\.Double\\[' + String(num) + '\\]'
        let reg2 = new RegExp(str2, 'g')
        formula = formula.replace(reg2, result)
      }
    }
    if (formula.indexOf(cStr + '.Defense') > -1 && cStr.match(/pc/)) {
      let str = cStr + '\\.Defense\\[([0-9]+)\\]'
      let reg = new RegExp(str)
      while (formula.match(reg)) {
        let num = Number(RegExp.$1)
        let result = '0'
        if (num < MONSTER_TYPE) {
          if (cm.Defense[num]) {
            result = '1'
          }
        }
        let str2 = cStr + '\\.Defense\\[' + String(num) + '\\]'
        let reg2 = new RegExp(str2, 'g')
        formula = formula.replace(reg2, result)
      }
    }
    if (formula.indexOf(cStr + '.Resist0') > -1) {
      let str = cStr + '\\.Resist0\\[([0-9]+)\\]'
      let reg = new RegExp(str)
      while (formula.match(reg)) {
        let num = Number(RegExp.$1)
        let result = '0'
        if (cm.Resist0[num]) {
          result = '1'
        }
        let str2 = cStr + '\\.Resist0\\[' + String(num) + '\\]'
        let reg2 = new RegExp(str2, 'g')
        formula = formula.replace(reg2, result)
      }
    }
    if (formula.indexOf(cStr + '.Resist1') > -1) {
      let str = cStr + '\\.Resist1\\[([0-9]+)\\]'
      let reg = new RegExp(str)
      while (formula.match(reg)) {
        let num = Number(RegExp.$1)
        let result = '0'
        if (cm.Resist1[num]) {
          result = '1'
        }
        let str2 = cStr + '\\.Resist1\\[' + String(num) + '\\]'
        let reg2 = new RegExp(str2, 'g')
        formula = formula.replace(reg2, result)
      }
    }
    if (formula.indexOf(cStr + '.Resist') > -1) {
      let str = cStr + '\\.Resist\\[([0-9]+)\\]'
      let reg = new RegExp(str)
      while (formula.match(reg)) {
        let num = Number(RegExp.$1)
        let result = '0'
        if (cm.Resist[num]) {
          result = '1'
        }
        let str2 = cStr + '\\.Resist\\[' + String(num) + '\\]'
        let reg2 = new RegExp(str2, 'g')
        formula = formula.replace(reg2, result)
      }
    }
    if (formula.indexOf(cStr + '.WeakPoint0') > -1 && cStr.match(/mon/)) {
      let str = cStr + '\\.WeakPoint0\\[([0-9]+)\\]'
      let reg = new RegExp(str)
      while (formula.match(reg)) {
        let num = Number(RegExp.$1)
        let result = '0'
        if (cm.WeakPoint0[num]) {
          result = '1'
        }
        let str2 = cStr + '\\.WeakPoint0\\[' + String(num) + '\\]'
        let reg2 = new RegExp(str2, 'g')
        formula = formula.replace(reg2, result)
      }
    }
    if (formula.indexOf(cStr + '.WeakPoint1') > -1 && cStr.match(/mon/)) {
      let str = cStr + '\\.WeakPoint1\\[([0-9]+)\\]'
      let reg = new RegExp(str)
      while (formula.match(reg)) {
        let num = Number(RegExp.$1)
        let result = '0'
        if (cm.WeakPoint1[num]) {
          result = '1'
        }
        let str2 = cStr + '\\.WeakPoint1\\[' + String(num) + '\\]'
        let reg2 = new RegExp(str2, 'g')
        formula = formula.replace(reg2, result)
      }
    }
    if (formula.indexOf(cStr + '.WeakPoint') > -1 && cStr.match(/mon/)) {
      let str = cStr + '\\.WeakPoint\\[([0-9]+)\\]'
      let reg = new RegExp(str)
      while (formula.match(reg)) {
        let num = Number(RegExp.$1)
        let result = '0'
        if (cm.WeakPoint[num]) {
          result = '1'
        }
        let str2 = cStr + '\\.WeakPoint\\[' + String(num) + '\\]'
        let reg2 = new RegExp(str2, 'g')
        formula = formula.replace(reg2, result)
      }
    }
    if (formula.indexOf(cStr + '.State') > -1) {
      let str = cStr + '\\.State\\[([0-9]+)\\]'
      let reg = new RegExp(str)
      while (formula.match(reg)) {
        let num = Number(RegExp.$1)
        let result = '0'
        if (num == 0) {
          if (
            cm.State == 0 &&
            cm.Silence == 0 &&
            cm.Asleep == 0 &&
            cm.NoBreath == 0 &&
            cm.Poison == 0 &&
            !cm.SealSpell
          ) {
            result = '1'
          }
        } else if (num < 7) {
          if (cm.State == num) {
            result = '1'
          }
        } else if (num == 7) {
          if (cm.Silence != 0) {
            result = '1'
          }
        } else if (num == 8) {
          if (cm.Asleep > 0) {
            result = '1'
          }
        } else if (num == 9) {
          if (cm.Asleep < 0) {
            result = '1'
          }
        } else if (num == 10) {
          if (cm.NoBreath > 0) {
            result = '1'
          }
        } else if (num == 11) {
          if (cm.SealSpell) {
            result = '1'
          }
        } else if (num == 12) {
          if (cm.Poison > 0) {
            result = '1'
          }
        } else if (num == 13) {
          if (GameState.match(/^battle/) && cm.Hide) {
            result = '1'
          }
        }
        let str2 = cStr + '\\.State\\[' + String(num) + '\\]'
        let reg2 = new RegExp(str2, 'g')
        formula = formula.replace(reg2, result)
      }
    }
    if (formula.indexOf(cStr + '.AttackAdd') > -1) {
      let str = cStr + '\\.AttackAdd\\[([0-9]+)\\]'
      let reg = new RegExp(str)
      while (formula.match(reg)) {
        let num = Number(RegExp.$1)
        let result = '0'
        if (cm.checkAttackAdd(num)) {
          result = '1'
        }
        let str2 = cStr + '\\.AttackAdd\\[' + String(num) + '\\]'
        let reg2 = new RegExp(str2, 'g')
        formula = formula.replace(reg2, result)
      }
    }
    if (formula.indexOf(cStr + '.gm') > -1 && cStr.match(/pc/)) {
      let str = cStr + '\\.gm\\[([0-9]+)\\]'
      let reg = new RegExp(str)
      while (formula.match(reg)) {
        let num = Number(RegExp.$1)
        let result
        if (noGm) {
          result = '0'
        } else {
          result = GameData['GENERAL_CORRECTION'][cm.PcClass][num]
        }
        if (result == undefined || result == null) {
          result = '1'
        }
        if (!noGm) {
          result =
            '(' + replaceFormula(result, [['pc', cNum]], false, true) + ')'
        }
        let str2 = cStr + '\\.gm\\[' + String(num) + '\\]'
        let reg2 = new RegExp(str2, 'g')
        formula = formula.replace(reg2, result)
      }
    }
    if (formula.indexOf(cStr + '.rank') > -1) {
      let result = 1
      if (cStr.match(/pc/)) {
        if (pt > -1) {
          if (!PARTY[pt].frontRankCheck(PARTY[pt].getMemberForPcNum(cNum))) {
            result = 2
          }
        }
      } else {
        result = getMonsterRank(cNum)
      }
      let reg = new RegExp(cStr + '\\.rank', 'g')
      formula = formula.replace(reg, String(result))
    }
    if (formula.indexOf(cStr + '.lv') > -1) {
      let reg = new RegExp(cStr + '\\.lv', 'g')
      let result = String(cm.Level)
      if (result == 'undefined' || result == 'null') {
        result = '0'
      }
      formula = formula.replace(reg, result)
    }
    if (formula.indexOf(cStr + '.ac0') > -1) {
      let reg = new RegExp(cStr + '\\.ac0', 'g')
      let result = String(cm.Ac0)
      if (result == 'undefined' || result == 'null') {
        result = '0'
      }
      formula = formula.replace(reg, result)
    }
    if (formula.indexOf(cStr + '.ac1') > -1) {
      let reg = new RegExp(cStr + '\\.ac1', 'g')
      let result = String(cm.Ac1)
      if (result == 'undefined' || result == 'null') {
        result = '0'
      }
      formula = formula.replace(reg, result)
    }
    if (formula.indexOf(cStr + '.ac2') > -1) {
      let reg = new RegExp(cStr + '\\.ac2', 'g')
      let result = String(cm.getAc(true))
      if (result == 'undefined' || result == 'null') {
        result = '0'
      }
      formula = formula.replace(reg, result)
    }
    if (formula.indexOf(cStr + '.ac') > -1) {
      let reg = new RegExp(cStr + '\\.ac', 'g')
      let result = String(cm.getAc())
      if (result == 'undefined' || result == 'null') {
        result = '0'
      }
      formula = formula.replace(reg, result)
    }
    if (formula.indexOf(cStr + '.hpMax0') > -1) {
      let reg = new RegExp(cStr + '\\.hpMax0', 'g')
      let result = String(cm.HpMax0)
      if (result == 'undefined' || result == 'null') {
        result = '0'
      }
      formula = formula.replace(reg, result)
    }
    if (formula.indexOf(cStr + '.hpMax') > -1) {
      let reg = new RegExp(cStr + '\\.hpMax', 'g')
      let result = String(cm.HpMax)
      if (result == 'undefined' || result == 'null') {
        result = '0'
      }
      formula = formula.replace(reg, result)
    }
    if (formula.indexOf(cStr + '.hp') > -1) {
      let reg = new RegExp(cStr + '\\.hp', 'g')
      let result = String(cm.Hp)
      if (result == 'undefined' || result == 'null') {
        result = '0'
      }
      formula = formula.replace(reg, result)
    }
    if (formula.indexOf(cStr + '.at0') > -1) {
      let reg = new RegExp(cStr + '\\.at0', 'g')
      let result = String(cm.At0)
      if (result == 'undefined' || result == 'null') {
        result = '0'
      }
      formula = formula.replace(reg, result)
    }
    if (formula.indexOf(cStr + '.at') > -1) {
      let reg = new RegExp(cStr + '\\.at', 'g')
      let result = String(cm.At)
      if (result == 'undefined' || result == 'null') {
        result = '0'
      }
      formula = formula.replace(reg, result)
    }
    if (formula.indexOf(cStr + '.hit0') > -1) {
      let reg = new RegExp(cStr + '\\.hit0', 'g')
      let result = String(cm.Hit0)
      if (result == 'undefined' || result == 'null') {
        result = '0'
      }
      formula = formula.replace(reg, result)
    }
    if (formula.indexOf(cStr + '.hit1') > -1) {
      let reg = new RegExp(cStr + '\\.hit1', 'g')
      let result = String(cm.Hit1)
      if (result == 'undefined' || result == 'null') {
        result = '0'
      }
      formula = formula.replace(reg, result)
    }
    if (formula.indexOf(cStr + '.hit') > -1) {
      let reg = new RegExp(cStr + '\\.hit', 'g')
      let result = String(cm.Hit)
      if (result == 'undefined' || result == 'null') {
        result = '0'
      }
      formula = formula.replace(reg, result)
    }
    if (formula.indexOf(cStr + '.sc0') > -1) {
      let reg = new RegExp(cStr + '\\.sc0', 'g')
      let result = String(cm.SpellCancel0)
      if (result == 'undefined' || result == 'null') {
        result = '0'
      }
      formula = formula.replace(reg, result)
    }
    if (formula.indexOf(cStr + '.sc1') > -1) {
      let reg = new RegExp(cStr + '\\.sc1', 'g')
      let result = String(cm.SpellCancel1)
      if (result == 'undefined' || result == 'null') {
        result = '0'
      }
      formula = formula.replace(reg, result)
    }
    if (formula.indexOf(cStr + '.sc') > -1) {
      let reg = new RegExp(cStr + '\\.sc', 'g')
      let result = String(cm.SpellCancel)
      if (result == 'undefined' || result == 'null') {
        result = '0'
      }
      formula = formula.replace(reg, result)
    }
    if (formula.indexOf(cStr + '.spellCancel') > -1) {
      let reg = new RegExp(cStr + '\\.spellCancel', 'g')
      let result = String(cm.SpellCancel)
      if (result == 'undefined' || result == 'null') {
        result = '0'
      }
      formula = formula.replace(reg, result)
    }
    if (formula.indexOf(cStr + '.breathBarrierNum') > -1) {
      let reg = new RegExp(cStr + '\\.breathBarrierNum', 'g')
      let result = String(cm.breathBarrier)
      if (result == 'undefined' || result == 'null') {
        result = '0'
      }
      formula = formula.replace(reg, result)
    }
    if (formula.indexOf(cStr + '.breathBarrier') > -1) {
      let reg = new RegExp(cStr + '\\.breathBarrier', 'g')
      let result = cm.breathBarrier
      if (result == undefined || result == null) {
        result = 0
      }
      if (result > 0) {
        result = 1
      } else {
        result = 0
      }
      formula = formula.replace(reg, String(result))
    }
    if (formula.indexOf(cStr + '.gold') > -1 && cStr.match(/pc/)) {
      let reg = new RegExp(cStr + '\\.gold', 'g')
      let result = String(cm.Gold)
      if (result == 'undefined' || result == 'null') {
        result = '0'
      }
      formula = formula.replace(reg, result)
    }
    if (formula.indexOf(cStr + '.exp') > -1 && cStr.match(/pc/)) {
      let reg = new RegExp(cStr + '\\.exp', 'g')
      let result = String(cm.Exp)
      if (result == 'undefined' || result == 'null') {
        result = '0'
      }
      formula = formula.replace(reg, result)
    }
    if (formula.indexOf(cStr + '.age') > -1 && cStr.match(/pc/)) {
      let reg = new RegExp(cStr + '\\.age', 'g')
      let result = String(cm.Age)
      if (result == 'undefined' || result == 'null') {
        result = '0'
      }
      formula = formula.replace(reg, result)
    }
    if (formula.indexOf(cStr + '.lifetime') > -1 && cStr.match(/pc/)) {
      let reg = new RegExp(cStr + '\\.lifetime', 'g')
      let result = String(cm.Lifetime)
      if (result == 'undefined' || result == 'null') {
        result = '0'
      }
      formula = formula.replace(reg, result)
    }
    if (formula.indexOf(cStr + '.rip') > -1 && cStr.match(/pc/)) {
      let reg = new RegExp(cStr + '\\.rip', 'g')
      let result = String(cm.Rip)
      if (result == 'undefined' || result == 'null') {
        result = '0'
      }
      formula = formula.replace(reg, result)
    }
    if (formula.indexOf(cStr + '.thiefLv') > -1 && cStr.match(/pc/)) {
      let reg = new RegExp(cStr + '\\.thiefLv', 'g')
      let result = String(cm.ThiefLv)
      if (result == 'undefined' || result == 'null') {
        result = '0'
      }
      formula = formula.replace(reg, result)
    }
    if (formula.indexOf(cStr + '.marks') > -1 && cStr.match(/pc/)) {
      let reg = new RegExp(cStr + '\\.marks', 'g')
      let result = String(cm.Marks)
      if (result == 'undefined' || result == 'null') {
        result = '0'
      }
      formula = formula.replace(reg, result)
    }
    if (formula.indexOf(cStr + '.Race') > -1 && cStr.match(/pc/)) {
      let num = cm.Race
      let reg = new RegExp(cStr + '\\.Race\\[' + String(num) + '\\]', 'g')
      formula = formula.replace(reg, '1')
      reg = new RegExp(cStr + '\\.Race\\[[0-9]+\\]', 'g')
      formula = formula.replace(reg, '0')
    }
    if (formula.indexOf(cStr + '.Class') > -1 && cStr.match(/pc/)) {
      let num = cm.PcClass
      let reg = new RegExp(cStr + '\\.Class\\[' + String(num) + '\\]', 'g')
      formula = formula.replace(reg, '1')
      reg = new RegExp(cStr + '\\.Class\\[[0-9]+\\]', 'g')
      formula = formula.replace(reg, '0')
    }
    if (formula.indexOf(cStr + '.Sex') > -1 && cStr.match(/pc/)) {
      let num = cm.Sex
      let reg = new RegExp(cStr + '\\.Sex\\[' + String(num) + '\\]', 'g')
      formula = formula.replace(reg, '1')
      reg = new RegExp(cStr + '\\.Sex\\[[0-9]+\\]', 'g')
      formula = formula.replace(reg, '0')
    }
    if (formula.indexOf(cStr + '.Alignment') > -1 && cStr.match(/pc/)) {
      let num = cm.Alignment
      let reg = new RegExp(cStr + '\\.Alignment\\[' + String(num) + '\\]', 'g')
      formula = formula.replace(reg, '1')
      reg = new RegExp(cStr + '\\.Alignment\\[[0-9]+\\]', 'g')
      formula = formula.replace(reg, '0')
    }
    if (formula.indexOf(cStr + '.Ali') > -1 && cStr.match(/pc/)) {
      let num = cm.Alignment
      let reg = new RegExp(cStr + '\\.Ali\\[' + String(num) + '\\]', 'g')
      formula = formula.replace(reg, '1')
      reg = new RegExp(cStr + '\\.Ali\\[[0-9]+\\]', 'g')
      formula = formula.replace(reg, '0')
    }
    if (formula.indexOf(cStr + '.haveItemNum') > -1 && cStr.match(/pc/)) {
      let str = cStr + '\\.haveItemNum\\[([0-9]+)\\]\\[([0-9]+)\\]'
      let reg = new RegExp(str)
      while (formula.match(reg)) {
        let num1 = Number(RegExp.$1)
        let num2 = Number(RegExp.$2)
        let result = String(cm.haveItemNum(num1, num2))
        if (result == 'undefined' || result == 'null') {
          result = '0'
        }
        let str2 =
          cStr +
          '\\.haveItemNum\\[' +
          String(num1) +
          '\\]\\[' +
          String(num2) +
          '\\]'
        let reg2 = new RegExp(str2, 'g')
        formula = formula.replace(reg2, result)
      }
    }
    if (formula.indexOf(cStr + '.Item') > -1 && cStr.match(/pc/)) {
      let str = cStr + '\\.Item\\[([0-9]+)\\]'
      let reg = new RegExp(str)
      while (formula.match(reg)) {
        let num1 = Number(RegExp.$1)
        let num2 = cm.haveItem(num1)
        let result = '0'
        if (num2 > -1) {
          result = '1'
        }
        let str2 = cStr + '\\.Item\\[' + String(num1) + '\\]'
        let reg2 = new RegExp(str2, 'g')
        formula = formula.replace(reg2, result)
      }
    }
    if (formula.indexOf(cStr + '.TitleIn') > -1 && cStr.match(/pc/)) {
      let str = cStr + '\\.TitleIn\\[(|[^\\[\\]]+)\\]'
      let reg = new RegExp(str)
      while (formula.match(reg)) {
        let regStr = RegExp.$1
        let result = '0'
        if (cm.Title.indexOf(regStr) > -1) {
          result = '1'
        }
        let str2 = cStr + '\\.TitleIn\\[' + MP.escapeProcessing(regStr) + '\\]'
        let reg2 = new RegExp(str2, 'g')
        formula = formula.replace(reg2, result)
      }
    }
    if (formula.indexOf(cStr + '.Title') > -1 && cStr.match(/pc/)) {
      let str = cStr + '\\.Title\\[(|[^\\[\\]]+)\\]'
      let reg = new RegExp(str)
      while (formula.match(reg)) {
        let regStr = RegExp.$1
        let result = '0'
        if (cm.Title == regStr) {
          result = '1'
        }
        let str2 = cStr + '\\.Title\\[' + MP.escapeProcessing(regStr) + '\\]'
        let reg2 = new RegExp(str2, 'g')
        formula = formula.replace(reg2, result)
      }
    }
    if (formula.indexOf(cStr + '.MasteredSpell') > -1 && cStr.match(/pc/)) {
      let str =
        cStr +
        '\\.MasteredSpell\\[(-?[0-9]+)\\]\\[(-?[0-9]+)\\]\\[(-?[0-9]+)\\]'
      let reg = new RegExp(str)
      while (formula.match(reg)) {
        let kind = Number(RegExp.$1)
        let lv = Number(RegExp.$2)
        let spell = Number(RegExp.$3)
        let result = '0'
        if (cm.spellMaster(kind, lv, spell)) {
          result = '1'
        }
        let str2 =
          cStr +
          '\\.MasteredSpell\\[' +
          kind +
          '\\]\\[' +
          lv +
          '\\]\\[' +
          spell +
          '\\]'
        let reg2 = new RegExp(str2, 'g')
        formula = formula.replace(reg2, result)
      }
      str = cStr + '\\.MasteredSpell\\[(-?[0-9]+)\\]\\[(-?[0-9]+)\\]'
      reg = new RegExp(str)
      while (formula.match(reg)) {
        let kind = Number(RegExp.$1)
        let lv = Number(RegExp.$2)
        let spell = -1
        let result = '0'
        if (cm.spellMaster(kind, lv, spell)) {
          result = '1'
        }
        let str2 = cStr + '\\.MasteredSpell\\[' + kind + '\\]\\[' + lv + '\\]'
        let reg2 = new RegExp(str2, 'g')
        formula = formula.replace(reg2, result)
      }
      str = cStr + '\\.MasteredSpell\\[(-?[0-9]+)\\]'
      reg = new RegExp(str)
      while (formula.match(reg)) {
        let kind = Number(RegExp.$1)
        let lv = -1
        let spell = -1
        let result = '0'
        if (cm.spellMaster(kind, lv, spell)) {
          result = '1'
        }
        let str2 = cStr + '\\.MasteredSpell\\[' + kind + '\\]'
        let reg2 = new RegExp(str2, 'g')
        formula = formula.replace(reg2, result)
      }
      reg = new RegExp(cStr + '\\.MasteredSpell', 'g')
      let result = '0'
      if (cm.spellMaster(-1, -1, -1)) {
        result = '1'
      }
      formula = formula.replace(reg, result)
    }
  }
  for (let i = 0; i < repAry.length; i++) {
    let itemStr = repAry[i][0]
    if (!itemStr.match(/item/)) {
      continue
    }
    let itemNum = repAry[i][1]
    if (formula.indexOf(itemStr + '.lv') > -1) {
      let reg = new RegExp(itemStr + '\\.lv', 'g')
      formula = formula.replace(reg, ITEM[itemNum].LV)
    }
    if (formula.indexOf(itemStr + '.price') > -1) {
      let reg = new RegExp(itemStr + '\\.price', 'g')
      formula = formula.replace(reg, ITEM[itemNum].PRICE)
    }
  }
  if (pt > -1) {
    let reg = new RegExp(
      'pt\\.(lv|maxLv|minLv|hpMax0|maxHpMax0|minHpMax0|hpMax|maxHpMax|minHpMax|hp|maxHp|minHp|ac0|maxAc0|minAc0|ac1|maxAc1|minAc1|ac|maxAc|minAc|spellCancel|maxSpellCancel|minSpellCancel|sc0|maxSc0|minSc0|sc1|maxSc1|minSc1|sc|maxSc|minSc|age|maxAge|minAge|rip|maxRip|minRip|marks|maxMarks|minMarks|gold|maxGold|minGold|exp|maxExp|minExp|abi0\\[[0-9]+\\]|maxAbi0\\[[0-9]+\\]|minAbi0\\[[0-9]+\\]|abi1\\[[0-9]+\\]|maxAbi1\\[[0-9]+\\]|minAbi1\\[[0-9]+\\]|abi\\[[0-9]+\\]|maxAbi\\[[0-9]+\\]|minAbi\\[[0-9]+\\]|gm\\[[0-9]+\\]|maxGm\\[[0-9]+\\]|minGm\\[[0-9]+\\])'
    )
    while (formula.match(reg)) {
      let refStr = RegExp.$1
      let result = replaceFormulaPartyAverage(pt, true, refStr, noGm)
      let reg2 = new RegExp('pt\\.' + refStr.replace(/([\[\]])/g, '\\$1'), 'g')
      formula = formula.replace(reg2, result)
    }
    reg = new RegExp(
      'pt\\.(Sex\\[[0-3]\\]|Ali\\[[0-2]\\]|Race\\[[0-9]+\\]|Class\\[[0-9]+\\]|itemCommentNum\\[.+\\]\\[[0-5]\\]|classCommentNum\\[.+\\]|raceCommentNum\\[.+\\]|haveItemNum\\[[0-9]+\\]\\[[0-5]\\]|Resist0\\[[0-9]+\\]|Resist1\\[[0-9]+\\]|Resist\\[[0-9]+\\]|BreathBarrier|MasteredSpell\\[[0-9]+\\]\\[[0-9]+\\]\\[[0-9]+\\]|MasteredSpell\\[[0-9]+\\]\\[[0-9]+\\]|MasteredSpell\\[[0-9]+\\]|MasteredSpell)'
    )
    while (formula.match(reg)) {
      let refStr = RegExp.$1
      let result = replaceFormulaParty(pt, true, refStr)
      let reg2 = new RegExp('pt\\.' + MP.escapeProcessing(refStr), 'g')
      formula = formula.replace(reg2, result)
    }
    reg = new RegExp('pt\\.itemCommentNum\\[[^\\[\\]]*\\]\\[[0-9]*\\]', 'g')
    formula = formula.replace(reg, '0')
    reg = new RegExp('pt\\.(stateNum\\[([0-9]+)\\])')
    while (formula.match(reg)) {
      let refStr = RegExp.$1
      let num = Number(RegExp.$2)
      let result = PARTY[pt].getMemberNum(true, num)
      let reg2 = new RegExp('pt\\.' + refStr.replace(/([\[\]])/g, '\\$1'), 'g')
      formula = formula.replace(reg2, String(result))
    }
    reg = new RegExp('pt\\.(State\\[([0-9]+)\\])')
    while (formula.match(reg)) {
      let refStr = RegExp.$1
      let num = Number(RegExp.$2)
      let result = 0
      if (PARTY[pt].getMemberNum(true, num) > 0) {
        result = 1
      }
      let reg2 = new RegExp('pt\\.' + refStr.replace(/([\[\]])/g, '\\$1'), 'g')
      formula = formula.replace(reg2, String(result))
    }
    reg = new RegExp('pt\\.(attackAddNum\\[([0-9]+)\\])')
    while (formula.match(reg)) {
      let refStr = RegExp.$1
      let num = Number(RegExp.$2)
      let result = PARTY[pt].getMemberAttackAdd(num, true)
      let reg2 = new RegExp('pt\\.' + refStr.replace(/([\[\]])/g, '\\$1'), 'g')
      formula = formula.replace(reg2, String(result))
    }
    reg = new RegExp('pt\\.(AttackAdd\\[([0-9]+)\\])')
    while (formula.match(reg)) {
      let refStr = RegExp.$1
      let num = Number(RegExp.$2)
      let result = 0
      if (PARTY[pt].getMemberAttackAdd(num, true) > 0) {
        result = 1
      }
      let reg2 = new RegExp('pt\\.' + refStr.replace(/([\[\]])/g, '\\$1'), 'g')
      formula = formula.replace(reg2, String(result))
    }
    reg = new RegExp('pt\\.(MemberNum\\[([0-6])\\])')
    while (formula.match(reg)) {
      let refStr = RegExp.$1
      let num = Number(RegExp.$2)
      let result = 0
      if (PARTY[pt].getMemberNum(true) == num) {
        result = 1
      }
      let reg2 = new RegExp('pt\\.' + refStr.replace(/([\[\]])/g, '\\$1'), 'g')
      formula = formula.replace(reg2, String(result))
    }
    reg = new RegExp('pt\\.memberNum')
    formula = formula.replace(reg, String(PARTY[pt].getMemberNum(true)))
    reg = new RegExp('pt\\.spaceNum')
    formula = formula.replace(
      reg,
      String(GameData['PARTY_MEMBER_MAX'] - PARTY[pt].getMemberNum(false))
    )
    reg = new RegExp('pt\\.(Direction\\[([1-4])\\])')
    while (formula.match(reg)) {
      let refStr = RegExp.$1
      let num = Number(RegExp.$2) - 1
      let result = 0
      if (PARTY[pt].Direction == num) {
        result = 1
      }
      let reg2 = new RegExp('pt\\.' + refStr.replace(/([\[\]])/g, '\\$1'), 'g')
      formula = formula.replace(reg2, String(result))
    }
    reg = new RegExp('pt\\.direction')
    formula = formula.replace(reg, String(PARTY[pt].Direction + 1))
  }
  if (formula.indexOf('ShopStock') > -1) {
    let reg = new RegExp('(ShopStock\\[([0-9]+)\\])')
    while (formula.match(reg)) {
      let refStr = RegExp.$1
      let num = Number(RegExp.$2)
      let result = 0
      if (num < ITEM.length) {
        result = ITEM[num].Stock
        if (result == 120) {
          result = 100
        }
      }
      let reg2 = new RegExp(refStr.replace(/([\[\]])/g, '\\$1'), 'g')
      formula = formula.replace(reg2, String(result))
    }
  }
  if (formula.indexOf('PcSpaceNum') > -1) {
    let result = GameData['PC_ENTRY_MAX'] - PlayData['PcMax']
    formula = formula.replace(/PcSpaceNum/g, String(result))
  }
  if (formula.indexOf('DumpItem') > -1) {
    let reg = new RegExp('(DumpItem\\[(-?[0-9]+)\\]\\[(-?[0-9])\\])')
    while (formula.match(reg)) {
      let refStr = RegExp.$1
      let num1 = Number(RegExp.$2)
      let num2 = Number(RegExp.$3)
      let stack = []
      for (let i = 0; i < PlayData['GarbageItem'].length; i++) {
        let strAry = PlayData['GarbageItem'][i].split(',')
        let num3 = Number(strAry[0])
        if (num2 == -2 || num2 == num3) {
          stack.push(Number(strAry[1]))
        }
      }
      let result = 0
      if (num1 < 0) {
        if (stack.length > 0) {
          result = 1
        }
      } else if (stack.indexOf(num1) > -1) {
        result = 1
      }
      let reg2 = new RegExp(refStr.replace(/([\[\]])/g, '\\$1'), 'g')
      formula = formula.replace(reg2, String(result))
    }
  }
  if (formula.indexOf('AllItem') > -1) {
    let reg = new RegExp('(AllItem\\[([0-9]+)\\])')
    while (formula.match(reg)) {
      let refStr = RegExp.$1
      let num = Number(RegExp.$2)
      if (num >= ITEM.length) {
        num = 0
      }
      let result = 0
      if (ITEM[num].Stock > 0) {
        result = 1
      } else {
        for (let i = 0; i < PlayData['PcMax']; i++) {
          if (PC[PlayData['PcList'][i]].haveItemNum(num, 2) > 0) {
            result = 1
            break
          }
        }
      }
      let reg2 = new RegExp(refStr.replace(/([\[\]])/g, '\\$1'), 'g')
      formula = formula.replace(reg2, String(result))
    }
  }
  if (formula.indexOf('AllTitle') > -1) {
    let reg = new RegExp('(AllTitleIn\\[([^\\[\\]]+)\\])')
    while (formula.match(reg)) {
      let refStr = RegExp.$1
      let str = RegExp.$2
      let result = 0
      for (let i = 0; i < PlayData['PcMax']; i++) {
        if (PC[PlayData['PcList'][i]].Title.indexOf(str) > -1) {
          result = 1
          break
        }
      }
      let reg2 = new RegExp(MP.escapeProcessing(refStr), 'g')
      formula = formula.replace(reg2, String(result))
    }
    reg = new RegExp('(AllTitle\\[([^\\[\\]]+)\\])')
    while (formula.match(reg)) {
      let refStr = RegExp.$1
      let str = RegExp.$2
      let result = 0
      for (let i = 0; i < PlayData['PcMax']; i++) {
        if (PC[PlayData['PcList'][i]].Title == str) {
          result = 1
          break
        }
      }
      let reg2 = new RegExp(MP.escapeProcessing(refStr), 'g')
      formula = formula.replace(reg2, String(result))
    }
  }
  if (formula.indexOf('FlagS') > -1) {
    let reg = new RegExp('(FlagS\\[([0-9]+)\\])')
    while (formula.match(reg)) {
      let refStr = RegExp.$1
      let num = Number(RegExp.$2)
      let result = 0
      if (PlayData['GameFlagS'][num]) {
        result = 1
      }
      let reg2 = new RegExp(refStr.replace(/([\[\]])/g, '\\$1'), 'g')
      formula = formula.replace(reg2, String(result))
    }
  }
  if (formula.indexOf('Flag') > -1) {
    let reg = new RegExp('(Flag\\[([0-9]+)\\])')
    while (formula.match(reg)) {
      let refStr = RegExp.$1
      let num = Number(RegExp.$2)
      let result = 0
      if (PlayData['GameFlag'][num]) {
        result = 1
      }
      let reg2 = new RegExp(refStr.replace(/([\[\]])/g, '\\$1'), 'g')
      formula = formula.replace(reg2, String(result))
    }
  }
  if (formula.indexOf('Wall') > -1) {
    let reg = new RegExp('(Wall\\[([0-9]+)\\]\\[([0-9]+)\\]\\[([0-9]+)\\])')
    while (formula.match(reg)) {
      let refStr = RegExp.$1
      let num1 = Number(RegExp.$2)
      if (num1 >= DUNGEON.DUNGEON_MAX) {
        num1 = 0
      }
      let num2 = Number(RegExp.$3)
      if (num2 >= 10) {
        num2 = 0
      }
      let num3 = Number(RegExp.$4)
      let result = 0
      if (PlayData['WallFlag'][num1][num2][num3]) {
        result = 1
      }
      let reg2 = new RegExp(refStr.replace(/([\[\]])/g, '\\$1'), 'g')
      formula = formula.replace(reg2, String(result))
    }
  }
  if (formula.indexOf('Map') > -1) {
    let reg = new RegExp('(Map\\[([0-9]+)\\]\\[([0-9]+)\\]\\[([0-9]+)\\])')
    while (formula.match(reg)) {
      let refStr = RegExp.$1
      let num1 = Number(RegExp.$2)
      if (num1 >= DUNGEON.DUNGEON_MAX) {
        num1 = 0
      }
      let num2 = Number(RegExp.$3)
      if (num2 >= 10) {
        num2 = 0
      }
      let num3 = Number(RegExp.$4)
      if (num3 >= 20) {
        num3 = 0
      }
      let num4 = Number(RegExp.$5)
      let result = 0
      if (PlayData['MapFlag'][num1][num2][num3][num4]) {
        result = 1
      }
      let reg2 = new RegExp(refStr.replace(/([\[\]])/g, '\\$1'), 'g')
      formula = formula.replace(reg2, String(result))
    }
  }
  if (formula.indexOf('Situation') > -1) {
    let reg = new RegExp('(Situation\\[([0-9]+)\\])')
    while (formula.match(reg)) {
      let refStr = RegExp.$1
      let num = Number(RegExp.$2)
      let s1 = getSituation()
      let result = 0
      if (s1 == num) {
        result = 1
      }
      let reg2 = new RegExp(refStr.replace(/([\[\]])/g, '\\$1'), 'g')
      formula = formula.replace(reg2, String(result))
    }
    if (formula.indexOf('Situation') > -1) {
      let result = getSituation()
      formula = formula.replace(/Situation/g, String(result))
    }
  }
  if (GameState.match(/^battle/)) {
    if (formula.indexOf('SummonState') > -1) {
      let reg = new RegExp('(SummonState\\[(-?[0-9]+)\\])')
      while (formula.match(reg)) {
        let refStr = RegExp.$1
        let num = Number(RegExp.$2)
        let result = 0
        if (getSummonReference('state', num)) {
          result = 1
        }
        let reg2 = new RegExp(refStr.replace(/([\[\]])/g, '\\$1'), 'g')
        formula = formula.replace(reg2, String(result))
      }
    }
    if (formula.indexOf('SummonType') > -1) {
      let reg = new RegExp('(SummonType\\[(-?[0-9]+)\\])')
      while (formula.match(reg)) {
        let refStr = RegExp.$1
        let num = Number(RegExp.$2)
        let result = 0
        if (getSummonReference('type', num)) {
          result = 1
        }
        let reg2 = new RegExp(refStr.replace(/([\[\]])/g, '\\$1'), 'g')
        formula = formula.replace(reg2, String(result))
      }
    }
  }
  if (pt > -1) {
    if (formula.indexOf('PtMemberNum') > -1) {
      let reg = new RegExp('(PtMemberNum\\[([0-9]+)\\])')
      while (formula.match(reg)) {
        let refStr = RegExp.$1
        let num = Number(RegExp.$2)
        let result = 0
        if (PARTY[pt].getMemberNum() == num) {
          result = 1
        }
        let reg2 = new RegExp(refStr.replace(/([\[\]])/g, '\\$1'), 'g')
        formula = formula.replace(reg2, String(result))
      }
    }
    if (formula.indexOf('PtItem') > -1) {
      let reg = new RegExp('(PtItem\\[([0-9]+)\\])')
      while (formula.match(reg)) {
        let refStr = RegExp.$1
        let num = Number(RegExp.$2)
        let result = 0
        if (PARTY[pt].haveItemNum(num) > 0) {
          result = 1
        }
        let reg2 = new RegExp(refStr.replace(/([\[\]])/g, '\\$1'), 'g')
        formula = formula.replace(reg2, String(result))
      }
    }
    if (formula.indexOf('ItemSpace') > -1) {
      let result = 0
      if (PARTY[pt].putItem() > -1) {
        result = 1
      }
      formula = formula.replace(/ItemSpace/g, String(result))
    }
    if (formula.indexOf('ItemMargin') > -1) {
      let reg = new RegExp('(ItemMargin\\[([0-9]+)\\])')
      while (formula.match(reg)) {
        let refStr = RegExp.$1
        let num = Number(RegExp.$2)
        let result = 0
        if (PARTY[pt].getItemSpaceNum() >= num) {
          result = 1
        }
        let reg2 = new RegExp(refStr.replace(/([\[\]])/g, '\\$1'), 'g')
        formula = formula.replace(reg2, String(result))
      }
    }
    if (formula.indexOf('TitleIn') > -1) {
      let reg = new RegExp('(TitleIn\\[([^\\[\\]]+)\\])')
      while (formula.match(reg)) {
        let refStr = RegExp.$1
        let str = RegExp.$2
        let result = 0
        for (let i = 0; i < PARTY[pt].PartyMember.length; i++) {
          if (PARTY[pt].PartyMember[i] < 0) {
            break
          }
          if (PC[PARTY[pt].PartyMember[i]].Title.indexOf(str) > -1) {
            result = 1
            break
          }
        }
        let reg2 = new RegExp(MP.escapeProcessing(refStr), 'g')
        formula = formula.replace(reg2, String(result))
      }
    }
    if (formula.indexOf('Title') > -1) {
      let reg = new RegExp('(Title\\[([^\\[\\]]+)\\])')
      while (formula.match(reg)) {
        let refStr = RegExp.$1
        let str = RegExp.$2
        let result = 0
        for (let i = 0; i < PARTY[pt].PartyMember.length; i++) {
          if (PARTY[pt].PartyMember[i] < 0) {
            break
          }
          if (PC[PARTY[pt].PartyMember[i]].Title == str) {
            result = 1
            break
          }
        }
        let reg2 = new RegExp(MP.escapeProcessing(refStr), 'g')
        formula = formula.replace(reg2, String(result))
      }
    }
    if (formula.match(/Resist|MasteredSpell/)) {
      reg = new RegExp(
        '(Resist0\\[[0-9]+\\]|Resist1\\[[0-9]+\\]|Resist\\[[0-9]+\\]|BreathBarrier|MasteredSpell\\[[0-9]+\\]\\[[0-9]+\\]\\[[0-9]+\\]|MasteredSpell\\[[0-9]+\\]\\[[0-9]+\\]|MasteredSpell\\[[0-9]+\\]|MasteredSpell)'
      )
      while (formula.match(reg)) {
        let refStr = RegExp.$1
        let result = replaceFormulaParty(pt, false, refStr)
        let reg2 = new RegExp(refStr.replace(/([\[\]])/g, '\\$1'), 'g')
        formula = formula.replace(reg2, result)
      }
    }
    if (formula.indexOf('stateNum') > -1) {
      reg = new RegExp('(stateNum\\[([0-9]+)\\])')
      while (formula.match(reg)) {
        let refStr = RegExp.$1
        let num = Number(RegExp.$2)
        let result = PARTY[pt].getMemberNum(false, num)
        let reg2 = new RegExp(refStr.replace(/([\[\]])/g, '\\$1'), 'g')
        formula = formula.replace(reg2, String(result))
      }
    }
    if (formula.indexOf('State') > -1) {
      reg = new RegExp('(State\\[([0-9]+)\\])')
      while (formula.match(reg)) {
        let refStr = RegExp.$1
        let num = Number(RegExp.$2)
        let result = 0
        if (PARTY[pt].getMemberNum(false, num) > 0) {
          result = 1
        }
        let reg2 = new RegExp(refStr.replace(/([\[\]])/g, '\\$1'), 'g')
        formula = formula.replace(reg2, String(result))
      }
    }
    if (formula.indexOf('attackAddNum') > -1) {
      reg = new RegExp('(attackAddNum\\[([0-9]+)\\])')
      while (formula.match(reg)) {
        let refStr = RegExp.$1
        let num = Number(RegExp.$2)
        let result = PARTY[pt].getMemberAttackAdd(num)
        let reg2 = new RegExp(refStr.replace(/([\[\]])/g, '\\$1'), 'g')
        formula = formula.replace(reg2, String(result))
      }
    }
    if (formula.indexOf('AttackAdd') > -1) {
      reg = new RegExp('(AttackAdd\\[([0-9]+)\\])')
      while (formula.match(reg)) {
        let refStr = RegExp.$1
        let num = Number(RegExp.$2)
        let result = 0
        if (PARTY[pt].getMemberAttackAdd(num) > 0) {
          result = 1
        }
        let reg2 = new RegExp(refStr.replace(/([\[\]])/g, '\\$1'), 'g')
        formula = formula.replace(reg2, String(result))
      }
    }
    if (formula.indexOf('Fly') > -1) {
      let result = 0
      if (PARTY[pt].Flying != 0) {
        result = 1
      }
      formula = formula.replace(/Fly/g, String(result))
    }
  }
  if (noDice) {
    formula = formula.replace(/(^|[^a-zA-Z])[Dd]([^a-zA-Z]|$)/g, '$1$2')
  }
  formula = formula.replace(/<->/g, '\\[')
  formula = formula.replace(/<\/>/g, '\\]')
  return formula
}
function replaceFormulaMyAndTarget (
  formula,
  my,
  myNum,
  target,
  targetNum,
  noDice,
  noGm
) {
  let pcRep = 'pc'
  let monRep = 'monster'
  if (my == 'pc') {
    pcRep += '2'
  } else if (my == 'monster') {
    monRep += '2'
  } else if (my == 'summon') {
    my = 'monster'
    monRep += '2'
  } else {
    my = ''
  }
  if (target == 'pc') {
    target = pcRep
  } else if (target == 'monster') {
    target = monRep
  } else if (target == 'summon') {
    target = monRep
  } else {
    target = ''
  }
  if (my != '' && target != '') {
    formula = replaceFormula(
      formula,
      [
        [my, myNum],
        [target, targetNum]
      ],
      noDice,
      noGm
    )
  } else if (my != '' && target == '') {
    formula = replaceFormula(formula, [[my, myNum]], noDice, noGm)
  } else if (my == '' && target != '') {
    formula = replaceFormula(formula, [[target, targetNum]], noDice, noGm)
  }
  return formula
}
function replaceFormulaParty (pt, possibleToAction, refStr) {
  let party = PARTY[pt]
  let result = 0
  for (let i = 0; i < party.PartyMember.length; i++) {
    if (party.PartyMember[i] < 0) {
      break
    }
    let pc = party.PartyMember[i]
    if (possibleToAction && !PC[pc].possibleToAction()) {
      continue
    }
    if (refStr.match(/itemCommentNum\[([^\[\]]+)\]\[([0-5])\]/)) {
      let str = RegExp.$1
      let num = Number(RegExp.$2)
      let str2 = replaceBrackets('de', str)
      result += PC[pc].itemCommentNum(str2, num)
    } else if (refStr.match(/classCommentNum\[([^\[\]]+)\]/)) {
      let str = RegExp.$1
      let str2 = replaceBrackets('de', str)
      result += PC[pc].classCommentNum(str2)
    } else if (refStr.match(/raceCommentNum\[([^\[\]]+)\]/)) {
      let str = RegExp.$1
      let str2 = replaceBrackets('de', str)
      result += PC[pc].raceCommentNum(str2)
    } else if (refStr.match(/Sex\[([0-3])\]/)) {
      let num = Number(RegExp.$1)
      if (num == PC[pc].Sex) {
        result = 1
        break
      }
    } else if (refStr.match(/Ali\[([0-2])\]/)) {
      let num = Number(RegExp.$1)
      if (num == PC[pc].Alignment) {
        result = 1
        break
      }
    } else if (refStr.match(/Race\[([0-9]+)\]/)) {
      let num = Number(RegExp.$1)
      if (num == PC[pc].Race) {
        result = 1
        break
      }
    } else if (refStr.match(/Class\[([0-9]+)\]/)) {
      let num = Number(RegExp.$1)
      if (num == PC[pc].PcClass) {
        result = 1
        break
      }
    } else if (refStr.match(/haveItemNum\[([0-9]+)\]\[([0-5])\]/)) {
      let num1 = Number(RegExp.$1)
      let num2 = Number(RegExp.$2)
      result += PC[pc].haveItemNum(num1, num2)
    } else if (refStr.match(/Resist0\[([0-9]+)\]/)) {
      let num = Number(RegExp.$1)
      if (PC[pc].Resist0[num]) {
        result = 1
        break
      }
    } else if (refStr.match(/Resist1\[([0-9]+)\]/)) {
      let num = Number(RegExp.$1)
      if (PC[pc].Resist1[num]) {
        result = 1
        break
      }
    } else if (refStr.match(/Resist\[([0-9]+)\]/)) {
      let num = Number(RegExp.$1)
      if (PC[pc].Resist[num]) {
        result = 1
        break
      }
    } else if (refStr.match(/BreathBarrier/)) {
      if (PC[pc].BtOnlySpellEffectPlus[0] > 0) {
        result = 1
        break
      }
    } else if (
      refStr.match(/MasteredSpell\[([0-9]+)\]\[([0-9]+)\]\[([0-9]+)\]/)
    ) {
      let kind = Number(RegExp.$1)
      let lv = Number(RegExp.$2)
      let spell = Number(RegExp.$3)
      if (PC[pc].spellMaster(kind, lv, spell)) {
        result = 1
        break
      }
    } else if (refStr.match(/MasteredSpell\[([0-9]+)\]\[([0-9]+)\]/)) {
      let kind = Number(RegExp.$1)
      let lv = Number(RegExp.$2)
      let spell = -1
      if (PC[pc].spellMaster(kind, lv, spell)) {
        result = 1
        break
      }
    } else if (refStr.match(/MasteredSpell\[([0-9]+)\]/)) {
      let kind = Number(RegExp.$1)
      let lv = -1
      let spell = -1
      if (PC[pc].spellMaster(kind, lv, spell)) {
        result = 1
        break
      }
    } else if (refStr.match(/MasteredSpell/)) {
      let kind = -1
      let lv = -1
      let spell = -1
      if (PC[pc].spellMaster(kind, lv, spell)) {
        result = 1
        break
      }
    }
  }
  return String(result)
}
function replaceFormulaPartyAverage (pt, possibleToAction, refStr, noGm) {
  let party = PARTY[pt]
  let resultAry = []
  for (let i = 0; i < party.PartyMember.length; i++) {
    if (party.PartyMember[i] < 0) {
      break
    }
    let pc = party.PartyMember[i]
    if (possibleToAction && !PC[pc].possibleToAction()) {
      continue
    }
    if (refStr.match(/lv|maxLv|minLv/)) {
      resultAry.push(PC[pc].Level)
    } else if (refStr.match(/hpMax0|maxHpMax0|minHpMax0/)) {
      resultAry.push(PC[pc].HpMax0)
    } else if (refStr.match(/hpMax|maxHpMax|minHpMax/)) {
      resultAry.push(PC[pc].HpMax)
    } else if (refStr.match(/hp|maxHp|minHp/)) {
      resultAry.push(PC[pc].Hp)
    } else if (refStr.match(/ac0|maxAc0|minAc0/)) {
      resultAry.push(PC[pc].Ac0)
    } else if (refStr.match(/ac1|maxAc1|minAc1/)) {
      resultAry.push(PC[pc].Ac1)
    } else if (refStr.match(/ac|maxAc|minAc/)) {
      resultAry.push(PC[pc].Ac)
    } else if (refStr.match(/sc0|maxSc0|minSc0/)) {
      resultAry.push(PC[pc].SpellCancel0)
    } else if (refStr.match(/sc1|maxSc1|minSc1/)) {
      resultAry.push(PC[pc].SpellCancel1)
    } else if (
      refStr.match(/sc|maxSc|minSc|spellCancel|maxSpellCancel|minSpellCancel/)
    ) {
      resultAry.push(PC[pc].SpellCancel)
    } else if (refStr.match(/age|maxAge|minAge/)) {
      resultAry.push(PC[pc].Age)
    } else if (refStr.match(/rip|maxRip|minRip/)) {
      resultAry.push(PC[pc].Rip)
    } else if (refStr.match(/marks|maxMarks|minMarks/)) {
      resultAry.push(PC[pc].Marks)
    } else if (refStr.match(/gold|maxGold|minGold/)) {
      resultAry.push(PC[pc].Gold)
    } else if (refStr.match(/exp|maxExp|minExp/)) {
      resultAry.push(PC[pc].Exp)
    } else if (
      refStr.match(/abi0\[([0-9]+)\]|maxAbi0\[([0-9]+)\]|minAbi0\[([0-9]+)\]/)
    ) {
      let num = Number(RegExp.$1)
      if (num >= GameData['ABILITY'].length) {
        num = 0
      }
      resultAry.push(PC[pc].Ability0[num])
    } else if (
      refStr.match(/abi1\[([0-9]+)\]|maxAbi1\[([0-9]+)\]|minAbi1\[([0-9]+)\]/)
    ) {
      let num = Number(RegExp.$1)
      if (num >= GameData['ABILITY'].length) {
        num = 0
      }
      resultAry.push(PC[pc].Ability1[num])
    } else if (
      refStr.match(/abi\[([0-9]+)\]|maxAbi\[([0-9]+)\]|minAbi\[([0-9]+)\]/)
    ) {
      let num = Number(RegExp.$1)
      if (num >= GameData['ABILITY'].length) {
        num = 0
      }
      resultAry.push(PC[pc].Ability[num])
    } else if (
      refStr.match(/gm\[([0-9]+)\]|maxGm\[([0-9]+)\]|minGm\[([0-9]+)\]/)
    ) {
      let num = Number(RegExp.$1)
      if (num >= 10) {
        num = 0
      }
      let gm = 0
      if (!noGm) {
        let gmStr = GameData['GENERAL_CORRECTION'][PC[pc].PcClass][num]
        if (gmStr == undefined || gmStr == null) {
          gmStr = '1'
        }
        gm = strCalculation(replaceFormula(gmStr, [['pc', pc]], false, true))
      }
      resultAry.push(gm)
    }
  }
  if (resultAry.length == 0) {
    return 0
  }
  let result = 0
  if (refStr.match(/^max/)) {
    resultAry.sort(function (a, b) {
      return b - a
    })
    result = resultAry[0]
  } else if (refStr.match(/^min/)) {
    resultAry.sort(function (a, b) {
      return a - b
    })
    result = resultAry[0]
  } else {
    for (let i = 0; i < resultAry.length; i++) {
      result += resultAry[i]
    }
    result = Math.floor(result / resultAry.length)
  }
  return result
}
function replaceGenericFormula (str) {
  if (str == undefined || str == null || str == '') {
    return str
  }
  if (str.indexOf('formula[') < 0) {
    return str
  }
  while (str.match(GENERIC_FORMULA_REG)) {
    let num = Number(RegExp.$1)
    let result = '0'
    if (num < GameData['GENERIC_FORMULA'].length) {
      result = GameData['GENERIC_FORMULA'][num]
    }
    let reg = new RegExp('formula\\[' + String(num) + '\\]', 'g')
    str = str.replace(reg, result)
  }
  return str
}
function replaceMonsterResist (str) {
  str = str.replace(/9/, 'A')
  str = str.replace(/0/, 'B')
  str = str.replace(/a/, 'C')
  str = str.replace(/b/, 'D')
  str = str.replace(/c/, 'E')
  str = str.replace(/1/, 'G')
  str = str.replace(/2/, 'H')
  str = str.replace(/3/, 'I')
  str = str.replace(/4/, 'K')
  str = str.replace(/5/, 'L')
  str = str.replace(/6/, 'M')
  str = str.replace(/7/, 'N')
  str = str.replace(/8/, 'O')
  str = str.replace(/A/, '0')
  str = str.replace(/B/, '1')
  str = str.replace(/C/, '2')
  str = str.replace(/D/, '3')
  str = str.replace(/E/, '4')
  str = str.replace(/G/, '6')
  str = str.replace(/H/, '7')
  str = str.replace(/I/, '8')
  str = str.replace(/K/, 'a')
  str = str.replace(/L/, 'b')
  str = str.replace(/M/, 'c')
  str = str.replace(/N/, 'd')
  str = str.replace(/O/, 'e')
  return str
}
function replaceMyAndTarget (str, my, target) {
  if (str == undefined || str == null) {
    str = ''
  }
  if (my == undefined || my == null) {
    my = ''
  }
  if (target == undefined || target == null) {
    target = ''
  }
  let monRep = 'monster'
  let pcRep = 'pc'
  if (my == 'pc') {
    str = str.replace(/my\./g, 'pc.')
    pcRep += '2'
  } else if (my == 'monster') {
    str = str.replace(/my\./g, 'monster.')
    monRep += '2'
  } else if (my == 'summon') {
    str = str.replace(/my\./g, 'monster.')
    monRep += '2'
  }
  pcRep += '.'
  monRep += '.'
  if (target == 'pc') {
    str = str.replace(/target\./g, pcRep)
  } else if (target == 'monster') {
    str = str.replace(/target\./g, monRep)
  } else if (target == 'summon') {
    str = str.replace(/target\./g, monRep)
  }
  return str
}
function reset () {
  GenericVariable['ReturnKeyControll'] = -1
  GenericVariable['FullKeyInvalid'] = true
  GenericVariable['KeyInvalid'] = false
  GameState = 'reset'
  GameMode = ''
  Mode = 'normal'
  seStop()
  musicStop()
  MP.SelectMode['run'] = false
  MP.clearMainWindow()
  MP.setOptionMode('partsClear')
  if (MP.ButtonObject['debug_div'] != undefined) {
    MP.ButtonObject['debug_div'].style.display = ''
  }
  if (MP.ButtonObject['escape_div'] != undefined) {
    MP.ButtonObject['escape_div'].style.display = ''
  }
  let debugView = PlayData['DebugView']
  initializePlayData()
  PlayData['DebugView'] = debugView
  deleteTempVariable()
  if (!loadData()) {
    initializePlayData()
    initializeFirstPc()
    checkShopItemListFull()
  } else {
    if (PlayData['ActiveParty'] > -1) {
      let ptNum = PlayData['ActiveParty']
      if (PARTY[ptNum].DungeonNumber > -1) {
        if (!GameData['SPELL_EFFECT_CONTINUE']) {
          PARTY[ptNum].spellEffectClear(false)
          PARTY[ptNum].check()
        }
        PlayData['ActiveParty'] = -1
      }
    }
  }
  if (GameData['FACE_GRAPHIC_STATUS'] || GameData['FACE_GRAPHIC_BATTLE']) {
    let ary = adjustFaceGraphic()
    if (ary.length > 0) {
      MP.paintMask()
      readGraphicFile(ary, GenericVariable['PrioritizeHR'], readEndAction)
    } else {
      main('start')
    }
  } else {
    main('start')
  }
}
function resizeWindow () {
  setWindowResize(GameBody.width, GameBody.height)
  GameBody.scale = WinScale
  let stage = document.getElementById('enchant-stage')
  for (let i = 0; i < stage.children.length; i++) {
    if (stage.children[i].id.match(/_div$/)) {
      continue
    }
    stage.children[i].style.transform = 'scale(' + WinScale + ')'
  }
  setWindowAlign()
  for (let key in MP.ButtonObject) {
    let str = String(calTimes(MP.ButtonObject[key].width, WinScale)) + 'px'
    MP.ButtonObject[key].style.width = str
    let key2 = key.replace(/_div$/, '')
    let elm = document.getElementById(key2)
    elm.style.width = str
    str = String(calTimes(MP.ButtonObject[key].height, WinScale)) + 'px'
    MP.ButtonObject[key].style.height = str
    elm.style.height = str
    str = String(calTimes(MP.ButtonObject[key].y, WinScale)) + 'px'
    MP.ButtonObject[key].style.top = str
    str = String(calTimes(MP.ButtonObject[key].x, WinScale)) + 'px'
    MP.ButtonObject[key].style.left = str
  }
  gl.canvas.style.width = String(calTimes(GameBody.width, WebGL_Scale)) + 'px'
}
function saveData (text) {
  if (text == undefined || text == null) {
    text = ''
  }
  GenericVariable['FullKeyInvalid'] = true
  let dataStr = getSaveDataStr()
  localStorage.setItem(SaveName + 'Save', dataStr)
  printDebugMessage('[SAVE] ' + text)
  GenericVariable['FullKeyInvalid'] = false
}
function sePlay (name) {
  if (
    SoundData[name] == undefined ||
    SoundData[name] == null ||
    !Config['Se']
  ) {
    return
  }
  SoundData[name].play()
}
function seStop () {
  for (let key in SoundData) {
    if (SoundData[key] == null) {
      continue
    }
    try {
      SoundData[key].stop()
    } catch (e) {}
  }
}
function selectKeyAction (key) {
  let selFlag = false
  if (MP.SelectMode['mode'] == 'abiSel') {
    if (
      key.indexOf('enter') > -1 ||
      key.indexOf('right') > -1 ||
      key.indexOf('left') > -1 ||
      key.match(/^(cancel|escape)$/)
    ) {
      MP.SelectMode['run'] = false
      let str
      if (key.indexOf('enter') > -1) {
        str = 'enter'
        sePlay('enter')
      } else if (key.indexOf('right') > -1) {
        str = 'right'
        sePlay('select')
      } else if (key.indexOf('left') > -1) {
        str = 'left'
        sePlay('select')
      } else if (key == 'cancel') {
        str = 'cancel'
        sePlay('cancel')
      } else if (key == 'escape') {
        str = 'escape'
        sePlay('enter')
      }
      MP.SelectMode['callBackFunc'](str)
      return
    }
  } else if (MP.SelectMode['mode'] == 'status') {
    if (key.match(/^(up|down)$/)) {
      key = ''
    } else if (key.indexOf('right') > -1) {
      key = 'down'
    } else if (key.indexOf('left') > -1) {
      key = 'up'
    }
  } else if (MP.SelectMode['mode'].match(/^(statusCommand|statusAbility)$/)) {
    if (
      (MP.SelectMode['mode'] == 'statusCommand' && key.match(/^shift_/)) ||
      (MP.SelectMode['mode'] == 'statusAbility' && key.match(/(right|left)$/))
    ) {
      if (key.indexOf('right') > -1) {
        if (MP.PreSelect['select'][0] < MP.PreSelect['selAry'][0].length - 1) {
          MP.PreSelect['select'][0]++
        } else {
          MP.PreSelect['select'][0] = 0
        }
      } else if (key.indexOf('left') > -1) {
        if (MP.PreSelect['select'][0] > 0) {
          MP.PreSelect['select'][0]--
        } else {
          MP.PreSelect['select'][0] = MP.PreSelect['selAry'][0].length - 1
        }
      }
      MP.SelectMode['callBackFunc']()
      return
    }
    if (MP.SelectMode['mode'] == 'statusAbility') {
      if (!key.match(/(enter|cancel|escape)/)) {
        return
      }
    }
  } else if (MP.SelectMode['mode'] == 'spellLvSel') {
    if (key.match(/(up|down|right|left)$/)) {
      if (key == 'up') {
        if (MP.SelectMode['select'] > 0) {
          MP.SelectMode['select']--
        } else {
          MP.SelectMode['select'] = GameData['SPELL_KIND'] - 1
        }
      } else if (key == 'down') {
        if (MP.SelectMode['select'] < GameData['SPELL_KIND'] - 1) {
          MP.SelectMode['select']++
        } else {
          MP.SelectMode['select'] = 0
        }
      } else if (key.indexOf('right') > -1) {
        if (MP.SelectMode['selectF'] < GameData['SPELL_LVMAX'] - 1) {
          MP.SelectMode['selectF']++
        } else {
          MP.SelectMode['selectF'] = 0
        }
      } else if (key.indexOf('left') > -1) {
        if (MP.SelectMode['selectF'] > 0) {
          MP.SelectMode['selectF']--
        } else {
          MP.SelectMode['selectF'] = GameData['SPELL_LVMAX'] - 1
        }
      }
      key = ''
      selFlag = true
    }
  } else if (MP.SelectMode['mode'] == 'spellSel') {
    if (key.match(/(right|left)$/)) {
      if (key.indexOf('right') > -1) {
        if (MP.PreSelect['selectF'][2] < GameData['SPELL_LVMAX'] - 1) {
          MP.PreSelect['selectF'][2]++
        } else {
          MP.PreSelect['selectF'][2] = 0
        }
      } else if (key.indexOf('left') > -1) {
        if (MP.PreSelect['selectF'][2] > 0) {
          MP.PreSelect['selectF'][2]--
        } else {
          MP.PreSelect['selectF'][2] = GameData['SPELL_LVMAX'] - 1
        }
      }
      sePlay('select')
      MP.SelectMode['callBackFunc']()
      return
    }
  } else if (MP.SelectMode['mode'] == 'itemTrade') {
    if (key.match(/^shift_(right|left)$/)) {
      MP.SelectMode['callBackFunc'](key)
      return
    }
  } else if (MP.SelectMode['mode'] == 'monsterCatalog') {
    let changeMonFlag = false
    if (key.match(/^(cancel|escape)$/)) {
      key = 'cancel'
      sePlay('cancel')
    } else if (key.indexOf('right') > -1) {
      MP.SelectMode['select']++
      if (MP.SelectMode['select'] >= MP.SelectMode['valueAry'].length) {
        MP.SelectMode['select'] = 0
      }
      changeMonFlag = true
    } else if (key.indexOf('left') > -1) {
      MP.SelectMode['select']--
      if (MP.SelectMode['select'] < 0) {
        MP.SelectMode['select'] = MP.SelectMode['valueAry'].length - 1
      }
      changeMonFlag = true
    } else if (key == 'up') {
      if (TempVariable['CatalogTextMax'] > 1) {
        if (TempVariable['CatalogTextNum'] > 0) {
          TempVariable['CatalogTextNum']--
        }
      }
    } else if (key == 'down') {
      if (TempVariable['CatalogTextMax'] > 1) {
        if (
          TempVariable['CatalogTextNum'] <
          TempVariable['CatalogTextMax'] - 1
        ) {
          TempVariable['CatalogTextNum']++
        }
      }
    } else if (key.indexOf('enter') > -1) {
      if (TempVariable['CatalogTextMax'] > 1) {
        sePlay('enter')
        TempVariable['CatalogTextNum']++
        if (TempVariable['CatalogTextNum'] >= TempVariable['CatalogTextMax']) {
          TempVariable['CatalogTextNum'] = 0
        }
      }
    } else {
      key = ''
    }
    if (changeMonFlag) {
      let monNum =
        Number(MP.SelectMode['valueAry'][MP.SelectMode['select']]) - 1
      let mData = MONSTER_DATA[monNum]
      if (mData.COMMENT == '') {
        TempVariable['CatalogTextMax'] = 0
      } else {
        TempVariable['CatalogTextMax'] = mData.COMMENT.split('<p>').length
      }
      TempVariable['CatalogTextNum'] = 0
    }
    MP.SelectMode['callBackFunc'](key)
    return
  } else if (MP.SelectMode['mode'] == 'itemCatalog') {
    let changeMonFlag = false
    if (key.match(/^(cancel|escape)$/)) {
      key = 'cancel'
      sePlay('cancel')
    } else if (key.indexOf('right') > -1) {
      let nextNum = MP.SelectMode['select']
      let str = ''
      for (let i = 0; i < MP.SelectMode['valueAry'].length; i++) {
        nextNum++
        if (nextNum >= MP.SelectMode['valueAry'].length) {
          nextNum = 0
        }
        let itemNum = Number(MP.SelectMode['valueAry'][nextNum]) - 1
        str = ITEM[itemNum].COMMENT
        if (str != '') {
          break
        }
      }
      if (str != '') {
        MP.SelectMode['select'] = nextNum
        changeMonFlag = true
      }
    } else if (key.indexOf('left') > -1) {
      let nextNum = MP.SelectMode['select']
      let str = ''
      for (let i = 0; i < MP.SelectMode['valueAry'].length; i++) {
        nextNum--
        if (nextNum < 0) {
          nextNum = MP.SelectMode['valueAry'].length - 1
        }
        let itemNum = Number(MP.SelectMode['valueAry'][nextNum]) - 1
        str = ITEM[itemNum].COMMENT
        if (str != '') {
          break
        }
      }
      if (str != '') {
        MP.SelectMode['select'] = nextNum
        changeMonFlag = true
      }
    } else if (key == 'up') {
      if (TempVariable['CatalogTextMax'] > 1) {
        if (TempVariable['CatalogTextNum'] > 0) {
          TempVariable['CatalogTextNum']--
        }
      }
    } else if (key == 'down') {
      if (TempVariable['CatalogTextMax'] > 1) {
        if (
          TempVariable['CatalogTextNum'] <
          TempVariable['CatalogTextMax'] - 1
        ) {
          TempVariable['CatalogTextNum']++
        }
      }
    } else if (key.indexOf('enter') > -1) {
      if (TempVariable['CatalogTextMax'] > 1) {
        sePlay('enter')
        TempVariable['CatalogTextNum']++
        if (TempVariable['CatalogTextNum'] >= TempVariable['CatalogTextMax']) {
          TempVariable['CatalogTextNum'] = 0
        }
      }
    } else {
      key = ''
    }
    if (changeMonFlag) {
      let itemNum =
        Number(MP.SelectMode['valueAry'][MP.SelectMode['select']]) - 1
      let item = ITEM[itemNum]
      TempVariable['CatalogTextMax'] = item.COMMENT.split('<p>').length
      TempVariable['CatalogTextNum'] = 0
    }
    MP.SelectMode['callBackFunc'](key)
    return
  } else if (MP.SelectMode['mode'].match(/[nN]oCancel/)) {
    if (key.match(/^(cancel|escape)$/)) {
      sePlay('cancel')
      return
    }
  }
  let select2 = MP.SelectMode['select'] - MP.SelectMode['selectF']
  if (key == 'up') {
    let targetFlag = false
    if (MP.SelectMode['mode'] == 'itemTrade') {
      let targetNum
      if (TempVariable['trade'] == 'my') {
        targetNum = TempVariable['targetNum']
      } else {
        targetNum = PlayData['StatusNum']
      }
      if (PC[targetNum].haveItemNum(-1) > 0) {
        targetFlag = true
      }
    }
    if (targetFlag && MP.SelectMode['select'] <= 0) {
      let pcNum
      if (TempVariable['trade'] == 'my') {
        TempVariable['mySelectF'] = MP.SelectMode['selectF']
        TempVariable['trade'] = 'target'
        pcNum = TempVariable['targetNum']
      } else {
        TempVariable['targetSelectF'] = MP.SelectMode['selectF']
        TempVariable['trade'] = 'my'
        pcNum = PlayData['StatusNum']
      }
      let itemMax = PC[pcNum].haveItemNum(-1)
      let sel = itemMax - 1
      let lineNum = PC[pcNum].ItemMaxNum
      if (lineNum > 12) {
        lineNum = 12
      }
      MP.SelectMode['selectF'] = 0
      if (sel >= lineNum) {
        MP.SelectMode['selectF'] = sel - (lineNum - 1)
      }
      sePlay('select')
      MP.SelectMode['callBackFunc']('upDown' + String(sel))
      return
    } else if (MP.SelectMode['selAry'].length > 0) {
      if (MP.SelectMode['select'] > 0) {
        MP.SelectMode['select']--
        if (
          MP.SelectMode['mode'].match(/^(normal|itemTrade)$/) ||
          MP.SelectMode['mode'].match(/[nN]oCancel/)
        ) {
          if (select2 == 0) {
            MP.SelectMode['selectF']--
          }
        }
      } else {
        MP.SelectMode['select'] = MP.SelectMode['selAry'].length - 1
        if (
          MP.SelectMode['mode'].match(/^(normal|itemTrade)$/) ||
          MP.SelectMode['mode'].match(/[nN]oCancel/)
        ) {
          MP.SelectMode['selectF'] =
            MP.SelectMode['selAry'].length - MP.SelectMode['limit']
        }
      }
    }
    selFlag = true
  } else if (key == 'down') {
    let targetFlag = false
    if (MP.SelectMode['mode'] == 'itemTrade') {
      let targetNum
      if (TempVariable['trade'] == 'my') {
        targetNum = TempVariable['targetNum']
      } else {
        targetNum = PlayData['StatusNum']
      }
      if (PC[targetNum].haveItemNum(-1) > 0) {
        targetFlag = true
      }
    }
    if (
      targetFlag &&
      MP.SelectMode['select'] >= MP.SelectMode['selAry'].length - 1
    ) {
      if (TempVariable['trade'] == 'my') {
        TempVariable['mySelectF'] = MP.SelectMode['selectF']
        TempVariable['trade'] = 'target'
      } else {
        TempVariable['targetSelectF'] = MP.SelectMode['selectF']
        TempVariable['trade'] = 'my'
      }
      let sel = 0
      MP.SelectMode['selectF'] = 0
      sePlay('select')
      MP.SelectMode['callBackFunc']('upDown' + String(sel))
      return
    } else if (MP.SelectMode['selAry'].length > 0) {
      if (MP.SelectMode['select'] < MP.SelectMode['selAry'].length - 1) {
        MP.SelectMode['select']++
        if (
          MP.SelectMode['mode'].match(/^(normal|itemTrade)$/) ||
          MP.SelectMode['mode'].match(/[nN]oCancel/)
        ) {
          if (select2 == MP.SelectMode['lineNum'] - 1) {
            MP.SelectMode['selectF']++
          }
        }
      } else {
        MP.SelectMode['select'] = 0
        if (
          MP.SelectMode['mode'].match(/^(normal|itemTrade)$/) ||
          MP.SelectMode['mode'].match(/[nN]oCancel/)
        ) {
          if (MP.SelectMode['limit'] > 0) {
            MP.SelectMode['selectF'] = 0
          }
        }
      }
    }
    selFlag = true
  } else if (key.indexOf('right') > -1) {
    if (MP.SelectMode['selAry'].length > 0) {
      if (MP.SelectMode['select'] < MP.SelectMode['selAry'].length - 1) {
        if (
          MP.SelectMode['select'] <
          MP.SelectMode['selAry'].length - MP.SelectMode['limit'] - 1
        ) {
          MP.SelectMode['select'] += MP.SelectMode['limit']
          MP.SelectMode['selectF'] += MP.SelectMode['limit']
          if (MP.SelectMode['selectF'] > MP.SelectMode['selAry'].length - 1) {
            MP.SelectMode['selectF'] -= MP.SelectMode['selAry'].length
          }
        } else {
          MP.SelectMode['select'] = MP.SelectMode['selAry'].length - 1
          MP.SelectMode['selectF'] += MP.SelectMode['limit']
          select2 = MP.SelectMode['select'] - MP.SelectMode['selectF']
          if (select2 < 0) {
            MP.SelectMode['selectF'] -= MP.SelectMode['limit']
          }
        }
      }
    }
    selFlag = true
  } else if (key.indexOf('left') > -1) {
    if (MP.SelectMode['selAry'].length > 0) {
      if (MP.SelectMode['select'] > 0) {
        if (MP.SelectMode['select'] >= MP.SelectMode['limit']) {
          MP.SelectMode['select'] -= MP.SelectMode['limit']
          MP.SelectMode['selectF'] -= MP.SelectMode['limit']
          if (MP.SelectMode['selectF'] < 0) {
            MP.SelectMode['selectF'] = 0
          }
        } else {
          MP.SelectMode['select'] = 0
          MP.SelectMode['selectF'] = 0
        }
      }
    }
    selFlag = true
  } else if (key.indexOf('enter') > -1 || key.match(/^(cancel|escape)$/)) {
    if (MP.SelectMode['mode'] == 'pcSel') {
      PlayData['PartyStatusNum'] = -1
    }
    if (
      GameState.match(/^(inspectCast|inspectRead)$/) &&
      key.indexOf('enter') > -1
    ) {
      if (TempVariable['spellList'].length < 1) {
        sePlay('enter')
        return
      }
    } else if (
      GameState.match(/^(inspectCast2|battleCommandSpell2)$/) &&
      key.indexOf('enter') > -1
    ) {
      if (MP.SelectMode['select'] > -1) {
        let kind = MP.PreSelect['select'][2]
        let lv = MP.PreSelect['selectF'][2]
        let spell = Number(MP.SelectMode['valueAry'][MP.SelectMode['select']])
        let pcNum = PlayData['StatusNum']
        if (
          PC[pcNum].Mp[kind][lv] >=
          GameData['SPELL_CONSUMPTION_MP'][kind][lv][spell]
        ) {
          if (GameState == 'battleCommandSpell2') {
            sePlay('enter')
          }
          MP.SelectMode['run'] = false
          MP.SelectMode['callBackFunc']('enter')
        } else {
          sePlay('enter')
        }
      }
      return
    } else if (GameState == 'inspectRead2' && key.indexOf('enter') > -1) {
      return
    }
    MP.SelectMode['run'] = false
    let str
    if (key.indexOf('enter') > -1) {
      str = 'enter'
      if (
        !(
          (GameState == 'inspectSP' && MP.SelectMode['select'] == 0) ||
          GameState == 'inspectItemUse' ||
          GameState.match(/^inspect(Item|Cast)PcSel$/) ||
          GameState.match(/^battleBox(CastSpell|Item2)$/)
        )
      ) {
        sePlay('enter')
      }
    } else {
      str = 'cancel'
      sePlay('cancel')
    }
    MP.SelectMode['callBackFunc'](str)
  }
  if (selFlag) {
    if (MP.SelectMode['mode'] == 'status') {
      PlayData['StatusNum'] = Number(
        MP.SelectMode['valueAry'][MP.SelectMode['select']]
      )
      MP.viewStatus(PlayData['StatusNow'], PlayData['StatusNum'])
    } else {
      sePlay('select')
      MP.viewSelectMode()
    }
  }
}
function setExtensionData (type, latestExt) {
  latestExt = checkNull(latestExt, '')
  if (latestExt == '') {
    let fileExtData
    if (type == 'graphic') {
      fileExtData = GRAPHIC_FILE_EXTENSION
    } else if (type == 'sound') {
      fileExtData = SOUND_FILE_EXTENSION
    } else if (type == 'music') {
      fileExtData = MUSIC_FILE_EXTENSION
    } else {
      return
    }
    ExtData[type] = []
    for (let i = 0; i < fileExtData.length; i++) {
      ExtData[type].push(fileExtData[i])
      ExtData[type].push(fileExtData[i].toUpperCase())
    }
  } else {
    let sub = ExtData[type].indexOf(latestExt.toUpperCase())
    if (sub > -1) {
      ExtData[type].splice(sub, 1)
    }
    sub = ExtData[type].indexOf(latestExt.toLowerCase())
    if (sub > -1) {
      ExtData[type].splice(sub, 1)
    }
    let lowerCase = false
    if (latestExt.match(/^[a-z0-9]+$/)) {
      lowerCase = true
    }
    if (lowerCase) {
      ExtData[type].unshift(latestExt.toUpperCase())
    } else {
      ExtData[type].unshift(latestExt.toLowerCase())
    }
    ExtData[type].unshift(latestExt)
  }
}
function setDefaultMessage () {
  let str = getDefaultMessage('_STATUS_COLOR')
  if (str == 'on') {
    GameData['STATUS_COLOR'] = true
  } else {
    GameData['STATUS_COLOR'] = false
  }
  str = getDefaultMessage('_FACE_GRAPHIC_BATTLE')
  if (str == 'off') {
    GameData['FACE_GRAPHIC_BATTLE'] = false
  } else {
    GameData['FACE_GRAPHIC_BATTLE'] = true
  }
  str = getDefaultMessage('_FACE_GRAPHIC_STATUS')
  if (str == 'off') {
    GameData['FACE_GRAPHIC_STATUS'] = false
  } else {
    GameData['FACE_GRAPHIC_STATUS'] = true
  }
}
function setFirstPc (data, pcNum) {
  let strAry = data.split('<>')
  let strAry2 = strAry[5].split(',')
  let ary = []
  for (let i = 0; i < GameData['ABILITY'].length; i++) {
    if (i < strAry2.length) {
      ary[i] = Number(strAry2[i])
    } else {
      ary[i] = Number(strAry2[0])
    }
  }
  PC[pcNum].initializeVariable()
  let race = Number(strAry[2])
  if (GameData['RACE_SEX_INSIDE'][race] > -1) {
    strAry[1] = String(GameData['RACE_SEX_INSIDE'][race])
  } else if (GameData['RACE_SEX'][race].indexOf(strAry[1]) < 0) {
    strAry[1] = GameData['RACE_SEX'][race].charAt(0)
  }
  PC[pcNum].createPc(
    strAry[0],
    Number(strAry[1]),
    Number(strAry[2]),
    Number(strAry[3]),
    Number(strAry[4]),
    ary,
    Number(strAry[10])
  )
  let num = Math.floor(strCalculation(replaceFormula(strAry[6])))
  if (num < 1) {
    num = 1
  } else if (num > 99999) {
    num = 99999
  }
  if (num > 1) {
    PC[pcNum].levelUp(num)
  }
  for (let i = 0; i < GameData['ABILITY'].length; i++) {
    PC[pcNum].Ability0[i] = ary[i]
  }
  let tmpNum = Number(strAry[7])
  if (tmpNum > PC[pcNum].Exp) {
    PC[pcNum].Exp = tmpNum
  }
  PC[pcNum].Gold = Math.floor(strCalculation(replaceFormula(strAry[8])))
  if (strAry[9] != 'none') {
    let count = 0
    strAry2 = strAry[9].split(',')
    for (let i = 0; i < strAry2.length; i += 2) {
      let num = Number(strAry2[i])
      if (num >= ITEM.length) {
        continue
      }
      PC[pcNum].putItem(num, 1)
      PlayData['ItemFlag'][num] = true
      if (strAry[12] == 'true') {
        setPcEquip(pcNum, num, count)
      }
      count++
      if (count >= PC[pcNum].ItemMaxNum) {
        break
      }
    }
  }
  PC[pcNum].Title = strAry[11]
  PC[pcNum].NextUpExp = -1
  PC[pcNum].check()
  PlayData['PcMax']++
}
function setFont (font) {
  if (font == undefined || font == null) {
    font = ''
  }
  if (font == '' || font == 'monospaced') {
    MP.FONT_NAME = 'monospace'
  } else {
    MP.FONT_NAME = font
  }
  MP.setFont()
}
function setGameData (base64Text) {
  if (base64Text == undefined || base64Text == null) {
    return false
  }
  let text = base64.decode(base64Text, 1)
  let reg = new RegExp(' *([^ ]+) *= *"(.*)" *')
  let textAry = text.split(/\r\n|\n|\r/)
  for (let i = 0; i < textAry.length; i++) {
    if (textAry[i].match(reg)) {
      let key = textAry[i].replace(reg, '$1')
      let value = textAry[i].replace(reg, '$2')
      GameData[key] = value
    }
  }
  if (GameData['Version'] == undefined) {
    return false
  }
  GameData['VERSION'] = GameData['Version']
  delete GameData['Version']
  GameData['READDATA_VERSION'] = Number(GameData['VERSION'].replace('v', ''))
  GameData['GAMEDATA_VERSION'] = Number(GAMEDATA_VERSION.replace('v', ''))
  if (GameData['READDATA_VERSION'] > GameData['GAMEDATA_VERSION']) {
    return false
  }
  if (GameData['GameTitle'] == undefined) {
    return false
  }
  GameData['GAME_TITLE'] = GameData['GameTitle']
  delete GameData['GameTitle']
  if (GameData['ReadKeyword'] == undefined) {
    return false
  } else if (GameData['ReadKeyword'] == '') {
    GameData['ReadKeyword'] = 'none'
  }
  GameData['READ_KEYWORD'] = GameData['ReadKeyword']
  delete GameData['ReadKeyword']
  if (GameData['DebugCommand'] == undefined) {
    return false
  }
  GameData['DEBUG'] = parseStrToBoolean(GameData['DebugCommand'])
  delete GameData['DebugCommand']
  if (GameData['TitleCg'] == undefined) {
    return false
  }
  GameData['TITLE_CG'] = GameData['TitleCg']
  delete GameData['TitleCg']
  GameData['TITLE_TEXT'] = []
  let count = 0
  while (true) {
    let key = 'TitleText' + String(count)
    if (GameData[key] == undefined) {
      break
    }
    GameData['TITLE_TEXT'].push(GameData[key])
    delete GameData[key]
    count++
  }
  if (GameData['Music'] == undefined) {
    return false
  }
  GameData['MUSIC_NAME'] = []
  GameData['MUSIC_SRC'] = []
  let strAry = GameData['Music'].split(',')
  for (let i = 0; i < strAry.length; i += 2) {
    GameData['MUSIC_NAME'].push(strAry[i])
    GameData['MUSIC_SRC'].push(DirName['music'] + strAry[i + 1])
  }
  delete GameData['Music']
  if (GameData['Sound'] == undefined) {
    return false
  }
  GameData['SOUND_NAME'] = []
  GameData['SOUND_SRC'] = []
  strAry = GameData['Sound'].split(',')
  for (let i = 0; i < strAry.length; i += 2) {
    GameData['SOUND_NAME'].push(strAry[i])
    GameData['SOUND_SRC'].push(DirName['sound'] + strAry[i + 1])
  }
  delete GameData['Sound']
  DUNGEON = new DungeonData()
  if (GameData['MainOthers'] == undefined) {
    return false
  }
  strAry = GameData['MainOthers'].split(',')
  GameData['PARTY_MEMBER_MAX'] = Number(strAry[0])
  GameData['FRONT_RANK_NUM'] = Number(strAry[1])
  GameData['AUTO_MAP'] = Number(strAry[2])
  GameData['AUTO_MAP_TRAP'] = parseStrToBoolean(strAry[3])
  GameData['HELP_COMMENT'] = parseStrToBoolean(strAry[6])
  DUNGEON.FindDoor = parseStrToBoolean(strAry[7])
  DUNGEON.PickDoor = parseStrToBoolean(strAry[8])
  GameData['ITEM_DECIDED'] = parseStrToBoolean(strAry[9])
  GameData['SPELL_EFFECT_CONTINUE'] = parseStrToBoolean(strAry[10])
  GameData['TELEPORT_START_ZERO'] = parseStrToBoolean(strAry[11])
  GameData['ROCK_LOST'] = parseStrToBoolean(strAry[12])
  GameData['CAN_ADD_ALIGNMENT_DIFFERENT'] = parseStrToBoolean(strAry[13])
  GameData['SPELL_CAN_BE_USED'] = parseStrToBoolean(strAry[14])
  GameData['AUTO_MAP_DARK_ZONE'] = parseStrToBoolean(strAry[15])
  GameData['IDENTIFY_NOT_CURSED'] = parseStrToBoolean(strAry[16])
  GameData['CURSED_NOT_CRITICAL'] = parseStrToBoolean(strAry[17])
  GameData['LEAST_ONE_LEARNS_SPELL'] = parseStrToBoolean(strAry[18])
  GameData['HEALING_MESSAGE_NOT_DISPLAYED'] = parseStrToBoolean(strAry[19])
  let autoMappingOff = false
  if (strAry[20].indexOf('true') > -1) {
    autoMappingOff = true
  }
  GameData['BOX_NOT'] = parseStrToBoolean(strAry[21])
  GameData['VIEW_NOT_SOLD_OUT'] = parseStrToBoolean(strAry[22])
  GameData['HIDE_ON'] = parseStrToBoolean(strAry[23])
  GameData['MONSTER_CATALOG'] = parseStrToBoolean(strAry[24])
  GameData['ITEM_CATALOG'] = parseStrToBoolean(strAry[25])
  let str = strAry[26].replace(/\./g, ',')
  if (str == '') {
    GameData['AUTO_MAP_ITEM'] = ''
  } else {
    GameData['AUTO_MAP_ITEM'] = MP.getCmNum(str)
  }
  GameData['AUTO_MAP_FLAG'] = parseStrToBoolean(strAry[27])
  GameData['EFFECT_TIME_IS_INDICATED'] = parseStrToBoolean(strAry[28])
  GameData['GROUP_SPELL_OF_MONSTER_AIMS_AT_ALL'] = parseStrToBoolean(strAry[31])
  GameData['BOX_NOT_ALL_MONSTERS_RUN'] = parseStrToBoolean(strAry[32])
  GameData['ITEM_IS_GOT_IN_TURN'] = parseStrToBoolean(strAry[33])
  GameData['ABILITY_PARENTHESIS'] = parseStrToBoolean(strAry[34])
  let autoMappingOn = false
  if (strAry[35].indexOf('true') > -1) {
    autoMappingOn = true
  }
  if (autoMappingOn && autoMappingOff) {
    GameData['AUTO_MAPPING'] = 0
  } else if (autoMappingOn) {
    GameData['AUTO_MAPPING'] = 1
    Config['AutoMapping'] = true
  } else if (autoMappingOff) {
    GameData['AUTO_MAPPING'] = 2
    Config['AutoMapping'] = false
  } else {
    GameData['AUTO_MAPPING'] = 0
  }
  GameData['CARRY_INDICATED_BY_STORE'] = parseStrToBoolean(strAry[36])
  GameData['AUTO_MAP_EVENT'] = parseStrToBoolean(strAry[37])
  GameData['CORRECTED_ABILITY_IS_NOT_INDICATED'] = parseStrToBoolean(strAry[38])
  GameData['ACTION_IS_NOT_STOPED'] = parseStrToBoolean(strAry[39])
  GameData['BONUS_CANNOT_ROLL_AGAIN'] = parseStrToBoolean(strAry[40])
  GameData['CANNOT_USE_CURSED_ITEM'] = parseStrToBoolean(strAry[41])
  GameData['MODIFIED_MESSAGE_NOT_DISPLAYED'] = parseStrToBoolean(strAry[42])
  GameData['DO_NOT_OPEN_CAMP'] = parseStrToBoolean(strAry[43])
  GameData['BATTLE_EXCHANGE'] = parseStrToBoolean(strAry[44])
  GameData['CHANGE_TARGET'] = parseStrToBoolean(strAry[45])
  GameData['ITEM_DO_NOT_DISAPPEAR_AT_SHOPS'] = parseStrToBoolean(strAry[46])
  GameData['EQUIP_COMMENT'] = parseStrToBoolean(strAry[47], false)
  GameData['ATTACK_FIRST_MONSTER'] = parseStrToBoolean(strAry[48], true)
  GameData['MODIFYING_EFFECTS_ON_HIDDEN_ABILITY_ARE_NOT_DISPLAYED'] =
    parseStrToBoolean(strAry[49], false)
  GameData['RETURN_PARTY_ANNIHILATION'] = parseStrToBoolean(strAry[50], false)
  GameData['ABILITY_VALUE_ZERO'] = parseStrToBoolean(strAry[51], false)
  delete GameData['MainOthers']
  if (GameData['ExclusiveUseOfMonsters'] == undefined) {
    return false
  }
  GameData['SPELL_EXCLUSIVE'] = parseStrToBoolean(
    GameData['ExclusiveUseOfMonsters']
  )
  delete GameData['ExclusiveUseOfMonsters']
  count = 0
  while (true) {
    if (GameData['SpellKind' + String(count)] == undefined) {
      break
    } else if (count >= 5) {
      break
    }
    count++
  }
  if (count == 0) {
    GameData['SPELL_EXCLUSIVE'] = false
  }
  if (GameData['SPELL_EXCLUSIVE'] || count > 4) {
    count--
  }
  if (count < 0) {
    count = 0
  }
  GameData['SPELL_KIND'] = count
  if (GameData['SpellLvNum'] == undefined) {
    return false
  }
  GameData['SPELL_LVMAX'] = Number(GameData['SpellLvNum'])
  delete GameData['SpellLvNum']
  if (GameData['CastleTown'] == undefined) {
    return false
  }
  str = getDefaultMessage('FACILITIES_NAME_CASTLE_TOWN', 1, 24)
  if (str != '') {
    GameData['CastleTown'] = str
  }
  if (GameData['Tavern'] == undefined) {
    return false
  }
  str = getDefaultMessage('FACILITIES_NAME_TAVERN', 1, 24)
  if (str != '') {
    GameData['Tavern'] = str
  }
  if (GameData['Inn'] == undefined) {
    return false
  }
  str = getDefaultMessage('FACILITIES_NAME_CASTLE_INN', 1, 24)
  if (str != '') {
    GameData['Inn'] = str
  }
  if (GameData['Shop'] == undefined) {
    return false
  }
  str = getDefaultMessage('FACILITIES_NAME_CASTLE_SHOP', 1, 24)
  if (str != '') {
    GameData['Shop'] = str
  }
  if (GameData['Temple'] == undefined) {
    return false
  }
  str = getDefaultMessage('FACILITIES_NAME_CASTLE_TEMPLE', 1, 24)
  if (str != '') {
    GameData['Temple'] = str
  }
  if (GameData['Castle'] == undefined) {
    return false
  }
  str = getDefaultMessage('FACILITIES_NAME_CASTLE_CASTLE', 1, 24)
  if (str != '') {
    GameData['Castle'] = str
  }
  if (GameData['EdgeOfTown'] == undefined) {
    return false
  }
  str = getDefaultMessage('FACILITIES_NAME_CASTLE_EDGE_OF_TOWN', 1, 24)
  if (str != '') {
    GameData['EdgeOfTown'] = str
  }
  strAry = [
    'INN_CHARGE',
    'INN_DAYS',
    'INN_HEALING',
    'INN_MP_HEALING',
    'INN_ABI_DEC_RATE'
  ]
  for (let i = 0; i < strAry.length; i++) {
    GameData[strAry[i]] = []
  }
  for (let i = 0; i < 5; i++) {
    let key = 'Inn' + String(i)
    if (GameData[key] == undefined) {
      return false
    }
    strAry = GameData[key].split('<>')
    GameData['INN_CHARGE'].push(strAry[0])
    GameData['INN_DAYS'].push(Number(strAry[1]))
    GameData['INN_HEALING'].push(strAry[2])
    GameData['INN_MP_HEALING'].push(strAry[3])
    GameData['INN_ABI_DEC_RATE'].push(Number(strAry[4]))
    delete GameData[key]
  }
  if (GameData['ItemSell'] == undefined) {
    return false
  }
  GameData['ITEM_SELL'] = GameData['ItemSell']
  delete GameData['ItemSell']
  if (GameData['ItemSellUndecided'] == undefined) {
    return false
  }
  GameData['ITEM_SELL_UNDECIDED'] = GameData['ItemSellUndecided']
  delete GameData['ItemSellUndecided']
  if (GameData['ItemUncurse'] == undefined) {
    return false
  }
  GameData['ITEM_UNCURSE'] = GameData['ItemUncurse']
  delete GameData['ItemUncurse']
  if (GameData['ItemIdentify'] == undefined) {
    return false
  }
  GameData['ITEM_IDENTIFY'] = GameData['ItemIdentify']
  delete GameData['ItemIdentify']
  if (GameData['ItemComplete'] == undefined) {
    return false
  }
  GameData['ITEM_COMPLETE'] = GameData['ItemComplete']
  delete GameData['ItemComplete']
  if (LaunchSettings['GraphicPrefetch']) {
    let sourceStr = GameData['ITEM_COMPLETE']
    let reg = new RegExp('<img *src="([^>]*?)".*?>')
    while (sourceStr.match(reg)) {
      let prefetchStr = 'graphic/' + RegExp.$1
      if (Prefetch['event'].indexOf(prefetchStr) < 0) {
        Prefetch['event'].push(prefetchStr)
      }
      sourceStr = sourceStr.replace(reg, '')
    }
  }
  if (GameData['TempleParalyze'] == undefined) {
    return false
  }
  GameData['TEMPLE_PARALYZE'] = GameData['TempleParalyze']
  delete GameData['TempleParalyze']
  if (GameData['TempleStone'] == undefined) {
    return false
  }
  GameData['TEMPLE_STONE'] = GameData['TempleStone']
  delete GameData['TempleStone']
  if (GameData['TempleDead'] == undefined) {
    return false
  }
  GameData['TEMPLE_DEAD'] = GameData['TempleDead']
  delete GameData['TempleDead']
  if (GameData['TempleAsh'] == undefined) {
    return false
  }
  GameData['TEMPLE_ASH'] = GameData['TempleAsh']
  delete GameData['TempleAsh']
  if (GameData['TempleResuscitate'] == undefined) {
    return false
  }
  GameData['RESUSCITATE_PROB'] = GameData['TempleResuscitate']
  delete GameData['TempleResuscitate']
  if (GameData['TempleAddAge'] == undefined) {
    return false
  }
  GameData['TEMPLE_ADD_AGE'] = GameData['TempleAddAge']
  delete GameData['TempleAddAge']
  if (GameData['TempleNotAggravated'] == undefined) {
    return false
  }
  GameData['TEMPLE_NOT_AGGRAVATED'] = parseStrToBoolean(
    GameData['TempleNotAggravated']
  )
  delete GameData['TempleNotAggravated']
  GameData['FULL_HP_TEMPLE'] = parseStrToBoolean(
    checkNull(GameData['FullHpTemple'], 'true')
  )
  delete GameData['FullHpTemple']
  GameData['FULL_MP_TEMPLE'] = parseStrToBoolean(
    checkNull(GameData['FullMpTemple'], 'false')
  )
  delete GameData['FullMpTemple']
  if (GameData['Training'] == undefined) {
    return false
  }
  GameData['TRAINING_MUSIC'] = GameData['Training']
  delete GameData['Training']
  if (GameData['LevelUp'] == undefined) {
    return false
  }
  strAry = GameData['LevelUp'].split(',')
  GameData['SPELL_MPMAX'] = Number(strAry[0])
  GameData['MPMAX_UP'] = []
  GameData['SPELL_LEARNED_PROB'] = []
  for (let i = 0; i < GameData['SPELL_KIND']; i++) {
    GameData['MPMAX_UP'][i] = []
    GameData['MPMAX_UP'][i].push(strAry[1 + i])
    GameData['MPMAX_UP'][i].push(strAry[5 + i])
    GameData['MPMAX_UP'][i].push(strAry[9 + i])
    GameData['SPELL_LEARNED_PROB'].push(strAry[13 + i])
  }
  GameData['SPELL_LEARNED_PROB_DEC'] = strAry[17]
  GameData['SPELL_ACQUIRED_INT_TURN'] = parseStrToBoolean(strAry[20])
  if (GameData['PcCreateItem'] == undefined) {
    return false
  }
  GameData['PC_CREATE_ITEM'] = GameData['PcCreateItem']
  delete GameData['PcCreateItem']
  if (GameData['ClassChange'] == undefined) {
    return false
  }
  strAry = GameData['ClassChange'].split('<>')
  GameData['CLASS_CHANGE'] = parseStrToBoolean(strAry[0])
  GameData['CLASS_CHANGE_ADD_AGE'] = strAry[1]
  GameData['CLASS_CHANGE_LV'] = strAry[2]
  GameData['CLASS_CHANGE_HP'] = strAry[3]
  GameData['CLASS_CHANGE_ABI'] = []
  let strAry2 = strAry[4].split(',')
  for (let i = 0; i < 36; i++) {
    if (i >= strAry2.length) {
      GameData['CLASS_CHANGE_ABI'][i] = ''
    } else {
      GameData['CLASS_CHANGE_ABI'][i] = strAry2[i]
    }
    if (GameData['CLASS_CHANGE_ABI'][i] == ' ') {
      GameData['CLASS_CHANGE_ABI'][i] = ''
    }
  }
  delete GameData['ClassChange']
  GameData['CASTLE_EVENT'] = []
  count = 0
  while (true) {
    let key = 'CastleEvent' + String(count)
    if (GameData[key] == undefined) {
      break
    } else if (count >= 1000) {
      break
    }
    GameData['CASTLE_EVENT'].push(
      GameData[key].replace(/item2?\[([0-9]+)\]/g, '$1')
    )
    if (LaunchSettings['GraphicPrefetch']) {
      let sourceStr = GameData['CASTLE_EVENT'][count]
      let reg = new RegExp('<img *src="([^>]*?)".*?>')
      while (sourceStr.match(reg)) {
        let prefetchStr = 'graphic/' + RegExp.$1
        if (Prefetch['event'].indexOf(prefetchStr) < 0) {
          Prefetch['event'].push(prefetchStr)
        }
        sourceStr = sourceStr.replace(reg, '')
      }
      strAry = GameData['CASTLE_EVENT'][count].split('<>')
      if (!strAry[10].match(/^(| )$/)) {
        let prefetchStr = 'graphic/bg/' + strAry[10]
        if (Prefetch['castle'].indexOf(prefetchStr) < 0) {
          Prefetch['castle'].push(prefetchStr)
        }
      }
    }
    count++
    delete GameData[key]
  }
  if (GameData['RegistrationTransmigration'] == undefined) {
    return false
  }
  strAry = GameData['RegistrationTransmigration'].split('</>')
  GameData['REG_TM_FLAG'] = parseStrToBoolean(strAry[0])
  GameData['REG_TM_READKEYWORD'] = strAry[1]
  GameData['REG_TM_RACE'] = Number(strAry[2])
  GameData['REG_TM_CLASS'] = Number(strAry[3])
  GameData['REG_TM_SEX'] = parseStrToBoolean(strAry[4])
  GameData['REG_TM_ALI'] = parseStrToBoolean(strAry[5])
  GameData['REG_TM_AGE'] = strAry[6]
  GameData['REG_TM_ABI'] = strAry[7]
  GameData['REG_TM_LV'] = strAry[8]
  GameData['REG_TM_GOLD'] = strAry[9]
  GameData['REG_TM_TITLE'] = strAry[10]
  GameData['REG_TM_ITEM'] = strAry[11].replace(/item\[([0-9]+)\]/g, '$1')
  delete GameData['RegistrationTransmigration']
  if (GameData['TransmigrationCharacter'] == undefined) {
    return false
  }
  strAry = GameData['TransmigrationCharacter'].split('</>')
  GameData['TM_FLAG'] = parseStrToBoolean(strAry[0])
  GameData['TM'] = strAry[1]
  delete GameData['TransmigrationCharacter']
  GameData['SEX'] = []
  GameData['SEX_ABBR'] = []
  for (let i = 0; i < 4; i++) {
    let key = 'Sex' + String(i)
    if (GameData[key] == undefined) {
      if (i < 2) {
        return false
      } else if (i == 2) {
        GameData['SEX'][i] = 'Bigender'
        GameData['SEX_ABBR'][i] = 'B'
      } else if (i == 3) {
        GameData['SEX'][i] = 'Neither'
        GameData['SEX_ABBR'][i] = 'N'
      }
    } else {
      strAry = GameData[key].split('<>')
      GameData['SEX'][i] = strAry[0]
      GameData['SEX_ABBR'][i] = strAry[1]
      delete GameData[key]
    }
  }
  GameData['ALIGNMENT'] = []
  GameData['ALIGNMENT_ABBR'] = []
  for (let i = 0; i < 3; i++) {
    let key = 'Ali' + String(i)
    if (GameData[key] == undefined) {
      return false
    }
    strAry = GameData[key].split('<>')
    GameData['ALIGNMENT'][i] = strAry[0]
    GameData['ALIGNMENT_ABBR'][i] = strAry[1]
    delete GameData[key]
  }
  if (GameData['AbiMaxFix'] == undefined) {
    return false
  }
  GameData['ABILITY_FIX'] = Number(GameData['AbiMaxFix'])
  delete GameData['AbiMaxFix']
  if (GameData['AbiMax'] == undefined) {
    return false
  }
  GameData['ABILITY_MAX'] = Number(GameData['AbiMax'])
  delete GameData['AbiMax']
  strAry = [
    'ABILITY',
    'ABILITY_NO_BONUS',
    'ABILITY_ABBR',
    'ABILITY_SEX',
    'ABILITY_INDIVIDUAL',
    'ABILITY_INDIVIDUAL_SEX',
    'ABILITY_NOT_DISPLAY',
    'ABILITY_DISPLAY',
    'ABILITY_NO_DEATH'
  ]
  for (let i = 0; i < strAry.length; i++) {
    GameData[strAry[i]] = []
  }
  for (let i = 0; i < 4; i++) {
    GameData['ABILITY_SEX'][i] = []
  }
  count = 0
  while (true) {
    let key = 'Abi' + String(count)
    if (GameData[key] == undefined) {
      break
    } else if (count >= 36) {
      break
    }
    strAry = GameData[key].split('<>')
    GameData['ABILITY'].push(strAry[0])
    GameData['ABILITY_ABBR'].push(strAry[1])
    GameData['ABILITY_SEX'][0].push(Number(strAry[2]))
    GameData['ABILITY_SEX'][1].push(Number(strAry[3]))
    GameData['ABILITY_NO_BONUS'].push(parseStrToBoolean(strAry[4]))
    GameData['ABILITY_INDIVIDUAL'].push(strAry[5])
    GameData['ABILITY_INDIVIDUAL_SEX'].push(parseStrToBoolean(strAry[6]))
    if (count < 10) {
      if (count == 0 || !GameData['ABILITY_NO_BONUS'][count]) {
        GameData['ABILITY_NOT_DISPLAY'].push(false)
      } else {
        GameData['ABILITY_NOT_DISPLAY'].push(parseStrToBoolean(strAry[7]))
      }
      if (!GameData['ABILITY_NOT_DISPLAY'][count]) {
        GameData['ABILITY_DISPLAY'].push(count)
      }
    } else {
      GameData['ABILITY_NOT_DISPLAY'].push(true)
    }
    GameData['ABILITY_NO_DEATH'].push(parseStrToBoolean(strAry[8], false))
    GameData['ABILITY_SEX'][2].push(Number(checkNull(strAry[9], '0')))
    GameData['ABILITY_SEX'][3].push(Number(checkNull(strAry[10], '0')))
    delete GameData[key]
    count++
  }
  strAry = [
    'RACE',
    'RACE_ABBR',
    'RACE_CONDITION',
    'RACE_AC',
    'RACE_HEALING',
    'RACE_RESIST',
    'RACE_SPELL_CANCEL',
    'RACE_BREATH',
    'RACE_BREATH_NUM',
    'RACE_LIFETIME',
    'RACE_ABI',
    'RACE_COMMENT',
    'RACE_BREATH_ATTRIBUTE',
    'RACE_ITEM',
    'RACE_SEX',
    'RACE_SEX_INSIDE'
  ]
  for (let i = 0; i < strAry.length; i++) {
    GameData[strAry[i]] = []
  }
  count = 0
  while (true) {
    let key = 'Race' + String(count)
    if (GameData[key] == undefined) {
      break
    } else if (count >= RACE_CLASS_MAX) {
      break
    }
    strAry = GameData[key].split('<>')
    GameData['RACE'].push(strAry[0])
    GameData['RACE_ABBR'].push(strAry[1])
    GameData['RACE_ABI'][count] = []
    for (let i = 0; i < GameData['ABILITY'].length; i++) {
      GameData['RACE_ABI'][count].push(1)
    }
    strAry2 = strAry[2].split(',')
    for (let i = 0; i < strAry2.length; i++) {
      GameData['RACE_ABI'][count][i] = Number(strAry2[i])
    }
    GameData['RACE_LIFETIME'].push(Number(strAry[3]))
    GameData['RACE_AC'].push(Number(strAry[4]))
    GameData['RACE_HEALING'].push(Number(strAry[5]))
    GameData['RACE_SPELL_CANCEL'].push(Number(strAry[6]))
    GameData['RACE_BREATH'].push(strAry[7])
    GameData['RACE_BREATH_NUM'].push(strAry[8])
    GameData['RACE_RESIST'].push(strAry[9])
    GameData['RACE_CONDITION'].push(strAry[10])
    if (strAry[11] == ' ') {
      strAry[11] = ''
    }
    GameData['RACE_COMMENT'].push(MP.strChangeLine(strAry[11], 28, 10, true))
    let num = Number(strAry[12])
    if (num >= 0 && num <= 3) {
      num++
    } else if (num == 4) {
      num = 8
    } else if (num >= 5 && num <= 8) {
      num += 5
    } else {
      num = 14
    }
    GameData['RACE_BREATH_ATTRIBUTE'].push(num)
    GameData['RACE_ITEM'].push(Number(strAry[13]))
    GameData['RACE_SEX'].push(checkNull(strAry[14], '01'))
    GameData['RACE_SEX_INSIDE'].push(Number(checkNull(strAry[15], -1)))
    delete GameData[key]
    count++
  }
  if (GameData['CreateAge'] == undefined) {
    return false
  }
  GameData['PC_CREATE_AGE'] = GameData['CreateAge']
  delete GameData['CreateAge']
  if (GameData['CreateGold'] == undefined) {
    return false
  }
  GameData['PC_CREATE_GOLD'] = GameData['CreateGold']
  delete GameData['CreateGold']
  if (GameData['BonusDice'] == undefined) {
    return false
  }
  strAry = GameData['BonusDice'].split('<>')
  GameData['BONUS_DICE_NUM'] = strAry[0]
  GameData['BONUS_DICE'] = strAry[1]
  GameData['BONUS_DICE_PLUS'] = strAry[2]
  delete GameData['BonusDice']
  if (GameData['BonusPlus'] == undefined) {
    return false
  }
  GameData['BONUS_PLUS'] = parseStrToBoolean(GameData['BonusPlus'])
  delete GameData['BonusPlus']
  strAry = GameData['LevelUp'].split(',')
  strAry2 = strAry[18].split('<>')
  GameData['ABILITY_CHANGE_PROB'] = []
  for (let i = 0; i < GameData['ABILITY'].length; i++) {
    if (i >= strAry2.length) {
      GameData['ABILITY_CHANGE_PROB'].push(strAry2[0])
    } else {
      strAry2[i] = strAry2[i].replace(/ /g, '')
      if (strAry2[i] == '') {
        GameData['ABILITY_CHANGE_PROB'].push(strAry2[0])
      } else {
        GameData['ABILITY_CHANGE_PROB'].push(strAry2[i])
      }
    }
  }
  strAry2 = strAry[19].split('<>')
  GameData['ABILITY_DOWN_PROB'] = []
  for (let i = 0; i < GameData['ABILITY'].length; i++) {
    if (i >= strAry2.length) {
      GameData['ABILITY_DOWN_PROB'].push(strAry2[0])
    } else {
      strAry2[i] = strAry2[i].replace(/ /g, '')
      if (strAry2[i] == '') {
        GameData['ABILITY_DOWN_PROB'].push(strAry2[0])
      } else {
        GameData['ABILITY_DOWN_PROB'].push(strAry2[i])
      }
    }
  }
  delete GameData['LevelUp']
  strAry = [
    'PC_CLASS',
    'PC_CLASS_ABBR',
    'CLASS_CONDITION',
    'CLASS_COMMENT',
    'CLASS_HP_ADD',
    'CLASS_ITEM',
    'CLASS_IDENTIFY',
    'CLASS_AC',
    'CLASS_DMG1',
    'CLASS_DMG2',
    'CLASS_DMG3',
    'CLASS_ATTACK_NUM',
    'CLASS_ATTACK_ADD',
    'CLASS_HIT',
    'CLASS_THIEF',
    'CLASS_DISPELL_LV',
    'CLASS_DISPELL_KIND',
    'CLASS_NECESSARY_EXP',
    'CLASS_SEX',
    'CLASS_ALI',
    'CLASS_ABI',
    'CLASS_LEARNED_SPELL',
    'GENERAL_CORRECTION'
  ]
  for (let i = 0; i < strAry.length; i++) {
    GameData[strAry[i]] = []
  }
  count = 0
  while (true) {
    let key = 'Class' + String(count)
    if (GameData[key] == undefined) {
      break
    } else if (count >= RACE_CLASS_MAX) {
      break
    }
    strAry = GameData[key].split('<>')
    GameData['PC_CLASS'].push(strAry[0])
    GameData['PC_CLASS_ABBR'].push(strAry[1])
    GameData['CLASS_SEX'][count] = []
    for (let i = 0; i < 4; i++) {
      if (strAry[2].indexOf(String(i)) > -1) {
        GameData['CLASS_SEX'][count].push(true)
      } else {
        GameData['CLASS_SEX'][count].push(false)
      }
    }
    GameData['CLASS_ALI'][count] = []
    for (let i = 0; i < 3; i++) {
      if (strAry[3].indexOf(String(i)) > -1) {
        GameData['CLASS_ALI'][count].push(true)
      } else {
        GameData['CLASS_ALI'][count].push(false)
      }
    }
    GameData['CLASS_ABI'][count] = []
    for (let i = 0; i < 10; i++) {
      GameData['CLASS_ABI'][count].push(0)
    }
    strAry2 = strAry[4].split(',')
    for (let i = 0; i < strAry2.length; i++) {
      if (i >= GameData['CLASS_ABI'][count].length) {
        break
      }
      GameData['CLASS_ABI'][count][i] = Number(strAry2[i])
    }
    GameData['CLASS_AC'].push(strAry[5])
    GameData['CLASS_HIT'].push(strAry[6])
    GameData['CLASS_ATTACK_NUM'].push(strAry[7])
    strAry2 = strAry[8].split(',')
    GameData['CLASS_DMG1'].push(strAry2[0])
    GameData['CLASS_DMG2'].push(strAry2[1])
    GameData['CLASS_DMG3'].push(strAry2[2])
    GameData['CLASS_ATTACK_ADD'].push(Number(strAry[9]))
    GameData['CLASS_THIEF'].push(Number(strAry[10]))
    GameData['CLASS_IDENTIFY'].push(parseStrToBoolean(strAry[11]))
    GameData['CLASS_DISPELL_LV'].push(Number(strAry[12]))
    GameData['CLASS_DISPELL_KIND'].push(strAry[13])
    GameData['CLASS_LEARNED_SPELL'][count] = []
    for (let i = 0; i < GameData['SPELL_KIND']; i++) {
      GameData['CLASS_LEARNED_SPELL'][count][i] = []
      GameData['CLASS_LEARNED_SPELL'][count][i].push(0)
      GameData['CLASS_LEARNED_SPELL'][count][i].push(0)
      GameData['CLASS_LEARNED_SPELL'][count][i].push(1)
      GameData['CLASS_LEARNED_SPELL'][count][i].push(10)
    }
    strAry2 = strAry[14].split(',')
    for (let i = 0; i < GameData['SPELL_KIND']; i++) {
      if (i >= strAry2.length) {
        break
      } else if (strAry2[i].indexOf('_') == -1) {
        break
      }
      let strAry3 = strAry2[i].split('_')
      GameData['CLASS_LEARNED_SPELL'][count][i][0] = Number(strAry3[0])
      GameData['CLASS_LEARNED_SPELL'][count][i][1] = Number(strAry3[1])
      GameData['CLASS_LEARNED_SPELL'][count][i][2] = Number(strAry3[3])
      GameData['CLASS_LEARNED_SPELL'][count][i][3] = Number(strAry3[2])
      if (
        GameData['CLASS_LEARNED_SPELL'][count][i][2] == 0 ||
        GameData['CLASS_LEARNED_SPELL'][count][i][3] == 0
      ) {
        GameData['CLASS_LEARNED_SPELL'][count][i][2] = 0
        GameData['CLASS_LEARNED_SPELL'][count][i][3] = 0
      } else if (
        GameData['CLASS_LEARNED_SPELL'][count][i][2] >
        GameData['CLASS_LEARNED_SPELL'][count][i][3]
      ) {
        GameData['CLASS_LEARNED_SPELL'][count][i][3] =
          GameData['CLASS_LEARNED_SPELL'][count][i][2]
      }
    }
    GameData['CLASS_HP_ADD'].push(strAry[15])
    GameData['CLASS_NECESSARY_EXP'].push(strAry[16])
    GameData['CLASS_COMMENT'].push(MP.strChangeLine(strAry[17], 26, 16, true))
    GameData['CLASS_ITEM'].push(Number(strAry[18]))
    if (strAry[19] == ' ') {
      strAry[19] = ''
    }
    strAry2 = strAry[19].split(',')
    GameData['GENERAL_CORRECTION'][count] = []
    for (let i = 0; i < 10; i++) {
      if (i < strAry2.length) {
        if (strAry2[i] != '') {
          GameData['GENERAL_CORRECTION'][count].push(strAry2[i])
        } else {
          GameData['GENERAL_CORRECTION'][count].push('1')
        }
      } else {
        GameData['GENERAL_CORRECTION'][count].push('1')
      }
    }
    GameData['CLASS_CONDITION'].push(strAry[20])
    delete GameData[key]
    count++
  }
  GameData['SPELL_BASE'] = []
  count = 0
  while (true) {
    let key = 'SpellBase' + String(count)
    if (GameData[key] == undefined) {
      break
    } else if (count >= 10000) {
      break
    }
    strAry = GameData[key].split('<>')
    if (strAry.length < 2) {
      GameData['SPELL_BASE'].push('')
    } else {
      let str = ''
      for (let i = 1; i < strAry.length; i++) {
        if (i > 1) {
          str += '<>'
        }
        let strAry2 = strAry[i].split(',')
        let ef = strAry2[0]
        if (ef == 72 || ef == 73) {
          let subscript
          if (ef == 72) {
            subscript = 5
          } else if (ef == 73) {
            subscript = 4
          }
          let tmpStr = ''
          for (let j = 0; j < strAry2[subscript].length; j++) {
            if (strAry2[subscript].charAt(j) == '9') {
              tmpStr += 'a'
            } else if (strAry2[subscript].charAt(j) == 'a') {
              tmpStr += 'b'
            } else if (strAry2[subscript].charAt(j) == 'b') {
              tmpStr += 'c'
            } else if (strAry2[subscript].charAt(j) == 'c') {
              tmpStr += 'd'
            } else if (strAry2[subscript].charAt(j) == 'd') {
              tmpStr += 'e'
            } else {
              tmpStr += strAry2[subscript].charAt(j)
            }
          }
          strAry2[subscript] = tmpStr
          strAry[i] = strAry2.join(',')
        }
        str += strAry[i]
      }
      str = str.replace(/monster2\[([0-9]+)\]/g, '$1')
      str = str.replace(/abiRep\[([0-9]+)\]/g, '$1')
      str = str.replace(/race\[([0-9]+)\]/g, '$1')
      str = str.replace(/class\[([0-9]+)\]/g, '$1')
      str = str.replace(/item2?\[([0-9]+)\]/g, '$1')
      str = str.replace(/dungeon\[([0-9]+)\]/g, '$1')
      str = str.replace(/floor\[([0-9]+)\]/g, '$1')
      str = str.replace(/monster2\[([0-9]+)\]/g, '$1')
      GameData['SPELL_BASE'].push(str)
    }
    delete GameData[key]
    count++
  }
  strAry = [
    'SPELL_KIND_NAME',
    'SPELL',
    'SPELL_EFFECT',
    'SPELL_COMMENT',
    'SPELL_NOT_LEARNED',
    'SPELL_CONSUMPTION_MP',
    'SPELL_EVEN_SILENCE'
  ]
  for (let i = 0; i < strAry.length; i++) {
    GameData[strAry[i]] = []
  }
  strAry.splice(0, 1)
  let loop = GameData['SPELL_KIND']
  if (GameData['SPELL_EXCLUSIVE']) {
    loop++
  }
  for (let i = 0; i < loop; i++) {
    for (let l = 0; l < strAry.length; l++) {
      GameData[strAry[l]][i] = []
    }
    for (let j = 0; j < GameData['SPELL_LVMAX']; j++) {
      for (let l = 0; l < strAry.length; l++) {
        GameData[strAry[l]][i][j] = []
      }
      for (let k = 0; k < 6; k++) {
        GameData['SPELL'][i][j].push('')
        GameData['SPELL_EFFECT'][i][j].push('0,0')
        GameData['SPELL_COMMENT'][i][j].push('')
        GameData['SPELL_NOT_LEARNED'][i][j].push(false)
        GameData['SPELL_CONSUMPTION_MP'][i][j].push(1)
        GameData['SPELL_EVEN_SILENCE'][i][j].push(false)
      }
    }
  }
  let stack = []
  for (let i = 0; i < 4; i++) {
    stack[i] = []
  }
  for (let i = 0; i < GameData['SPELL'].length; i++) {
    let key = 'SpellKind' + String(i)
    strAry = GameData[key].split('<-->')
    GameData['SPELL_KIND_NAME'][i] = strAry[0]
    for (let j = 1; j < strAry.length; j++) {
      if (j > GameData['SPELL_LVMAX']) {
        break
      }
      if (strAry[j] == ' ') {
        strAry2 = ['']
      } else {
        strAry2 = strAry[j].split('<++>')
      }
      for (let k = 0; k < 6; k++) {
        if (k >= strAry2.length || strAry2[k] == '') {
          continue
        }
        let strAry3 = strAry2[k].split('<>')
        if (i < 4) {
          if (SpellName[i][j - 1][k] != '') {
            GameData['SPELL'][i][j - 1][k] =
              SpellName[i][j - 1][k] + '<>' + strAry3[1]
          } else {
            GameData['SPELL'][i][j - 1][k] = strAry3[0] + '<>' + strAry3[1]
          }
        } else {
          GameData['SPELL'][i][j - 1][k] = strAry3[0] + '<>' + strAry3[1]
        }
        let strAry4 = strAry3[2].split('<+>')
        let str = ''
        for (let l = 0; l < strAry4.length; l++) {
          if (l > 0) {
            str += '<+>'
          }
          str += MP.strChangeLine(strAry4[l], 54, 5, true)
        }
        let spellCommentAry = str.split('<+>')
        if (spellCommentAry.length == 2) {
          str += '<+>' + spellCommentAry[0] + '<+>' + spellCommentAry[0]
        }
        GameData['SPELL_COMMENT'][i][j - 1][k] = str
        GameData['SPELL_EFFECT'][i][j - 1][k] = strAry3[3]
        let num1 = Number(strAry3[4])
        if (num1 > 0) {
          let num2 = i * 100 + (j - 1) * 10 + k
          if (num1 == 1) {
            stack[1].push(num2)
          } else if (num1 == 2) {
            stack[2].push(num2)
          } else if (num1 == 3) {
            stack[3].push(num2)
          }
        }
        GameData['SPELL_NOT_LEARNED'][i][j - 1][k] = parseStrToBoolean(
          strAry3[5]
        )
        GameData['SPELL_CONSUMPTION_MP'][i][j - 1][k] = Number(strAry3[6])
        GameData['SPELL_EVEN_SILENCE'][i][j - 1][k] = parseStrToBoolean(
          strAry3[7]
        )
      }
    }
    delete GameData[key]
  }
  for (let k = 1; k < 4; k++) {
    stack[0] = []
    for (let i = 0; i < 10; i++) {
      for (let j = 0; j < stack[k].length; j++) {
        let num = Math.floor((stack[k][j] % 100) / 10)
        if (i == num) {
          stack[0].push(stack[k][j])
        }
      }
    }
    let str = ''
    if (stack[0].length > 0) {
      let num1 = Math.floor((stack[0][stack[0].length - 1] % 100) / 10)
      str += String(stack[0][stack[0].length - 1])
      for (let i = stack[0].length - 2; i >= 0; i--) {
        let num2 = Math.floor((stack[0][i] % 100) / 10)
        if (num1 == num2) {
          str += ',' + String(stack[0][i])
        } else {
          num1 = num2
          str += '<>' + String(stack[0][i])
        }
      }
    }
    if (k == 1) {
      GameData['SPELL_AT'] = str
    } else if (k == 2) {
      GameData['SPELL_SUPPORT'] = str
    } else if (k == 3) {
      GameData['SPELL_HEAL'] = str
    }
  }
  GameData['SPELL_HEAL2'] = ['', '', '', '', '', '', '', '']
  stack = []
  for (let i = 0; i < 9; i++) {
    stack[i] = []
  }
  let healCheck = []
  for (let i = 0; i < 8; i++) {
    healCheck.push(false)
  }
  strAry = GameData['SPELL_HEAL'].split('<>')
  for (let i = 0; i < strAry.length; i++) {
    if (strAry[i] == '') {
      continue
    }
    strAry2 = strAry[i].split(',')
    for (let j = 0; j < strAry2.length; j++) {
      for (let k = 0; k < healCheck.length; k++) {
        healCheck[k] = false
      }
      let spell = Number(strAry2[j])
      let kind = Math.floor(spell / 100)
      spell %= 100
      let lv = Math.floor(spell / 10)
      spell %= 10
      let str = GameData['SPELL_EFFECT'][kind][lv][spell]
      str = spellEffectReplace(str, 0)
      str = str.replace(/<notCancel>/g, '')
      str = str.replace(/[0-9]+<->/g, '')
      let spellAry = str.split('<+>')
      for (let k = 0; k < spellAry.length; k++) {
        let spellAry2
        if (spellAry[k].indexOf('<*>') > -1) {
          spellAry2 = spellAry[k].split('<*>')
        } else {
          spellAry2 = ['', spellAry[k]]
        }
        for (let l = 1; l < spellAry2.length; l++) {
          let spellAry3 = spellAry2[l].split('<>')
          for (let m = 0; m < spellAry3.length; m++) {
            let spellAry4 = spellAry3[m].split(',')
            let num = Number(spellAry4[0])
            if (num == 1) {
              if (!healCheck[0]) {
                healCheck[0] = true
                stack[1].push(Number(strAry2[j]))
              }
            } else if (num == 4) {
              if (!healCheck[1]) {
                healCheck[1] = true
                stack[2].push(Number(strAry2[j]))
              }
            } else if (num == 2) {
              let ary = ['4', '5', '6', '7', '2', '3']
              let healNum = 1
              for (let n = 0; n < ary.length; n++) {
                healNum++
                if (spellAry4[2].indexOf(ary[n]) > -1) {
                  if (!healCheck[healNum]) {
                    healCheck[healNum] = true
                    stack[healNum + 1].push(Number(strAry2[j]))
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  for (let i = 0; i < 8; i++) {
    stack[0] = []
    for (let j = 0; j < 10; j++) {
      for (let k = 0; k < stack[i + 1].length; k++) {
        let num = Math.floor((stack[i + 1][k] % 100) / 10)
        if (num == j) {
          stack[0].push(stack[i + 1][k])
        }
      }
    }
    if (stack[0].length > 0) {
      let num1 = Math.floor((stack[0][stack[0].length - 1] % 100) / 10)
      GameData['SPELL_HEAL2'][i] += String(stack[0][stack[0].length - 1])
      for (let j = stack[0].length - 2; j >= 0; j--) {
        let num2 = Math.floor((stack[0][j] % 100) / 10)
        if (num1 == num2) {
          GameData['SPELL_HEAL2'][i] += ',' + stack[0][j]
        } else {
          num1 = num2
          GameData['SPELL_HEAL2'][i] += '<>' + stack[0][j]
        }
      }
    }
  }
  ITEM = []
  count = 0
  while (true) {
    let key = 'Item' + String(count)
    if (GameData[key] == undefined) {
      break
    } else if (count >= 10000) {
      break
    }
    strAry = GameData[key].split('<>')
    let data = []
    data[0] = count
    data[1] = strAry[0]
    data[2] = strAry[1]
    data[3] = strAry[2]
    data[4] = strAry[27]
    data[5] = strAry[3]
    data[6] = strAry[4]
    let str = ''
    if (strAry[5] != '') {
      strAry2 = strAry[5].split(',')
      if (strAry2[0] == '-') {
        str += '-,'
      } else {
        let strAry3 = strAry2[0].split('<+>')
        for (let i = 0; i < strAry3.length; i++) {
          str += Number(
            strAry3[i].replace(/class\[([0-9]+)\]/g, '$1')
          ).toString(36)
        }
        str += ','
      }
      if (strAry2[1] == '-') {
        str += '-'
      } else {
        strAry3 = strAry2[1].split('<+>')
        for (let i = 0; i < strAry3.length; i++) {
          str += Number(strAry3[i].replace(/race\[([0-9]+)\]/g, '$1')).toString(
            36
          )
        }
      }
    }
    data[7] = str
    data[8] = strAry[6]
    data[9] = strAry[15]
    data[10] = strAry[8]
    data[11] = strAry[9]
    data[12] = strAry[10]
    data[13] = strAry[12]
    data[14] = strAry[13]
    let num = Number(strAry[14])
    if (num == 1) {
      num = 3
    } else if (num == 2) {
      num = 4
    } else if (num == 3) {
      num = 0
    } else if (num == 4) {
      num = 1
    } else if (num == 5) {
      num = 2
    } else {
      num = -1
    }
    data[15] = String(num)
    data[16] = strAry[34]
    ;(data[17] = strAry[18]), (data[18] = strAry[22])
    data[19] = strAry[19]
    data[20] = strAry[16]
    data[21] = strAry[17]
    data[22] = strAry[24]
    data[23] = strAry[28]
    data[24] = strAry[25]
    data[25] = strAry[20]
    data[26] = strAry[21].replace(/item\[([0-9]+)\]/g, '$1')
    data[27] = strAry[23]
    data[28] = strAry[7]
    data[29] = strAry[11]
    data[30] = strAry[26]
    data[31] = strAry[33]
    data[32] = strAry[29]
    data[33] = strAry[35]
    data[34] = strAry[30]
    data[35] = strAry[31]
    data[36] = strAry[32]
    data[37] = strAry[37]
    data[38] = strAry[36]
    data[39] = strAry[38]
    data[40] = checkNull(strAry[39], '')
    ITEM[count] = new ItemData(data)
    delete GameData[key]
    count++
  }
  GameData['ITEM_DROP'] = []
  count = 0
  while (true) {
    let key = 'ItemDrop' + String(count)
    if (GameData[key] == undefined) {
      break
    } else if (count >= 1000) {
      break
    }
    GameData[key] = GameData[key].replace(/item2?\[([0-9]+)\]/g, '$1')
    GameData[key] = GameData[key].replace(/trap\[([0-9]+)\]/g, '$1')
    GameData['ITEM_DROP'].push(GameData[key])
    delete GameData[key]
    count++
  }
  MONSTER_DATA = []
  count = 0
  while (true) {
    let key = 'Monster' + String(count)
    if (GameData[key] == undefined) {
      break
    } else if (count >= 10000) {
      break
    }
    GameData[key] = GameData[key].replace(/item\[([0-9]+)\]/g, '$1')
    GameData[key] = GameData[key].replace(/item2\[([0-9]+)\]/g, '$1')
    GameData[key] = GameData[key].replace(/monster\[([0-9]+)\]/g, '$1')
    GameData[key] = GameData[key].replace(/monster2\[([0-9]+)\]/g, '$1')
    GameData[key] = GameData[key].replace(/trap\[([0-9]+)\]/g, '$1')
    GameData[key] = GameData[key].replace(/spellRep\[([0-9]+)\]/g, '$1')
    strAry = GameData[key].split('<>')
    let data = []
    data[0] = strAry[0]
    data[1] = strAry[2]
    data[2] = strAry[1]
    data[3] = strAry[3]
    data[4] = strAry[4]
    data[5] = strAry[5]
    data[6] = strAry[7]
    data[7] = strAry[8]
    data[8] = strAry[9]
    data[9] = strAry[10]
    data[10] = strAry[11]
    data[11] = strAry[12]
    data[12] = strAry[13]
    data[13] = strAry[19]
    data[14] = strAry[14]
    data[15] = strAry[15]
    let num = Number(strAry[21])
    if (num >= 1 && num <= 5) {
      num += 0
    } else if (num == 6) {
      num = 8
    } else if (num >= 7 && num <= 11) {
      num += 3
    } else {
      num = 0
    }
    data[16] = String(num)
    data[17] = strAry[18]
    data[18] = strAry[16]
    data[19] = replaceMonsterResist(strAry[22])
    data[21] = replaceMonsterResist(strAry[23])
    data[20] = strAry[17]
    data[22] = strAry[25]
    data[23] = strAry[24]
    data[24] = strAry[26]
    data[25] = strAry[27]
    data[26] = strAry[29] + '<>' + strAry[28]
    data[27] = strAry[6]
    data[28] = strAry[36]
    let str =
      strAry[30] + '<>' + strAry[31] + '<+>' + strAry[32] + '<>' + strAry[33]
    str += '<+>' + strAry[34] + '<>' + strAry[35]
    data[29] = str
    data[30] = strAry[20]
    data[31] = strAry[38] + '<>' + strAry[37]
    data[32] = strAry[39]
    data[33] = strAry[40]
    data[34] = strAry[41]
    data[35] = strAry[42]
    data[36] = strAry[43]
    data[37] = strAry[57]
    data[38] = strAry[44]
    data[39] = strAry[45]
    data[40] = strAry[46]
    data[41] = strAry[47]
    data[42] = strAry[48]
    data[43] = strAry[49]
    data[44] = strAry[50]
    data[45] = strAry[51].replace(/itemDrop\[([0-9]+)\]/g, '$1')
    data[46] = strAry[52]
    data[47] = strAry[53]
    data[48] = strAry[54]
    data[49] = strAry[55] + '<>' + strAry[56]
    data[50] = checkNull(strAry[58], '')
    data[51] = checkNull(strAry[59], 'false')
    MONSTER_DATA[count] = new MonsterData(data)
    delete GameData[key]
    count++
  }
  GameData['TRAP_NAME'] = []
  GameData['TRAP_EFFECT'] = []
  count = 0
  while (true) {
    let key = 'Trap' + String(count)
    if (GameData[key] == undefined) {
      break
    } else if (count >= 16) {
      break
    }
    strAry = GameData[key].split('</>')
    GameData['TRAP_NAME'].push(strAry[0])
    GameData['TRAP_EFFECT'].push(strAry[1])
    delete GameData[key]
    count++
  }
  GameData['FIRST_PC'] = []
  count = 0
  while (true) {
    let key = 'InitialPc' + String(count)
    if (GameData[key] == undefined) {
      break
    } else if (count >= 120) {
      break
    }
    strAry = GameData[key].split('<>')
    if (strAry[9] == 'none') {
      GameData['FIRST_PC'].push(GameData[key])
    } else {
      strAry2 = strAry[9].split(',')
      let str = ''
      for (let i = 0; i < strAry2.length; i++) {
        if (i > 0) {
          str += ','
        }
        str += strAry2[i]
        str += ',0'
      }
      let str2 = ''
      for (let i = 0; i < strAry.length; i++) {
        if (i > 0) {
          str2 += '<>'
        }
        if (i == 9) {
          str2 += str
        } else {
          str2 += strAry[i]
        }
      }
      GameData['FIRST_PC'].push(str2)
    }
    GameData['FIRST_PC'][count] = GameData['FIRST_PC'][count].replace(
      /class\[([0-9]+)\]/g,
      '$1'
    )
    GameData['FIRST_PC'][count] = GameData['FIRST_PC'][count].replace(
      /race\[([0-9]+)\]/g,
      '$1'
    )
    GameData['FIRST_PC'][count] = GameData['FIRST_PC'][count].replace(
      /item2?\[([0-9]+)\]/g,
      '$1'
    )
    delete GameData[key]
    count++
  }
  if (GameData['Battle'] == undefined) {
    return false
  }
  strAry = GameData['Battle'].split(',')
  GameData['DECIDED_PROB'] = strAry[0]
  GameData['TURN_ORDER'] = strAry[1]
  if (strAry[4].indexOf('40') > -1) {
    GameData['ATTACK_RANGE'] = [4, 0]
  } else if (strAry[4].indexOf('20') > -1) {
    GameData['ATTACK_RANGE'] = [2, 0]
  } else if (strAry[4].indexOf('42') > -1) {
    GameData['ATTACK_RANGE'] = [4, 2]
  } else if (strAry[4].indexOf('44') > -1) {
    GameData['ATTACK_RANGE'] = [4, 4]
  } else if (strAry[4].indexOf('02') > -1) {
    GameData['ATTACK_RANGE'] = [0, 2]
  } else if (strAry[4].indexOf('04') > -1) {
    GameData['ATTACK_RANGE'] = [0, 4]
  } else if (strAry[4].indexOf('22') > -1) {
    GameData['ATTACK_RANGE'] = [2, 2]
  } else {
    GameData['ATTACK_RANGE'] = [0, 0]
  }
  GameData['HIT_DECISION'] = strAry[5]
  GameData['HIT_MODIFY'] = strAry[6]
  GameData['MONSTER_HIT_MODIFY'] = strAry[7]
  GameData['DMG_PLUS'] = strAry[8]
  GameData['SPECIAL_ATTACK_PROB_POISON'] = strAry[9]
  GameData['SPELL_RESIST'] = Number(strAry[10])
  GameData['SPELL_WEAK'] = Number(strAry[11])
  GameData['ASLEEP'] = strAry[12]
  GameData['CURE_ASLEEP_TURN'] = strAry[13]
  GameData['CURE_ASLEEP_DMG'] = strAry[14]
  GameData['CURE_SILENCE'] = strAry[15]
  GameData['HIDE_PROB'] = strAry[16]
  GameData['HIDING_KEEP_PROB'] = strAry[17]
  GameData['PARRY_AC'] = strAry[18]
  GameData['PARRY_RESIST'] = strAry[19]
  GameData['NON_MOVE_AC'] = strAry[20]
  GameData['NON_MOVE_DMG'] = Number(strAry[21])
  GameData['BREATH_DMG'] = strAry[22]
  GameData['BREATH_RESIST_PROB'] = strAry[23]
  GameData['SPELL_CANCEL_PROB'] = strAry[24]
  GameData['DISPELL_PROB'] = strAry[25]
  GameData['DISPELL_EXP'] = Number(strAry[26])
  GameData['RUN_PROB'] = strAry[27]
  GameData['MONSTER_RUN_PROB'] = strAry[28]
  GameData['CALL_PROB'] = strAry[29]
  GameData['MONSTER_SUPPORT_SPELL'] = strAry[30]
  GameData['ALIGNMENT_PROB'] = strAry[31]
  GameData['BATTLE_ATTACK_EFFECT'] = strAry[32]
  GameData['BATTLE_DEFENSE_EFFECT'] = strAry[33]
  GameData['SPECIAL_ATTACK_PROB_ASLEEP'] = strAry[34]
  GameData['SPECIAL_ATTACK_PROB_PARALYSIS'] = strAry[35]
  GameData['SPECIAL_ATTACK_PROB_STONE'] = strAry[36]
  GameData['SPECIAL_ATTACK_PROB_KO'] = strAry[37]
  GameData['SPECIAL_ATTACK_PROB_CRIT'] = strAry[38]
  GameData['SPECIAL_ATTACK_PROB_DRAIN'] = strAry[39]
  GameData['CORRECTION_DMG'] = strAry[40]
  GameData['REGISTRATION_MONSTER_CATALOG'] = Number(strAry[41])
  GameData['FIRST_CHOICE_FRIENDSHIP'] = parseStrToBoolean(strAry[42])
  GameData['PREEMPTIVE_PROB_PC'] = strAry[43]
  GameData['PREEMPTIVE_PROB_MONSTER'] = strAry[44]
  GameData['SPECIAL_ATTACK_PROB_HP_DRAIN'] = checkNull(strAry[45], '60')
  delete GameData['Battle']
  if (GameData['SpellEffectIndicated'] == undefined) {
    return false
  }
  GameData['SPELL_EFFECT_INDICATED'] = []
  strAry = GameData['SpellEffectIndicated'].split(',')
  for (let i = 0; i < strAry.length; i++) {
    GameData['SPELL_EFFECT_INDICATED'].push(parseStrToBoolean(strAry[i]))
  }
  delete GameData['SpellEffectIndicated']
  count = 0
  while (true) {
    let key = 'Dungeon' + String(count)
    if (GameData[key] == undefined) {
      break
    } else if (count >= 10) {
      break
    }
    strAry = GameData[key].split('</3>')
    strAry2 = strAry[0].split('<>')
    DUNGEON.DungeonName.push(strAry2[0])
    let strAry3 = strAry2[1].split(',')
    DUNGEON.Width.push(Number(strAry3[0]) + 1)
    DUNGEON.Height.push(Number(strAry3[1]) + 1)
    if (strAry2[2] == 'none') {
      strAry2[2] = ''
    }
    DUNGEON.DungeonMusic.push(strAry2[2])
    DUNGEON.DUNGEON_CONDITION.push(strAry2[3])
    let num1 = Number(strAry2[5])
    if (num1 < 83) {
      num1 = 83 - num1
    } else {
      num1 = 82 - num1
    }
    DUNGEON.FloorMinMax[count] = []
    let num2 = Number(strAry2[4])
    let floorCount = num1
    for (let i = 0; i <= num2; i++) {
      DUNGEON.FloorMinMax[count].push(floorCount)
      floorCount++
      if (floorCount == 0) {
        floorCount++
      }
    }
    num1 = Number(strAry2[6])
    if (num1 > num2) {
      num1 = num2
    }
    DUNGEON.StartFloor.push(num1)
    strAry3 = strAry2[7].split(',')
    DUNGEON.StartPointX.push(Number(strAry3[0]))
    DUNGEON.StartPointY.push(Number(strAry3[1]))
    DUNGEON.StartDirection.push(Number(strAry2[8]))
    DUNGEON.StartFlag.push(strAry2[9].replace(/\//g, '<>'))
    DUNGEON.Light[count] = []
    DUNGEON.NotWarp[count] = []
    DUNGEON.NotUseWarp[count] = []
    DUNGEON.NoFriendship[count] = []
    DUNGEON.EnterLimit[count] = []
    DUNGEON.EncounterRate[count] = []
    DUNGEON.EncounterMonsters[count] = []
    DUNGEON.EncounterNum[count] = []
    DUNGEON.BoxTrap[count] = []
    DUNGEON.BoxGold[count] = []
    DUNGEON.DungeonImage[count] = []
    DUNGEON.BattleMusic[count] = []
    DUNGEON.FloorMusicCheck[count] = []
    DUNGEON.FloorMusic[count] = []
    DUNGEON.DungeonFlag[count] = []
    DUNGEON.BoxAppearance[count] = []
    DUNGEON.MonsterRoomEncounterRate[count] = []
    DUNGEON.WestWall[count] = []
    DUNGEON.SouthWall[count] = []
    DUNGEON.Space[count] = []
    DUNGEON.MonsterRoom[count] = []
    DUNGEON.RoomGuardian[count] = []
    DUNGEON.FloorName[count] = []
    DUNGEON.NoMusicCamp[count] = []
    strAry2 = strAry[1].split('</2>')
    for (let i = strAry2.length - 1; i >= 0; i--) {
      strAry2[i] = strAry2[i].replace(/monster2?\[([0-9]+)\]/g, '$1')
      strAry2[i] = strAry2[i].replace(/trap\[([0-9]+)\]/g, '$1')
      strAry3 = strAry2[i].split('<>')
      if (strAry3[0].charAt(0) == '1') {
        DUNGEON.Light[count][i] = true
      } else {
        DUNGEON.Light[count][i] = false
      }
      if (strAry3[0].charAt(1) == '1') {
        DUNGEON.NotWarp[count][i] = true
      } else {
        DUNGEON.NotWarp[count][i] = false
      }
      if (strAry3[0].charAt(2) == '1') {
        DUNGEON.NotUseWarp[count][i] = true
      } else {
        DUNGEON.NotUseWarp[count][i] = false
      }
      if (strAry3[0].charAt(3) == '1') {
        DUNGEON.NoFriendship[count][i] = true
      } else {
        DUNGEON.NoFriendship[count][i] = false
      }
      if (strAry3[1].match(/^[0-8]$/)) {
        let num = Number(strAry3[1])
        if (num == 0) {
          strAry3[1] = ','
        } else if (num == 1) {
          strAry3[1] = '0,'
        } else if (num == 2) {
          strAry3[1] = '1,'
        } else if (num == 3) {
          strAry3[1] = '2,'
        } else if (num == 4) {
          strAry3[1] = '01,'
        } else if (num == 5) {
          strAry3[1] = '02,'
        } else if (num == 6) {
          strAry3[1] = '12,'
        } else if (num == 7) {
          strAry3[1] = ',0'
        } else if (num == 8) {
          strAry3[1] = ',1'
        }
      }
      DUNGEON.EnterLimit[count][i] = strAry3[1]
      DUNGEON.EncounterRate[count][i] = strAry3[2]
      DUNGEON.EncounterMonsters[count][i] = strAry3[3]
      DUNGEON.EncounterNum[count][i] = []
      DUNGEON.EncounterNum[count][i].push(Number(strAry3[4]))
      DUNGEON.EncounterNum[count][i].push(Number(strAry3[5]))
      DUNGEON.BoxTrap[count][i] = strAry3[6] + '<>' + strAry3[7]
      DUNGEON.BoxGold[count][i] = strAry3[8]
      DUNGEON.DungeonImage[count][i] = strAry3[9]
      if (LaunchSettings['GraphicPrefetch']) {
        let prefetchAry = DUNGEON.DungeonImage[count][i].split('<->')
        for (let j = 0; j < prefetchAry.length; j++) {
          if (prefetchAry[j] == '') {
            continue
          }
          let prefetchStr = 'graphic/dungeon/' + prefetchAry[j]
          if (Prefetch['dungeon'].indexOf(prefetchStr) < 0) {
            Prefetch['dungeon'].push(prefetchStr)
          }
        }
      }
      if (strAry3[10] == 'none') {
        strAry3[10] = ''
      }
      DUNGEON.BattleMusic[count][i] = strAry3[10]
      DUNGEON.FloorMusicCheck[count][i] = parseStrToBoolean(strAry3[11])
      if (strAry3[12] == 'none') {
        strAry3[12] = ''
      }
      DUNGEON.FloorMusic[count][i] = strAry3[12]
      DUNGEON.DungeonFlag[count][i] = strAry3[13].replace(/\//g, '<>')
      DUNGEON.BoxAppearance[count][i] = strAry3[14]
      DUNGEON.MonsterRoomEncounterRate[count][i] = strAry3[15]
      DUNGEON.WestWall[count][i] = []
      DUNGEON.SouthWall[count][i] = []
      DUNGEON.Space[count][i] = []
      DUNGEON.MonsterRoom[count][i] = []
      for (let j = 0; j < DUNGEON.Width[count]; j++) {
        DUNGEON.WestWall[count][i][j] = []
        DUNGEON.SouthWall[count][i][j] = []
        DUNGEON.Space[count][i][j] = []
        DUNGEON.MonsterRoom[count][i][j] = []
        for (let k = 0; k < DUNGEON.Height[count]; k++) {
          DUNGEON.WestWall[count][i][j].push('0')
          DUNGEON.SouthWall[count][i][j].push('0')
          DUNGEON.Space[count][i][j].push('0')
          DUNGEON.MonsterRoom[count][i][j].push(-1)
        }
      }
      DUNGEON.RoomGuardian[count][i] = []
      for (let j = 0; j < 100; j++) {
        DUNGEON.RoomGuardian[count][i].push('')
      }
      if (strAry3[16] == ' ') {
        strAry3[16] = ''
      }
      DUNGEON.FloorName[count][i] = strAry3[16]
      DUNGEON.NoMusicCamp[count][i] = strAry3[17]
    }
    strAry2 = strAry[2].split('</2>')
    strAry3 = strAry[3].split('</2>')
    let preCheck = ''
    for (let i = 0; i < strAry2.length; i++) {
      if (strAry2[i] == 'none') {
        break
      }
      let strAry4 = strAry2[i].split('<*>')
      let strAry5 = strAry4[0].split('<->')
      let strAry6 = strAry5[0].split('<+>')
      for (let j = 0; j < strAry6.length; j++) {
        if (j >= DUNGEON.Width[count]) {
          break
        }
        let k = 0
        let strAry7 = strAry6[j].split(',,')
        for (let l = 0; l < strAry7.length; l++) {
          if (k >= DUNGEON.Height[count]) {
            break
          }
          if (strAry7[l].indexOf(',') > -1) {
            DUNGEON.WestWall[count][i][j][k] = strAry7[l]
            if (!DUNGEON.FindDoor) {
              if (
                DUNGEON.WestWall[count][i][j][k].match(
                  /3,[0-9]+,[0-9]+,(0|ws|en)/
                )
              ) {
                DUNGEON.FindDoor = true
              }
            }
            if (!DUNGEON.PickDoor) {
              if (DUNGEON.WestWall[count][i][j][k].match(/6,[0-9]+,[0-9]+/)) {
                DUNGEON.PickDoor = true
              }
            }
            k++
          } else {
            for (let m = 0; m < strAry7[l].length; m++) {
              if (k >= DUNGEON.Height[count]) {
                break
              }
              DUNGEON.WestWall[count][i][j][k] = strAry7[l].charAt(m)
              k++
            }
          }
        }
      }
      strAry6 = strAry5[1].split('<+>')
      for (let j = 0; j < strAry6.length; j++) {
        if (j >= DUNGEON.Width[count]) {
          break
        }
        let k = 0
        let strAry7 = strAry6[j].split(',,')
        for (let l = 0; l < strAry7.length; l++) {
          if (k >= DUNGEON.Height[count]) {
            break
          }
          if (strAry7[l].indexOf(',') > -1) {
            DUNGEON.SouthWall[count][i][j][k] = strAry7[l]
            if (!DUNGEON.FindDoor) {
              if (
                DUNGEON.SouthWall[count][i][j][k].match(
                  /3,[0-9]+,[0-9]+,(0|ws|en)/
                )
              ) {
                DUNGEON.FindDoor = true
              }
            }
            if (!DUNGEON.PickDoor) {
              if (DUNGEON.SouthWall[count][i][j][k].match(/6,[0-9]+,[0-9]+/)) {
                DUNGEON.PickDoor = true
              }
            }
            k++
          } else {
            for (let m = 0; m < strAry7[l].length; m++) {
              if (k >= DUNGEON.Height[count]) {
                break
              }
              DUNGEON.SouthWall[count][i][j][k] = strAry7[l].charAt(m)
              k++
            }
          }
        }
      }
      strAry6 = strAry5[2].split('<+>')
      for (let j = 0; j < strAry6.length; j++) {
        if (j >= DUNGEON.Width[count]) {
          break
        }
        k = 0
        let strAry7 = strAry6[j].split(',,')
        for (let l = 0; l < strAry7.length; l++) {
          if (k >= DUNGEON.Height[count]) {
            break
          }
          if (strAry7[l].indexOf(',') > -1 || strAry7[l].indexOf('<>') > -1) {
            if (strAry7[l].charAt(0) == 'E') {
              let eventStr = strAry7[l].split('<>')
              let reg = new RegExp('^' + String(j) + ',' + String(k) + '</0>.+')
              strAry7[l] += '<>true<>none<>none'
              let strAry8 = strAry3[i].split('</1>')
              for (let m = 0; m < strAry8.length; m++) {
                if (strAry8[m].match(reg)) {
                  let strAry9 = strAry8[m].split('</0>')
                  strAry7[l] = eventStr[0] + '<>' + strAry9[1]
                  break
                }
              }
            }
            strAry7[l] = strAry7[l].replace(/monster2?\[([0-9]+)\]/g, '$1')
            strAry7[l] = strAry7[l].replace(/item2?\[([0-9]+)\]/g, '$1')
            strAry7[l] = strAry7[l].replace(/dungeon\[([0-9]+)\]/g, '$1')
            strAry7[l] = strAry7[l].replace(/floor\[([0-9]+)\]/g, '$1')
            strAry7[l] = strAry7[l].replace(/floorMyDungeon\[([0-9]+)\]/g, '$1')
            DUNGEON.Space[count][i][j][k] = strAry7[l]
            if (LaunchSettings['GraphicPrefetch']) {
              let sourceStr = DUNGEON.Space[count][i][j][k]
              let reg = new RegExp('<img *src="([^>]*?)".*?>')
              while (sourceStr.match(reg)) {
                let prefetchStr = 'graphic/' + RegExp.$1
                if (Prefetch['event'].indexOf(prefetchStr) < 0) {
                  Prefetch['event'].push(prefetchStr)
                }
                sourceStr = sourceStr.replace(reg, '')
              }
            }
            k++
          } else {
            for (let m = 0; m < strAry7[l].length; m++) {
              if (k >= DUNGEON.Height[count]) {
                break
              }
              DUNGEON.Space[count][i][j][k] = strAry7[l].charAt(m)
              k++
            }
          }
        }
      }
      strAry5 = strAry4[1].split('<>')
      for (let l = 0; l < strAry5.length; l++) {
        if (strAry5[l].indexOf(',') < 0) {
          break
        }
        let strAry6 = strAry5[l].split(',')
        let j = Number(strAry6[0])
        let k = Number(strAry6[1])
        if (j < DUNGEON.Width[count] && k < DUNGEON.Height[count]) {
          DUNGEON.MonsterRoom[count][i][j][k] = Number(strAry6[2])
        }
      }
      strAry5 = strAry4[2].split('<->')
      for (let k = 0; k < strAry5.length; k++) {
        if (strAry5[k].indexOf('<+>') < 0) {
          break
        }
        strAry6 = strAry5[k].split('<+>')
        let j = Number(strAry6[0])
        strAry6[1] = strAry6[1].replace(/monster2?\[([0-9]+)\]/g, '$1')
        strAry6[1] = strAry6[1].replace(/item2?\[([0-9]+)\]/g, '$1')
        DUNGEON.RoomGuardian[count][i][j] = strAry6[1]
      }
      if (strAry4[3] == 'all') {
        if (preCheck != '') {
          preCheck += '<>'
        }
        preCheck += String(i) + ',all'
      } else {
        let strAry5 = strAry4[3].split('<>')
        for (let j = 0; j < strAry5.length; j++) {
          if (strAry5[j].indexOf(',') < 0) {
            break
          }
          let strAry6 = strAry5[j].split(',')
          if (preCheck != '') {
            preCheck += '<>'
          }
          preCheck += String(i) + ',' + strAry6[0] + ',' + strAry6[1]
        }
      }
    }
    DUNGEON.CheckedSpacePreCheck.push(preCheck)
    delete GameData[key]
    count++
  }
  DUNGEON.DUNGEON_MAX = count
  if (GameData['Others'] == undefined) {
    return false
  }
  strAry = GameData['Others'].split(',')
  GameData['IDENTIFY_PROB'] = strAry[0]
  GameData['CURSE_EVASION_PROB'] = strAry[1]
  GameData['BOX_INSPECT'] = strAry[2]
  GameData['BOX_DISARM'] = strAry[3]
  GameData['TRAP_PROB'] = strAry[4]
  GameData['PIT_EVASION_PROB'] = strAry[5]
  GameData['PIT_DAMAGE'] = strAry[6]
  GameData['FIND_DOOR_PROB'] = []
  GameData['FIND_DOOR_PROB'].push(strAry[7])
  GameData['FIND_DOOR_PROB'].push(strAry[8])
  GameData['PICK_DOOR_PROB'] = strAry[9]
  GameData['CURE_AFRAID_PROB'] = strAry[10]
  delete GameData['Others']
  if (GameData['Save'] == undefined) {
    return false
  }
  strAry = GameData['Save'].split(',')
  GameData['SAVE_CAMP'] = parseStrToBoolean(strAry[0])
  GameData['SAVE_FLOOR_MOVED'] = parseStrToBoolean(strAry[1])
  GameData['SAVE_BATTLE_END'] = parseStrToBoolean(strAry[2])
  GameData['SAVE_ANNIHILATION'] = parseStrToBoolean(strAry[3])
  GameData['SAVE_SUB_QUIT'] = parseStrToBoolean(strAry[4])
  if (
    !GameData['SAVE_CAMP'] &&
    !GameData['SAVE_FLOOR_MOVED'] &&
    !GameData['SAVE_BATTLE_END'] &&
    !GameData['SAVE_SUB_QUIT']
  ) {
    GameData['LOAD_RESTART'] = false
  } else {
    GameData['LOAD_RESTART'] = true
  }
  delete GameData['Save']
  GameData['RECOVERY_ON_RETURN'] = []
  if (GameData['RecoveryOnReturn'] == undefined) {
    for (let i = 0; i < 7; i++) {
      GameData['RECOVERY_ON_RETURN'].push(false)
    }
  } else {
    strAry = GameData['RecoveryOnReturn'].split(',')
    for (let i = 0; i < 7; i++) {
      GameData['RECOVERY_ON_RETURN'].push(
        parseStrToBoolean(checkNull(strAry[i], 'false'))
      )
    }
    delete GameData['RecoveryOnReturn']
  }
  if (GameData['Box'] == undefined) {
    return false
  }
  GameData['BOX_MUSIC'] = GameData['Box']
  delete GameData['Box']
  if (GameData['InitialFlag'] == undefined) {
    return false
  }
  GameData['INITIAL_FLAG'] = GameData['InitialFlag']
  delete GameData['InitialFlag']
  GameData['PC_ENTRY_MAX'] = Number(checkNull(GameData['PcEntryMax'], '36'))
  delete GameData['PcEntryMax']
  if (GameData['PC_ENTRY_MAX'] > 120) {
    GameData['PC_ENTRY_MAX'] = 120
  } else if (GameData['PC_ENTRY_MAX'] < PC_ENTRY_MIN) {
    GameData['PC_ENTRY_MAX'] = PC_ENTRY_MIN
  }
  GameData['SELECT_COLOR'] = ''
  if (DefaultMessage['_SELECT_COLOR'] != undefined) {
    if (DefaultMessage['_SELECT_COLOR'] != null) {
      GameData['SELECT_COLOR'] = DefaultMessage['_SELECT_COLOR']
    }
    delete DefaultMessage['_SELECT_COLOR']
  }
  if (
    GameData['SELECT_COLOR'].match(
      /^[0-9a-zA-Z][0-9a-zA-Z][0-9a-zA-Z][0-9a-zA-Z][0-9a-zA-Z][0-9a-zA-Z]$/
    )
  ) {
    GameData['SELECT_COLOR'] = '#' + GameData['SELECT_COLOR']
  } else {
    GameData['SELECT_COLOR'] = '#FF0000'
  }
  GameData['SELECT_OVER_COLOR'] = ''
  if (DefaultMessage['_SELECT_OVER_COLOR'] != undefined) {
    if (DefaultMessage['_SELECT_OVER_COLOR'] != null) {
      GameData['SELECT_OVER_COLOR'] = DefaultMessage['_SELECT_OVER_COLOR']
    }
    delete DefaultMessage['_SELECT_COLOR']
  }
  if (
    GameData['SELECT_OVER_COLOR'].match(
      /^[0-9a-zA-Z][0-9a-zA-Z][0-9a-zA-Z][0-9a-zA-Z][0-9a-zA-Z][0-9a-zA-Z]$/
    )
  ) {
    GameData['SELECT_OVER_COLOR'] = '#' + GameData['SELECT_OVER_COLOR']
  } else {
    GameData['SELECT_OVER_COLOR'] = '#98FB98'
  }
  GameData['GP'] = getDefaultMessage('GP', 1, 4)
  if (GameData['GP'] == '') {
    GameData['GP'] = 'GP'
  }
  GameData['LEVEL_UP'] = getDefaultMessage('LEVEL_UP', 1, 1)
  if (GameData['LEVEL_UP'] == '') {
    GameData['LEVEL_UP'] = '@'
  }
  GameData['ITEM_NOT_NAME_UNDECIDED'] = true
  let checkEquip = [],
    checkShop = []
  for (let i = 0; i < 7; i++) {
    checkEquip[i] = false
    checkShop[i] = false
  }
  for (let i = 0; i < ITEM.length; i++) {
    if (ITEM[i].EQUIP_REQ_CLASS.indexOf('-') < 0) {
      checkEquip[ITEM[i].TYPE] = true
    }
    if (ITEM[i].PRICE > 0 && ITEM[i].STOCK_OK) {
      checkShop[ITEM[i].TYPE] = true
    }
    if (GameData['ITEM_NOT_NAME_UNDECIDED']) {
      if (!ITEM[i].NOT_DISPLAYED && ITEM[i].NAME[0] != '') {
        GameData['ITEM_NOT_NAME_UNDECIDED'] = false
      }
    }
  }
  GameData['ITEM_EQUIP_LIST'] = []
  GameData['SHOP_KIND_LIST'] = []
  for (let i = 0; i < 7; i++) {
    if (checkEquip[i]) {
      GameData['ITEM_EQUIP_LIST'].push(i)
      if (i == 0) {
        GameData['ITEM_EQUIP_LIST'].push(7)
      }
    }
    if (checkShop[i]) {
      GameData['SHOP_KIND_LIST'].push(i)
    }
  }
  GameData['MONSTER_NOT_NAME_UNDECIDED'] = true
  for (let i = 0; i < MONSTER_DATA.length; i++) {
    if (MONSTER_DATA[i].NAME[0] != MONSTER_DATA[i].NAME[1]) {
      GameData['MONSTER_NOT_NAME_UNDECIDED'] = false
      break
    }
  }
  GameData['GENERIC_FORMULA'] = []
  count = 0
  while (true) {
    let key = 'GenericFormula' + String(count)
    if (GameData[key] == undefined) {
      break
    } else if (count >= 1000) {
      break
    }
    let strAry = GameData[key].split('<>')
    GameData['GENERIC_FORMULA'].push(strAry[1].replace(/<br>/g, ' '))
    let str = GameData['GENERIC_FORMULA'][count].replace(/ /g, '')
    if (str == '') {
      GameData['GENERIC_FORMULA'][count] = '0'
    }
    delete GameData[key]
    count++
  }
  if (GameData['GENERIC_FORMULA'].length > 0) {
    for (let i = 0; i < GameData['INN_CHARGE'].length; i++) {
      GameData['INN_CHARGE'][i] = replaceGenericFormula(
        GameData['INN_CHARGE'][i]
      )
    }
    for (let i = 0; i < GameData['INN_HEALING'].length; i++) {
      GameData['INN_HEALING'][i] = replaceGenericFormula(
        GameData['INN_HEALING'][i]
      )
    }
    for (let i = 0; i < GameData['INN_MP_HEALING'].length; i++) {
      GameData['INN_MP_HEALING'][i] = replaceGenericFormula(
        GameData['INN_MP_HEALING'][i]
      )
    }
    GameData['ITEM_SELL'] = replaceGenericFormula(GameData['ITEM_SELL'])
    GameData['ITEM_SELL_UNDECIDED'] = replaceGenericFormula(
      GameData['ITEM_SELL_UNDECIDED']
    )
    GameData['ITEM_UNCURSE'] = replaceGenericFormula(GameData['ITEM_UNCURSE'])
    GameData['ITEM_IDENTIFY'] = replaceGenericFormula(GameData['ITEM_IDENTIFY'])
    GameData['TEMPLE_PARALYZE'] = replaceGenericFormula(
      GameData['TEMPLE_PARALYZE']
    )
    GameData['TEMPLE_STONE'] = replaceGenericFormula(GameData['TEMPLE_STONE'])
    GameData['TEMPLE_DEAD'] = replaceGenericFormula(GameData['TEMPLE_DEAD'])
    GameData['TEMPLE_ASH'] = replaceGenericFormula(GameData['TEMPLE_ASH'])
    GameData['RESUSCITATE_PROB'] = replaceGenericFormula(
      GameData['RESUSCITATE_PROB']
    )
    GameData['TEMPLE_ADD_AGE'] = replaceGenericFormula(
      GameData['TEMPLE_ADD_AGE']
    )
    for (let i = 0; i < GameData['MPMAX_UP'].length; i++) {
      for (let j = 0; j < GameData['MPMAX_UP'][i].length; j++) {
        GameData['MPMAX_UP'][i][j] = replaceGenericFormula(
          GameData['MPMAX_UP'][i][j]
        )
      }
    }
    for (let i = 0; i < GameData['SPELL_LEARNED_PROB'].length; i++) {
      GameData['SPELL_LEARNED_PROB'][i] = replaceGenericFormula(
        GameData['SPELL_LEARNED_PROB'][i]
      )
    }
    GameData['SPELL_LEARNED_PROB_DEC'] = replaceGenericFormula(
      GameData['SPELL_LEARNED_PROB_DEC']
    )
    for (let i = 0; i < GameData['ABILITY_CHANGE_PROB'].length; i++) {
      GameData['ABILITY_CHANGE_PROB'][i] = replaceGenericFormula(
        GameData['ABILITY_CHANGE_PROB'][i]
      )
    }
    for (let i = 0; i < GameData['ABILITY_DOWN_PROB'].length; i++) {
      GameData['ABILITY_DOWN_PROB'][i] = replaceGenericFormula(
        GameData['ABILITY_DOWN_PROB'][i]
      )
    }
    GameData['PC_CREATE_AGE'] = replaceGenericFormula(GameData['PC_CREATE_AGE'])
    GameData['PC_CREATE_GOLD'] = replaceGenericFormula(
      GameData['PC_CREATE_GOLD']
    )
    GameData['PC_CREATE_ITEM'] = replaceGenericFormula(
      GameData['PC_CREATE_ITEM']
    )
    GameData['BONUS_DICE_NUM'] = replaceGenericFormula(
      GameData['BONUS_DICE_NUM']
    )
    GameData['BONUS_DICE'] = replaceGenericFormula(GameData['BONUS_DICE'])
    GameData['BONUS_DICE_PLUS'] = replaceGenericFormula(
      GameData['BONUS_DICE_PLUS']
    )
    GameData['CLASS_CHANGE_ADD_AGE'] = replaceGenericFormula(
      GameData['CLASS_CHANGE_ADD_AGE']
    )
    GameData['CLASS_CHANGE_LV'] = replaceGenericFormula(
      GameData['CLASS_CHANGE_LV']
    )
    GameData['CLASS_CHANGE_HP'] = replaceGenericFormula(
      GameData['CLASS_CHANGE_HP']
    )
    for (let i = 0; i < GameData['CLASS_CHANGE_ABI'].length; i++) {
      GameData['CLASS_CHANGE_ABI'][i] = replaceGenericFormula(
        GameData['CLASS_CHANGE_ABI'][i]
      )
    }
    for (let i = 0; i < GameData['CASTLE_EVENT'].length; i++) {
      GameData['CASTLE_EVENT'][i] = replaceGenericFormula(
        GameData['CASTLE_EVENT'][i]
      )
    }
    GameData['REG_TM_AGE'] = replaceGenericFormula(GameData['REG_TM_AGE'])
    GameData['REG_TM_LV'] = replaceGenericFormula(GameData['REG_TM_LV'])
    GameData['REG_TM_ABI'] = replaceGenericFormula(GameData['REG_TM_ABI'])
    GameData['REG_TM_GOLD'] = replaceGenericFormula(GameData['REG_TM_GOLD'])
    GameData['TM'] = replaceGenericFormula(GameData['TM'])
    for (let i = 0; i < GameData['RACE_CONDITION'].length; i++) {
      GameData['RACE_CONDITION'][i] = replaceGenericFormula(
        GameData['RACE_CONDITION'][i]
      )
    }
    for (let i = 0; i < GameData['RACE_BREATH_NUM'].length; i++) {
      GameData['RACE_BREATH_NUM'][i] = replaceGenericFormula(
        GameData['RACE_BREATH_NUM'][i]
      )
    }
    for (let i = 0; i < GameData['CLASS_CONDITION'].length; i++) {
      GameData['CLASS_CONDITION'][i] = replaceGenericFormula(
        GameData['CLASS_CONDITION'][i]
      )
    }
    for (let i = 0; i < GameData['CLASS_AC'].length; i++) {
      GameData['CLASS_AC'][i] = replaceGenericFormula(GameData['CLASS_AC'][i])
    }
    for (let i = 0; i < GameData['CLASS_HIT'].length; i++) {
      GameData['CLASS_HIT'][i] = replaceGenericFormula(GameData['CLASS_HIT'][i])
    }
    for (let i = 0; i < GameData['CLASS_ATTACK_NUM'].length; i++) {
      GameData['CLASS_ATTACK_NUM'][i] = replaceGenericFormula(
        GameData['CLASS_ATTACK_NUM'][i]
      )
    }
    for (let i = 0; i < GameData['CLASS_DMG1'].length; i++) {
      GameData['CLASS_DMG1'][i] = replaceGenericFormula(
        GameData['CLASS_DMG1'][i]
      )
    }
    for (let i = 0; i < GameData['CLASS_DMG2'].length; i++) {
      GameData['CLASS_DMG2'][i] = replaceGenericFormula(
        GameData['CLASS_DMG2'][i]
      )
    }
    for (let i = 0; i < GameData['CLASS_DMG3'].length; i++) {
      GameData['CLASS_DMG3'][i] = replaceGenericFormula(
        GameData['CLASS_DMG3'][i]
      )
    }
    for (let i = 0; i < GameData['CLASS_HP_ADD'].length; i++) {
      GameData['CLASS_HP_ADD'][i] = replaceGenericFormula(
        GameData['CLASS_HP_ADD'][i]
      )
    }
    for (let i = 0; i < GameData['CLASS_NECESSARY_EXP'].length; i++) {
      GameData['CLASS_NECESSARY_EXP'][i] = replaceGenericFormula(
        GameData['CLASS_NECESSARY_EXP'][i]
      )
    }
    for (let i = 0; i < GameData['GENERAL_CORRECTION'].length; i++) {
      for (let j = 0; j < GameData['GENERAL_CORRECTION'][i].length; j++) {
        GameData['GENERAL_CORRECTION'][i][j] = replaceGenericFormula(
          GameData['GENERAL_CORRECTION'][i][j]
        )
      }
    }
    for (let i = 0; i < GameData['SPELL_BASE'].length; i++) {
      GameData['SPELL_BASE'][i] = replaceGenericFormula(
        GameData['SPELL_BASE'][i]
      )
    }
    for (let i = 0; i < ITEM.length; i++) {
      ITEM[i].DMG = replaceGenericFormula(ITEM[i].DMG)
      ITEM[i].BREAK_PROB = replaceGenericFormula(ITEM[i].BREAK_PROB)
    }
    for (let i = 0; i < GameData['ITEM_DROP'].length; i++) {
      GameData['ITEM_DROP'][i] = replaceGenericFormula(GameData['ITEM_DROP'][i])
    }
    for (let i = 0; i < MONSTER_DATA.length; i++) {
      MONSTER_DATA[i].LEVEL = replaceGenericFormula(MONSTER_DATA[i].LEVEL)
      MONSTER_DATA[i].EXP = replaceGenericFormula(MONSTER_DATA[i].EXP)
      MONSTER_DATA[i].HP_MAX = replaceGenericFormula(MONSTER_DATA[i].HP_MAX)
      MONSTER_DATA[i].MP_MAX = replaceGenericFormula(MONSTER_DATA[i].MP_MAX)
      MONSTER_DATA[i].AC = replaceGenericFormula(MONSTER_DATA[i].AC)
      MONSTER_DATA[i].DMG = replaceGenericFormula(MONSTER_DATA[i].DMG)
      MONSTER_DATA[i].AT = replaceGenericFormula(MONSTER_DATA[i].AT)
      MONSTER_DATA[i].ENTER_NUM = replaceGenericFormula(
        MONSTER_DATA[i].ENTER_NUM
      )
      MONSTER_DATA[i].FOLLOWER = replaceGenericFormula(MONSTER_DATA[i].FOLLOWER)
      MONSTER_DATA[i].GOLD = replaceGenericFormula(MONSTER_DATA[i].GOLD)
      MONSTER_DATA[i].ACTION_PATTERN = replaceGenericFormula(
        MONSTER_DATA[i].ACTION_PATTERN
      )
    }
    for (let i = 0; i < GameData['TRAP_EFFECT'].length; i++) {
      GameData['TRAP_EFFECT'][i] = replaceGenericFormula(
        GameData['TRAP_EFFECT'][i]
      )
    }
    for (let i = 0; i < GameData['FIRST_PC'].length; i++) {
      GameData['FIRST_PC'][i] = replaceGenericFormula(GameData['FIRST_PC'][i])
    }
    GameData['DECIDED_PROB'] = replaceGenericFormula(GameData['DECIDED_PROB'])
    GameData['TURN_ORDER'] = replaceGenericFormula(GameData['TURN_ORDER'])
    GameData['PREEMPTIVE_PROB_PC'] = replaceGenericFormula(
      GameData['PREEMPTIVE_PROB_PC']
    )
    GameData['PREEMPTIVE_PROB_MONSTER'] = replaceGenericFormula(
      GameData['PREEMPTIVE_PROB_MONSTER']
    )
    GameData['HIT_DECISION'] = replaceGenericFormula(GameData['HIT_DECISION'])
    GameData['HIT_MODIFY'] = replaceGenericFormula(GameData['HIT_MODIFY'])
    GameData['MONSTER_HIT_MODIFY'] = replaceGenericFormula(
      GameData['MONSTER_HIT_MODIFY']
    )
    GameData['DMG_PLUS'] = replaceGenericFormula(GameData['DMG_PLUS'])
    GameData['ASLEEP'] = replaceGenericFormula(GameData['ASLEEP'])
    GameData['CURE_ASLEEP_TURN'] = replaceGenericFormula(
      GameData['CURE_ASLEEP_TURN']
    )
    GameData['CURE_ASLEEP_DMG'] = replaceGenericFormula(
      GameData['CURE_ASLEEP_DMG']
    )
    GameData['CURE_SILENCE'] = replaceGenericFormula(GameData['CURE_SILENCE'])
    GameData['HIDE_PROB'] = replaceGenericFormula(GameData['HIDE_PROB'])
    GameData['HIDING_KEEP_PROB'] = replaceGenericFormula(
      GameData['HIDING_KEEP_PROB']
    )
    GameData['PARRY_AC'] = replaceGenericFormula(GameData['PARRY_AC'])
    GameData['PARRY_RESIST'] = replaceGenericFormula(GameData['PARRY_RESIST'])
    GameData['NON_MOVE_AC'] = replaceGenericFormula(GameData['NON_MOVE_AC'])
    GameData['BATTLE_ATTACK_EFFECT'] = replaceGenericFormula(
      GameData['BATTLE_ATTACK_EFFECT']
    )
    GameData['BATTLE_DEFENSE_EFFECT'] = replaceGenericFormula(
      GameData['BATTLE_DEFENSE_EFFECT']
    )
    GameData['CORRECTION_DMG'] = replaceGenericFormula(
      GameData['CORRECTION_DMG']
    )
    GameData['BREATH_DMG'] = replaceGenericFormula(GameData['BREATH_DMG'])
    GameData['BREATH_RESIST_PROB'] = replaceGenericFormula(
      GameData['BREATH_RESIST_PROB']
    )
    GameData['SPELL_CANCEL_PROB'] = replaceGenericFormula(
      GameData['SPELL_CANCEL_PROB']
    )
    GameData['ALIGNMENT_PROB'] = replaceGenericFormula(
      GameData['ALIGNMENT_PROB']
    )
    GameData['DISPELL_PROB'] = replaceGenericFormula(GameData['DISPELL_PROB'])
    GameData['RUN_PROB'] = replaceGenericFormula(GameData['RUN_PROB'])
    GameData['MONSTER_RUN_PROB'] = replaceGenericFormula(
      GameData['MONSTER_RUN_PROB']
    )
    GameData['CALL_PROB'] = replaceGenericFormula(GameData['CALL_PROB'])
    GameData['MONSTER_SUPPORT_SPELL'] = replaceGenericFormula(
      GameData['MONSTER_SUPPORT_SPELL']
    )
    GameData['SPECIAL_ATTACK_PROB_POISON'] = replaceGenericFormula(
      GameData['SPECIAL_ATTACK_PROB_POISON']
    )
    GameData['SPECIAL_ATTACK_PROB_ASLEEP'] = replaceGenericFormula(
      GameData['SPECIAL_ATTACK_PROB_ASLEEP']
    )
    GameData['SPECIAL_ATTACK_PROB_PARALYSIS'] = replaceGenericFormula(
      GameData['SPECIAL_ATTACK_PROB_PARALYSIS']
    )
    GameData['SPECIAL_ATTACK_PROB_STONE'] = replaceGenericFormula(
      GameData['SPECIAL_ATTACK_PROB_STONE']
    )
    GameData['SPECIAL_ATTACK_PROB_KO'] = replaceGenericFormula(
      GameData['SPECIAL_ATTACK_PROB_KO']
    )
    GameData['SPECIAL_ATTACK_PROB_CRIT'] = replaceGenericFormula(
      GameData['SPECIAL_ATTACK_PROB_CRIT']
    )
    GameData['SPECIAL_ATTACK_PROB_DRAIN'] = replaceGenericFormula(
      GameData['SPECIAL_ATTACK_PROB_DRAIN']
    )
    for (let i = 0; i < DUNGEON.DUNGEON_CONDITION.length; i++) {
      DUNGEON.DUNGEON_CONDITION[i] = replaceGenericFormula(
        DUNGEON.DUNGEON_CONDITION[i]
      )
    }
    for (let i = 0; i < DUNGEON.EncounterRate.length; i++) {
      for (let j = 0; j < DUNGEON.EncounterRate[i].length; j++) {
        DUNGEON.EncounterRate[i][j] = replaceGenericFormula(
          DUNGEON.EncounterRate[i][j]
        )
      }
    }
    for (let i = 0; i < DUNGEON.MonsterRoomEncounterRate.length; i++) {
      for (let j = 0; j < DUNGEON.MonsterRoomEncounterRate[i].length; j++) {
        DUNGEON.MonsterRoomEncounterRate[i][j] = replaceGenericFormula(
          DUNGEON.MonsterRoomEncounterRate[i][j]
        )
      }
    }
    for (let i = 0; i < DUNGEON.BoxAppearance.length; i++) {
      for (let j = 0; j < DUNGEON.BoxAppearance[i].length; j++) {
        DUNGEON.BoxAppearance[i][j] = replaceGenericFormula(
          DUNGEON.BoxAppearance[i][j]
        )
      }
    }
    for (let i = 0; i < DUNGEON.BoxGold.length; i++) {
      for (let j = 0; j < DUNGEON.BoxGold[i].length; j++) {
        DUNGEON.BoxGold[i][j] = replaceGenericFormula(DUNGEON.BoxGold[i][j])
      }
    }
    for (let i = 0; i < DUNGEON.NoMusicCamp.length; i++) {
      for (let j = 0; j < DUNGEON.NoMusicCamp[i].length; j++) {
        DUNGEON.NoMusicCamp[i][j] = replaceGenericFormula(
          DUNGEON.NoMusicCamp[i][j]
        )
      }
    }
    for (let i = 0; i < DUNGEON.Space.length; i++) {
      for (let j = 0; j < DUNGEON.Space[i].length; j++) {
        for (let k = 0; k < DUNGEON.Space[i][j].length; k++) {
          for (let l = 0; l < DUNGEON.Space[i][j][k].length; l++) {
            if (DUNGEON.Space[i][j][k][l] == null) {
              continue
            }
            if (!DUNGEON.Space[i][j][k][l].match(/^E(,[^<>]+)?<>.+$/)) {
              continue
            }
            DUNGEON.Space[i][j][k][l] = replaceGenericFormula(
              DUNGEON.Space[i][j][k][l]
            )
          }
        }
      }
    }
    for (let i = 0; i < DUNGEON.RoomGuardian.length; i++) {
      for (let j = 0; j < DUNGEON.RoomGuardian[i].length; j++) {
        for (let k = 0; k < DUNGEON.RoomGuardian[i][j].length; k++) {
          DUNGEON.RoomGuardian[i][j][k] = replaceGenericFormula(
            DUNGEON.RoomGuardian[i][j][k]
          )
        }
      }
    }
    GameData['IDENTIFY_PROB'] = replaceGenericFormula(GameData['IDENTIFY_PROB'])
    GameData['CURSE_EVASION_PROB'] = replaceGenericFormula(
      GameData['CURSE_EVASION_PROB']
    )
    GameData['BOX_INSPECT'] = replaceGenericFormula(GameData['BOX_INSPECT'])
    GameData['BOX_DISARM'] = replaceGenericFormula(GameData['BOX_DISARM'])
    GameData['TRAP_PROB'] = replaceGenericFormula(GameData['TRAP_PROB'])
    GameData['PIT_EVASION_PROB'] = replaceGenericFormula(
      GameData['PIT_EVASION_PROB']
    )
    GameData['PIT_DAMAGE'] = replaceGenericFormula(GameData['PIT_DAMAGE'])
    for (let i = 0; i < GameData['FIND_DOOR_PROB'].length; i++) {
      GameData['FIND_DOOR_PROB'][i] = replaceGenericFormula(
        GameData['FIND_DOOR_PROB'][i]
      )
    }
    GameData['PICK_DOOR_PROB'] = replaceGenericFormula(
      GameData['PICK_DOOR_PROB']
    )
    GameData['CURE_AFRAID_PROB'] = replaceGenericFormula(
      GameData['CURE_AFRAID_PROB']
    )
  }
  return true
}
function setKeyConfig (keyConfigData) {
  let keyName = []
  KeyConfig = {}
  for (let i = 0; i < KEY_NAME.length; i++) {
    keyName[i] = KEY_NAME[i].replace('KEY_', '').toLowerCase()
    KeyConfig[keyName[i]] = []
  }
  for (let i = 0; i < KEY_NAME.length; i++) {
    KeyConfig[keyName[i]] = keyConfigData[KEY_NAME[i]].split(',')
    for (let j = 0; j < KeyConfig[keyName[i]].length; j++) {
      KeyConfig[keyName[i]][j] = KeyConfig[keyName[i]][j].replace(/ /g, '')
    }
  }
  ShortcutSuppression = []
  for (let i = 0; i < keyName.length; i++) {
    for (let j = 0; j < KeyConfig[keyName[i]].length; j++) {
      let ary = getKeycode(KeyConfig[keyName[i]][j])
      for (let k = 0; k < ary.length; k++) {
        ShortcutSuppression.push(ary[k])
      }
    }
  }
  let keyNameAry = ['enter', 'escape', 'alt']
  for (let i = 0; i < keyNameAry.length; i++) {
    let ary = getKeycode(keyNameAry[i])
    for (let j = 0; j < ary.length; j++) {
      ShortcutSuppression.push(ary[j])
    }
  }
}
function setMonster (monster, alarm) {
  if (alarm == undefined || alarm == null) {
    alarm = false
  }
  let ptNum = PlayData['ActiveParty']
  let pt = PARTY[ptNum]
  let dungeon = pt.DungeonNumber
  let floor = pt.Floor
  TempVariable['setMonster'] = []
  TempVariable['monsterNum'] = []
  TempVariable['monsterDecided'] = []
  TempVariable['monsterDecidedChange'] = []
  for (let i = 0; i < 4; i++) {
    TempVariable['setMonster'].push(-1)
    TempVariable['monsterNum'].push(0)
    TempVariable['monsterDecided'].push(false)
    TempVariable['monsterDecidedChange'].push(false)
    for (let j = 0; j < 9; j++) {
      PlayData['MonsterList'][i][j] = -1
    }
  }
  TempVariable['summonNum'] = []
  for (let i = 0; i < 2; i++) {
    TempVariable['summonNum'].push(-1)
    for (let j = 0; j < 9; j++) {
      PlayData['SummonList'][i][j] = -1
    }
  }
  for (let i = 0; i < MONSTER.length; i++) {
    MONSTER[i].initialize()
  }
  for (let i = 0; i < SUMMON.length; i++) {
    SUMMON[i].initialize()
  }
  if (monster.match(/^(|-1)$/)) {
    monster = DUNGEON.EncounterMonsters[dungeon][floor]
  }
  TempVariable['setMonster'][0] = getMonster(monster)
  let itemDrop = MONSTER_DATA[TempVariable['setMonster'][0]].ITEM_DROP
  if (itemDrop < 0 || itemDrop >= GameData['ITEM_DROP'].length) {
    TempVariable['itemDrop'] = ''
    if (!alarm) {
      TempVariable['goldStr'] = ''
    }
    TempVariable['trapStr'] = ''
  } else {
    let strAry = GameData['ITEM_DROP'][itemDrop].split('<->')
    TempVariable['itemDrop'] = strAry[0]
    let strAry2 = strAry[1].split('<>')
    if (!alarm) {
      if (parseStrToBoolean(strAry2[0])) {
        TempVariable['goldStr'] = strAry2[1]
      } else {
        TempVariable['goldStr'] = ''
      }
    }
    if (parseStrToBoolean(strAry2[2])) {
      TempVariable['trapStr'] = strAry2[3] + '<>' + strAry2[4]
    } else {
      TempVariable['trapStr'] = ''
    }
  }
  for (let i = 1; i < 4; i++) {
    if (i >= DUNGEON.EncounterNum[dungeon][floor][0]) {
      break
    }
    let prob = MONSTER_DATA[TempVariable['setMonster'][i - 1]].FOLLOWER_RATE
    if (prob < dice(1, 100)) {
      break
    }
    let follower = MONSTER_DATA[TempVariable['setMonster'][i - 1]].FOLLOWER
    TempVariable['setMonster'][i] = getMonster(follower)
  }
  TempVariable['monsterBgm'] = ''
  let count = 0
  for (let i = 0; i < 4; i++) {
    if (TempVariable['setMonster'][i] < 0) {
      break
    }
    let monDataNum = TempVariable['setMonster'][i]
    if (
      TempVariable['monsterBgm'] == '' &&
      MONSTER_DATA[monDataNum].MUSIC_FLAG
    ) {
      TempVariable['monsterBgm'] = MONSTER_DATA[monDataNum].MUSIC
      if (TempVariable['monsterBgm'] == '') {
        TempVariable['monsterBgm'] = 'none'
      }
    }
    let formula = MONSTER_DATA[monDataNum].ENTER_NUM
    let strAry = DUNGEON.BoxTrap[dungeon][floor].split('<>')
    formula = formula.replace(/trap\.lv/g, strAry[0])
    let num = Math.floor(strCalculation(replaceFormula(formula)))
    let limit = DUNGEON.EncounterNum[dungeon][floor][1]
    if (num < 1) {
      num = 1
    } else if (num > limit) {
      num = limit
    }
    if (num > 9) {
      num = 9
    }
    TempVariable['monsterNum'][i] = num
    for (let j = 0; j < TempVariable['monsterNum'][i]; j++) {
      MONSTER[count].createMonster(monDataNum, count)
      PlayData['MonsterList'][i][j] = count
      count++
    }
    if (GameData['REGISTRATION_MONSTER_CATALOG'] == 1) {
      if (!PlayData['MonsterFlag'][monDataNum]) {
        printDebugMessage(
          String(monDataNum) +
            ':' +
            MONSTER_DATA[monDataNum].NAME[1] +
            ' was registered with a catalog.'
        )
        PlayData['MonsterFlag'][monDataNum] = true
      }
    }
  }
  function getMonster (monster) {
    if (monster == '') {
      return 0
    } else {
      let strAry = MP.getCmNum(monster).split(',')
      let num = Number(strAry[dice(1, strAry.length) - 1])
      if (num >= MONSTER_DATA.length) {
        num = 0
      }
      return num
    }
  }
}
function setPcEquip (pcNum, item, haveItemNum) {
  if (!ITEM[item].equipCheck(pcNum)) {
    return
  } else if (ITEM[item].TYPE == 0) {
    if (PC[pcNum].kindEquipedItem(0, true) > -1) {
      let num = PC[pcNum].weaponCursedCheck()
      if (
        PC[pcNum].kindEquipedItem(7, true) > -1 ||
        PC[pcNum].kindEquipedItem(2, true) > -1 ||
        ITEM[PC[pcNum].Item[num]].WEAPON_TYPE == 1 ||
        PC[pcNum].kindCursedCheck(0) ||
        ITEM[item].WEAPON_TYPE != 2
      ) {
        return
      }
      if (ITEM[item].curseCheck(pcNum)) {
        num = PC[pcNum].kindEquipedItem(0)
        PC[pcNum].Equip[num] = 0
        PC[pcNum].Equip[haveItemNum] = 2
      } else {
        PC[pcNum].Equip[haveItemNum] = 3
      }
      return
    } else if (
      ITEM[item].WEAPON_TYPE == 1 &&
      PC[pcNum].kindEquipedItem(2, true) > -1
    ) {
      return
    }
  } else if (ITEM[item].TYPE == 2) {
    if (PC[pcNum].kindEquipedItem(2, true) > -1) {
      return
    }
    if (PC[pcNum].kindEquipedItem(0, true) > -1) {
      let num = PC[pcNum].weaponCursedCheck()
      if (
        ITEM[PC[pcNum].Item[num]].WEAPON_TYPE == 1 ||
        PC[pcNum].kindEquipedItem(7, true) > -1
      ) {
        return
      }
    }
  } else if (PC[pcNum].kindEquipedItem(ITEM[item].TYPE, true) > -1) {
    return
  }
  if (ITEM[item].curseCheck(pcNum)) {
    PC[pcNum].Equip[haveItemNum] = 2
  } else {
    PC[pcNum].Equip[haveItemNum] = 1
  }
}
function setWindowAlign () {
  let winLeft
  if (WinAlign == 'left') {
    winLeft = 0
  } else {
    winLeft = window.innerWidth - GameBody.width * GameBody.scale
    if (WinAlign != 'right') {
      winLeft /= 2
    }
  }
  let stage = document.getElementById('enchant-stage')
  stage.style.position = 'absolute'
  stage.style.left = winLeft + 'px'
  GameBody._pageX = winLeft
}
function setWindowResize (windowWidth, windowHeight) {
  let winW = window.innerWidth,
    winH = window.innerHeight
  WinScale = calDiv(winW, windowWidth)
  let screenW, screenH
  if (calTimes(windowHeight, WinScale) <= winH) {
    screenW = winW
    screenH = calTimes(windowHeight, WinScale)
  } else {
    screenH = winH
    WinScale = calDiv(winH, windowHeight)
    screenW = calTimes(windowWidth, WinScale)
  }
  WindowScaleWidth = calDiv(windowWidth, screenW)
  WindowScaleHeight = calDiv(windowHeight, screenH)
  if (WebGL_Scale == 0) {
    WebGL_Scale = calDiv(windowWidth, screenW)
  }
}
function shortcutSuppression (event) {
  if (ShortcutSuppression.indexOf(event.which) > -1) {
    event.which = null
    return false
  }
}
function spellEffectReplace (effect, type) {
  let reg = new RegExp('(spell\\[([0-9]+)\\])')
  while (effect.match(reg)) {
    let refStr = RegExp.$1
    let num = Number(RegExp.$2)
    let str = ''
    if (num < GameData['SPELL_BASE'].length) {
      let strAry = GameData['SPELL_BASE'][num].split('<>')
      if (type == 3) {
        for (let i = 0; i < strAry.length; i++) {
          let strAry2 = strAry[i].split(',')
          if (strAry2.length > 1) {
            strAry2[1] = '1'
          }
          strAry[i] = ''
          for (let j = 0; j < strAry2.length; j++) {
            if (j > 0) {
              strAry[i] += ','
            }
            strAry[i] += strAry2[j]
          }
        }
      } else if (type == 4) {
        for (let i = 0; i < strAry.length; i++) {
          let strAry2 = strAry[i].split(',')
          let spellNum = Number(strAry2[0])
          if (spellNum == 401 || spellNum == 403 || spellNum == 410) {
            strAry[i] = '0,0'
            continue
          } else if (strAry2.length > 1) {
            strAry2[1] = '1'
          }
          strAry[i] = ''
          for (let j = 0; j < strAry2.length; j++) {
            if (j > 0) {
              strAry[i] += ','
            }
            strAry[i] += strAry2[j]
          }
        }
      }
      for (let i = 0; i < strAry.length; i++) {
        if (i > 0) {
          str += '<>'
        }
        str += strAry[i]
      }
    }
    let reg2 = new RegExp(refStr.replace(/([\[\]])/g, '\\$1'), 'g')
    effect = effect.replace(reg2, str)
  }
  if (effect == '') {
    effect = '0,0'
  }
  return effect
}
function strCalculation (str) {
  if (str == undefined || str == null) {
    return 0
  }
  str = str.replace(/[ 　]/g, '')
  if (str == '') {
    return 0
  }
  let list = []
  let regNum = new RegExp('^(-?[0-9]+(\\.[0-9]+)?).*')
  let regOthers = new RegExp(
    '.+?((\\+|\\-|\\*|/|%|&&|\\|\\||min|max|sqrt|d|D|round|ceil|floor|abs|==|!=|<=|>=|<|>|\\(|\\)|\\^|true|false).*)'
  )
  while (str != '') {
    if (str.match(regNum)) {
      let flag = false
      let strTmp
      if (str.indexOf('-') == 0 && list.length > 0) {
        strTmp = list[list.length - 1]
        if (strTmp.match(regNum) || strTmp == ')') {
          flag = true
        }
      }
      strTmp = str.replace(regNum, '$1')
      str = str.replace(strTmp, '')
      if (flag) {
        list.push('-')
        strTmp = strTmp.substring(1)
      }
      list.push(strTmp)
    } else if (str.indexOf('true') == 0) {
      str = str.substring(4)
      list.push('1.0')
    } else if (str.indexOf('false') == 0) {
      str = str.substring(5)
      list.push('0.0')
    } else if (str.indexOf('(') == 0) {
      str = str.substring(1)
      list.push('(')
    } else if (str.indexOf('^') == 0) {
      str = str.substring(1)
      list.push('^')
    } else if (str.indexOf('abs') == 0) {
      str = str.substring(3)
      list.push('abs')
    } else if (str.indexOf('==') == 0) {
      str = str.substring(2)
      list.push('==')
    } else if (str.indexOf('!=') == 0) {
      str = str.substring(2)
      list.push('!=')
    } else if (str.indexOf('<=') == 0) {
      str = str.substring(2)
      list.push('<=')
    } else if (str.indexOf('>=') == 0) {
      str = str.substring(2)
      list.push('>=')
    } else if (str.indexOf('<') == 0) {
      str = str.substring(1)
      list.push('<')
    } else if (str.indexOf('>') == 0) {
      str = str.substring(1)
      list.push('>')
    } else if (str.indexOf('floor') == 0) {
      str = str.substring(5)
      list.push('floor')
    } else if (str.indexOf('ceil') == 0) {
      str = str.substring(4)
      list.push('ceil')
    } else if (str.indexOf('round') == 0) {
      str = str.substring(5)
      list.push('round')
    } else if (str.indexOf('D') == 0 || str.indexOf('d') == 0) {
      str = str.substring(1)
      list.push('D')
    } else if (str.indexOf('pow') == 0) {
      str = str.substring(3)
      list.push('pow')
    } else if (str.indexOf('sqrt') == 0) {
      str = str.substring(4)
      list.push('sqrt')
    } else if (str.indexOf('max') == 0) {
      str = str.substring(3)
      list.push('max')
    } else if (str.indexOf('min') == 0) {
      str = str.substring(3)
      list.push('min')
    } else if (str.indexOf('||') == 0) {
      str = str.substring(2)
      list.push('||')
    } else if (str.indexOf('&&') == 0) {
      str = str.substring(2)
      list.push('&&')
    } else if (str.indexOf('%') == 0) {
      str = str.substring(1)
      list.push('%')
    } else if (str.indexOf('/') == 0) {
      str = str.substring(1)
      list.push('/')
    } else if (str.indexOf('*') == 0) {
      str = str.substring(1)
      list.push('*')
    } else if (str.indexOf('-') == 0) {
      str = str.substring(1)
      if (list.length > 0) {
        list.push('-')
      } else {
        list.push('-1')
        list.push('*')
      }
    } else if (str.indexOf('+') == 0) {
      str = str.substring(1)
      if (list.length > 0) {
        list.push('+')
      }
    } else if (str.indexOf(')') == 0) {
      str = str.substring(1)
      list.push(')')
    } else {
      if (str.match(regOthers)) {
        str = str.replace(regOthers, '$1')
      } else {
        str = ''
      }
      list.push('0.0')
    }
  }
  let order = []
  order['('] = 0
  ;(order['+'] = 1), (order['-'] = 1), (order['||'] = 1)
  ;(order['%'] = 2), (order['/'] = 2), (order['*'] = 2), (order['&&'] = 2)
  order['pow'] = 3
  order['sqrt'] = 4
  ;(order['min'] = 5), (order['max'] = 5), (order['=='] = 5), (order['!='] = 5)
  ;(order['<='] = 5), (order['>='] = 5), (order['<'] = 5), (order['>'] = 5)
  order['D'] = 6
  order['abs'] = 7
  ;(order['floor'] = 7), (order['ceil'] = 7), (order['round'] = 7)
  order['^'] = 7
  order[')'] = 8
  let stack = []
  let list2 = []
  for (let i = 0; i < list.length; i++) {
    str = list[i]
    if (str.match(regNum)) {
      list2.push(str)
    } else if (str == '(') {
      stack.push(str)
    } else if (str == ')') {
      while (true) {
        if (stack.length < 1) {
          break
        }
        let strTmp = stack.pop()
        if (strTmp == '(') {
          break
        } else {
          list2.push(strTmp)
        }
      }
    } else {
      while (true) {
        if (stack.length < 1) {
          stack.push(str)
          break
        } else if (order[str] > order[stack[stack.length - 1]]) {
          stack.push(str)
          break
        } else {
          list2.push(stack.pop())
        }
      }
    }
  }
  while (stack.length > 0) {
    list2.push(stack.pop())
  }
  result = 0
  stack = []
  for (i = 0; i < list2.length; i++) {
    str = list2[i]
    if (str.match(regNum)) {
      stack.push(str)
    } else {
      if (stack.length > 0) {
        let num2 = Number(stack.pop())
        if (str == 'floor') {
          result = Math.floor(num2)
        } else if (str == 'ceil') {
          result = Math.ceil(num2)
        } else if (str == 'abs') {
          result = Math.abs(num2)
        } else if (str == 'round') {
          result = Math.round(num2)
        } else if (str == 'sqrt') {
          result = BigNumber(num2).sqrt().toNumber()
        } else if (str == '^') {
          if (num2 == 0) {
            result = 1
          } else {
            result = 0
          }
        } else if (stack.length > 0) {
          let num1 = Number(stack.pop())
          if (str == '%') {
            result = BigNumber(num1).mod(num2).toNumber()
          } else if (str == '/') {
            if (num1 == 0 || num2 == 0) {
              result = 0
            } else {
              result = BigNumber(num1).div(num2).toNumber()
            }
          } else if (str == '*') {
            result = BigNumber(num1).times(num2).toNumber()
          } else if (str == '-') {
            result = BigNumber(num1).minus(num2).toNumber()
          } else if (str == '+') {
            result = BigNumber(num1).plus(num2).toNumber()
          } else if (str == 'min') {
            result = Math.min(num1, num2)
          } else if (str == 'max') {
            result = Math.max(num1, num2)
          } else if (str == 'pow') {
            result = Math.pow(num1, num2)
          } else if (str == 'D') {
            result = dice(num1, num2)
          } else if (str == '||') {
            if (num1 == 0 && num2 == 0) {
              result = 0
            } else if (num1 != 0 && num2 != 0) {
              result = 1
            } else {
              result = 1
            }
          } else if (str == '&&') {
            if (num1 == 0 && num2 == 0) {
              result = 0
            } else if (num1 != 0 && num2 != 0) {
              result = 1
            } else {
              result = 0
            }
          } else if (str == '==') {
            if (num1 == num2) {
              result = 1
            } else {
              result = 0
            }
          } else if (str == '!=') {
            if (num1 != num2) {
              result = 1
            } else {
              result = 0
            }
          } else if (str == '<=') {
            if (num1 <= num2) {
              result = 1
            } else {
              result = 0
            }
          } else if (str == '>=') {
            if (num1 >= num2) {
              result = 1
            } else {
              result = 0
            }
          } else if (str == '<') {
            if (num1 < num2) {
              result = 1
            } else {
              result = 0
            }
          } else if (str == '>') {
            if (num1 > num2) {
              result = 1
            } else {
              result = 0
            }
          } else {
            result = 0
          }
        } else {
          result = 0
        }
      } else {
        result = 0
      }
      stack.push(result)
    }
  }
  if (stack.length < 1) {
    return result
  }
  result = stack.pop()
  return result
}
function titleAction (key) {
  if (key == undefined || key == null) {
    key = ''
  }
  if (GameState == 'titleStart') {
    MP.clearMainWindow()
    musicPlay('opening')
    let strAry = GameData['TITLE_CG'].split('<>')
    if (!strAry[0].match(/^(| )$/)) {
      let titleGra = 'graphic/' + strAry[0]
      if (GraphicData[titleGra] != null) {
        strAry = strAry[1].split(',')
        let scale = MP.MAIN_WIDTH / 300
        let w = Number(strAry[0]) * scale,
          h = Number(strAry[1]) * scale
        let x = Number(strAry[2]) * scale,
          y = Number(strAry[3]) * scale
        MP.paintGraphic(MP.MainSurface, GraphicData[titleGra], x, y, w, h)
      }
    }
    if (GameData['TITLE_TEXT'].length > 0) {
      for (let i = 0; i < GameData['TITLE_TEXT'].length; i++) {
        strAry = GameData['TITLE_TEXT'][i].split('<>')
        MP.drawText_Full(
          MP.MainSurface,
          strAry[0],
          strAry[1],
          Number(strAry[2])
        )
      }
    }
    MP.clearTextSurface('all')
    GameState = 'title'
  }
  let value
  if (key == '' || key == 'cancel') {
    value = 0
  } else {
    value = MP.SelectMode['valueAry'][MP.SelectMode['select']]
  }
  if (key == 'enter') {
    if (value == 0) {
      GameState = 'castleTownStart'
      townAction()
      return
    } else if (value == 1) {
      Config['AutoMapping'] = !Config['AutoMapping']
      configSave()
      value = 0
    }
  }
  let selAry = []
  selAry.push(getDefaultMessage('START_GAME', 1))
  if (GameData['AUTO_MAPPING'] == 0) {
    let str = getDefaultMessage('AUTOMAP_DISPLAY', 1) + ' : '
    if (Config['AutoMapping']) {
      str += getDefaultMessage('AUTOMAP_GRAPH', 1)
    } else {
      str += getDefaultMessage('AUTOMAP_NUMERIC', 1)
    }
    selAry.push(str)
  }
  MP.setSelectMode(
    titleAction,
    'normal',
    selAry,
    null,
    null,
    null,
    'center',
    MP.LINE_HEIGHT * 21,
    0,
    0,
    'left',
    value,
    0,
    GameData['SELECT_COLOR']
  )
}
function uploadTextFile (extension, callbackFunc) {
  let reader = new FileReader()
  reader.onload = function () {
    UploadData = reader.result
    callbackFunc()
  }
  let input = document.createElement('input')
  input.type = 'file'
  input.accept = '.' + extension
  input.onchange = function (event) {
    GenericVariable['FullKeyInvalid'] = true
    reader.readAsText(event.target.files[0])
  }
  input.click()
}
