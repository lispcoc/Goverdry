function battleAction (key) {
  GenericVariable['ReturnAction'] = battleAction
  if (key == undefined || key == null) {
    key = ''
    MP.SelectMode['selectF'] = 0
  }
  if (key.match(/^(none|start)$/)) {
    MP.SelectMode['selectF'] = 0
  }
  let value
  if (key == '' || key.match(/^(cancel|escape|start)$/)) {
    value = 0
  } else {
    value = MP.SelectMode['valueAry'][MP.SelectMode['select']]
  }
  let ptNum = PlayData['ActiveParty']
  let pt = PARTY[ptNum]
  let dungeon = pt.DungeonNumber
  let floor = pt.Floor
  let selAry = [],
    valueAry = [],
    colorAry = null
  let mode = 'normal',
    comment = ''
  let align = 'center',
    y = MP.LINE_HEIGHT,
    charMin = 0,
    lineNum = 0,
    textAlign = 'left'
  if (GameState == 'battleStart') {
    MP.clearTextSurface('all')
    let text = MP.strChangeLine(getDefaultMessage('ENCOUNTER'), 42, 12, true)
    y *= 8 - Math.floor(MP.strGetLineNum(text) / 2)
    MP.drawTextFrame(
      MP.TextSurface[MP.TextSurfaceNum],
      text,
      'center',
      y,
      0,
      0,
      'center'
    )
    GenericVariable['KeyInvalid'] = true
    GenericVariable['TimeEventCountMax'] = TIME_COUNT[1]
    GenericVariable['TimeEventCount'] = 0
    GenericVariable['TimeEvent'] = 'battleStart'
    GameMode = 'battle'
    if (!TempVariable['battleStart'].match(/^preemptive/)) {
      TempVariable['turn'] = 1
    }
    TempVariable['battleMusic'] = getBattleMusic(
      TempVariable['eventBgm'],
      TempVariable['monsterBgm'],
      DUNGEON.BattleMusic[dungeon][floor]
    )
    return
  } else if (GameState == 'battleStart2') {
    MP.clearMainWindow()
    MP.viewPartyStatus()
    if (TempVariable['battleStart'] == 'friendship') {
      if (key == 'enter') {
        if (value == 0) {
          changeAlignmentFriendly('fight')
          GameState = 'battleReadGraphic'
          battleAction()
        } else {
          changeAlignmentFriendly('leave')
          controlFlag(TempVariable['flagWin'], false)
          if (TempVariable['roomNum'] > -1) {
            DUNGEON.CheckedMonsterRoom[TempVariable['roomNum']] = true
          }
          let eventAgain = TempVariable['eventAgain']
          pt.battleReset()
          pt.check()
          deleteTempVariable()
          if (GameData['SAVE_BATTLE_END']) {
            saveData('Battle end (It returns to the dungeon)')
          }
          GameState = 'moveStart'
          if (eventAgain) {
            dungeonAction('step')
          } else {
            dungeonAction('view')
          }
        }
        return
      }
      let text = ''
      if (TempVariable['monsterNum'][0] > 1) {
        text = getDefaultMessage('FRIENDLY_GROUP')
      } else {
        text = getDefaultMessage('FRIENDLY_GROUP_1')
      }
      let mon = MONSTER[PlayData['MonsterList'][0][0]]
      let monName, monNames
      if (TempVariable['monsterDecided'][0]) {
        monName = mon.Name[1]
        monNames = mon.Names[1]
      } else {
        monName = mon.Name[0]
        monNames = mon.Names[0]
      }
      text = text.replace(/\[monster\]/g, monName)
      text = text.replace(/\[monsters\]/g, monNames)
      text = MP.strChangeLine(text, 42, 12, true)
      let yLine = MP.strGetLineNum(text)
      y *= 8 - Math.floor(yLine / 2)
      MP.drawTextFrame(
        MP.TextSurface[MP.TextSurfaceNum],
        text,
        'center',
        y,
        0,
        0,
        'center'
      )
      MP.TextSurfaceNum++
      selAry.push(getDefaultMessage('BATTLE_SELECT_FIGHT', 1))
      selAry.push(getDefaultMessage('FRIENDLY_LEAVE', 1))
      y += MP.LINE_HEIGHT * (yLine + 1)
      if (GameData['FIRST_CHOICE_FRIENDSHIP']) {
        if (pt.checkAlignment() == 0) {
          value = 1
        }
      }
    } else if (TempVariable['battleStart'].match(/^preemptive/)) {
      let text = ''
      if (TempVariable['battleStart'] == 'preemptivePc') {
        text = 'SURPRISED_MONSTER'
      } else {
        text = 'SURPRISED_YOU'
      }
      text = MP.strChangeLine(getDefaultMessage(text), 42, 12, true)
      y *= 8 - Math.floor(MP.strGetLineNum(text) / 2)
      MP.drawTextFrame(
        MP.TextSurface[MP.TextSurfaceNum],
        text,
        'center',
        y,
        0,
        0,
        'center'
      )
      GameState = 'battleReadGraphicInputKey'
      return
    } else {
      GameState = 'battleReadGraphic'
      battleAction()
      return
    }
  } else if (GameState == 'battleReadGraphic') {
    if (TempVariable['battleMusic'] != 'no change') {
      musicPlay(TempVariable['battleMusic'])
    }
    let monsterAry = []
    for (let i = 0; i < 4; i++) {
      if (TempVariable['setMonster'][i] < 0) {
        break
      }
      let num = TempVariable['setMonster'][i]
      if (monsterAry.indexOf(num) < 0) {
        monsterAry.push(num)
      }
    }
    monsterAry = checkGraphic_Monster(monsterAry)
    GameState = 'battleSetTurn'
    if (monsterAry.length > 0) {
      readGraphicFile_Monster(monsterAry, battleAction)
      return
    }
    battleAction()
    return
  } else if (GameState == 'battleSetTurn') {
    MP.clearMainWindow()
    pt.battleActionReset()
    sortNoAction()
    setMonsterList()
    GenericVariable['KeyInvalid'] = true
    TempVariable['monsterCG'] = [
      ['', ''],
      ['', '']
    ]
    TempVariable['monsterView'] = ['normal', 'normal']
    TempVariable['monsterViewCount'] = 0
    TempVariable['monsterViewStage'] = 0
    for (let i = 0; i < 2; i++) {
      if (TempVariable['monsterNum'][i] > 0) {
        let monDataNum = TempVariable['setMonster'][i]
        TempVariable['monsterCG'][i][0] =
          MONSTER_DATA[monDataNum].ConfirmedCG[0]
        TempVariable['monsterCG'][i][1] =
          MONSTER_DATA[monDataNum].ConfirmedCG[1]
        if (TempVariable['monsterLineChange'][i]) {
          TempVariable['monsterView'][i] = 'line'
          let num = 0
          if (TempVariable['monsterDecided'][i]) {
            num = 1
          }
          if (GraphicData[TempVariable['monsterCG'][i][num]] == null) {
            TempVariable['monsterView'][i] = 'normal'
          }
        } else if (TempVariable['monsterDecidedChange'][i]) {
          TempVariable['monsterView'][i] = 'decided'
          if (
            GraphicData[TempVariable['monsterCG'][i][0]] == null &&
            GraphicData[TempVariable['monsterCG'][i][1]] == null
          ) {
            TempVariable['monsterView'][i] = 'normal'
          }
        }
      }
    }
    TempVariable['monsterDecidedChange'] = [false, false, false, false]
    TempVariable['monsterLineChange'] = [false, false]
    MP.paintMonsterGrahic(
      TempVariable['monsterCG'],
      TempVariable['monsterDecided'],
      TempVariable['monsterView'],
      TempVariable['monsterViewStage']
    )
    if (
      TempVariable['monsterView'][0] == 'normal' &&
      TempVariable['monsterView'][1] == 'normal'
    ) {
      GameState = 'battleSetTurn2'
      battleAction()
    } else {
      GenericVariable['MonsterGraphic'] = true
    }
    return
  } else if (GameState == 'battleSetTurn2') {
    GenericVariable['KeyInvalid'] = true
    GenericVariable['TimeEventCountMax'] = TIME_COUNT[3]
    GenericVariable['TimeEventCount'] = 0
    GenericVariable['TimeEvent'] = 'battleSetTurn'
    return
  } else if (GameState == 'battleSetTurn3') {
    GenericVariable['KeyInvalid'] = false
    let activeMemberNum = pt.getMemberNum(true)
    if (activeMemberNum < 1) {
      GameState = 'battleCommandEnd'
    } else if (
      TempVariable['turn'] > 0 ||
      TempVariable['battleStart'] == 'preemptivePc'
    ) {
      GameState = 'battleCommand'
      PlayData['StatusNum'] = pt.PartyMember[0]
    } else {
      GameState = 'battleCommandEnd'
    }
    battleAction()
    return
  } else if (GameState == 'battleTurnAction') {
    TempVariable['turnCount'] = [-1, -1, -1]
    if (TempVariable['turnAction'].length < 1) {
      pt.healingEffect(true)
      battleText('clear')
      GameState = 'battleTurnHealingEffect'
      battleAction()
      return
    }
    MP.clearTextSurface('all')
    MP.viewPartyStatus('clear')
    let turnAction = TempVariable['turnAction'].shift()
    if (turnAction >= 50) {
      TempVariable['actionCharType'] = 'summon'
      let num = turnAction - 50
      let summonNumInGroup1 = Math.floor(num / 10),
        summonNumInGroup2 = num % 10
      TempVariable['actionCharNumInGroup'] = [
        summonNumInGroup1,
        summonNumInGroup2
      ]
      let summonNum =
        PlayData['SummonList'][summonNumInGroup1][summonNumInGroup2]
      if (summonNum < 0) {
        battleAction()
        return
      }
      TempVariable['actionCharNum'] = summonNum
      let summon = SUMMON[summonNum]
      let mData = MONSTER_DATA[summon.MonsterDataNum]
      let action = summon.Action[0]
      if (checkBattleEnd() == 2 || !summon.possibleToAction() || action < 0) {
        battleAction()
      } else if (action == 0) {
        let target = summon.Action[1]
        if (target >= 20) {
          target = Math.floor((target - 20) / 10)
        } else if (target >= 10) {
          target -= 10
        }
        if (TempVariable['monsterNum'][target] < 1) {
          if (mData.TWICE_ATTACKS) {
            target = summon.Action[2]
            if (target >= 20) {
              target = Math.floor((target - 20) / 10)
            } else if (target >= 10) {
              target -= 10
            }
            if (TempVariable['monsterNum'][target] > 0) {
              GameState = 'battleTurnAction2'
              TempVariable['turnCount'][2] = 0
            }
          }
        } else {
          GameState = 'battleTurnAction2'
        }
        battleAction()
      } else if (action == 3 || action == 8 || action == 9) {
        if (summon.NoBreath != 0 && (action == 3 || action == 9)) {
          battleAction()
        } else if (action == 3) {
          let actionFlag = false
          if (mData.BREATH_RANGE == 2) {
            actionFlag = true
          } else {
            summon.Action[2] -= 10
            let target = summon.Action[2]
            if (TempVariable['monsterNum'][target] > 0) {
              actionFlag = true
            }
          }
          if (actionFlag) {
            GameState = 'battleTurnAction2'
          }
          battleAction()
        } else {
          GameState = 'battleTurnAction2'
          battleAction()
        }
      } else if (action == 4) {
        GameState = 'battleTurnAction2'
        battleAction()
      } else if (action == 6) {
        let actionFlag = false
        let spellAry = decomposeSpellNum(summon.Action[1])
        if (
          summon.NoBreath == 0 &&
          summon.Mp[spellAry[0]][spellAry[1]] >=
            GameData['SPELL_CONSUMPTION_MP'][spellAry[0]][spellAry[1]][
              spellAry[2]
            ]
        ) {
          let target = summon.Action[2]
          if (target >= 10) {
            target -= 10
            if (TempVariable['monsterNum'][target] > 0) {
              actionFlag = true
            }
          } else {
            actionFlag = true
          }
        }
        if (actionFlag) {
          GameState = 'battleTurnAction2'
        }
        battleAction()
      } else {
        battleAction()
      }
    } else if (turnAction >= 40) {
      TempVariable['actionCharType'] = 'pc'
      let pcNumInPt = turnAction % 10
      TempVariable['actionCharNumInGroup'] = [pcNumInPt, -1]
      let pcNum = pt.PartyMember[pcNumInPt]
      if (pcNum < 0) {
        battleAction()
        return
      }
      TempVariable['actionCharNum'] = pcNum
      let pc = PC[pcNum]
      let hideProb = 100
      let btEnd = checkBattleEnd()
      let action = pc.Action[0]
      if (
        (btEnd == 2 && !GameData['ACTION_IS_NOT_STOPED']) ||
        !pc.possibleToAction() ||
        action < 0
      ) {
        battleAction()
        return
      } else if (pc.Hide && btEnd != 2) {
        let monNum = PlayData['MonsterList'][0][0]
        let formula = GameData['HIDING_KEEP_PROB']
        formula = replaceMyAndTarget(formula, 'pc', 'monster')
        formula = replaceFormula(formula, [
          ['pc', pcNum],
          ['monster', monNum]
        ])
        hideProb = Math.floor(strCalculation(formula))
        if (hideProb < 0) {
          hideProb = 0
        } else if (hideProb > 100) {
          hideProb = 100
        }
      }
      if (hideProb < dice(1, 100)) {
        pc.Hide = false
        pc.battleActionReset()
        let str = getDefaultMessage('HIDING_FOUND')
        str = str.replace(/\[name\]/g, pc.Name[0])
        battleText('set', str)
        GameState = 'battleTurnActionReturn'
        battleText()
      } else if (action == 0 || action == 2 || action == 7) {
        if (action == 7 && pc.NoBreath != 0) {
          battleAction()
        } else {
          if (pc.Action[2] >= 10) {
            pc.Action[2] -= 10
          }
          let target = pc.Action[2]
          if (TempVariable['monsterNum'][target] < 1) {
            if (GameData['CHANGE_TARGET']) {
              if (!changeTarget(pcNum, action, target)) {
                battleAction()
                return
              }
            } else {
              battleAction()
              return
            }
          }
          GameState = 'battleTurnAction2'
          battleAction()
        }
      } else if (action == 1) {
        if (btEnd != 2) {
          GameState = 'battleTurnAction2'
          battleAction()
        } else {
          battleAction()
          return
        }
      } else if (action == 3) {
        let actionFlag = false
        if (pc.NoBreath != 0) {
          actionFlag = false
        } else if (pc.Breath == 3) {
          actionFlag = true
        } else {
          pc.Action[2] -= 10
          let target = pc.Action[2]
          if (TempVariable['monsterNum'][target] < 1) {
            if (GameData['CHANGE_TARGET']) {
              if (
                changeTarget(pcNum, action, target) ||
                GameData['ACTION_IS_NOT_STOPED']
              ) {
                actionFlag = true
              }
            } else if (GameData['ACTION_IS_NOT_STOPED']) {
              actionFlag = true
            }
          } else {
            actionFlag = true
          }
        }
        if (actionFlag) {
          if (pc.BreathNum > 0) {
            pc.BreathNum--
          }
          GameState = 'battleTurnAction2'
        }
        battleAction()
      } else if (action == 5 || action == 6) {
        let actionFlag = true
        if (action == 5 && pc.NoBreath != 0) {
          actionFlag = false
        } else if (action == 6) {
          let spellAry = decomposeSpellNum(pc.Action[1])
          if (
            !pc.spellMaster(spellAry[0], spellAry[1], spellAry[2]) ||
            pc.NoBreath != 0 ||
            pc.Mp[spellAry[0]][spellAry[1]] <
              GameData['SPELL_CONSUMPTION_MP'][spellAry[0]][spellAry[1]][
                spellAry[2]
              ]
          ) {
            actionFlag = false
          }
        }
        if (actionFlag) {
          actionFlag = false
          let target = pc.Action[2]
          if (target >= 10) {
            target -= 10
            if (TempVariable['monsterNum'][target] < 1) {
              if (GameData['CHANGE_TARGET']) {
                if (
                  changeTarget(pcNum, action, target) ||
                  GameData['ACTION_IS_NOT_STOPED']
                ) {
                  actionFlag = true
                }
              } else if (GameData['ACTION_IS_NOT_STOPED']) {
                actionFlag = true
              }
            } else {
              actionFlag = true
            }
          } else {
            actionFlag = true
          }
        }
        if (actionFlag) {
          GameState = 'battleTurnAction2'
        }
        battleAction()
      } else {
        battleAction()
      }
    } else {
      TempVariable['actionCharType'] = 'monster'
      let monNumInGroup1 = Math.floor(turnAction / 10),
        monNumInGroup2 = turnAction % 10
      TempVariable['actionCharNumInGroup'] = [monNumInGroup1, monNumInGroup2]
      let monNum = PlayData['MonsterList'][monNumInGroup1][monNumInGroup2]
      if (monNum < 0) {
        battleAction()
        return
      }
      TempVariable['actionCharNum'] = monNum
      let mon = MONSTER[monNum]
      let mData = MONSTER_DATA[mon.MonsterDataNum]
      let action = mon.Action[0]
      if (!mon.possibleToAction() || action < 0) {
        battleAction()
        return
      } else if (action == 0) {
        let twiceAttacks = false
        let target = mon.Action[1]
        if (target >= 60) {
          target = Math.floor((target - 60) / 10)
          if (TempVariable['summonNum'][target] < 1) {
            if (mData.TWICE_ATTACKS) {
              twiceAttacks = true
            }
          } else {
            GameState = 'battleTurnAction2'
          }
        } else {
          let targetPc = PC[pt.PartyMember[target]]
          if (targetPc.State > 3 || targetPc.Hide) {
            if (mData.TWICE_ATTACKS) {
              twiceAttacks = true
            }
          } else {
            GameState = 'battleTurnAction2'
          }
        }
        if (twiceAttacks) {
          target = mon.Action[2]
          if (target >= 60) {
            target = Math.floor((target - 60) / 10)
            if (TempVariable['summonNum'][target] > 0) {
              GameState = 'battleTurnAction2'
              TempVariable['turnCount'][2] = 0
            }
          } else {
            let targetPc = PC[pt.PartyMember[target]]
            if (targetPc.State < 4 && !targetPc.Hide) {
              GameState = 'battleTurnAction2'
              TempVariable['turnCount'][2] = 0
            }
          }
        }
        battleAction()
      } else if (action == 3 || action == 8 || action == 9) {
        if (mon.NoBreath != 0 && (action == 3 || action == 9)) {
          battleAction()
        } else if (action == 3) {
          if (mData.BREATH_RANGE == 0) {
            let target = mon.Action[2]
            if (target >= 60) {
              target = Math.floor((target - 60) / 10)
              if (TempVariable['summonNum'][target] > 0) {
                GameState = 'battleTurnAction2'
              }
            } else {
              let targetPc = PC[pt.PartyMember[target]]
              if (targetPc.State < 4) {
                GameState = 'battleTurnAction2'
              }
            }
          } else if (mData.BREATH_RANGE == 1) {
            let memberNum = pt.getMemberNum()
            let ck = false
            if (mon.Action[2] == 8) {
              if (memberNum > GameData['FRONT_RANK_NUM']) {
                memberNum = GameData['FRONT_RANK_NUM']
              }
              for (let i = 0; i < memberNum; i++) {
                if (PC[pt.PartyMember[i]].State < 4) {
                  ck = true
                  break
                }
              }
              if (TempVariable['summonNum'][0] > 0) {
                ck = true
              }
              if (ck) {
                GameState = 'battleTurnAction2'
              }
            } else {
              for (let i = GameData['FRONT_RANK_NUM']; i < memberNum; i++) {
                if (PC[pt.PartyMember[i]].State < 4) {
                  ck = true
                  break
                }
              }
              if (TempVariable['summonNum'][1] > 0) {
                ck = true
              }
              if (ck) {
                GameState = 'battleTurnAction2'
              }
            }
          } else {
            let memberNum = pt.getMemberNum()
            let ck = false
            for (let i = 0; i < memberNum; i++) {
              if (PC[pt.PartyMember[i]].State < 4) {
                ck = true
                break
              }
            }
            if (
              TempVariable['summonNum'][0] > 0 ||
              TempVariable['summonNum'][1] > 0
            ) {
              ck = true
            }
            if (ck) {
              GameState = 'battleTurnAction2'
            }
          }
          battleAction()
        } else {
          GameState = 'battleTurnAction2'
          battleAction()
        }
      } else if (action == 4) {
        GameState = 'battleTurnAction2'
        battleAction()
      } else if (action == 6) {
        let spellAry = decomposeSpellNum(mon.Action[1])
        if (
          mon.NoBreath == 0 &&
          mon.Mp[spellAry[0]][spellAry[1]] >=
            GameData['SPELL_CONSUMPTION_MP'][spellAry[0]][spellAry[1]][
              spellAry[2]
            ]
        ) {
          let target = mon.Action[2]
          if (target >= 60) {
            target -= 60
            if (target >= 10) {
              target = Math.floor((target - 10) / 10)
            }
            if (TempVariable['summonNum'][target] > 0) {
              GameState = 'battleTurnAction2'
            }
          } else if (target >= 10) {
            target -= 10
            if (target >= 10) {
              target = Math.floor((target - 10) / 10)
            }
            if (TempVariable['monsterNum'][target] > 0) {
              GameState = 'battleTurnAction2'
            }
          } else {
            GameState = 'battleTurnAction2'
          }
        }
        battleAction()
      } else {
        battleAction()
      }
    }
    return
  } else if (GameState == 'battleTurnAction2') {
    MP.clearTextSurface('all')
    let charType = TempVariable['actionCharType']
    let cmNumInGroup = TempVariable['actionCharNumInGroup']
    let cmNum = TempVariable['actionCharNum']
    let cmNum2 = cmNum
    if (charType == 'summon') {
      cmNum2 += 50
    }
    let cm,
      cmData = null
    if (charType == 'pc') {
      cm = PC[cmNum]
    } else if (charType == 'monster') {
      cm = MONSTER[cmNum]
      cmData = MONSTER_DATA[cm.MonsterDataNum]
    } else {
      cm = SUMMON[cmNum]
      cmData = MONSTER_DATA[cm.MonsterDataNum]
    }
    let turnCount = TempVariable['turnCount']
    let action
    if (turnCount[0] == -1) {
      action = cm.Action[0]
      TempVariable['battleAction'] = action
    } else {
      action = TempVariable['battleAction']
    }
    let haman = false,
      spellSelNum = 0
    if (key == 'enter') {
      spellSelNum = value
    }
    GameState = 'battleTurnAction2Return'
    if (action == 0 || action == 2) {
      if (turnCount[0] == -1) {
        if (charType == 'pc') {
          turnCount[0] = cm.Action[2]
        } else if (turnCount[2] == -1) {
          turnCount[0] = cm.Action[1]
        } else {
          turnCount[0] = cm.Action[2]
        }
        let text = '',
          weponNum = -1
        if (action == 0) {
          let attackKind = ''
          if (charType == 'pc') {
            if (turnCount[2] == -1) {
              attackKind = cm.AttackKind
              weponNum = cm.weaponCursedCheck()
            } else {
              attackKind = cm.AttackKindSub
              weponNum = cm.kindEquipedItem(7)
            }
            if (weponNum > -1) {
              let wepon = ITEM[cm.Item[weponNum]]
              if (wepon.BATTLE_FIGHT.length > 0) {
                text =
                  wepon.BATTLE_FIGHT[dice(1, wepon.BATTLE_FIGHT.length) - 1]
                text = text.replace(
                  /\[(item|this)\]/g,
                  wepon.NAME[cm.ItemDecided[weponNum]]
                )
              }
            }
          } else {
            attackKind = cmData.ATTACK_KIND
            if (cmData.BATTLE_FIGHT.length > 0) {
              text =
                cmData.BATTLE_FIGHT[dice(1, cmData.BATTLE_FIGHT.length) - 1]
            }
          }
          if (text.match(/^(| )$/)) {
            weponNum = -1
            let stack = []
            for (let i = 0; i < 6; i++) {
              if (attackKind.indexOf(String(i)) > -1) {
                stack.push(i)
              }
            }
            if (stack.length < 1) {
              stack.push(0)
            }
            let num = stack[dice(1, stack.length) - 1]
            let randNum = dice(1, 2)
            if (num == 1) {
              text = getDefaultMessage('FIGHT_STAB' + String(randNum))
            } else if (num == 2) {
              text = getDefaultMessage('FIGHT_SLASH' + String(randNum))
            } else if (num == 3) {
              text = getDefaultMessage('FIGHT_BASH' + String(randNum))
            } else if (num == 4) {
              randNum = dice(1, 3)
              text = getDefaultMessage('FIGHT_FIRE' + String(randNum))
            } else if (num == 5) {
              randNum = dice(1, 4)
              text = getDefaultMessage('FIGHT_GNAW' + String(randNum))
            } else if (num == 6) {
              text = getDefaultMessage('FIGHT_CLAW' + String(randNum))
            } else {
              randNum = dice(1, 3)
              text = getDefaultMessage('FIGHT_ATTACK' + String(randNum))
            }
          }
        } else {
          let randNum = dice(1, 2)
          text = getDefaultMessage('FIGHT_AMBUSH' + String(randNum))
        }
        let targetNum = turnCount[0]
        cm.AttackCount = 0
        if (charType == 'pc') {
          text = text.replace(/\[name\]/g, cm.Name[0])
          text = text.replace(/\[target\]/g, getMonsterName(targetNum))
          turnCount[1] = cm.Action[3]
          if (turnCount[1] > -1) {
            if (
              MONSTER[PlayData['MonsterList'][turnCount[0]][turnCount[1]]].Hp <
              1
            ) {
              turnCount[1] = -1
            }
          }
          if (turnCount[1] < 0) {
            turnCount[1] = nextTargetMonster(turnCount[0], -1)
          }
        } else if (charType == 'monster') {
          text = text.replace(/\[name\]/g, getMonsterName(cmNumInGroup[0]))
          if (targetNum >= 60) {
            if (targetNum >= 70) {
              targetNum = Math.floor((targetNum - 70) / 10)
            } else {
              targetNum -= 60
            }
            text = text.replace(
              /\[target\]/g,
              SUMMON[PlayData['SummonList'][targetNum][0]].Name[1]
            )
            turnCount[1] = nextTargetSummon(targetNum, -1)
          } else {
            text = text.replace(
              /\[target\]/g,
              PC[pt.PartyMember[targetNum]].Name[0]
            )
          }
        } else {
          if (targetNum >= 20) {
            targetNum = Math.floor((targetNum - 20) / 10)
          } else if (targetNum >= 10) {
            targetNum -= 10
          }
          text = text.replace(/\[name\]/g, cm.Name[1])
          text = text.replace(/\[target\]/g, getMonsterName(targetNum))
          turnCount[1] = nextTargetMonster(targetNum, -1)
        }
        battleText('set', text)
        sePlay('attack')
      } else {
        let targetNum, targetNumInGroup, targetNum2, target, mData, targetType
        if (charType == 'pc' || charType == 'summon') {
          let num = turnCount[0]
          if (num >= 20) {
            num = Math.floor((num - 20) / 10)
          } else if (num >= 10) {
            num -= 10
          }
          targetNumInGroup = [num, turnCount[1]]
          targetNum = PlayData['MonsterList'][num][turnCount[1]]
          targetNum2 = targetNum
          target = MONSTER[targetNum]
          mData = MONSTER_DATA[target.MonsterDataNum]
          targetType = 'monster'
        } else {
          let num = turnCount[0]
          if (num >= 60) {
            if (num >= 70) {
              num = Math.floor((num - 70) / 10)
            } else {
              num -= 60
            }
            targetNumInGroup = [num, turnCount[1]]
            targetNum = PlayData['SummonList'][num][turnCount[1]]
            targetNum2 = targetNum + 50
            target = SUMMON[targetNum]
            mData = MONSTER_DATA[target.MonsterDataNum]
            targetType = 'summon'
          } else {
            targetNumInGroup = [turnCount[0], -1]
            targetNum = pt.PartyMember[turnCount[0]]
            targetNum2 = targetNum
            target = PC[targetNum]
            mData = null
            targetType = 'pc'
          }
        }
        let formula = GameData['HIT_DECISION']
        formula = replaceMyAndTarget(formula, charType, targetType)
        if (action == 2) {
          formula = replaceAmbush(formula)
        }
        formula = replaceFormulaMyAndTarget(
          formula,
          charType,
          cmNum2,
          targetType,
          targetNum2
        )
        let prob = Math.floor(strCalculation(formula))
        if (prob < 0) {
          prob = 0
        } else if (prob > 100) {
          prob = 100
        }
        printDebugMessage(
          getNameBattle(cm, charType, cmNumInGroup, true) +
            ' attack rate: ' +
            String(prob) +
            '%'
        )
        let at = cm.At
        if (charType == 'pc' && turnCount[2] == 0 && cm.SubweaponHalf) {
          at = Math.ceil(at / 2)
        }
        let str
        if (charType == 'pc') {
          if (turnCount[2] == -1) {
            str = cm.Dmg
          } else {
            str = cm.DmgSub
          }
          let strAry = str.split(',')
          formula = strAry[0]
          formula = replaceMyAndTarget(formula, 'pc', 'monster')
          if (action == 2) {
            formula = replaceAmbush(formula)
          }
          formula = replaceFormula(
            formula,
            [
              ['pc', cmNum],
              ['monster', targetNum2]
            ],
            true
          )
          let num = Math.floor(strCalculation(formula))
          if (num < 0) {
            num = 0
          }
          str = String(num) + 'D'
          formula = strAry[1]
          formula = replaceMyAndTarget(formula, 'pc', 'monster')
          if (action == 2) {
            formula = replaceAmbush(formula)
          }
          formula = replaceFormula(
            formula,
            [
              ['pc', cmNum],
              ['monster', targetNum2]
            ],
            true
          )
          num = Math.floor(strCalculation(formula))
          if (num < 0) {
            num = 0
          }
          str += String(num)
          formula = strAry[2]
          formula = replaceMyAndTarget(formula, 'pc', 'monster')
          if (action == 2) {
            formula = replaceAmbush(formula)
          }
          formula = replaceFormula(
            formula,
            [
              ['pc', cmNum],
              ['monster', targetNum2]
            ],
            true
          )
          num = Math.floor(strCalculation(formula))
          if (num > 0) {
            str += '+' + String(num)
          } else if (num < 0) {
            str += String(num)
          }
        } else {
          str = cmData.DMG
          str = replaceMyAndTarget(str, charType, targetType)
          str = replaceFormulaMyAndTarget(
            str,
            charType,
            cmNum2,
            targetType,
            targetNum2
          )
        }
        let dmgFix = GameData['CORRECTION_DMG']
        dmgFix = replaceMyAndTarget(dmgFix, charType, targetType)
        if (action == 2) {
          dmgFix = replaceAmbush(dmgFix)
        }
        dmgFix = replaceFormulaMyAndTarget(
          dmgFix,
          charType,
          cmNum2,
          targetType,
          targetNum2
        )
        let dmg = 0,
          hitCount = 0
        for (let i = 0; i < at; i++) {
          if (prob >= dice(1, 100)) {
            hitCount++
            let num = Math.floor(strCalculation(str)) + cm.DmgPlus
            let dmgFixStr = dmgFix.replace(/damage/g, String(num))
            num = Math.floor(strCalculation(dmgFixStr))
            if (num < 0) {
              num = 0
            }
            dmg += num
          }
        }
        let spProb = {}
        ;(spProb['poison'] = 0),
          (spProb['asleep'] = 0),
          (spProb['paralize'] = 0)
        ;(spProb['stone'] = 0),
          (spProb['knockOut'] = 0),
          (spProb['critical'] = 0)
        if (cmData != null) {
          spProb['drain'] = 0
        }
        let invincible = false
        if (mData != null) {
          if (mData.INVINCIBILITY) {
            invincible = true
          }
        }
        if (!invincible) {
          for (let key in spProb) {
            let keyStr = 'SPECIAL_ATTACK_PROB_'
            if (key == 'poison') {
              keyStr += 'POISON'
            } else if (key == 'asleep') {
              keyStr += 'ASLEEP'
            } else if (key == 'paralize') {
              keyStr += 'PARALYSIS'
            } else if (key == 'stone') {
              keyStr += 'STONE'
            } else if (key == 'knockOut') {
              keyStr += 'KO'
            } else if (key == 'critical') {
              keyStr += 'CRIT'
            } else if (key == 'drain') {
              if (cmData.HP_DRAIN) {
                keyStr += 'HP_DRAIN'
              } else {
                keyStr += 'DRAIN'
              }
            }
            formula = GameData[keyStr]
            formula = replaceMyAndTarget(formula, charType, targetType)
            if (action == 2) {
              formula = replaceAmbush(formula)
            }
            formula = replaceFormulaMyAndTarget(
              formula,
              charType,
              cmNum2,
              targetType,
              targetNum2
            )
            num = Math.floor(strCalculation(formula))
            if (num < 0) {
              num = 0
            } else if (num > 100) {
              num = 100
            }
            spProb[key] = num
          }
        }
        if (hitCount < 1) {
          str = getDefaultMessage('FIGHT_MISS')
          str = str.replace(
            /\[name\]/g,
            getNameBattle(cm, charType, cmNumInGroup)
          )
          str = str.replace(
            /\[target\]/g,
            getNameBattle(target, targetType, targetNumInGroup)
          )
          battleText('push', str)
        } else {
          let stack = []
          let curse = false
          if (cm.checkCursed() > -1) {
            curse = true
          }
          if ((!curse || !GameData['CURSED_NOT_CRITICAL']) && !invincible) {
            if (cm.AttackPoison > 0) {
              if (!target.Resist[2]) {
                if (target.WeakPoint[2] && spProb['poison'] > 0) {
                  spProb['poison'] = 100
                }
                printDebugMessage(
                  getNameBattle(cm, charType, cmNumInGroup, true) +
                    ' special attack (Poison) rate: ' +
                    String(spProb['poison']) +
                    '%'
                )
                if (spProb['poison'] >= dice(1, 100)) {
                  stack.push(0)
                }
              }
            }
            if (cm.AttackAdd[0]) {
              if (!target.Resist[1] && target.State < 2 && target.Asleep >= 0) {
                if (target.WeakPoint[1] && spProb['asleep'] > 0) {
                  spProb['asleep'] = 100
                }
                printDebugMessage(
                  getNameBattle(cm, charType, cmNumInGroup, true) +
                    ' special attack (Asleep) rate: ' +
                    String(spProb['asleep']) +
                    '%'
                )
                if (spProb['asleep'] >= dice(1, 100)) {
                  stack.push(1)
                }
              }
            }
            if (cm.AttackAdd[3]) {
              if (!target.Resist[6] && target.State < 2) {
                if (target.WeakPoint[6] && spProb['knockOut'] > 0) {
                  spProb['knockOut'] = 100
                }
                printDebugMessage(
                  getNameBattle(cm, charType, cmNumInGroup, true) +
                    ' special attack (K.O.) rate: ' +
                    String(spProb['knockOut']) +
                    '%'
                )
                if (spProb['knockOut'] >= dice(1, 100)) {
                  stack.push(5)
                }
              }
            }
            if (cm.AttackAdd[1]) {
              if (!target.Resist[3] && target.State < 2) {
                if (target.WeakPoint[3] && spProb['paralize'] > 0) {
                  spProb['paralize'] = 100
                }
                printDebugMessage(
                  getNameBattle(cm, charType, cmNumInGroup, true) +
                    ' special attack (Paralysis) rate: ' +
                    String(spProb['paralize']) +
                    '%'
                )
                if (spProb['paralize'] >= dice(1, 100)) {
                  stack.push(2)
                }
              }
            }
            if (cm.AttackAdd[2]) {
              if (!target.Resist[4] && target.State < 3) {
                if (target.WeakPoint[4] && spProb['stone'] > 0) {
                  spProb['stone'] = 100
                }
                printDebugMessage(
                  getNameBattle(cm, charType, cmNumInGroup, true) +
                    ' special attack (Stone) rate: ' +
                    String(spProb['stone']) +
                    '%'
                )
                if (spProb['stone'] >= dice(1, 100)) {
                  stack.push(3)
                }
              }
            }
            if (cmData != null) {
              if (cmData.DRAIN > 0) {
                if (!target.Resist[5]) {
                  let drainStr = 'Drain'
                  if (cmData.HP_DRAIN) {
                    drainStr = 'HpDrain'
                  }
                  printDebugMessage(
                    getNameBattle(cm, charType, cmNumInGroup, true) +
                      ' special attack (' +
                      drainStr +
                      ') rate: ' +
                      String(spProb['drain']) +
                      '%'
                  )
                  if (spProb['drain'] >= dice(1, 100)) {
                    stack.push(4)
                  }
                }
              }
            }
            if (cm.AttackAdd[4]) {
              if (!target.Resist[7]) {
                if (target.WeakPoint[7] && spProb['critical'] > 0) {
                  spProb['critical'] = 100
                }
                printDebugMessage(
                  getNameBattle(cm, charType, cmNumInGroup, true) +
                    ' special attack (Critical) rate: ' +
                    String(spProb['critical']) +
                    '%'
                )
                if (spProb['critical'] >= dice(1, 100)) {
                  stack.push(6)
                }
              }
            }
          }
          let hitDmg = target.Hp
          if (stack.indexOf(6) < 0) {
            if (!target.possibleToAction() || action == 2) {
              dmg = Math.floor(calTimes(dmg, GameData['NON_MOVE_DMG']))
            }
            if (mData != null) {
              if (cm.Attack[mData.TYPE]) {
                formula = GameData['BATTLE_ATTACK_EFFECT']
                if (action == 2) {
                  formula = replaceAmbush(formula)
                }
                formula = replaceFormulaMyAndTarget(
                  formula,
                  charType,
                  cmNum2,
                  targetType,
                  targetNum2
                )
                num = Math.floor(strCalculation(formula))
                if (num < 0) {
                  num = 0
                } else if (num > 1000) {
                  num = 1000
                }
                num = calDiv(num, 100)
                dmg = Math.floor(calTimes(dmg, num))
              }
            }
            if (cmData != null) {
              if (target.Defense[cmData.TYPE]) {
                formula = GameData['BATTLE_DEFENSE_EFFECT']
                formula = replaceFormulaMyAndTarget(
                  formula,
                  charType,
                  cmNum2,
                  targetType,
                  targetNum2
                )
                num = Math.floor(strCalculation(formula))
                if (num < 0) {
                  num = 0
                } else if (num > 1000) {
                  num = 1000
                }
                num = calDiv(num, 100)
                dmg = Math.ceil(calTimes(dmg, num))
              }
            }
            if (dmg < 0) {
              dmg = 0
            }
            if (invincible) {
              dmg = 0
            }
            if (hitCount == 1) {
              str = getDefaultMessage('FIGHT_HIT_1')
            } else if (hitCount == 2) {
              str = getDefaultMessage('FIGHT_HIT_2')
            } else {
              str = getDefaultMessage('FIGHT_HIT')
            }
            str = str.replace(
              /\[name\]/g,
              getNameBattle(cm, charType, cmNumInGroup)
            )
            str = str.replace(
              /\[target\]/g,
              getNameBattle(target, targetType, targetNumInGroup)
            )
            str = str.replace(/\[hit\]/g, String(hitCount))
            str = str.replace(/\[damage\]/g, String(dmg))
            battleText('push', str)
            sePlay('hit')
            if (dmg < hitDmg) {
              hitDmg = dmg
            }
            target.controlHp(dmg * -1, true)
            printDebugMessage(
              getNameBattle(target, targetType, targetNumInGroup, true) +
                ' HP: ' +
                MP.numberFormat(target.Hp) +
                ' / ' +
                MP.numberFormat(target.HpMax)
            )
            target.cureAsleepByDamage(dmg)
          }
          let spCount = 0
          let text = ''
          if (stack.indexOf(0) > -1) {
            if (target.Hp > 0 && target.State < 4) {
              let num = target.Poison
              num += cm.AttackPoison
              if (num < 0) {
                num = 0
              } else if (num > 99999) {
                num = 99999
              }
              target.Poison = num
              target.check()
            }
            str = getDefaultMessage('BE_POISONED')
            str = str.replace(
              /\[target\]/g,
              getNameBattle(target, targetType, targetNumInGroup)
            )
            text += str
            spCount++
          }
          if (stack.indexOf(1) > -1) {
            if (target.Hp > 0 && target.State < 2) {
              formula = GameData['ASLEEP']
              formula = replaceMyAndTarget(formula, charType, targetType)
              if (action == 2) {
                formula = replaceAmbush(formula)
              }
              formula = replaceFormulaMyAndTarget(
                formula,
                charType,
                cmNum2,
                targetType,
                targetNum2
              )
              let num = Math.floor(strCalculation(formula))
              if (num < 0) {
                num *= -1
              }
              num += target.Asleep
              if (num > 99999) {
                num = 99999
              }
              target.Asleep = num
            }
            target.Action[0] = -1
            if (spCount == 0) {
              str = getDefaultMessage('BE_SLEPT')
              str = str.replace(
                /\[target\]/g,
                getNameBattle(target, targetType, targetNumInGroup)
              )
            } else {
              str = getDefaultMessage('BE_SLEPT_IT')
            }
            if (spCount == 2 || spCount == 4) {
              text += '\n'
            }
            text += str
            spCount++
          }
          if (stack.indexOf(5) > -1) {
            if (target.Hp > 0 && target.State < 2) {
              target.Asleep = -1
            }
            target.Action[0] = -1
            if (spCount == 0) {
              str = getDefaultMessage('FAINTED')
              str = str.replace(
                /\[target\]/g,
                getNameBattle(target, targetType, targetNumInGroup)
              )
            } else {
              str = getDefaultMessage('FAINTED_IT')
            }
            if (spCount == 2 || spCount == 4) {
              text += '\n'
            }
            text += str
            spCount++
          }
          if (stack.indexOf(2) > -1) {
            if (target.Hp > 0 && target.State < 2) {
              target.State = 2
              target.Asleep = 0
            }
            target.Action[0] = -1
            if (spCount == 0) {
              str = getDefaultMessage('BE_PARALYZED')
              str = str.replace(
                /\[target\]/g,
                getNameBattle(target, targetType, targetNumInGroup)
              )
            } else {
              str = getDefaultMessage('BE_PARALYZED_IT')
            }
            if (spCount == 2 || spCount == 4) {
              text += '\n'
            }
            text += str
            spCount++
          }
          if (stack.indexOf(3) > -1) {
            if (target.Hp > 0 && target.State < 3) {
              target.State = 3
              target.Asleep = 0
            }
            target.Action[0] = -1
            if (spCount == 0) {
              str = getDefaultMessage('BE_STONED')
              str = str.replace(
                /\[target\]/g,
                getNameBattle(target, targetType, targetNumInGroup)
              )
            } else {
              str = getDefaultMessage('BE_STONED_IT')
            }
            if (spCount == 2 || spCount == 4) {
              text += '\n'
            }
            text += str
            spCount++
          }
          if (stack.indexOf(4) > -1) {
            if (cmData.HP_DRAIN) {
              let hpDrain = Math.ceil(
                calTimes(hitDmg, calDiv(cmData.DRAIN, 10))
              )
              cm.controlHp(hpDrain, true)
              printDebugMessage(
                getNameBattle(cm, charType, cmNumInGroup, true) +
                  ' HpDrain: ' +
                  MP.numberFormat(hpDrain) +
                  ' (HP: ' +
                  MP.numberFormat(cm.Hp) +
                  ' / ' +
                  MP.numberFormat(cm.HpMax) +
                  ')'
              )
              if (spCount == 0) {
                str = getDefaultMessage('BE_HP_DRAINED')
                str = str.replace(
                  /\[target\]/g,
                  getNameBattle(target, targetType, targetNumInGroup)
                )
              } else {
                str = getDefaultMessage('BE_HP_DRAINED_IT')
              }
            } else {
              let preLv = target.Level
              let num = preLv - cmData.DRAIN
              if (num < 1) {
                target.controlHp(0)
                target.State = 6
                target.Level = 0
                target.HpMax = 0
                target.Exp = 0
              } else {
                target.Level = num
                target.drainCheck(preLv)
              }
              target.check()
              if (spCount == 0) {
                if (cmData.DRAIN == 1) {
                  str = getDefaultMessage('BE_DRAINED_1')
                } else {
                  str = getDefaultMessage('BE_DRAINED')
                }
                str = str.replace(
                  /\[target\]/g,
                  getNameBattle(target, targetType, targetNumInGroup)
                )
              } else {
                if (cmData.DRAIN == 1) {
                  str = getDefaultMessage('BE_DRAINED_IT_1')
                } else {
                  str = getDefaultMessage('BE_DRAINED_IT')
                }
              }
              str = str.replace(/\[value\]/g, String(cmData.DRAIN))
            }
            if (spCount == 2 || spCount == 4) {
              text += '\n'
            }
            text += str
            spCount++
          }
          if (stack.indexOf(6) > -1 || target.Hp < 1) {
            if (stack.indexOf(6) > -1) {
              sePlay('critical')
              target.controlHp(0)
              str = getDefaultMessage('DECAPITATED')
            } else {
              str = getDefaultMessage('KILLED')
            }
            if (charType == 'pc') {
              cm.Marks++
            }
            if (targetType == 'summon') {
              TempVariable['summonNum'][targetNumInGroup[0]]--
              if (TempVariable['summonNum'][targetNumInGroup[0]] < 1) {
                hateCheck(210 + targetNumInGroup[0])
              }
            } else if (targetType == 'monster') {
              TempVariable['monsterNum'][targetNumInGroup[0]]--
              if (TempVariable['monsterNum'][targetNumInGroup[0]] < 1) {
                hateCheck(200 + targetNumInGroup[0])
              }
              TempVariable['getExp'] += target.Exp
              TempVariable['monsterKill'] = true
              registerInMonsterCatalog(targetNumInGroup[0])
            }
            str = str.replace(
              /\[name\]/g,
              getNameBattle(cm, charType, cmNumInGroup)
            )
            str = str.replace(
              /\[target\]/g,
              getNameBattle(target, targetType, targetNumInGroup)
            )
            if (spCount > 0) {
              text += '\n'
            }
            text += str
          }
          if (text != '') {
            battleText('push', text)
          }
        }
        cm.AttackCount++
        if (charType == 'pc') {
          turnCount[1] = nextTargetMonster(turnCount[0], turnCount[1])
          let groupAtNum
          if (turnCount[2] == -1) {
            groupAtNum = cm.GroupAtNum
          } else {
            groupAtNum = cm.GroupAtNumSub
          }
          if (turnCount[1] < 0 || cm.AttackCount >= groupAtNum) {
            let nextOne = false
            if (turnCount[2] == 0) {
              nextOne = true
            } else if (cm.DmgSub != '') {
              let subNext = false
              if (TempVariable['monsterNum'][turnCount[0]] > 0) {
                subNext = true
              } else if (GameData['CHANGE_TARGET']) {
                if (changeTarget(cmNum, cm.Action[0], turnCount[0])) {
                  subNext = true
                }
              }
              if (subNext) {
                turnCount[0] = -1
                turnCount[2] = 0
              } else {
                nextOne = true
              }
            } else {
              nextOne = true
            }
            if (nextOne) {
              GameState = 'battleTurnActionReturn'
            }
          }
        } else {
          let nextOne = false
          if (turnCount[2] == 0) {
            nextOne = true
          } else if (cmData.TWICE_ATTACKS) {
            let num = cm.Action[2]
            if (num >= 60) {
              num = Math.floor((num - 60) / 10)
              if (TempVariable['summonNum'][num] < 1) {
                nextOne = true
              }
            } else if (num >= 10) {
              num -= 10
              if (TempVariable['monsterNum'][num] < 1) {
                nextOne = true
              }
            } else {
              let targetPc = PC[pt.PartyMember[num]]
              if (targetPc.State > 3 || targetPc.Hide) {
                nextOne = true
              }
            }
          } else {
            nextOne = true
          }
          if (nextOne) {
            GameState = 'battleTurnActionReturn'
          } else {
            turnCount[0] = -1
            turnCount[2] = 0
          }
        }
      }
    } else if (action == 1 && charType == 'pc') {
      let formula = replaceMyAndTarget(
        GameData['HIDE_PROB'],
        charType,
        'monster'
      )
      formula = replaceFormulaMyAndTarget(
        formula,
        charType,
        cmNum2,
        'monster',
        PlayData['MonsterList'][0][0]
      )
      let prob = Math.floor(strCalculation(formula))
      if (prob < 0) {
        prob = 0
      } else if (prob > 100) {
        prob = 100
      }
      printDebugMessage(
        getNameBattle(cm, charType, cmNumInGroup, true) +
          ' hide rate: ' +
          String(prob) +
          '%'
      )
      let text
      if (prob >= dice(1, 100)) {
        text = getDefaultMessage('HIDING')
        cm.Hide = true
      } else {
        text = getDefaultMessage('HIDING_NOT')
      }
      text = text.replace(/\[name\]/g, cm.Name[0])
      battleText('set', text)
      GameState = 'battleTurnActionReturn'
    } else if (action == 3) {
      let breathRange
      if (charType == 'pc') {
        breathRange = cm.Breath - 1
      } else {
        breathRange = cmData.BREATH_RANGE
      }
      if (turnCount[0] == -1) {
        let text = ''
        if (charType != 'pc') {
          if (cmData.BATTLE_BREATH.length > 0) {
            text =
              cmData.BATTLE_BREATH[dice(1, cmData.BATTLE_BREATH.length) - 1]
          }
        }
        if (charType == 'pc' || charType == 'summon') {
          turnCount[2] = 1
          if (breathRange == 2) {
            text = getDefaultMessage('BREATH_ON_MONSTER')
            turnCount[0] = nextTargetMonsterGroup(-1)
            turnCount[1] = nextTargetMonster(turnCount[0], -1)
            if (turnCount[1] < 0) {
              if (turnCount[0] < 0) {
                turnCount[0] = 0
              }
              turnCount[2] = -1
            }
          } else {
            text = getDefaultMessage('BREATH_AT_TARGET')
            turnCount[0] = cm.Action[2]
            turnCount[1] = nextTargetMonster(turnCount[0], -1)
            if (turnCount[1] < 0) {
              if (turnCount[0] < 0) {
                turnCount[0] = 0
              }
              turnCount[2] = -1
            }
            text = text.replace(
              /\[target\]/g,
              getNameBattle(
                MONSTER[PlayData['MonsterList'][turnCount[0]][0]],
                'monster',
                [turnCount[0], 0]
              )
            )
          }
        } else if (charType == 'monster') {
          if (text.match(/^(| )$/)) {
            if (breathRange == 0) {
              text = getDefaultMessage('BREATH_AT_TARGET')
            } else {
              text = getDefaultMessage('BREATH_ON_PARTY')
            }
          }
          if (breathRange == 0) {
            turnCount[0] = cm.Action[2]
            let targetNumInGroup, targetNum, target, targetType
            if (turnCount[0] >= 60) {
              turnCount[0] -= 60
              turnCount[1] = nextTargetSummon(turnCount[0], -1)
              if (turnCount[1] < 0) {
                turnCount[2] = -1
              } else {
                turnCount[2] = 2
              }
              targetNumInGroup = [turnCount[0], 0]
              targetNum = PlayData['SummonList'][turnCount[0]][turnCount[1]]
              target = SUMMON[targetNum]
              targetType = 'summon'
            } else {
              turnCount[2] = 0
              targetNumInGroup = [turnCount[0], 0]
              targetNum = pt.PartyMember[turnCount[0]]
              target = PC[targetNum]
              targetType = 'pc'
            }
            text = text.replace(
              /\[target\]/g,
              getNameBattle(target, targetType, targetNumInGroup)
            )
          } else if (breathRange == 1) {
            if (cm.Action[2] == 8) {
              turnCount[0] = nextTargetPc('front', -1)
              turnCount[2] = 0
              if (turnCount[0] < 0) {
                turnCount[0] = 0
                turnCount[1] = nextTargetSummon(turnCount[0], -1)
                turnCount[2] = 2
                if (turnCount[1] < 0) {
                  turnCount[2] = -1
                }
              }
            } else {
              turnCount[0] = nextTargetPc('back', -1)
              turnCount[2] = 0
              if (turnCount[0] < 0) {
                turnCount[0] = 1
                turnCount[1] = nextTargetSummon(turnCount[0], -1)
                turnCount[2] = 2
                if (turnCount[1] < 0) {
                  turnCount[2] = -1
                }
              }
            }
          } else {
            turnCount[0] = nextTargetPc('all', -1)
            turnCount[2] = 0
          }
        }
        text = text.replace(
          /\[name\]/g,
          getNameBattle(cm, charType, cmNumInGroup)
        )
        battleText('set', text)
      } else if (turnCount[2] == -1) {
        let text = getDefaultMessage('CAST_NO_TARGET')
        battleText('push', text)
        GameState = 'battleTurnActionReturn'
      } else {
        let targetNum, targetNumInGroup, targetNum2, target, mData, targetType
        if (turnCount[2] == 0) {
          targetNumInGroup = [turnCount[0], -1]
          targetNum = pt.PartyMember[turnCount[0]]
          targetNum2 = targetNum
          target = PC[targetNum]
          mData = null
          targetType = 'pc'
        } else if (turnCount[2] == 1) {
          targetNumInGroup = [turnCount[0], turnCount[1]]
          targetNum = PlayData['MonsterList'][turnCount[0]][turnCount[1]]
          targetNum2 = targetNum
          target = MONSTER[targetNum]
          mData = MONSTER_DATA[target.MonsterDataNum]
          targetType = 'monster'
        } else {
          targetNumInGroup = [turnCount[0], turnCount[1]]
          targetNum = PlayData['SummonList'][turnCount[0]][turnCount[1]]
          targetNum2 = targetNum + 50
          target = SUMMON[targetNum]
          mData = MONSTER_DATA[target.MonsterDataNum]
          targetType = 'summon'
        }
        let text
        if (target.BtOnlySpellEffectPlus[0] > 0) {
          target.BtOnlySpellEffectPlus[0]--
          text = getDefaultMessage('BREATH_CANCEL')
          text = text.replace(
            /\[target\]/g,
            getNameBattle(target, targetType, targetNumInGroup)
          )
        } else {
          let formula = replaceMyAndTarget(
            GameData['BREATH_DMG'],
            charType,
            targetType
          )
          formula = replaceFormulaMyAndTarget(
            formula,
            charType,
            cmNum2,
            targetType,
            targetNum2
          )
          let dmg = Math.floor(strCalculation(formula))
          let breathType
          if (charType == 'pc') {
            breathType = GameData['RACE_BREATH_ATTRIBUTE'][cm.Race]
          } else {
            breathType = cmData.BREATH
          }
          if (target.Resist[breathType] && !target.WeakPoint[breathType]) {
            dmg = Math.ceil(calTimes(dmg, GameData['SPELL_RESIST']))
            printDebugMessage(
              getNameBattle(target, targetType, targetNumInGroup, true) +
                ' resist by attribute'
            )
          } else if (
            !target.Resist[breathType] &&
            target.WeakPoint[breathType]
          ) {
            dmg = Math.ceil(calTimes(dmg, GameData['SPELL_WEAK']))
            printDebugMessage(
              getNameBattle(target, targetType, targetNumInGroup, true) +
                ' weak point by attribute'
            )
          }
          formula = replaceMyAndTarget(
            GameData['BREATH_RESIST_PROB'],
            charType,
            targetType
          )
          formula = replaceFormulaMyAndTarget(
            formula,
            charType,
            cmNum2,
            targetType,
            targetNum2
          )
          let plus = target.BrPlus
          formula = formula.replace(/spellPlus/g, String(plus))
          if (target.Action[0] == 4) {
            printDebugMessage(
              getNameBattle(target, targetType, targetNumInGroup, true) +
                ' parry'
            )
            let formula2 = replaceMyAndTarget(
              GameData['PARRY_RESIST'],
              targetType
            )
            formula2 = replaceFormulaMyAndTarget(
              formula2,
              targetType,
              targetNum2
            )
            let parryPlus = Math.floor(strCalculation(formula2))
            formula = formula.replace(/parryPlus/g, String(parryPlus))
            plus += parryPlus
          }
          formula = formula.replace(/plus/g, String(plus))
          let prob = Math.floor(strCalculation(formula))
          printDebugMessage(
            getNameBattle(target, targetType, targetNumInGroup, true) +
              ' breath resist rate: ' +
              prob +
              '%'
          )
          if (prob >= dice(1, 100)) {
            dmg = Math.ceil(dmg / 2)
            printDebugMessage(
              getNameBattle(target, targetType, targetNumInGroup, true) +
                ' resist success'
            )
          }
          if (targetType != 'pc') {
            if (mData.INVINCIBILITY) {
              dmg = 0
            }
          }
          text = getDefaultMessage('TAKE_DAMAGE')
          text = text.replace(
            /\[target\]/g,
            getNameBattle(target, targetType, targetNumInGroup)
          )
          text = text.replace(/\[damage\]/g, String(dmg))
          sePlay('hit')
          target.controlHp(dmg * -1, true)
          printDebugMessage(
            getNameBattle(target, targetType, targetNumInGroup, true) +
              ' HP: ' +
              MP.numberFormat(target.Hp) +
              ' / ' +
              MP.numberFormat(target.HpMax)
          )
          target.cureAsleepByDamage(dmg)
          if (target.Hp < 1) {
            let str = getDefaultMessage('KILLED')
            str = str.replace(
              /\[name\]/g,
              getNameBattle(cm, charType, cmNumInGroup)
            )
            str = str.replace(
              /\[target\]/g,
              getNameBattle(target, targetType, targetNumInGroup)
            )
            text += '\n' + str
            if (charType == 'pc') {
              cm.Marks++
            }
            if (targetType == 'summon') {
              TempVariable['summonNum'][targetNumInGroup[0]]--
              if (TempVariable['summonNum'][targetNumInGroup[0]] < 1) {
                hateCheck(210 + targetNumInGroup[0])
              }
            } else if (targetType == 'monster') {
              TempVariable['monsterNum'][targetNumInGroup[0]]--
              if (TempVariable['monsterNum'][targetNumInGroup[0]] < 1) {
                hateCheck(200 + targetNumInGroup[0])
              }
              TempVariable['getExp'] += target.Exp
              TempVariable['monsterKill'] = true
              registerInMonsterCatalog(targetNumInGroup[0])
            }
          }
        }
        battleText('push', text)
        let nextOne = false
        if (breathRange == 0) {
          nextOne = true
        } else if (breathRange == 1) {
          if (charType == 'pc' || charType == 'summon') {
            turnCount[1] = nextTargetMonster(turnCount[0], turnCount[1])
            if (turnCount[1] < 0) {
              nextOne = true
            }
          } else {
            if (cm.Action[2] == 8) {
              if (turnCount[2] == 0) {
                turnCount[0] = nextTargetPc('front', turnCount[0])
                if (turnCount[0] < 0) {
                  turnCount[0] = 0
                  turnCount[1] = nextTargetSummon(turnCount[0], -1)
                  turnCount[2] = 2
                  if (turnCount[1] < 0) {
                    nextOne = true
                  }
                }
              } else {
                turnCount[1] = nextTargetSummon(turnCount[0], turnCount[1])
                if (turnCount[1] < 0) {
                  nextOne = true
                }
              }
            } else {
              if (turnCount[2] == 0) {
                turnCount[0] = nextTargetPc('back', turnCount[0])
                if (turnCount[0] < 0) {
                  turnCount[0] = 1
                  turnCount[1] = nextTargetSummon(turnCount[0], -1)
                  turnCount[2] = 2
                  if (turnCount[1] < 0) {
                    nextOne = true
                  }
                }
              } else {
                turnCount[1] = nextTargetSummon(turnCount[0], turnCount[1])
                if (turnCount[1] < 0) {
                  nextOne = true
                }
              }
            }
          }
        } else {
          if (charType == 'pc' || charType == 'summon') {
            turnCount[1] = nextTargetMonster(turnCount[0], turnCount[1])
            if (turnCount[1] < 0) {
              turnCount[0] = nextTargetMonsterGroup(turnCount[0])
              if (turnCount[0] < 0) {
                nextOne = true
              } else {
                turnCount[1] = nextTargetMonster(turnCount[0], -1)
              }
            }
          } else {
            if (turnCount[2] == 0) {
              turnCount[0] = nextTargetPc('all', turnCount[0])
              if (turnCount[0] < 0) {
                turnCount[2] = 2
                for (let i = 0; i < 2; i++) {
                  turnCount[0] = i
                  turnCount[1] = nextTargetSummon(turnCount[0], -1)
                  if (turnCount[1] > -1) {
                    break
                  }
                }
                if (turnCount[1] < 0) {
                  nextOne = true
                }
              }
            } else {
              turnCount[1] = nextTargetSummon(turnCount[0], turnCount[1])
              if (turnCount[1] < 0) {
                if (turnCount[0] == 0) {
                  turnCount[0] = 1
                  turnCount[1] = nextTargetSummon(turnCount[0], -1)
                  if (turnCount[1] < 0) {
                    nextOne = true
                  }
                } else {
                  nextOne = true
                }
              }
            }
          }
        }
        if (nextOne) {
          GameState = 'battleTurnActionReturn'
        }
      }
    } else if (action == 4 && charType != 'pc') {
      let text = ''
      if (cmData.BATTLE_PARRY.length > 0) {
        text = cmData.BATTLE_PARRY[dice(1, cmData.BATTLE_PARRY.length) - 1]
      }
      if (text.match(/^(| )$/)) {
        GameState = 'battleTurnAction'
        battleAction()
        return
      } else {
        text = text.replace(
          /\[name\]/g,
          getNameBattle(cm, charType, cmNumInGroup)
        )
        battleText('set', text)
        GameState = 'battleTurnActionReturn'
      }
    } else if (action == 5 || action == 6) {
      if (turnCount[0] < 0) {
        let text = ''
        let spellData
        if (action == 5) {
          let itemNum = cm.Item[cm.Action[1]]
          let item = ITEM[itemNum]
          spellData = decomposeSpell(spellEffectReplace(item.USE, 1), cmNum)
          if (
            cm.Level >= spellData['levelLimit'] &&
            spellData['selectNum'] > 0
          ) {
            haman = true
          }
          if (item.USE_TEXT.length > 0) {
            text = item.USE_TEXT[dice(1, item.USE_TEXT.length) - 1]
          }
          if (text.match(/^(| )$/)) {
            text = getDefaultMessage('USED_ITEM')
          }
          text = text.replace(/\[item\]/g, cm.getItemName(cm.Action[1]))
        } else {
          let spellAry = decomposeSpellNum(cm.Action[1])
          let pcNum = -1,
            branch = -1
          if (charType == 'pc') {
            pcNum = cmNum
          } else {
            branch = cm.Action[3]
          }
          spellData = decomposeSpell(
            spellEffectReplace(
              GameData['SPELL_EFFECT'][spellAry[0]][spellAry[1]][spellAry[2]],
              0
            ),
            pcNum,
            branch
          )
          if (
            cm.Level >= spellData['levelLimit'] &&
            (cm.Silence == 0 ||
              GameData['SPELL_EVEN_SILENCE'][spellAry[0]][spellAry[1]][
                spellAry[2]
              ]) &&
            spellData['selectNum'] > 0
          ) {
            haman = true
          }
          if (charType != 'pc') {
            for (let i = 0; i < cmData.BATTLE_SPELL.length; i++) {
              let strAry = MP.getCmNum(cmData.BATTLE_SPELL_NUM[i]).split(',')
              if (strAry.indexOf(String(cm.Action[1])) > -1) {
                let strAry2 = cmData.BATTLE_SPELL[i].split('<>')
                text = strAry2[dice(1, strAry2.length) - 1]
                break
              }
            }
          }
          if (text.match(/^(| )$/)) {
            text = getDefaultMessage('CAST_SPELL')
          }
          let spellName =
            GameData['SPELL'][spellAry[0]][spellAry[1]][spellAry[2]].split('<>')
          text = text.replace(/\[spell\]/g, spellName[0])
          if (charType != 'pc') {
            let target = cm.Action[2]
            if (target > -1) {
              if (target < pt.getMemberNum()) {
                text = text.replace(
                  /\[target\]/g,
                  PC[pt.PartyMember[target]].Name[0]
                )
              } else if (target >= 10 && target < 60) {
                if (target < 20) {
                  target -= 10
                } else {
                  target -= 20
                  target = Math.floor(target / 10)
                }
                text = text.replace(/\[target\]/g, getMonsterName(target))
              } else if (target >= 60 && target < 90) {
                if (target < 70) {
                  target -= 60
                } else {
                  target -= 70
                  target = Math.floor(target / 10)
                }
                let targetNum = PlayData['SummonList'][target][0]
                if (targetNum > -1) {
                  text = text.replace(/\[target\]/g, SUMMON[targetNum].Name[1])
                }
              }
            }
          }
        }
        if (charType == 'pc') {
          text = text.replace(/\[name\]/g, cm.Name[0])
        } else if (charType == 'monster') {
          text = text.replace(/\[name\]/g, getMonsterName(cmNumInGroup[0]))
        } else {
          text = text.replace(/\[name\]/g, cm.Name[1])
        }
        turnCount[0]++
        GameState = 'battleTurnAction2'
        battleText('set', text)
        if (haman) {
          sePlay('spell')
          battleText()
          MP.drawTextFrame(
            MP.TextSurface[MP.TextSurfaceNum],
            getDefaultMessage('WHICH_BOON_DO_YOU_DESIRE_IN_BATTLE', 1),
            'center',
            MP.LINE_HEIGHT * 7
          )
          MP.TextSurfaceNum++
          let spellSelectAry = SPELL_EF.getSelectSpellEffect(
            spellData['selectNum'],
            spellData['spellEffect'].length
          )
          for (let i = 0; i < spellSelectAry.length; i++) {
            let num = spellSelectAry[i]
            let selText = ''
            if (num < spellData['selectText'].length) {
              selText = spellData['selectText'][num]
            }
            selAry.push(selText)
            valueAry.push(num)
          }
          y *= 10
          mode = 'noCancel'
        } else {
          battleAction()
          return
        }
      } else if (turnCount[0] == 0) {
        let spellData
        if (action == 5) {
          let itemNum = cm.Item[cm.Action[1]]
          let item = ITEM[itemNum]
          spellData = decomposeSpell(spellEffectReplace(item.USE, 1), cmNum)
        } else {
          let spellAry = decomposeSpellNum(cm.Action[1])
          let pcNum = -1,
            branch = -1
          if (charType == 'pc') {
            pcNum = cmNum
          } else {
            branch = cm.Action[3]
          }
          spellData = decomposeSpell(
            spellEffectReplace(
              GameData['SPELL_EFFECT'][spellAry[0]][spellAry[1]][spellAry[2]],
              0
            ),
            pcNum,
            branch
          )
        }
        if (key != 'enter') {
          spellSelNum = dice(1, spellData['spellEffect'].length) - 1
        }
        let situation
        if (action == 5) {
          situation = 'battleItem'
        } else {
          situation = 'battleSpell'
        }
        let castCharNum
        if (charType == 'pc') {
          castCharNum = cmNumInGroup[0]
        } else if (charType == 'monster') {
          castCharNum = cmNumInGroup[0] * 10 + 20 + cmNumInGroup[1]
        } else {
          castCharNum = cmNumInGroup[0] * 10 + 70 + cmNumInGroup[1]
        }
        SPELL_EF.spellEffect(
          spellData,
          spellSelNum,
          situation,
          castCharNum,
          cm.Action[2]
        )
        turnCount[0]++
        if (key == 'enter') {
          GameState = 'battleTurnAction2'
          battleAction()
          return
        } else {
          if (SPELL_EF.Effect != 'notCast') {
            sePlay('spell')
          }
        }
      } else {
        let text = ''
        let targetCharNum = SPELL_EF.checkResultChar()
        if (SPELL_EF.Effect == 'notCast') {
          text = getDefaultMessage('CAST_NO_SPEAK')
          SPELL_EF.Effect = ''
        } else if (SPELL_EF.Effect.match(/^(none|levelLimit|fizzle)$/)) {
          text = getDefaultMessage('CAST_NO_HAPPEN')
          SPELL_EF.Effect = ''
        } else if (SPELL_EF.Effect == 'noTarget') {
          text = getDefaultMessage('CAST_NO_TARGET')
          SPELL_EF.Effect = ''
        } else if (SPELL_EF.MessageStack[0].length > 0) {
          if (turnCount[0] == 1) {
            turnCount[0]++
          }
          text = SPELL_EF.MessageStack[0].shift()
          text = text.replace(/<p>/g, '<br>')
          text = MP.strChangeLine(text, 52, 5, true)
        } else if (targetCharNum > -1) {
          if (turnCount[0] == 1) {
            turnCount[0]++
          }
          let targetChar = SPELL_EF.setCharData(targetCharNum)
          let arySub = targetChar['type']
          if (targetChar['type'] == 'pc') {
            arySub += String(targetChar['numInGroup'][0])
          } else {
            arySub +=
              String(targetChar['numInGroup'][0]) +
              String(targetChar['numInGroup'][1])
          }
          text = SPELL_EF.getBattleSpellResult(arySub, targetChar)
          if (text == '') {
            GameState = 'battleTurnAction2'
            battleAction()
            return
          }
        } else if (SPELL_EF.Effect.indexOf('teleport') > -1) {
          let effect = SPELL_EF.Effect
          SPELL_EF.Effect = ''
          let fizzle = false
          if (DUNGEON.NotUseWarp[pt.DungeonNumber][pt.Floor]) {
            fizzle = true
          } else {
            let ary = effect.split(',')
            let teleportPoint = SPELL_EF.getPointRandomTeleport(
              ptNum,
              ary[1],
              ary[3]
            )
            if (
              teleportPoint[0] == pt.Floor &&
              teleportPoint[1] == pt.X &&
              teleportPoint[2] == pt.Y
            ) {
              fizzle = true
            } else {
              pt.Floor = teleportPoint[0]
              pt.X = teleportPoint[1]
              pt.Y = teleportPoint[2]
              pt.PreX = pt.X
              pt.PreY = pt.Y
              controlFlag(TempVariable['flagRun'], false)
              pt.battleReset()
              pt.check()
              sortNoAction()
              deleteTempVariable()
              if (GameData['SAVE_BATTLE_END']) {
                saveData('Battle end (It returns to the dungeon)')
              }
              GameState = 'moveStart'
              dungeonAction('step')
              return
            }
          }
          if (fizzle && turnCount[0] == 1) {
            text = getDefaultMessage('CAST_NO_HAPPEN')
          }
        } else if (SPELL_EF.Effect == 'return') {
          pt.battleReset()
          pt.check()
          sortNoAction()
          pt.returnGround()
          return
        } else if (SPELL_EF.Effect.indexOf('coordinateTeleport') > -1) {
          let ary = SPELL_EF.Effect.split(',')
          let tp = [
            Number(ary[1]),
            Number(ary[2]),
            Number(ary[3]),
            Number(ary[4])
          ]
          if (tp[0] < 0) {
            pt.battleReset()
            pt.check()
            sortNoAction()
            pt.returnGround()
            return
          } else {
            pt.DungeonNumber = tp[0]
            pt.Floor = tp[1]
            pt.X = tp[2]
            pt.Y = tp[3]
            pt.PreX = pt.X
            pt.PreY = pt.Y
            controlFlag(TempVariable['flagRun'], false)
            pt.battleReset()
            pt.check()
            sortNoAction()
            deleteTempVariable()
            if (GameData['SAVE_BATTLE_END']) {
              saveData('Battle end (It returns to the dungeon)')
            }
            GameState = 'moveStart'
            dungeonAction('step')
            return
          }
        } else if (SPELL_EF.MessageStack[1].length > 0) {
          text = SPELL_EF.MessageStack[1].shift()
          text = text.replace(/<p>/g, '<br>')
          text = MP.strChangeLine(text, 52, 5, true)
        }
        if (text == '') {
          GameState = 'battleTurnAction'
          battleAction()
          return
        }
        battleText('push', text)
      }
    } else if (action == 7 && charType == 'pc') {
      let targetNumInGroup = cm.Action[2]
      let mData = MONSTER_DATA[TempVariable['setMonster'][targetNumInGroup]]
      let monType = mData.TYPE.toString(16)
      let result = 0
      if (GameData['CLASS_DISPELL_KIND'][cm.PcClass].indexOf(monType) > -1) {
        for (let i = 0; i < 9; i++) {
          let monNum = PlayData['MonsterList'][targetNumInGroup][i]
          if (monNum < 0) {
            break
          }
          let mon = MONSTER[monNum]
          if (mon.Hp < 1) {
            continue
          }
          let formula = replaceMyAndTarget(
            GameData['DISPELL_PROB'],
            charType,
            'monster'
          )
          formula = replaceFormulaMyAndTarget(
            formula,
            charType,
            cmNum2,
            'monster',
            monNum
          )
          let prob = Math.floor(strCalculation(formula))
          if (prob < 0) {
            prob = 0
          } else if (prob > 100) {
            prob = 100
          }
          if (mData.INVINCIBILITY) {
            prob = 0
          }
          printDebugMessage(
            getNameBattle(cm, charType, cmNumInGroup, true) +
              ' dispell rate: ' +
              String(prob) +
              '%'
          )
          if (prob >= dice(1, 100)) {
            result++
            mon.controlHp(0)
            TempVariable['monsterNum'][targetNumInGroup]--
            if (TempVariable['monsterNum'][targetNumInGroup] < 1) {
              hateCheck(200 + targetNumInGroup)
            }
            cm.Marks++
            TempVariable['getExp'] += Math.floor(
              mon.Exp * (GameData['DISPELL_EXP'] / 100)
            )
            TempVariable['monsterKill'] = true
            registerInMonsterCatalog(targetNumInGroup)
          }
        }
      }
      let text
      if (result == 1) {
        text = getDefaultMessage('DISPELL_1')
      } else if (result > 1) {
        text = getDefaultMessage('DISPELL')
      } else {
        text = getDefaultMessage('DISPELL_FAIL')
      }
      text = text.replace(/\[name\]/g, cm.Name[0])
      text = text.replace(/\[monster\]/g, getMonsterName(targetNumInGroup))
      text = text.replace(
        /\[monsters\]/g,
        getMonsterName(targetNumInGroup, true)
      )
      text = text.replace(/\[value\]/g, String(result))
      battleText('set', text)
      GameState = 'battleTurnActionReturn'
    } else if (action == 8 && charType != 'pc') {
      let text = ''
      if (cmData.BATTLE_RUN.length > 0) {
        text = cmData.BATTLE_RUN[dice(1, cmData.BATTLE_RUN.length) - 1]
      }
      if (text.match(/^(| )$/)) {
        text = getDefaultMessage('FLEE')
      }
      text = text.replace(
        /\[name\]/g,
        getNameBattle(cm, charType, cmNumInGroup)
      )
      cm.Hp = 0
      if (charType == 'monster') {
        TempVariable['monsterNum'][cmNumInGroup[0]]--
        if (TempVariable['monsterNum'][cmNumInGroup[0]] < 1) {
          hateCheck(200 + cmNumInGroup[0])
        }
      } else {
        TempVariable['summonNum'][cmNumInGroup[0]]--
        if (TempVariable['summonNum'][cmNumInGroup[0]] < 1) {
          hateCheck(210 + cmNumInGroup[0])
        }
      }
      battleText('set', text)
      GameState = 'battleTurnActionReturn'
    } else if (action == 9 && charType != 'pc') {
      if (turnCount[0] == -1) {
        let text = ''
        if (cmData.BATTLE_CALL.length > 0) {
          text = cmData.BATTLE_CALL[dice(1, cmData.BATTLE_CALL.length) - 1]
        }
        if (text.match(/^(| )$/)) {
          text = getDefaultMessage('CALL')
        }
        text = text.replace(
          /\[name\]/g,
          getNameBattle(cm, charType, cmNumInGroup)
        )
        battleText('set', text)
        turnCount[0]++
      } else {
        let ck = false
        let num, monNum
        if (charType == 'monster') {
          num = TempVariable['monsterNum'][cmNumInGroup[0]]
          monNum = getNextMonster()
        } else {
          num = TempVariable['summonNum'][cmNumInGroup[0]]
          monNum = getNextSummon()
        }
        if (num < 9) {
          let formula = replaceFormula(GameData['CALL_PROB'], [
            ['monster', cmNum2]
          ])
          let prob = Math.floor(strCalculation(formula))
          if (prob < 0) {
            prob = 0
          } else if (prob > 100) {
            prob = 100
          }
          if (prob >= dice(1, 100) && monNum > -1) {
            ck = true
            let silence = cm.Silence,
              list,
              listStr
            if (charType == 'monster') {
              TempVariable['monsterNum'][cmNumInGroup[0]]++
              MONSTER[monNum].createMonster(cm.MonsterDataNum, monNum, silence)
              list = MONSTER
              listStr = 'MonsterList'
            } else {
              TempVariable['summonNum'][cmNumInGroup[0]]++
              SUMMON[monNum].createMonster(
                cm.MonsterDataNum,
                monNum + 50,
                silence
              )
              list = SUMMON
              listStr = 'SummonList'
            }
            for (let i = 0; i < 9; i++) {
              if (PlayData[listStr][cmNumInGroup[0]][i] < 0) {
                PlayData[listStr][cmNumInGroup[0]][i] = monNum
                break
              }
              let ckMonNum = PlayData[listStr][cmNumInGroup[0]][i]
              if (list[ckMonNum].Hp < 1) {
                PlayData[listStr][cmNumInGroup[0]][i] = monNum
                break
              }
            }
          }
        }
        let text
        if (ck) {
          text = getDefaultMessage('CALL_APPEAR')
        } else {
          text = getDefaultMessage('CALL_NO_COME')
        }
        text = text.replace(
          /\[name\]/g,
          getNameBattle(cm, charType, cmNumInGroup)
        )
        battleText('push', text)
        GameState = 'battleTurnActionReturn'
      }
    } else {
      GameState = 'battleTurnAction'
      battleAction()
      return
    }
    if (!haman) {
      battleText()
      return
    }
  } else if (GameState == 'battleTurnHealingEffect') {
    MP.clearTextSurface('all')
    let turnCount = TempVariable['turnCount']
    if (turnCount[2] < 0) {
      turnCount[2] = 0
    }
    if (turnCount[2] == 0) {
      turnCount[0]++
      if (turnCount[0] >= pt.getMemberNum()) {
        if (checkBattleEnd() == 1) {
          controlFlag(TempVariable['flagAnnihilation'], false)
          pt.battleReset()
          pt.check()
          deleteTempVariable()
          GameState = 'annihilate'
          MP.viewRip()
          annihilateProcessing()
          return
        }
        turnCount[0] = 0
        turnCount[1] = -1
        turnCount[2] = 1
      } else {
        let pc = PC[pt.PartyMember[turnCount[0]]]
        if (pc.State > 3 || pc.Hp < 1) {
          battleAction()
          return
        }
      }
    }
    if (turnCount[2] == 1) {
      turnCount[1]++
      if (turnCount[1] >= 9) {
        turnCount[0]++
        turnCount[1] = 0
        if (turnCount[0] >= 2) {
          turnCount[0] = 0
          turnCount[1] = -1
          turnCount[2] = 2
        }
      }
      if (turnCount[2] == 1) {
        let monNum = PlayData['SummonList'][turnCount[0]][turnCount[1]]
        if (monNum < 0) {
          battleAction()
          return
        } else if (SUMMON[monNum].Hp < 1) {
          battleAction()
          return
        }
      }
    }
    if (turnCount[2] == 2) {
      turnCount[1]++
      if (turnCount[1] >= 9) {
        turnCount[0]++
        turnCount[1] = 0
        if (turnCount[0] >= 4) {
          turnCount[0] = -1
        }
      }
      if (turnCount[0] > -1) {
        let monNum = PlayData['MonsterList'][turnCount[0]][turnCount[1]]
        if (monNum < 0) {
          battleAction()
          return
        } else if (MONSTER[monNum].Hp < 1) {
          battleAction()
          return
        }
      }
    }
    if (turnCount[0] < 0) {
      TempVariable['battleStart'] = 'normal'
      if (checkBattleEnd() == 2) {
        GameState = 'battleWin'
        battleAction()
        return
      }
      if (TempVariable['turn'] < 99999) {
        TempVariable['turn']++
      }
      pt.battleActionReset()
      pt.check()
      monsterDecidedCheck()
      GameState = 'battleSetTurn'
      battleAction()
      return
    }
    let cmNum, cmNum2, cm, charType
    if (turnCount[2] == 0) {
      charType = 'pc'
      cmNum = pt.PartyMember[turnCount[0]]
      cmNum2 = cmNum
      cm = PC[cmNum]
    } else if (turnCount[2] == 1) {
      charType = 'summon'
      cmNum = PlayData['SummonList'][turnCount[0]][turnCount[1]]
      cmNum2 = cmNum + 50
      cm = SUMMON[cmNum]
    } else {
      charType = 'monster'
      cmNum = PlayData['MonsterList'][turnCount[0]][turnCount[1]]
      cmNum2 = cmNum
      cm = MONSTER[cmNum]
    }
    if (turnCount[2] != 0) {
      cm.healingEffect(true)
    }
    let point = cm.HpPlus
    let count = 0
    let loop = cm.CD_Turn.length
    for (let i = 0; i < loop; i++) {
      let formula = cm.CD_Value[count]
      let dmg
      if (turnCount[2] == 0) {
        formula = replaceFormula(formula, [
          ['pc', cmNum],
          ['pc2', cmNum]
        ])
      } else {
        formula = replaceFormula(formula, [
          ['monster', cmNum2],
          ['monster2', cmNum2]
        ])
      }
      dmg = Math.floor(strCalculation(formula))
      if (dmg < -9999) {
        dmg = -9999
      } else if (dmg > 9999) {
        dmg = 9999
      }
      let attribute = cm.CD_Attribute[count]
      if (
        attribute != 0 &&
        cm.Resist[attribute] &&
        !cm.WeakPoint[attribute] &&
        dmg > 0
      ) {
        dmg = Math.ceil(calTimes(dmg, GameData['SPELL_RESIST']))
      } else if (
        attribute != 0 &&
        !cm.Resist[attribute] &&
        cm.WeakPoint[attribute] &&
        dmg > 0
      ) {
        dmg = Math.ceil(calTimes(dmg, GameData['SPELL_WEAK']))
      }
      let resistPlus = cm.SrPlus
      if (cm.Action[0] == 4) {
        formula = GameData['PARRY_RESIST']
        if (turnCount[2] == 0) {
          formula = formula.replace(/my\./g, 'pc.')
          formula = replaceFormula(formula, [['pc', cmNum]])
        } else {
          formula = formula.replace(/my\./g, 'monster.')
          formula = replaceFormula(formula, [['monster', cmNum2]])
        }
        resistPlus += Math.floor(strCalculation(formula))
      }
      formula = cm.CD_Resist[count]
      formula = formula.replace(/plus/g, resistPlus)
      if (turnCount[2] == 0) {
        formula = replaceFormula(formula, [
          ['pc', cmNum],
          ['pc2', cmNum]
        ])
      } else {
        formula = replaceFormula(formula, [
          ['monster', cmNum2],
          ['monster2', cmNum2]
        ])
      }
      let prob = Math.floor(strCalculation(formula))
      if (prob < 0) {
        prob = 0
      } else if (prob > 100) {
        prob = 100
      }
      if (prob >= dice(1, 100)) {
        dmg = Math.ceil(dmg / 2)
      }
      point += dmg * -1
      if (cm.CD_Turn[count] == 0) {
        cm.CD_Turn.splice(count, 1)
        cm.CD_Attribute.splice(count, 1)
        cm.CD_Value.splice(count, 1)
        cm.CD_Resist.splice(count, 1)
      } else {
        if (cm.CD_Turn[count] > 0) {
          cm.CD_Turn[count]--
        }
        count++
      }
    }
    if (point < -99999) {
      point = -99999
    } else if (point > 99999) {
      point = 99999
    }
    if (turnCount[2] != 0) {
      if (cm.INVINCIBILITY && point < 0) {
        point = 0
      }
    }
    for (let i = 0; i < 9; i++) {
      if (cm.BtSpellEffectPlus[i] != 0) {
        if (cm.BtSpellEffectTurn[i] == 0) {
          cm.BtSpellEffectPlus[i] = 0
        } else if (cm.BtSpellEffectTurn[i] > 0) {
          cm.BtSpellEffectTurn[i]--
        }
      }
    }
    if (cm.BtOnlySpellEffectPlus[0] != 0) {
      if (cm.BtOnlySpellEffectTurn[0] == 0) {
        cm.BtOnlySpellEffectPlus[0] = 0
      } else if (cm.BtOnlySpellEffectTurn[0] > 0) {
        cm.BtOnlySpellEffectTurn[0]--
      }
    }
    if (cm.Hate > -1) {
      if (cm.HateTurn == 0) {
        cm.Hate = -1
      } else if (cm.HateTurn > 0) {
        cm.HateTurn--
      }
    }
    for (let i = 0; i < cm.AbiTurn.length; i++) {
      if (cm.Bt_abiPlus[i] != 0) {
        if (cm.AbiTurn[i] == 0) {
          cm.Bt_abiPlus[i] = 0
        } else if (cm.AbiTurn[i] > 0) {
          cm.AbiTurn[i]--
        }
      }
    }
    for (let i = 0; i < cm.ResistTurn.length; i++) {
      if (cm.Bt_resistPlus[i] != -2) {
        if (cm.ResistTurn[i] == 0) {
          cm.Bt_resistPlus[i] = -2
        } else if (cm.ResistTurn[i] > 0) {
          cm.ResistTurn[i]--
        }
      }
    }
    for (let i = 0; i < cm.AttackAddTurn.length; i++) {
      if (cm.Bt_attackAddPlus[i]) {
        if (cm.AttackAddTurn[i] == 0) {
          cm.Bt_attackAddPlus[i] = false
        } else if (cm.AttackAddTurn[i] > 0) {
          cm.AttackAddTurn[i]--
        }
      }
    }
    cm.check()
    if (cm.State > 3 || cm.Hp < 1 || point == 0) {
      battleAction()
      return
    }
    let resultStr = ''
    if (cm.Hp == cm.HpMax) {
      if (point < 0) {
        cm.controlHp(point, true)
        resultStr = 'dmg'
      }
    } else {
      cm.controlHp(point, true)
      if (cm.Hp == cm.HpMax) {
        resultStr = 'full'
      } else if (point > 0) {
        resultStr = 'heal'
      } else {
        resultStr = 'dmg'
      }
    }
    printDebugMessage(
      getNameBattle(cm, charType, [turnCount[0], turnCount[1]], true) +
        ' HP: ' +
        MP.numberFormat(cm.Hp) +
        ' / ' +
        MP.numberFormat(cm.HpMax)
    )
    if (resultStr == '') {
      battleAction()
      return
    }
    let text = ''
    if (resultStr == 'full' && !GameData['HEALING_MESSAGE_NOT_DISPLAYED']) {
      sePlay('heal')
      text = getDefaultMessage('CAST_HEALED_COMPLETE')
    } else if (
      resultStr == 'heal' &&
      !GameData['HEALING_MESSAGE_NOT_DISPLAYED']
    ) {
      sePlay('heal')
      if (point == 1) {
        text = getDefaultMessage('CAST_HEALED_1')
      } else {
        text = getDefaultMessage('CAST_HEALED')
      }
      text = text.replace(/\[value\]/g, String(point))
    } else if (resultStr == 'dmg') {
      cm.cureAsleepByDamage(point * -1)
      sePlay('hit')
      text = getDefaultMessage('TAKE_DAMAGE')
      text = text.replace(/\[damage\]/g, String(point * -1))
    }
    if (cm.State > 3 || cm.Hp < 1) {
      if (turnCount[2] == 1) {
        TempVariable['summonNum'][turnCount[0]]--
        if (TempVariable['summonNum'][turnCount[0]] < 1) {
          hateCheck(210 + turnCount[0])
        }
      } else if (turnCount[2] == 2) {
        TempVariable['monsterNum'][turnCount[0]]--
        if (TempVariable['monsterNum'][turnCount[0]] < 1) {
          hateCheck(200 + turnCount[0])
        }
        TempVariable['getExp'] += cm.Exp
        TempVariable['monsterKill'] = true
        registerInMonsterCatalog(turnCount[0])
      }
      text += '\n'
      text += getDefaultMessage('KILLED')
    }
    if (text == '') {
      battleAction()
      return
    }
    let nameStr = ''
    if (turnCount[2] == 0) {
      nameStr = cm.Name[0]
    } else if (turnCount[2] == 1) {
      nameStr = cm.Name[1]
    } else {
      nameStr = getMonsterName(turnCount[0])
    }
    text = text.replace(/\[target\]/g, nameStr)
    battleText('push', text)
    GameState = 'battleTurnHealingEffectReturn'
    battleText()
    return
  } else if (GameState == 'battleCommand') {
    let pcNum = PlayData['StatusNum']
    let pc, pcNumInPt
    if (pcNum > -1) {
      pc = PC[pcNum]
      pcNumInPt = pt.getMemberForPcNum(pcNum)
    }
    if (key == 'cancel') {
      key = 'enter'
      value = 'back'
    }
    if (key == 'enter') {
      MP.controlPreSelect('clear')
      MP.controlPreSelect('push')
      TempVariable['monsterSelectLimit'] = false
      if (value.match(/^(fight|ambush|breath|dispell)$/)) {
        let commandNum
        if (value == 'ambush') {
          commandNum = 2
        } else if (value == 'breath') {
          commandNum = 3
        } else if (value == 'dispell') {
          commandNum = 7
        } else {
          commandNum = 0
        }
        if (value == 'breath' && pc.Breath == 3) {
          pc.Action[0] = commandNum
        } else {
          let hateTarget = 10
          if (TempVariable['monsterNum'][1] > 0) {
            hateTarget = getHateTarget('pc', pcNum, -1, commandNum)
          }
          if (hateTarget > -1) {
            pc.Action[0] = commandNum
            pc.Action[2] = hateTarget
          } else {
            if (value == 'fight') {
              let num = 1
              if (pt.frontRankCheck(pcNumInPt)) {
                num = 0
              }
              if (pc.Range[num] != 4) {
                TempVariable['monsterSelectLimit'] = true
              }
            }
            TempVariable['commandNum'] = commandNum
            GameState = 'battleCommandSelectMonster'
            battleAction()
            return
          }
        }
      } else if (value == 'hide') {
        pc.Action[0] = 1
      } else if (value == 'parry') {
        pc.Action[0] = 4
      } else if (value == 'item') {
        GameState = 'battleCommandItem'
        battleAction()
        return
      } else if (value == 'spell') {
        MP.TextSurfaceNum++
        GameState = 'battleCommandSpell'
        battleAction()
        return
      } else if (value == 'run') {
        pt.battleActionReset()
        let prob
        let ck = true
        for (let i = 0; i < 4; i++) {
          if (!ck) {
            break
          }
          for (let j = 0; j < TempVariable['monsterNum'][i]; j++) {
            let monNum = PlayData['MonsterList'][i][j]
            if (monNum > -1) {
              if (MONSTER[monNum].possibleToAction()) {
                ck = false
                break
              }
            }
          }
        }
        if (ck) {
          prob = 100
        } else {
          let monNum = PlayData['MonsterList'][0][0]
          let formula = GameData['RUN_PROB']
          formula = replaceMyAndTarget(formula, 'pc', 'monster')
          formula = replaceFormula(formula, [
            ['pc', pcNum],
            ['monster', monNum]
          ])
          prob = Math.floor(strCalculation(formula))
          if (prob < 0) {
            prob = 0
          } else if (prob > 100) {
            prob = 100
          }
        }
        printDebugMessage(
          '[' + pc.Name[0] + '] escape rate: ' + String(prob) + '%'
        )
        let str = ''
        if (prob >= dice(1, 100)) {
          ck = true
          str = getDefaultMessage('FLEE')
        } else {
          ck = false
          str = getDefaultMessage('FLEE_NOT')
        }
        str = str.replace(/\[name\]/g, pc.Name[0])
        battleText('set', str)
        MP.clearTextSurface('all')
        MP.viewPartyStatus('clear')
        battleText()
        if (ck) {
          GameState = 'battleRunReturn'
        } else {
          GameState = 'battleCommandEndReturn'
        }
        return
      } else if (value == 'back') {
        commandPrevPc()
        battleAction()
        return
      } else if (value == 'exchange') {
        GameState = 'battleCommandExchange'
        battleAction()
        return
      } else if (value == 'end') {
        GameState = 'battleCommandEnd'
        battleAction()
        return
      }
      commandNextPc()
      battleAction()
      return
    }
    MP.clearTextSurface('all')
    MP.TopSurface.clear()
    MP.viewPartyStatus()
    MP.viewMonsterList(MP.TextSurface[MP.TextSurfaceNum])
    MP.TextSurfaceNum++
    if (TempVariable['summonListStr'] != '') {
      MP.drawTextFrame(
        MP.TextSurface[MP.TextSurfaceNum],
        TempVariable['summonListStr'],
        MP.MAIN_X + MP.MAIN_WIDTH / 2 - (MP.FONT_SIZE / 2) * 28,
        MP.LINE_HEIGHT * 15
      )
    }
    if (pcNum < 0) {
      MP.drawTextFrame(
        MP.TextSurface[MP.TextSurfaceNum],
        getDefaultMessage('ARE_YOU_OK', 1, 48),
        'center',
        MP.LINE_HEIGHT * 8
      )
      selAry.push(getDefaultMessage('BATTLE_SELECT_FIGHT', 1, 10))
      valueAry.push('end')
      selAry.push(getDefaultMessage('BATTLE_BACK', 1, 10))
      valueAry.push('back')
      MP.TextSurfaceNum++
      y *= 11
    } else {
      MP.drawTextFrame(
        MP.TextSurface[MP.TextSurfaceNum],
        MP.strFitLength(pc.Name[0], 20),
        MP.MAIN_X + MP.MAIN_WIDTH / 2 + (MP.FONT_SIZE / 2) * 7,
        MP.LINE_HEIGHT * 5.5
      )
      if (GameData['FACE_GRAPHIC_BATTLE']) {
        let srcStr
        if (!pc.FaceGraphic.match(/^(| |none)$/)) {
          srcStr = '<>' + pc.FaceGraphic
        } else {
          srcStr = 'graphic/face/' + pc.Name[0]
        }
        if (GraphicData[srcStr] != undefined && GraphicData[srcStr] != null) {
          let faceX = MP.MAIN_X + MP.MAIN_WIDTH / 2 + (MP.FONT_SIZE / 2) * 2
          let faceY = MP.MAIN_Y + MP.LINE_HEIGHT * 7.2
          let faceSize = MP.FONT_SIZE * 7
          MP.paintGraphic(
            MP.TextSurface[MP.TextSurfaceNum],
            GraphicData[srcStr],
            faceX,
            faceY,
            faceSize,
            faceSize
          )
          MP.drawFrame(
            MP.TextSurface[MP.TextSurfaceNum],
            faceX,
            faceY,
            faceSize,
            faceSize,
            MP.FRAME_ARC,
            MP.FRAME_WIDTH / 2,
            'white'
          )
        }
      }
      MP.TextSurfaceNum++
      if (pc.Hide && pc.State == 0) {
        selAry.push(getDefaultMessage('BATTLE_AMBUSH', 1, 10))
        valueAry.push('ambush')
      } else if (pt.frontRankCheck(pcNumInPt)) {
        if (pc.Range[0] > 0) {
          selAry.push(getDefaultMessage('BATTLE_FIGHT', 1, 10))
          valueAry.push('fight')
        }
      } else if (pc.Range[1] > 0) {
        selAry.push(getDefaultMessage('BATTLE_FIGHT', 1, 10))
        valueAry.push('fight')
      }
      if (GameData['HIDE_ON'] && pc.ThiefLv > 0 && !pc.Hide && pc.State == 0) {
        selAry.push(getDefaultMessage('BATTLE_HIDE', 1, 10))
        valueAry.push('hide')
      }
      if (pc.Breath > 0 && pc.BreathNum != 0 && pc.NoBreath == 0) {
        selAry.push(getDefaultMessage('BATTLE_BREATH', 1, 10))
        valueAry.push('breath')
      }
      selAry.push(getDefaultMessage('BATTLE_PARRY', 1, 10))
      valueAry.push('parry')
      let spaceSpellUsedNum = DUNGEON.checkSpaceSpellUsed(
        pt.DungeonNumber,
        pt.Floor,
        pt.X,
        pt.Y
      )
      if (
        pc.haveItemBattle() > 0 &&
        pc.NoBreath == 0 &&
        spaceSpellUsedNum != 1 &&
        spaceSpellUsedNum != 2
      ) {
        selAry.push(getDefaultMessage('BATTLE_ITEM', 1, 10))
        valueAry.push('item')
      }
      if (
        pc.spellMaster(-1, -1, -1) &&
        pc.State == 0 &&
        (pc.Silence == 0 || (pc.Silence != 0 && pc.spellMasterSilence())) &&
        !pc.SealSpell &&
        (!(
          TempVariable['turn'] == 0 &&
          TempVariable['battleStart'] == 'preemptivePc'
        ) ||
          GameData['SPELL_CAN_BE_USED']) &&
        pc.NoBreath == 0 &&
        spaceSpellUsedNum != 0 &&
        spaceSpellUsedNum != 2
      ) {
        selAry.push(getDefaultMessage('BATTLE_SPELL', 1, 10))
        valueAry.push('spell')
      }
      let classDispellLv = GameData['CLASS_DISPELL_LV'][pc.PcClass]
      if (
        classDispellLv > 0 &&
        pc.Level >= classDispellLv &&
        pc.NoBreath == 0
      ) {
        selAry.push(getDefaultMessage('BATTLE_DISPELL', 1, 10))
        valueAry.push('dispell')
      }
      if (
        GameData['BATTLE_EXCHANGE'] &&
        !pc.kindCursedCheck(0) &&
        pc.haveEquipItem(0)
      ) {
        selAry.push(getDefaultMessage('BATTLE_EXCHANGE', 1, 10))
        valueAry.push('exchange')
      }
      selAry.push(getDefaultMessage('BATTLE_RUN', 1, 10))
      valueAry.push('run')
      if (pcNumInPt > 0) {
        selAry.push(getDefaultMessage('BATTLE_BACK', 1, 10))
        valueAry.push('back')
      }
      align = MP.MAIN_X + MP.MAIN_WIDTH / 2 + (MP.FONT_SIZE / 2) * 18
      y *= 8
    }
  } else if (GameState == 'battleCommandItem') {
    let pcNum = PlayData['StatusNum']
    let pc = PC[pcNum]
    MP.viewPartyStatus()
    MP.viewMonsterList(MP.TextSurface[0])
    if (key == 'cancel') {
      MP.controlPreSelect('pop')
      GameState = 'battleCommand'
      battleAction('return')
      return
    } else if (key == 'enter') {
      let haveNum = Number(value)
      let itemNum = pc.Item[haveNum]
      let item = ITEM[itemNum]
      let spellData = decomposeSpell(spellEffectReplace(item.USE, 1), pcNum)
      pc.Action[1] = haveNum
      MP.controlPreSelect('push')
      let num = spellData['target']
      if (num == 1 || num == 4 || num == 6) {
        MP.drawTextFrame(
          MP.TextSurface[MP.TextSurfaceNum],
          getDefaultMessage('ITEM_USE_WHOM', 1, 48),
          'center',
          MP.LINE_HEIGHT * 11
        )
        if (num == 1) {
          if (pt.getMemberNum() == 1) {
            pc.Action[0] = 5
            pc.Action[2] = 0
            GameState = 'battleCommand'
            commandNextPc()
          } else {
            MP.TopSurface.clear()
            GameState = 'battleCommandSelectPcItem'
          }
        } else {
          let hateTarget = 10
          if (TempVariable['monsterNum'][1] > 0) {
            hateTarget = getHateTarget('pc', pcNum, -1, 5)
          }
          if (hateTarget > -1) {
            pc.Action[0] = 5
            pc.Action[2] = hateTarget
            GameState = 'battleCommand'
            commandNextPc()
          } else {
            GameState = 'battleCommandSelectMonsterItem'
          }
        }
      } else {
        pc.Action[0] = 5
        GameState = 'battleCommand'
        commandNextPc()
      }
      battleAction()
      return
    }
    MP.TextSurfaceNum = 3
    let itemMax = pc.haveItemNum(-1)
    for (let i = 0; i < itemMax; i++) {
      let itemNum = pc.Item[i]
      let item = ITEM[itemNum]
      if (!item.USE_EQUIP || (item.USE_EQUIP && item.equipCheck(pcNum))) {
        if (!(GameData['CANNOT_USE_CURSED_ITEM'] && pc.Equip[i] == 2)) {
          let spellData = decomposeSpell(spellEffectReplace(item.USE, 1), pcNum)
          if (spellData['situation'] == 0 || spellData['situation'] == 2) {
            selAry.push(PC[pcNum].getItemName(i, 'equip'))
            valueAry.push(String(i))
          }
        }
      }
    }
    y *= 5.5
    charMin = 26
    lineNum = pc.ItemMaxNum
    if (lineNum > 12) {
      lineNum = 12
    }
    comment = 'haveItem'
  } else if (GameState == 'battleCommandSpell') {
    let pcNum = PlayData['StatusNum']
    let pc = PC[pcNum]
    if (key == 'enter') {
      let ary = pc.getLearnedSpell(
        2,
        MP.SelectMode['select'],
        MP.SelectMode['selectF']
      )
      if (ary.length > 0) {
        MP.controlPreSelect('push')
        MP.controlPreSelect('push')
        GameState = 'battleCommandSpell2'
        battleAction()
        return
      }
      value = MP.SelectMode['select']
    } else if (key == 'cancel') {
      MP.controlPreSelect('pop')
      GameState = 'battleCommand'
      battleAction('return')
      return
    } else if (key == '') {
      let ary = pc.getSpellSelect()
      value = ary[0]
      MP.SelectMode['selectF'] = ary[1]
    }
    MP.clearTextSurface(MP.TextSurfaceNum - 1)
    MP.viewPreSelectMode(MP.TextSurfaceNum - 1, 0, 'none')
    mode = 'spellLvSel'
    comment = 'spellLv'
    y *= 5.5
  } else if (GameState == 'battleCommandSpell2') {
    MP.viewPartyStatus()
    MP.viewMonsterList(MP.TextSurface[0])
    MP.TextSurfaceNum = 3
    let pcNum = PlayData['StatusNum']
    let pc = PC[pcNum]
    if (key == 'enter') {
      let kind = MP.PreSelect['select'][2]
      let lv = MP.PreSelect['selectF'][2]
      let spell = Number(MP.SelectMode['valueAry'][MP.SelectMode['select']])
      pc.Action[1] = kind * 100 + lv * 10 + spell
      let spellData = decomposeSpell(
        spellEffectReplace(GameData['SPELL_EFFECT'][kind][lv][spell], 0),
        pcNum
      )
      let num = spellData['target']
      if (num == 1 || num == 4 || num == 6) {
        MP.controlPreSelect('push')
        MP.drawTextFrame(
          MP.TextSurface[MP.TextSurfaceNum],
          getDefaultMessage('CAST_WHOM', 1, 48),
          'center',
          MP.LINE_HEIGHT * 11
        )
        if (num == 1) {
          if (pt.getMemberNum() == 1) {
            pc.Action[0] = 6
            pc.Action[2] = 0
            GameState = 'battleCommand'
            commandNextPc()
          } else {
            GameState = 'battleCommandSelectPcSpell'
          }
        } else {
          let hateTarget = 10
          if (TempVariable['monsterNum'][1] > 0) {
            hateTarget = getHateTarget('pc', pcNum, -1, 6)
          }
          if (hateTarget > -1) {
            pc.Action[0] = 6
            pc.Action[2] = hateTarget
            GameState = 'battleCommand'
            commandNextPc()
          } else {
            GameState = 'battleCommandSelectMonsterSpell'
          }
        }
      } else {
        pc.Action[0] = 6
        GameState = 'battleCommand'
        commandNextPc()
      }
      battleAction()
      return
    } else if (key == 'cancel') {
      let preSel = MP.PreSelect['selectF'][2]
      MP.controlPreSelect('pop')
      MP.controlPreSelect('pop')
      GameState = 'battleCommandSpell'
      MP.SelectMode['valueAry'][MP.SelectMode['select']] =
        MP.SelectMode['select']
      MP.SelectMode['selectF'] = preSel
      battleAction('return')
      return
    }
    MP.viewPreSelectMode(MP.TextSurfaceNum - 1, 0, 'none')
    MP.PreSelect['selectF'][1] = MP.PreSelect['selectF'][2]
    MP.viewPreSelectMode(MP.TextSurfaceNum - 1, 1, 'none')
    MP.SelectMode['selectF'] = 0
    let kind = MP.PreSelect['select'][2]
    let lv = MP.PreSelect['selectF'][2]
    let ary = pc.getLearnedSpell(2, kind, lv)
    colorAry = []
    for (let i = 0; i < ary.length; i++) {
      let strAry = GameData['SPELL'][kind][lv][ary[i]].split('<>')
      selAry.push(strAry[0])
      valueAry.push(String(ary[i]))
      if (
        pc.Mp[kind][lv] >= GameData['SPELL_CONSUMPTION_MP'][kind][lv][ary[i]]
      ) {
        colorAry.push('white')
      } else {
        colorAry.push('gray')
      }
    }
    align = MP.MAIN_X + MP.MAIN_WIDTH / 2 - (MP.FONT_SIZE / 2) * 12
    y *= 7 + GameData['SPELL_KIND']
    charMin = 24
    lineNum = 6
    mode = 'spellSel'
    comment = 'spell'
  } else if (GameState.match(/^battleCommandSelectMonster/)) {
    if (key == 'cancel') {
      MP.controlPreSelect('pop')
      if (GameState.match(/MonsterItem$/)) {
        GameState = 'battleCommandItem'
      } else if (GameState.match(/MonsterSpell$/)) {
        GameState = 'battleCommandSpell2'
      } else {
        GameState = 'battleCommand'
      }
      battleAction('return')
      return
    } else if (key == 'enter') {
      let pcNum = PlayData['StatusNum']
      let pc = PC[pcNum]
      if (GameState.match(/MonsterItem$/)) {
        pc.Action[0] = 5
      } else if (GameState.match(/MonsterSpell$/)) {
        pc.Action[0] = 6
      } else {
        pc.Action[0] = TempVariable['commandNum']
      }
      pc.Action[2] = value + 10
      GameState = 'battleCommand'
      commandNextPc()
      battleAction()
      return
    }
    MP.TextSurfaceNum = 0
    let selectLimit = false
    if (TempVariable['monsterSelectLimit']) {
      selectLimit = true
    }
    for (let i = 0; i < 4; i++) {
      if (i > 1 && selectLimit) {
        break
      }
      if (TempVariable['monsterNum'][i] < 1) {
        break
      }
      selAry.push(String(i))
    }
    mode = 'monsterSel'
    if (selectLimit) {
      mode += 'Front'
    }
  } else if (GameState.match(/^battleCommandSelectPc/)) {
    if (key == 'cancel') {
      MP.controlPreSelect('pop')
      if (GameState.match(/PcItem$/)) {
        GameState = 'battleCommandItem'
      } else if (GameState.match(/PcSpell$/)) {
        GameState = 'battleCommandSpell2'
      } else {
        GameState = 'battleCommand'
      }
      battleAction('return')
      return
    } else if (key == 'enter') {
      let pcNum = PlayData['StatusNum']
      let pc = PC[pcNum]
      if (GameState.match(/PcItem$/)) {
        pc.Action[0] = 5
      } else if (GameState.match(/PcSpell$/)) {
        pc.Action[0] = 6
      } else {
        pc.Action[0] = 4
      }
      pc.Action[2] = pt.getMemberForPcNum(Number(value))
      GameState = 'battleCommand'
      commandNextPc()
      battleAction()
      return
    }
    let memberNum = pt.getMemberNum()
    for (let i = 0; i < memberNum; i++) {
      selAry.push(String(i))
      valueAry.push(String(pt.PartyMember[i]))
    }
    mode = 'pcSel'
  } else if (GameState == 'battleCommandExchange') {
    let pcNum = PlayData['StatusNum']
    let pc = PC[pcNum]
    if (key == '') {
      key = 'next'
      TempVariable['equipSel'] = -1
    }
    MP.TextSurfaceNum = 2
    if (changeEquipAction(key, value)) {
      return
    }
    value = TempVariable['value']
    selAry = TempVariable['selAry'].slice()
    valueAry = TempVariable['valueAry'].slice()
    y *= 5.5
    charMin = 26
    lineNum = pc.ItemMaxNum
    if (lineNum > 12) {
      lineNum = 12
    }
    comment = 'haveItem'
  } else if (GameState == 'battleCommandEnd') {
    let memberNum = pt.getMemberNum()
    if (!GameData['ATTACK_FIRST_MONSTER']) {
      for (let i = 0; i < 4; i++) {
        if (TempVariable['monsterNum'][i] < 1) {
          break
        }
        let stack = []
        for (let j = 0; j < memberNum; j++) {
          let pcNum = pt.PartyMember[j]
          let pc = PC[pcNum]
          if (
            (pc.Action[0] == 0 || pc.Action[0] == 2) &&
            pc.Action[2] == 10 + i &&
            pc.GroupAtNum < 2
          ) {
            stack.push(pcNum)
          }
        }
        if (stack.length < 2 || TempVariable['monsterNum'][i] < 2) {
          continue
        }
        for (let j = 0; j < stack.length; j++) {
          PC[stack[j]].Action[3] = j % TempVariable['monsterNum'][i]
        }
      }
    }
    TempVariable['frontHide'] = frontHideCheck()
    if (
      !(
        TempVariable['turn'] == 0 &&
        TempVariable['battleStart'] == 'preemptivePc'
      )
    ) {
      for (let i = 0; i < 4; i++) {
        if (TempVariable['monsterNum'][i] < 1) {
          continue
        }
        for (let j = 0; j < TempVariable['monsterNum'][i]; j++) {
          setMonsterAction(i, j)
        }
      }
    }
    for (let i = 0; i < 2; i++) {
      if (TempVariable['summonNum'][i] < 1) {
        continue
      }
      for (let j = 0; j < TempVariable['summonNum'][i]; j++) {
        setMonsterAction(i + 10, j)
      }
    }
    let sortData = []
    let turnOrderFormula = GameData['TURN_ORDER'].replace(/my\./g, 'pc.')
    for (let i = 0; i < memberNum; i++) {
      let pcNum = pt.PartyMember[i]
      let pc = PC[pcNum]
      if (pc.possibleToAction()) {
        let formula = replaceFormula(turnOrderFormula, [['pc', pcNum]])
        let num = strCalculation(formula)
        if (num < 0) {
          num = 0
        }
        let modStr = getSpellEffectList(getSpellEffect('pc', pcNum))
        modStr = getSpecifiedSpellEffect(modStr, 83)
        if (!modStr.match(/^(| |0)$/)) {
          modStr = modStr.replace(/my\./g, 'pc.')
          formula = replaceFormula(modStr, [['pc', pcNum]])
          let modNum = Number(strCalculation(formula))
          num += modNum
          if (num < 0) {
            num = 0
          }
          printDebugMessage(
            getNameBattle(pc, 'pc', null, true) +
              ' Order of Action Correction: ' +
              modNum +
              ' (-> ' +
              num +
              ')'
          )
        }
        sortData.push([40 + i, num])
      }
    }
    turnOrderFormula = GameData['TURN_ORDER'].replace(/my\./g, 'monster.')
    for (let i = 0; i < 2; i++) {
      for (let j = 0; j < TempVariable['summonNum'][i]; j++) {
        let summonNum = PlayData['SummonList'][i][j]
        let summon = SUMMON[summonNum]
        if (summon.possibleToAction()) {
          let formula = replaceFormula(turnOrderFormula, [
            ['monster', summonNum + 50]
          ])
          let num = strCalculation(formula)
          if (num < 0) {
            num = 0
          }
          let modStr = getSpellEffectList(getSpellEffect('summon', summonNum))
          modStr = getSpecifiedSpellEffect(modStr, 83)
          if (!modStr.match(/^(| |0)$/)) {
            modStr = modStr.replace(/my\./g, 'monster.')
            formula = replaceFormula(modStr, [['monster', summonNum + 50]])
            let modNum = Number(strCalculation(formula))
            num += modNum
            if (num < 0) {
              num = 0
            }
            printDebugMessage(
              getNameBattle(summon, 'summon', [i, j], true) +
                ' Order of Action Correction: ' +
                modNum +
                ' (-> ' +
                num +
                ')'
            )
          }
          sortData.push([50 + i * 10 + j, num])
        }
      }
    }
    for (let i = 0; i < 4; i++) {
      for (let j = 0; j < TempVariable['monsterNum'][i]; j++) {
        let monNum = PlayData['MonsterList'][i][j]
        let mon = MONSTER[monNum]
        if (mon.possibleToAction()) {
          let formula = replaceFormula(turnOrderFormula, [['monster', monNum]])
          let num = strCalculation(formula)
          if (num < 0) {
            num = 0
          }
          let modStr = getSpellEffectList(getSpellEffect('monster', monNum))
          modStr = getSpecifiedSpellEffect(modStr, 83)
          if (!modStr.match(/^(| |0)$/)) {
            modStr = modStr.replace(/my\./g, 'monster.')
            formula = replaceFormula(modStr, [['monster', monNum]])
            let modNum = Number(strCalculation(formula))
            num += modNum
            if (num < 0) {
              num = 0
            }
            printDebugMessage(
              getNameBattle(mon, 'monster', [i, j], true) +
                ' Order of Action Correction: ' +
                modNum +
                ' (-> ' +
                num +
                ')'
            )
          }
          sortData.push([i * 10 + j, num])
        }
      }
    }
    sortData.sort(function (a, b) {
      return b[1] - a[1]
    })
    TempVariable['turnAction'] = []
    for (let i = 0; i < sortData.length; i++) {
      TempVariable['turnAction'].push(sortData[i][0])
    }
    GameState = 'battleTurnAction'
    battleAction()
    return
  } else if (GameState == 'battleRun') {
    controlFlag(TempVariable['flagRun'], false)
    pt.X = pt.PreX
    pt.Y = pt.PreY
    pt.battleReset()
    pt.check()
    sortNoAction()
    deleteTempVariable()
    if (GameData['SAVE_BATTLE_END']) {
      saveData('Battle end (It returns to the dungeon)')
    }
    GameState = 'moveStart'
    dungeonAction('view')
    return
  } else if (GameState == 'battleWin') {
    if (TempVariable['flagWin'] != '') {
      controlFlag(TempVariable['flagWin'], false)
      TempVariable['flagWin'] = ''
    }
    if (GameData['BOX_NOT_ALL_MONSTERS_RUN'] && !TempVariable['monsterKill']) {
      if (TempVariable['nonAlarmItemNum'] > 0) {
        let strAry = TempVariable['haveItem'].split(',')
        let str = ''
        for (let i = 0; i < TempVariable['nonAlarmItemNum']; i++) {
          if (i > 0) {
            str += ','
          }
          str += strAry[i]
        }
        TempVariable['haveItem'] = str
      } else {
        TempVariable['haveItem'] = ''
      }
      TempVariable['boxProb'] = 0
    }
    MP.clearMainWindow()
    if (TempVariable['battleMusic'] != 'no change') {
      musicStop()
    }
    sePlay('battleWin')
    pt.battleReset()
    sortNoAction()
    let text = getDefaultMessage('SURVIVOR_GOT_EXP')
    let memberNum = pt.getMemberNum(true)
    TempVariable['getExp'] = Math.ceil(
      calTimes(TempVariable['getExp'], GenericVariable['ExpGained'])
    )
    TempVariable['getExp'] = Math.floor(TempVariable['getExp'] / memberNum)
    text = text.replace(/\[exp\]/g, MP.numberFormat(TempVariable['getExp']))
    memberNum = pt.getMemberNum()
    for (let i = 0; i < memberNum; i++) {
      let pcNum = pt.PartyMember[i]
      let pc = PC[pcNum]
      if (pc.possibleToAction()) {
        pc.Exp += TempVariable['getExp']
      }
    }
    GameState = 'battleWin2NotEnterReturn'
    battleText('set', text)
    battleText()
    return
  } else if (GameState == 'battleWin2') {
    MP.clearMainWindow()
    if (TempVariable['haveItem'] != '') {
      if (TempVariable['appearanceChest']) {
        TempVariable['getChestItem'] = true
      }
      let strAry = TempVariable['haveItem'].split(',')
      let itemNum = Number(strAry[0])
      if (itemNum < 0 || itemNum >= ITEM.length) {
        itemNum = 0
      }
      let decided = 0
      let item = ITEM[itemNum]
      if (item.DECIDED == 0) {
        if (GameData['ITEM_DECIDED']) {
          decided = 1
        }
      } else if (item.DECIDED == 1) {
        decided = 1
      }
      let member = pt.putItem(itemNum, decided)
      let text = ''
      if (member > -1) {
        if (decided == 1) {
          PlayData['ItemFlag'][itemNum] = true
        }
        text = getDefaultMessage('FOUND_ITEM')
        let pcNum = pt.PartyMember[member]
        let pc = PC[pcNum]
        let str = pc.Name[0]
        text = text.replace(/\[name\]/g, str)
        str = item.NAME[decided]
        text = text.replace(/\[item\]/g, str)
        str = ''
        for (let i = 1; i < strAry.length; i++) {
          if (i > 1) {
            str += ','
          }
          str += strAry[i]
        }
        TempVariable['haveItem'] = str
      } else {
        text = getDefaultMessage('CANNOT_CARRY_MORE')
        TempVariable['haveItem'] = ''
      }
      paintBox('boxOpen')
      GameState = 'battleWin2Return'
      battleText('push', text)
      battleText()
    } else {
      if (TempVariable['boxProb'] > 0) {
        printDebugMessage(
          'Appearance rate of Treasure Chest: ' +
            String(TempVariable['boxProb']) +
            '%'
        )
      }
      if (TempVariable['boxProb'] >= dice(1, 100)) {
        TempVariable['boxProb'] = 0
        if (
          GameData['BOX_NOT'] ||
          MONSTER_DATA[TempVariable['firstMonster']].BOX_NOT
        ) {
          TempVariable['appearanceChest'] = false
          TempVariable['getChestItem'] = false
          setBoxItem(false)
          battleAction()
        } else {
          battleText('clear')
          TempVariable['appearanceChest'] = true
          TempVariable['getChestItem'] = false
          TempVariable['inspectTrap'] = -2
          sortNoAction()
          let str
          if (TempVariable['trapStr'] != '') {
            str = TempVariable['trapStr']
          } else if (MONSTER_DATA[TempVariable['firstMonster']].TRAP != '') {
            str = MONSTER_DATA[TempVariable['firstMonster']].TRAP
          } else {
            str = DUNGEON.BoxTrap[pt.DungeonNumber][pt.Floor]
          }
          let strAry = str.split('<>')
          TempVariable['trapLv'] = Number(strAry[0])
          let strAry2 = strAry[1].split(',')
          TempVariable['trap'] = Number(strAry2[dice(1, strAry2.length) - 1])
          if (TempVariable['trap'] >= GameData['TRAP_NAME'].length) {
            TempVariable['trap'] = GameData['TRAP_NAME'].length - 1
          }
          if (TempVariable['battleMusic'] != 'no change') {
            musicPlay(GameData['BOX_MUSIC'])
          }
          paintBox('boxClose')
          GameState = 'battleBox'
          GameMode = 'box'
          battleAction()
        }
      } else {
        TempVariable['boxProb'] = 0
        if (TempVariable['getGold'] < 0) {
          if (
            !TempVariable['alarm'] &&
            GameData['BOX_NOT_ALL_MONSTERS_RUN'] &&
            !TempVariable['monsterKill']
          ) {
            TempVariable['getGold'] = 0
          } else {
            TempVariable['getGold'] = getGold()
          }
        }
        TempVariable['getGold'] = shareGold(TempVariable['getGold'])
        if (TempVariable['getGold'] == 0) {
          if (
            TempVariable['appearanceChest'] &&
            !TempVariable['getChestItem']
          ) {
            let text = getDefaultMessage('CHEST_EMPTY')
            GameState = 'battleEndReturn'
            battleText('push', text)
            battleText()
          } else {
            GameState = 'battleEnd'
            battleAction()
          }
        } else {
          paintBox('boxOpen')
          let text = getDefaultMessage('SURVIVOR_GOT_GOLD')
          text = text.replace(
            /\[gold\]/g,
            MP.numberFormat(TempVariable['getGold'])
          )
          text = text.replace(/\[GP\]/g, GameData['GP'])
          GameState = 'battleEndReturn'
          battleText('push', text)
          battleText()
        }
      }
    }
    return
  } else if (GameState == 'battleBox') {
    MP.controlPreSelect('clear')
    if (key == 'enter') {
      MP.controlPreSelect('push')
      if (value == 'inspect') {
        GameState = 'battleBoxInspect'
      } else if (value == 'disarm') {
        GameState = 'battleBoxDisarm'
      } else if (value == 'cast') {
        GameState = 'battleBoxCast'
      } else if (value == 'item') {
        GameState = 'battleBoxItem'
      } else if (value == 'open') {
        GameState = 'battleBoxOpen'
      } else if (value == 'leave') {
        GameState = 'battleEnd'
      }
      battleAction()
      return
    }
    MP.clearTextSurface('full')
    MP.viewPartyStatus('clear')
    MP.drawTextFrame(
      MP.TextSurface[MP.TextSurfaceNum],
      getDefaultMessage('CHEST'),
      'center',
      MP.LINE_HEIGHT * 0.5,
      54,
      2,
      'center'
    )
    MP.TextSurfaceNum++
    selAry.push(getDefaultMessage('CHEST_INSPECT', 1, 20))
    valueAry.push('inspect')
    if (GameData['TRAP_NAME'].length > 0) {
      selAry.push(getDefaultMessage('CHEST_DISARM', 1, 20))
      valueAry.push('disarm')
    }
    let spaceSpellUsedNum = DUNGEON.checkSpaceSpellUsed(
      pt.DungeonNumber,
      pt.Floor,
      pt.X,
      pt.Y
    )
    if (
      pt.boxSpell() > -1 &&
      spaceSpellUsedNum != 0 &&
      spaceSpellUsedNum != 2
    ) {
      selAry.push(getDefaultMessage('CAST', 1, 20))
      valueAry.push('cast')
    }
    if (pt.boxItem() > -1 && spaceSpellUsedNum != 1 && spaceSpellUsedNum != 2) {
      selAry.push(getDefaultMessage('BATTLE_ITEM', 1, 20))
      valueAry.push('item')
    }
    selAry.push(getDefaultMessage('CHEST_OPEN', 1, 20))
    valueAry.push('open')
    selAry.push(getDefaultMessage('CHEST_LEAVE', 1, 20))
    valueAry.push('leave')
    align = MP.MAIN_X + MP.MAIN_WIDTH / 2 + (MP.FONT_SIZE / 2) * 8
    y *= 4
  } else if (GameState.match(/^battleBox(Inspect|Disarm|Cast|Item|Open)$/)) {
    if (
      key == 'cancel' ||
      (GameState.indexOf('Item') > -1 && pt.boxItem() < 0)
    ) {
      MP.controlPreSelect('pop')
      GameState = 'battleBox'
      battleAction('return')
      return
    } else if (key == 'enter') {
      PlayData['StatusNum'] = Number(value)
      let pc = PC[PlayData['StatusNum']]
      if (pc.possibleToAction()) {
        if (GameState.indexOf('Inspect') > -1) {
          if (pc.InspectTrap[0] < -1) {
            let formula = GameData['BOX_INSPECT']
            formula = formula.replace(
              /trap\.lv/g,
              String(TempVariable['trapLv'])
            )
            formula = replaceFormula(formula, [['pc', PlayData['StatusNum']]])
            let prob = Math.floor(strCalculation(formula))
            if (prob < 0) {
              prob = 0
            } else if (prob > 100) {
              prob = 100
            }
            printDebugMessage(
              'trap inspect success rate: ' + String(prob) + '%'
            )
            let inspectTrap = -1
            if (prob >= dice(1, 100)) {
              printDebugMessage('  -> success')
              inspectTrap = TempVariable['trap']
            } else {
              formula = GameData['TRAP_PROB']
              formula = formula.replace(
                /trap\.lv/g,
                String(TempVariable['trapLv'])
              )
              formula = replaceFormula(formula, [['pc', PlayData['StatusNum']]])
              prob = Math.floor(strCalculation(formula))
              if (prob < 0) {
                prob = 0
              } else if (prob > 100) {
                prob = 100
              }
              printDebugMessage('trap operate rate: ' + String(prob) + '%')
              if (prob >= dice(1, 100)) {
                if (TempVariable['trap'] < 0) {
                  MP.clearTextSurface('full')
                  MP.viewPartyStatus('clear')
                  MP.drawTextFrame(
                    MP.TextSurface[MP.TextSurfaceNum],
                    '\n' + getDefaultMessage('TRAP_NOT', 1),
                    'center',
                    MP.LINE_HEIGHT * 0.5,
                    54,
                    2,
                    'center'
                  )
                  GameState = 'battleWin2Return'
                  setBoxItem(false)
                } else {
                  GameState = 'battleTrap'
                  battleAction()
                }
                return
              }
              inspectTrap = dice(1, GameData['TRAP_NAME'].length + 1) - 2
            }
            pc.InspectTrap[0] = inspectTrap
            pc.InspectTrap[1] = inspectTrap
            TempVariable['inspectTrap'] = inspectTrap
          } else {
            pc.InspectTrap[1] = pc.InspectTrap[0]
            TempVariable['inspectTrap'] = pc.InspectTrap[0]
          }
          MP.clearTextSurface('full')
          MP.viewPartyStatus('clear')
          let str = ''
          if (pc.InspectTrap[0] < 0) {
            str = getDefaultMessage('TRAPLESS', 1)
          } else {
            str = GameData['TRAP_NAME'][pc.InspectTrap[0]]
          }
          MP.drawTextFrame(
            MP.TextSurface[MP.TextSurfaceNum],
            '\n' + str,
            'center',
            MP.LINE_HEIGHT * 0.5,
            54,
            2,
            'center'
          )
          MP.controlPreSelect('pop')
          GameState = 'battleBoxReturn'
          return
        } else if (GameState.indexOf('Disarm') > -1) {
          GameState = 'battleBoxDisarm2'
          battleAction()
          return
        } else if (GameState.indexOf('Cast') > -1) {
          if (pc.boxSpell() > -1) {
            GameState = 'battleBoxCastLv'
            battleAction()
            return
          }
        } else if (GameState.indexOf('Item') > -1) {
          if (pc.boxItem() > 0) {
            GameState = 'battleBoxItem2'
            battleAction()
            return
          }
        } else if (GameState.indexOf('Open') > -1) {
          if (TempVariable['trap'] < 0) {
            MP.clearTextSurface('full')
            MP.viewPartyStatus('clear')
            MP.drawTextFrame(
              MP.TextSurface[MP.TextSurfaceNum],
              '\n' + getDefaultMessage('TRAP_NOT', 1),
              'center',
              MP.LINE_HEIGHT * 0.5,
              54,
              2,
              'center'
            )
            GameState = 'battleWin2Return'
            setBoxItem(false)
          } else {
            GameState = 'battleTrap'
            battleAction()
          }
          return
        }
      }
    }
    MP.clearTextSurface('full')
    MP.TopSurface.clear()
    MP.drawTextFrame(
      MP.TextSurface[MP.TextSurfaceNum],
      getDefaultMessage('CHEST'),
      'center',
      MP.LINE_HEIGHT * 0.5,
      54,
      2,
      'center'
    )
    MP.TextSurfaceNum++
    let str = ''
    if (GameState.indexOf('Inspect') > -1) {
      str = 'CHEST_WHO_INSPECT'
      value = pt.boxTrap(GameData['BOX_INSPECT'], TempVariable['trapLv'])
    } else if (GameState.indexOf('Disarm') > -1) {
      str = 'CHEST_WHO_DISARM'
      value = pt.boxTrap(GameData['BOX_DISARM'], TempVariable['trapLv'])
    } else if (GameState.indexOf('Cast') > -1) {
      str = 'CHEST_WHO_SPELL'
      value = pt.boxSpell()
    } else if (GameState.indexOf('Item') > -1) {
      str = 'CHEST_WHO_ITEM'
      value = pt.boxItem()
    } else if (GameState.indexOf('Open') > -1) {
      str = 'CHEST_WHO_OPEN'
    }
    MP.drawTextFrame(
      MP.TextSurface[MP.TextSurfaceNum],
      getDefaultMessage(str, 1),
      'center',
      MP.LINE_HEIGHT * 5
    )
    MP.TextSurfaceNum++
    let memberNum = pt.getMemberNum()
    for (let i = 0; i < memberNum; i++) {
      selAry.push(String(i))
      valueAry.push(String(pt.PartyMember[i]))
    }
    mode = 'pcSel'
  } else if (GameState == 'battleBoxDisarm2') {
    if (key == 'cancel') {
      GameState = 'battleBoxDisarm'
      battleAction()
      return
    } else if (key == 'enter') {
      let disarmTrap = value
      if (TempVariable['trap'] < 0) {
        MP.clearTextSurface('full')
        MP.drawTextFrame(
          MP.TextSurface[MP.TextSurfaceNum],
          '\n' + getDefaultMessage('TRAP_NOT', 1),
          'center',
          MP.LINE_HEIGHT * 0.5,
          54,
          2,
          'center'
        )
        GameState = 'battleWin2Return'
        setBoxItem(false)
      } else if (TempVariable['trap'] != disarmTrap) {
        GameState = 'battleTrap'
        battleAction()
      } else {
        let formula = GameData['BOX_DISARM']
        formula = formula.replace(/trap\.lv/g, String(TempVariable['trapLv']))
        formula = replaceFormula(formula, [['pc', PlayData['StatusNum']]])
        prob = Math.floor(strCalculation(formula))
        if (prob < 0) {
          prob = 0
        } else if (prob > 100) {
          prob = 100
        }
        printDebugMessage('trap disarm rate: ' + String(prob) + '%')
        if (prob >= dice(1, 100)) {
          MP.clearTextSurface('full')
          MP.drawTextFrame(
            MP.TextSurface[MP.TextSurfaceNum],
            '\n' + getDefaultMessage('TRAP_DISARM', 1),
            'center',
            MP.LINE_HEIGHT * 0.5,
            54,
            2,
            'center'
          )
          GameState = 'battleWin2Return'
          setBoxItem(false)
        } else {
          formula = GameData['TRAP_PROB']
          formula = formula.replace(/trap\.lv/g, String(TempVariable['trapLv']))
          formula = replaceFormula(formula, [['pc', PlayData['StatusNum']]])
          prob = Math.floor(strCalculation(formula))
          if (prob < 0) {
            prob = 0
          } else if (prob > 100) {
            prob = 100
          }
          printDebugMessage('trap operate rate: ' + String(prob) + '%')
          if (prob >= dice(1, 100)) {
            GameState = 'battleTrap'
            battleAction()
          } else {
            PC[PlayData['StatusNum']].InspectTrap[1] = TempVariable['trap']
            MP.clearTextSurface('full')
            MP.drawTextFrame(
              MP.TextSurface[MP.TextSurfaceNum],
              getDefaultMessage('TRAP_DISARM_NOT', 1),
              'center',
              MP.LINE_HEIGHT * 0.5,
              54,
              2,
              'center'
            )
            MP.controlPreSelect('pop')
            GameState = 'battleBoxReturn'
          }
        }
      }
      return
    }
    MP.clearTextSurface('full')
    MP.viewPartyStatus('clear')
    MP.drawTextFrame(
      MP.TextSurface[MP.TextSurfaceNum],
      getDefaultMessage('CHEST'),
      'center',
      MP.LINE_HEIGHT * 0.5,
      54,
      2,
      'center'
    )
    MP.TextSurfaceNum++
    align = MP.MAIN_X + MP.MAIN_WIDTH / 2 + (MP.FONT_SIZE / 2) * 8
    MP.drawTextFrame(
      MP.TextSurface[MP.TextSurfaceNum],
      getDefaultMessage('CHEST_TRAP', 1, 20),
      align,
      MP.LINE_HEIGHT * 4
    )
    MP.TextSurfaceNum++
    for (let i = 0; i < GameData['TRAP_NAME'].length; i++) {
      selAry.push(GameData['TRAP_NAME'][i])
      valueAry.push(i)
    }
    let pc = PC[PlayData['StatusNum']]
    if (pc.InspectTrap[1] > -1) {
      value = pc.InspectTrap[1]
    } else if (TempVariable['inspectTrap'] > -1) {
      value = TempVariable['inspectTrap']
    }
    y *= 6
  } else if (GameState == 'battleBoxCastLv') {
    let pc = PC[PlayData['StatusNum']]
    if (key == 'cancel') {
      GameState = 'battleBoxCast'
      battleAction()
      return
    } else if (key == 'enter') {
      let ary = pc.getLearnedSpell(
        3,
        MP.SelectMode['select'],
        MP.SelectMode['selectF']
      )
      if (ary.length > 0) {
        MP.controlPreSelect('push')
        MP.controlPreSelect('push')
        GameState = 'battleBoxCastSpell'
        battleAction()
        return
      }
      value = MP.SelectMode['select']
    } else if (key == '') {
      let spell = pc.boxSpell()
      let kind = Math.floor(spell / 100)
      spell %= 100
      let lv = Math.floor(spell / 10)
      spell %= 10
      MP.SelectMode['select'] = kind
      MP.SelectMode['selectF'] = lv
    }
    MP.clearTextSurface('full')
    MP.drawTextFrame(
      MP.TextSurface[MP.TextSurfaceNum],
      getDefaultMessage('CHEST'),
      'center',
      MP.LINE_HEIGHT * 0.5,
      54,
      2,
      'center'
    )
    MP.TextSurfaceNum++
    mode = 'spellLvSel'
    comment = 'spellLv'
    y *= 5.5
  } else if (GameState == 'battleBoxCastSpell') {
    let pcNum = PlayData['StatusNum']
    let pc = PC[pcNum]
    if (key == 'enter') {
      let kind = MP.PreSelect['select'][2]
      let lv = MP.PreSelect['selectF'][2]
      let spell = Number(MP.SelectMode['valueAry'][MP.SelectMode['select']])
      let spellData = decomposeSpell(
        spellEffectReplace(GameData['SPELL_EFFECT'][kind][lv][spell], 5),
        pcNum
      )
      let spellSelNum = 0
      if (spellData['spellEffect'].length > 1) {
        spellSelNum = dice(1, spellData['spellEffect'].length) - 1
      }
      SPELL_EF.spellEffect(
        spellData,
        spellSelNum,
        'boxSpell',
        pt.getMemberForPcNum(pcNum)
      )
      GameState = 'battleBoxSpellOrItemActivate'
      battleAction()
      return
    } else if (key == 'cancel') {
      let preSel = MP.PreSelect['selectF'][2]
      MP.controlPreSelect('pop')
      MP.controlPreSelect('pop')
      GameState = 'battleBoxCastLv'
      MP.SelectMode['valueAry'][MP.SelectMode['select']] =
        MP.SelectMode['select']
      MP.SelectMode['selectF'] = preSel
      battleAction('return')
      return
    }
    MP.clearTextSurface('full')
    MP.drawTextFrame(
      MP.TextSurface[MP.TextSurfaceNum],
      getDefaultMessage('CHEST'),
      'center',
      MP.LINE_HEIGHT * 0.5,
      54,
      2,
      'center'
    )
    MP.PreSelect['selectF'][1] = MP.PreSelect['selectF'][2]
    MP.viewPreSelectMode(MP.TextSurfaceNum, 1, 'none')
    MP.TextSurfaceNum++
    MP.SelectMode['selectF'] = 0
    let kind = MP.PreSelect['select'][2]
    let lv = MP.PreSelect['selectF'][2]
    let ary = pc.getLearnedSpell(3, kind, lv)
    colorAry = []
    for (let i = 0; i < ary.length; i++) {
      let strAry = GameData['SPELL'][kind][lv][ary[i]].split('<>')
      selAry.push(strAry[0])
      valueAry.push(String(ary[i]))
      if (
        pc.Mp[kind][lv] >= GameData['SPELL_CONSUMPTION_MP'][kind][lv][ary[i]]
      ) {
        colorAry.push('white')
      } else {
        colorAry.push('gray')
      }
    }
    align = MP.MAIN_X + MP.MAIN_WIDTH / 2 - (MP.FONT_SIZE / 2) * 12
    y *= 7 + GameData['SPELL_KIND']
    charMin = 24
    lineNum = 6
    mode = 'spellSel'
    comment = 'spell'
  } else if (GameState == 'battleBoxItem2') {
    let pcNum = PlayData['StatusNum']
    let pc = PC[pcNum]
    if (key == 'cancel' || pc.boxItem() < 1) {
      GameState = 'battleBoxItem'
      battleAction()
      return
    } else if (key == 'enter') {
      TempVariable['haveNum'] = Number(value)
      let itemNum = pc.Item[TempVariable['haveNum']]
      let item = ITEM[itemNum]
      let spellData = decomposeSpell(spellEffectReplace(item.USE, 5), pcNum)
      let spellSelNum = 0
      if (spellData['spellEffect'].length > 1) {
        spellSelNum = dice(1, spellData['spellEffect'].length) - 1
      }
      SPELL_EF.spellEffect(
        spellData,
        spellSelNum,
        'boxItem',
        pt.getMemberForPcNum(pcNum)
      )
      GameState = 'battleBoxSpellOrItemActivate'
      battleAction()
      return
    }
    MP.clearTextSurface('full')
    MP.TopSurface.clear()
    MP.drawTextFrame(
      MP.TextSurface[MP.TextSurfaceNum],
      getDefaultMessage('CHEST'),
      'center',
      MP.LINE_HEIGHT * 0.5,
      54,
      2,
      'center'
    )
    MP.TextSurfaceNum++
    let itemMax = pc.haveItemNum(-1)
    for (let i = 0; i < itemMax; i++) {
      if (pc.boxItem(i) > 0) {
        selAry.push(pc.getItemName(i, 'equip'))
        valueAry.push(String(i))
      }
    }
    y *= 5.5
    charMin = 26
    lineNum = pc.ItemMaxNum
    if (lineNum > 12) {
      lineNum = 12
    }
    comment = 'haveItem'
  } else if (GameState == 'battleBoxSpellOrItemActivate') {
    MP.clearTextSurface('full')
    MP.viewPartyStatus('clear')
    let pcNum = PlayData['StatusNum']
    let pc = PC[pcNum]
    let text = ''
    let effect = SPELL_EF.Effect
    if (effect.indexOf('boxInspect') > -1) {
      sePlay('spell')
      let inspectTrap
      if (effect.indexOf('True') > -1) {
        inspectTrap = TempVariable['trap']
      } else {
        inspectTrap = dice(1, GameData['TRAP_NAME'].length + 1) - 2
      }
      pc.InspectTrap[1] = inspectTrap
      TempVariable['inspectTrap'] = inspectTrap
      if (inspectTrap < 0) {
        text = getDefaultMessage('TRAPLESS', 1)
      } else {
        text = GameData['TRAP_NAME'][inspectTrap]
      }
      GameState = 'battleBoxReturn'
    } else if (effect.indexOf('boxDisarm') > -1) {
      sePlay('spell')
      if (effect.indexOf('True') > -1) {
        text = getDefaultMessage('TRAP_DISARM', 1)
        GameState = 'battleWin2Return'
        setBoxItem(false)
      } else {
        text = getDefaultMessage('TRAP_DISARM_NOT', 1)
        GameState = 'battleBoxReturn'
      }
    } else {
      sePlay('enter')
      text = getDefaultMessage('CAST_NO_HAPPEN', 1)
      GameState = 'battleBoxReturn'
    }
    MP.drawTextFrame(
      MP.TextSurface[MP.TextSurfaceNum],
      '\n' + text,
      'center',
      MP.LINE_HEIGHT * 0.5,
      54,
      2,
      'center'
    )
    return
  } else if (GameState == 'battleTrap') {
    MP.clearTextSurface('full')
    MP.viewPartyStatus('clear')
    MP.drawTextFrame(
      MP.TextSurface[MP.TextSurfaceNum],
      '\n' + getDefaultMessage('TRAP_TRIGGERED', 1),
      'center',
      MP.LINE_HEIGHT * 0.5,
      54,
      2,
      'center'
    )
    GameState = 'battleTrap2Return'
    return
  } else if (GameState == 'battleTrap2') {
    MP.clearMainWindow()
    let strAry = GameData['TRAP_EFFECT'][TempVariable['trap']].split('<++>')
    TempVariable['trapSe'] = strAry[2]
    let strAry2 = strAry[1].split(',')
    let trapTarget = Number(strAry2[0])
    let trapProb = strAry2[1]
    trapProb = trapProb.replace(/trap\.lv/g, String(TempVariable['trapLv']))
    let trapEffect = spellEffectReplace(strAry[0], 3)
    trapEffect = trapEffect.replace(/trap\.lv/g, String(TempVariable['trapLv']))
    SPELL_EF.clearSpellEffect()
    if (trapTarget == 0) {
      let pcNum = PlayData['StatusNum']
      let formula = replaceFormula(trapProb, [['pc', pcNum]])
      let prob = Math.floor(strCalculation(formula))
      if (prob < 0) {
        prob = 0
      } else if (prob > 100) {
        prob = 100
      }
      if (prob >= dice(1, 100)) {
        let spellData = decomposeSpell(trapEffect)
        let spellSelNum = 0
        if (spellData['spellEffect'].length > 1) {
          spellSelNum = dice(1, spellData['spellEffect'].length) - 1
        }
        SPELL_EF.spellEffect(spellData, spellSelNum, 'trap')
      }
    } else {
      let start = 0,
        end = pt.getMemberNum()
      if (trapTarget == 1) {
        start = pt.getMemberForPcNum(PlayData['StatusNum'])
        end = start + 1
      }
      for (let i = start; i < end; i++) {
        let pcNum = pt.PartyMember[i]
        let formula = replaceFormula(trapProb, [['pc', pcNum]])
        let prob = Math.floor(strCalculation(formula))
        if (prob < 0) {
          prob = 0
        } else if (prob > 100) {
          prob = 100
        }
        if (prob >= dice(1, 100)) {
          let spellData = decomposeSpell(trapEffect, pcNum)
          let spellSelNum = 0
          if (spellData['spellEffect'].length > 1) {
            spellSelNum = dice(1, spellData['spellEffect'].length) - 1
          }
          let charNum = pt.getMemberForPcNum(pcNum)
          SPELL_EF.spellEffect(spellData, spellSelNum, 'trap', charNum, charNum)
        }
      }
    }
    if (SPELL_EF.Effect.indexOf('eleport') < 0 && SPELL_EF.Effect != 'return') {
      sePlay(TempVariable['trapSe'])
    }
    let text = getDefaultMessage('TRAP_OOPS', 1) + '\n'
    text += MP.strFitLength(
      GameData['TRAP_NAME'][TempVariable['trap']],
      54,
      'center'
    )
    MP.drawTextFrame(
      MP.TextSurface[MP.TextSurfaceNum],
      text,
      'center',
      MP.LINE_HEIGHT * 0.5,
      54,
      2
    )
    MP.viewPartyStatus()
    GameState = 'battleTrap3Return'
    return
  } else if (GameState == 'battleTrap3') {
    MP.clearTextSurface('full')
    if (SPELL_EF.MessageStack[0].length > 0) {
      let text = SPELL_EF.MessageStack[0].shift()
      text = text.replace(/<p>/g, '<br>')
      text = MP.strChangeLine(text, 52, 5, true)
      MP.drawTextFrame(
        MP.TextSurface[MP.TextSurfaceNum],
        text,
        'center',
        MP.LINE_HEIGHT * 8,
        52
      )
      GameState = 'battleTrap3Return'
      return
    }
    if (pt.checkAnnihilate()) {
      GameMode = ''
      GameState = 'battleAnnihilate'
      battleAction()
      return
    }
    if (
      SPELL_EF.Effect.indexOf('eleport') > -1 ||
      SPELL_EF.Effect == 'return'
    ) {
      sePlay(TempVariable['trapSe'])
      setBoxItem(false)
      let strAry = TempVariable['haveItem'].split(',')
      for (let i = 0; i < strAry.length; i++) {
        if (strAry[i] == '') {
          break
        }
        let itemNum = Number(strAry[i])
        if (itemNum < 0 || itemNum >= ITEM.length) {
          itemNum = 0
        }
        let decided = 0
        let item = ITEM[itemNum]
        if (item.DECIDED == 0) {
          if (GameData['ITEM_DECIDED']) {
            decided = 1
          }
        } else if (item.DECIDED == 1) {
          decided = 1
        }
        if (pt.putItem(itemNum, decided) < 0) {
          break
        }
        if (decided == 1) {
          PlayData['ItemFlag'][itemNum] = true
        }
      }
      if (TempVariable['getGold'] < 0) {
        TempVariable['getGold'] = getGold()
      }
      shareGold(TempVariable['getGold'])
      if (SPELL_EF.Effect.indexOf('teleport') > -1) {
        strAry = SPELL_EF.Effect.split(',')
        let teleportPoint = SPELL_EF.getPointRandomTeleport(
          ptNum,
          strAry[1],
          strAry[3],
          true
        )
        TempVariable['nextDungeon'] = pt.DungeonNumber
        TempVariable['nextFloor'] = teleportPoint[0]
        TempVariable['nextX'] = teleportPoint[1]
        TempVariable['nextY'] = teleportPoint[2]
        if (TempVariable['roomNum'] > -1) {
          DUNGEON.CheckedMonsterRoom[TempVariable['roomNum']] = true
        }
      } else if (SPELL_EF.Effect == 'return') {
        TempVariable['nextDungeon'] = -1
        TempVariable['nextFloor'] = -1
        TempVariable['nextX'] = 0
        TempVariable['nextY'] = 0
      } else if (SPELL_EF.Effect.indexOf('coordinateTeleport') > -1) {
        let ary = SPELL_EF.Effect.split(',')
        let tp = [
          Number(ary[1]),
          Number(ary[2]),
          Number(ary[3]),
          Number(ary[4])
        ]
        if (tp[0] < 0) {
          TempVariable['nextDungeon'] = -1
          TempVariable['nextFloor'] = -1
          TempVariable['nextX'] = 0
          TempVariable['nextY'] = 0
        } else {
          TempVariable['nextDungeon'] = tp[0]
          TempVariable['nextFloor'] = tp[1]
          TempVariable['nextX'] = tp[2]
          TempVariable['nextY'] = tp[3]
          if (TempVariable['roomNum'] > -1) {
            DUNGEON.CheckedMonsterRoom[TempVariable['roomNum']] = true
          }
        }
      }
      GenericVariable['KeyInvalid'] = true
      GenericVariable['TimeEventCountMax'] = TIME_COUNT[1]
      GenericVariable['TimeEventCount'] = 0
      GenericVariable['TimeEvent'] = 'moveFloorFromTrap'
      return
    } else if (SPELL_EF.Effect.indexOf('alarm') > -1) {
      let strAry = SPELL_EF.Effect.split(',')
      setBoxItem(false)
      TempVariable['turn'] = 1
      TempVariable['monsterKill'] = false
      TempVariable['getExp'] = 0
      TempVariable['alarm'] = true
      TempVariable['eventBgm'] = ''
      pt.battleReset()
      pt.check()
      sortNoAction()
      setMonster(strAry[1], true)
      if (strAry[2] == 'true') {
        setBoxItem(true)
      }
      monsterDecidedCheck()
      for (let i = 0; i < 4; i++) {
        TempVariable['monsterDecidedChange'][i] = false
      }
      TempVariable['monsterLineChange'] = [false, false]
      TempVariable['battleStart'] = 'normal'
      GameState = 'battleStart'
      battleAction()
      return
    }
    setBoxItem(false)
    GameState = 'battleWin2'
    battleAction()
    return
  } else if (GameState == 'battleEnd') {
    if (TempVariable['roomNum'] > -1) {
      DUNGEON.CheckedMonsterRoom[TempVariable['roomNum']] = true
    }
    let eventAgain = TempVariable['eventAgain']
    pt.battleReset()
    pt.check()
    sortNoAction()
    deleteTempVariable()
    if (GameData['SAVE_BATTLE_END']) {
      saveData('Battle end (It returns to the dungeon)')
    }
    GameState = 'moveStart'
    if (eventAgain) {
      dungeonAction('step')
    } else {
      dungeonAction('view')
    }
    return
  } else if (GameState == 'battleAnnihilate') {
    controlFlag(TempVariable['flagAnnihilation'], false)
    GameState = 'annihilate'
    MP.viewRip()
    annihilateProcessing()
    return
  } else if (GameState == 'battleStatus') {
    MP.StatusTopSurface.clear()
    let num = TempVariable['viewStatus']
    let charType,
      cm,
      cmNum,
      cmNumInGroup = [0, -1]
    if (num < 10) {
      charType = 'pc'
      cmNumInGroup[0] = num
      cmNum = pt.PartyMember[cmNumInGroup[0]]
      cm = PC[cmNum]
    } else {
      charType = 'monster'
      cmNumInGroup[0] = Math.floor((num - 10) / 10)
      cmNumInGroup[1] = num % 10
      cmNum = PlayData['MonsterList'][cmNumInGroup[0]][cmNumInGroup[1]]
      cm = MONSTER[cmNum]
    }
    let text = ''
    if (charType == 'pc') {
      text += MP.strFitLength(cm.Title, 7) + cm.Name[0]
    } else {
      if (TempVariable['monsterDecided'][cmNumInGroup[0]]) {
        text += MP.strFitLength(cm.Name[1], 25)
        let nameStr = ''
        if (cm.Name[0] != cm.Name[1]) {
          nameStr = '[' + cm.Name[0] + ']'
        }
        text += MP.strFitLength(nameStr, 23)
      } else {
        text += MP.strFitLength(cm.Name[0], 48)
      }
      text += '(' + String(cmNumInGroup[1] + 1) + ')'
    }
    text += '\n'
    text += MP.strFitLength('', 16)
    if (
      charType == 'pc' ||
      (charType == 'monster' && GameData['SPELL_EFFECT_INDICATED'][1])
    ) {
      text += MP.strFitLength(getDefaultMessage('LEVEL', 1, 6), 6, 'right')
      text += MP.strFitLength(String(cm.Level), 5)
    } else {
      text += MP.strFitLength('', 11)
    }
    if (
      charType == 'pc' ||
      (charType == 'monster' && GameData['SPELL_EFFECT_INDICATED'][2])
    ) {
      text += '  ' + MP.strFitLength(String(cm.Hp), 5, 'right') + ' / '
      text += MP.strFitLength(String(cm.HpMax), 5)
      if (cm.HpPlus != 0) {
        text += ' ('
        if (cm.HpPlus > 0) {
          text += '+'
        }
        text += String(cm.HpPlus) + ')'
      }
    }
    let line = 0
    let plusText = ''
    if (
      cm.State == 0 &&
      cm.Asleep == 0 &&
      cm.Silence == 0 &&
      cm.NoBreath == 0 &&
      !cm.SealSpell &&
      cm.Poison == 0 &&
      cm.Hate == -1
    ) {
      text +=
        '\n' + MP.strFitLength('', 16) + getDefaultMessage('STATUS_OK', 1, 10)
      line++
    } else {
      let count = 0
      let str = ''
      if (cm.State == 1) {
        str = 'STATUS_AFRAID'
      } else if (cm.State == 2) {
        str = 'STATUS_PARALYZED'
      } else if (cm.State == 3) {
        str = 'STATUS_STONED'
      } else if (cm.State == 4) {
        str = 'STATUS_DEAD'
      } else if (cm.State == 5) {
        str = 'STATUS_ASHED'
      } else if (cm.State == 6) {
        str = 'STATUS_LOST'
      }
      if (str != '') {
        plusText += getDefaultMessage(str, 1, 10)
        count++
      }
      if (cm.Asleep != 0) {
        if (plusText != '') {
          plusText += ', '
        }
        if (cm.Asleep > 0) {
          plusText += getDefaultMessage('STATUS_ASLEEP', 1, 10)
          plusText += '(' + String(cm.Asleep) + ')'
        } else {
          plusText += getDefaultMessage('STATUS_FAINTED', 1, 10)
        }
        count++
        if (count >= 2) {
          text += '\n' + MP.strFitLength('', 16) + plusText
          plusText = ''
          count = 0
          line++
        }
      }
      if (cm.NoBreath > 0) {
        if (plusText != '') {
          plusText += ', '
        }
        plusText += getDefaultMessage('STATUS_RESTRAINED', 1, 10)
        plusText += '(' + String(cm.NoBreath) + ')'
        count++
        if (count >= 2) {
          text += '\n' + MP.strFitLength('', 16) + plusText
          plusText = ''
          count = 0
          line++
        }
      }
      if (cm.Silence != 0) {
        if (plusText != '') {
          plusText += ', '
        }
        plusText += getDefaultMessage('STATUS_SILENCE', 1, 10)
        if (cm.Silence > 0) {
          plusText += '(' + String(cm.Silence) + ')'
        }
        count++
        if (count >= 2) {
          text += '\n' + MP.strFitLength('', 16) + plusText
          plusText = ''
          count = 0
          line++
        }
      }
      if (cm.SealSpell) {
        if (plusText != '') {
          plusText += ', '
        }
        plusText += getDefaultMessage('STATUS_SEAL_SPELL', 1, 10)
        count++
        if (count >= 2) {
          text += '\n' + MP.strFitLength('', 16) + plusText
          plusText = ''
          count = 0
          line++
        }
      }
      if (cm.Poison > 0) {
        if (plusText != '') {
          plusText += ', '
        }
        plusText += getDefaultMessage('STATUS_POISONED', 1, 10)
        plusText += '(' + String(cm.Poison) + ')'
        count++
        if (count >= 2) {
          text += '\n' + MP.strFitLength('', 16) + plusText
          plusText = ''
          count = 0
          line++
        }
      }
      if (cm.Hate > -1) {
        if (plusText != '') {
          plusText += ', '
        }
        plusText += getDefaultMessage('STATUS_HATED', 1, 10)
        let turn = cm.HateTurn + 1
        if (turn > 9999) {
          turn = 9999
        }
        if (turn > 0) {
          plusText += ':(' + String(turn) + ')'
        }
        count++
        if (count >= 2) {
          text += '\n' + MP.strFitLength('', 16) + plusText
          plusText = ''
          count = 0
          line++
        }
      }
      if (plusText != '') {
        text += '\n' + MP.strFitLength('', 16) + plusText
        line++
      }
    }
    line = 5 - line
    for (let i = 0; i < line; i++) {
      text += '\n'
    }
    text += MP.strFitLength(
      getDefaultMessage('NUMBER_OF_TURNS', 1, 20) +
        ':' +
        String(TempVariable['turn']),
      52,
      'right'
    )
    text += '\n'
    plusText = MP.viewStatusSpellEffect(cm, true)
    if (plusText == '') {
      text += '\n' + getDefaultMessage('SPELL_EFFECT', 1, 20) + ':'
      text += getDefaultMessage('NONE', 1, 20)
    } else {
      text += plusText
    }
    MP.drawTextFrame(
      MP.StatusTopSurface,
      text,
      'center',
      MP.LINE_HEIGHT,
      52,
      23
    )
    let faceData
    if (charType == 'pc') {
      if (GameData['FACE_GRAPHIC_STATUS']) {
        if (!cm.FaceGraphic.match(/^(| |none)$/)) {
          faceData = GraphicData['<>' + cm.FaceGraphic]
        } else {
          faceData = GraphicData['graphic/face/' + cm.Name[0]]
        }
      }
    } else {
      let decided = 0
      if (TempVariable['monsterDecided'][cmNumInGroup[0]]) {
        decided = 1
      }
      faceData =
        GraphicData[MONSTER_DATA[cm.MonsterDataNum].ConfirmedCG[decided]]
    }
    if (faceData != undefined && faceData != null) {
      let x = MP.MAIN_WIDTH / 2 - MP.FONT_SIZE * 13
      let y = MP.LINE_HEIGHT * 2.2
      let size = MP.FONT_SIZE * 7.5
      MP.paintGraphic(MP.StatusTopSurface, faceData, x, y, size, size)
      MP.drawFrame(
        MP.StatusTopSurface,
        x,
        y,
        size,
        size,
        MP.FRAME_ARC,
        MP.FRAME_WIDTH / 2,
        'white'
      )
    }
    return
  }
  MP.setSelectMode(
    battleAction,
    mode,
    selAry,
    valueAry,
    colorAry,
    comment,
    align,
    y,
    charMin,
    lineNum,
    textAlign,
    value,
    MP.SelectMode['selectF'],
    GameData['SELECT_COLOR']
  )
  function battleText (mode, text) {
    if (mode == undefined || mode == null) {
      mode = 'view'
    }
    if (text == undefined || text == null) {
      text = ''
    }
    if (mode == 'clear' || mode == 'set') {
      TempVariable['battleText'] = []
    }
    if (mode == 'push' || mode == 'set') {
      text = MP.strChangeLine(text, 54, 5, true)
      let strAry = text.split(/<br>|<p>|\r\n|\n|\r/)
      for (let i = 0; i < strAry.length; i++) {
        TempVariable['battleText'].push(strAry[i])
      }
    } else if (mode == 'view') {
      text = ''
      let start = TempVariable['battleText'].length - 5
      if (start < 0) {
        start = 0
      }
      let count = start
      for (let i = 0; i < 5; i++) {
        if (count >= TempVariable['battleText'].length) {
          break
        }
        if (i > 0) {
          text += '<br>'
        }
        text += TempVariable['battleText'][count]
        count++
      }
      MP.clearTextSurface()
      MP.drawTextFrame(
        MP.TextSurface[MP.TextSurfaceNum],
        text,
        'center',
        MP.LINE_HEIGHT * 0.5,
        54,
        5
      )
    }
  }
  function changeAlignmentFriendly (mode) {
    let ptNum = PlayData['ActiveParty']
    let pt = PARTY[ptNum]
    let memberNum = pt.getMemberNum()
    for (let i = 0; i < memberNum; i++) {
      let pcNum = pt.PartyMember[i]
      let pc = PC[pcNum]
      if (pc.State > 1) {
        continue
      }
      if (mode == 'fight') {
        if (pc.Alignment != 0) {
          continue
        }
      } else {
        if (pc.Alignment != 2) {
          continue
        }
      }
      let formula = replaceFormula(GameData['ALIGNMENT_PROB'], [['pc', pcNum]])
      let prob = Math.floor(strCalculation(formula))
      if (prob < 0) {
        prob = 0
      } else if (prob > 100) {
        prob = 100
      }
      if (prob < dice(1, 100)) {
        continue
      }
      if (mode == 'fight') {
        pc.Alignment = 2
      } else {
        pc.Alignment = 0
      }
      pc.check()
    }
  }
  function changeTarget (pcNum, action, target) {
    let ptNum = PlayData['ActiveParty']
    let pt = PARTY[ptNum]
    let pcNumInPt = pt.getMemberForPcNum(pcNum)
    let pc = PC[pcNum]
    let result = false
    if (action == 0 || action == 2) {
      let frontMonsterSurvives = false
      if (
        TempVariable['monsterNum'][0] > 0 ||
        TempVariable['monsterNum'][1] > 0
      ) {
        frontMonsterSurvives = true
      }
      let rearMonsterSurvives = false
      if (
        TempVariable['monsterNum'][2] > 0 ||
        TempVariable['monsterNum'][3] > 0
      ) {
        rearMonsterSurvives = true
      }
      let attackTarget = -1
      let rank = 0
      if (!pt.frontRankCheck(pcNumInPt)) {
        rank = 1
      }
      let range = [0, 0]
      if (action == 0) {
        range[0] = pc.Range[0]
        range[1] = pc.Range[1]
      } else {
        range[0] = 4
        range[1] = 4
      }
      if (target == 0 || target == 1) {
        if (frontMonsterSurvives) {
          attackTarget = 0
        } else if (rearMonsterSurvives) {
          if (range[rank] >= 4) {
            attackTarget = 1
          }
        }
      } else {
        if (rearMonsterSurvives) {
          attackTarget = 1
        } else if (frontMonsterSurvives) {
          if (range[rank] >= 2) {
            attackTarget = 0
          }
        }
      }
      if (attackTarget > -1) {
        if (attackTarget == 0) {
          if (TempVariable['monsterNum'][0] > 0) {
            pc.Action[2] = 0
          } else {
            pc.Action[2] = 1
          }
        } else if (attackTarget == 1) {
          if (TempVariable['monsterNum'][2] > 0) {
            pc.Action[2] = 2
          } else {
            pc.Action[2] = 3
          }
        }
        pc.Action[3] = -1
        result = true
      }
    } else if (action == 3) {
      let stack = []
      if (pc.Breath == 1) {
        for (let i = 0; i < 4; i++) {
          if (TempVariable['monsterNum'][i] > 0) {
            stack.push(i)
          }
        }
      } else {
        let max = Math.max.apply(null, TempVariable['monsterNum'])
        if (max > 0) {
          for (let i = 0; i < 4; i++) {
            if (TempVariable['monsterNum'][i] == max) {
              stack.push(i)
            }
          }
        }
      }
      if (stack.length > 0) {
        pc.Action[2] = stack[dice(1, stack.length) - 1]
        result = true
      }
    } else if (action == 5 || action == 6) {
      let stack = []
      for (let i = 0; i < 4; i++) {
        if (TempVariable['monsterNum'][i] > 0) {
          stack.push(i)
        }
      }
      if (stack.length > 0) {
        pc.Action[2] = stack[dice(1, stack.length) - 1] + 10
        result = true
      }
    } else if (action == 7) {
      let stack = []
      for (let i = 0; i < 4; i++) {
        if (TempVariable['monsterNum'][i] > 0) {
          let type =
            MONSTER_DATA[TempVariable['setMonster'][i]].TYPE.toString(16)
          if (GameData['CLASS_DISPELL_KIND'][pc.PcClass].indexOf(type) > -1) {
            stack.push(i)
          }
        }
      }
      if (stack.length > 0) {
        pc.Action[2] = stack[dice(1, stack.length) - 1]
        result = true
      }
    }
    return result
  }
  function checkBattleEnd () {
    let ptNum = PlayData['ActiveParty']
    let pt = PARTY[ptNum]
    let ck = true
    let memberNum = pt.getMemberNum()
    for (let i = 0; i < memberNum; i++) {
      let pcNum = pt.PartyMember[i]
      let pc = PC[pcNum]
      if (pc.State < 2 && pc.Asleep > -1) {
        ck = false
        break
      }
    }
    if (ck) {
      return 1
    }
    ck = true
    for (let i = 0; i < 4; i++) {
      if (TempVariable['monsterNum'][i] > 0) {
        ck = false
        break
      }
    }
    if (ck) {
      return 2
    }
    return 0
  }
  function commandNextPc () {
    let ptNum = PlayData['ActiveParty']
    let pt = PARTY[ptNum]
    let pcNum = PlayData['StatusNum']
    let pcNumInPt = pt.getMemberForPcNum(pcNum)
    let memberNum = pt.getMemberNum()
    PlayData['StatusNum'] = -2
    while (PlayData['StatusNum'] == -2) {
      pcNumInPt++
      if (pcNumInPt >= memberNum) {
        PlayData['StatusNum'] = -1
      } else {
        pcNum = pt.PartyMember[pcNumInPt]
        if (PC[pcNum].possibleToAction()) {
          PlayData['StatusNum'] = pcNum
        }
      }
    }
  }
  function commandPrevPc () {
    let ptNum = PlayData['ActiveParty']
    let pt = PARTY[ptNum]
    let pcNum, pcNumInPt
    if (PlayData['StatusNum'] < 0) {
      pcNumInPt = pt.getMemberNum()
    } else {
      pcNum = PlayData['StatusNum']
      pcNumInPt = pt.getMemberForPcNum(pcNum)
    }
    PlayData['StatusNum'] = -1
    while (PlayData['StatusNum'] == -1) {
      pcNumInPt--
      if (pcNumInPt < 0) {
        pcNumInPt = 0
      }
      pcNum = pt.PartyMember[pcNumInPt]
      pc = PC[pcNum]
      pc.battleActionReset()
      if (pcNumInPt == 0 || pc.possibleToAction()) {
        PlayData['StatusNum'] = pcNum
      }
    }
  }
  function frontHideCheck () {
    let result = true
    let ptNum = PlayData['ActiveParty']
    let pt = PARTY[ptNum]
    let memberNum = pt.getMemberNum()
    for (let i = 0; i < memberNum; i++) {
      if (!pt.frontRankCheck(i)) {
        break
      }
      let pcNum = pt.PartyMember[i]
      let pc = PC[pcNum]
      if (pc.State < 4 && !pc.Hide) {
        result = false
        break
      }
    }
    return result
  }
  function getBattleMusic (eventBgm, monsterBgm, normalBgm) {
    let music = ''
    if (eventBgm != '') {
      music = eventBgm
    } else if (monsterBgm != '') {
      music = monsterBgm
    } else {
      music = normalBgm
    }
    if (music == 'none') {
      music = ''
    }
    return music
  }
  function getGold () {
    let ptNum = PlayData['ActiveParty']
    let pt = PARTY[ptNum]
    let goldStr
    if (TempVariable['goldStr'] != '') {
      goldStr = TempVariable['goldStr']
    } else if (MONSTER_DATA[TempVariable['firstMonster']].GOLD != '') {
      goldStr = MONSTER_DATA[TempVariable['firstMonster']].GOLD
    } else {
      goldStr = DUNGEON.BoxGold[pt.DungeonNumber][pt.Floor]
    }
    if (goldStr.indexOf('monsterNum') > -1) {
      let reg = new RegExp(
        'monsterNum\\[' + String(TempVariable['firstMonster']) + '\\]',
        'g'
      )
      goldStr = goldStr.replace(reg, '1')
      goldStr = goldStr.replace(/monsterNum\[[0-9]+\]/g, '0')
    }
    let gold = Math.floor(strCalculation(goldStr))
    if (gold < 0) {
      gold = 0
    }
    return gold
  }
  function getSpellEffect (mode, cmNum) {
    let action = -1,
      action1 = -1
    let result = ''
    if (mode == 'pc') {
      action = PC[cmNum].Action[0]
      action1 = PC[cmNum].Action[1]
    } else if (mode == 'monster') {
      action = MONSTER[cmNum].Action[0]
      action1 = MONSTER[cmNum].Action[1]
    } else if (mode == 'summon') {
      action = SUMMON[cmNum].Action[0]
      action1 = SUMMON[cmNum].Action[1]
    }
    if (action == 5) {
      let itemNum = PC[cmNum].Item[action1]
      let strAry = ITEM[itemNum].USE.split('</>')
      result = spellEffectReplace(strAry[1], 1)
    } else if (action == 6) {
      let spellAry = decomposeSpellNum(action1)
      result = GameData['SPELL_EFFECT'][spellAry[0]][spellAry[1]][spellAry[2]]
      result = spellEffectReplace(result, 0)
    }
    return result
  }
  function healSpellCheck (type) {
    let result = ''
    let groupNum, tmpVarStr
    if (type == 'monster') {
      groupNum = 4
      tmpVarStr = 'monsterNum'
    } else {
      groupNum = 2
      tmpVarStr = 'summonNum'
    }
    for (let i = 0; i < groupNum; i++) {
      for (let j = 0; j < TempVariable[tmpVarStr][i]; j++) {
        let monNum, mon
        if (type == 'monster') {
          monNum = PlayData['MonsterList'][i][j]
          mon = MONSTER[monNum]
        } else {
          monNum = PlayData['SummonList'][i][j]
          mon = SUMMON[monNum]
        }
        if (mon.Hp < 1) {
          continue
        }
        result += healSpellCheckCharactor(mon)
      }
    }
    if (type == 'summon') {
      let ptNum = PlayData['ActiveParty']
      let pt = PARTY[ptNum]
      let memberNum = pt.getMemberNum()
      for (let i = 0; i < memberNum; i++) {
        let pcNum = pt.PartyMember[i]
        let pc = PC[pcNum]
        if (pc.Hp < 1) {
          continue
        }
        result += healSpellCheckCharactor(pc)
      }
    }
    return result
  }
  function healSpellCheckCharactor (cm) {
    let result = ''
    if (!cm.GetHeal[0]) {
      if (cm.Hp < Math.ceil(cm.HpMax / 4)) {
        result += '0'
      } else if (cm.Hp < Math.ceil(cm.HpMax / 2)) {
        result += '1'
      }
    }
    if (!cm.GetHeal[1]) {
      for (let i = 0; i < GameData['SPELL_KIND']; i++) {
        for (let j = 0; j < GameData['SPELL_LVMAX']; j++) {
          if (cm.Mp[i][j] < cm.MpMax[i][j]) {
            result += '6'
            break
          }
        }
        if (result.indexOf('6') > -1) {
          break
        }
      }
    }
    if (!cm.GetHeal[2]) {
      if (cm.Poison > 0) {
        result += '2'
      }
    }
    if (!cm.GetHeal[3]) {
      if (cm.Asleep != 0) {
        result += '3'
      }
    }
    if (!cm.GetHeal[6]) {
      if (cm.State == 2) {
        result += '7'
      }
    }
    if (!cm.GetHeal[7]) {
      if (cm.State == 3) {
        result += '8'
      }
    }
    if (!cm.GetHeal[4]) {
      if (cm.Silence != 0) {
        result += '4'
      }
    }
    if (!cm.GetHeal[5]) {
      if (cm.NoBreath != 0) {
        result += '5'
      }
    }
    return result
  }
  function healSpellJudgment (str, spellAry) {
    let ary = [-1, -1]
    if (spellAry[2] > -1 && str.indexOf('0') > -1) {
      if (50 >= dice(1, 100)) {
        ary[0] = spellAry[2]
        ary[1] = 0
      }
    }
    if (ary[0] < 0 && spellAry[2] > -1 && str.indexOf('1') > -1) {
      if (25 >= dice(1, 100)) {
        ary[0] = spellAry[2]
        ary[1] = 1
      }
    }
    if (ary[0] < 0 && spellAry[4] > -1 && str.indexOf('2') > -1) {
      if (50 >= dice(1, 100)) {
        ary[0] = spellAry[4]
        ary[1] = 2
      }
    }
    if (ary[0] < 0 && spellAry[5] > -1 && str.indexOf('3') > -1) {
      if (50 >= dice(1, 100)) {
        ary[0] = spellAry[5]
        ary[1] = 3
      }
    }
    if (ary[0] < 0 && spellAry[8] > -1 && str.indexOf('7') > -1) {
      if (50 >= dice(1, 100)) {
        ary[0] = spellAry[8]
        ary[1] = 7
      }
    }
    if (ary[0] < 0 && spellAry[9] > -1 && str.indexOf('8') > -1) {
      if (50 >= dice(1, 100)) {
        ary[0] = spellAry[9]
        ary[1] = 8
      }
    }
    if (ary[0] < 0 && spellAry[6] > -1 && str.indexOf('4') > -1) {
      if (50 >= dice(1, 100)) {
        ary[0] = spellAry[6]
        ary[1] = 4
      }
    }
    if (ary[0] < 0 && spellAry[7] > -1 && str.indexOf('5') > -1) {
      if (50 >= dice(1, 100)) {
        ary[0] = spellAry[7]
        ary[1] = 5
      }
    }
    if (ary[0] < 0 && spellAry[3] > -1 && str.indexOf('6') > -1) {
      if (25 >= dice(1, 100)) {
        ary[0] = spellAry[3]
        ary[1] = 6
      }
    }
    return ary
  }
  function healSpellTarget (type, healType) {
    let stack = []
    let groupNum, tmpVarStr
    if (type == 'monster') {
      groupNum = 4
      tmpVarStr = 'monsterNum'
    } else {
      groupNum = 2
      tmpVarStr = 'summonNum'
    }
    for (let i = 0; i < groupNum; i++) {
      for (let j = 0; j < TempVariable[tmpVarStr][i]; j++) {
        let monNum, mon
        if (type == 'monster') {
          monNum = PlayData['MonsterList'][i][j]
          mon = MONSTER[monNum]
        } else {
          monNum = PlayData['SummonList'][i][j]
          mon = SUMMON[monNum]
        }
        if (mon.Hp < 1) {
          continue
        }
        if (healSpellTarget_sub(mon, healType)) {
          if (type == 'monster') {
            stack.push(20 * i + j)
          } else {
            stack.push(70 * i + j)
          }
        }
      }
    }
    let ptNum = PlayData['ActiveParty']
    let pt = PARTY[ptNum]
    if (type == 'summon') {
      let memberNum = pt.getMemberNum()
      for (let i = 0; i < memberNum; i++) {
        let pcNum = pt.PartyMember[i]
        let pc = PC[pcNum]
        if (pc.Hp < 1) {
          continue
        }
        if (healSpellTarget_sub(pc, healType)) {
          stack.push(i)
        }
      }
    }
    if (stack.length > 0) {
      let setType
      if (healType == 0 || healType == 1) {
        setType = 0
      } else if (healType == 6) {
        setType = 1
      } else if (healType == 7 || healType == 8) {
        setType = healType - 1
      } else {
        setType = healType
      }
      let num = stack[dice(1, stack.length) - 1]
      if (num >= 70) {
        let i = Math.floor((num - 70) / 10)
        let j = (num - 70) % 10
        SUMMON[PlayData['SummonList'][i][j]].GetHeal[setType] = true
      } else if (num >= 20) {
        let i = Math.floor((num - 20) / 10)
        let j = (num - 20) % 10
        MONSTER[PlayData['MonsterList'][i][j]].GetHeal[setType] = true
      } else {
        PC[pt.PartyMember[num]].GetHeal[setType] = true
      }
      return num
    } else {
      if (type == 'monster') {
        return 20
      } else {
        return 0
      }
    }
    function healSpellTarget_sub (cm, healType) {
      let str = healSpellCheckCharactor(cm)
      if (healType == 0 && !cm.GetHeal[0]) {
        if (str.indexOf('0') > -1) {
          return true
        }
      } else if (healType == 1 && !cm.GetHeal[0]) {
        if (str.indexOf('1') > -1) {
          return true
        }
      } else if (healType == 2 && !cm.GetHeal[2]) {
        if (str.indexOf('2') > -1) {
          return true
        }
      } else if (healType == 3 && !cm.GetHeal[3]) {
        if (str.indexOf('3') > -1) {
          return true
        }
      } else if (healType == 7 && !cm.GetHeal[6]) {
        if (str.indexOf('7') > -1) {
          return true
        }
      } else if (healType == 8 && !cm.GetHeal[7]) {
        if (str.indexOf('8') > -1) {
          return true
        }
      } else if (healType == 4 && !cm.GetHeal[4]) {
        if (str.indexOf('4') > -1) {
          return true
        }
      } else if (healType == 5 && !cm.GetHeal[5]) {
        if (str.indexOf('5') > -1) {
          return true
        }
      } else if (healType == 6 && !cm.GetHeal[1]) {
        if (str.indexOf('6') > -1) {
          return true
        }
      }
      return false
    }
  }
  function monsterAverageLevel () {
    let lv = 0,
      count = 0
    for (let i = 0; i < 4; i++) {
      if (TempVariable['monsterNum'][i] < 1) {
        continue
      }
      for (let j = 0; j < TempVariable['monsterNum'][i]; j++) {
        let monNum = PlayData['MonsterList'][i][j]
        let monster = MONSTER[monNum]
        if (monster.possibleToAction()) {
          lv += monster.Level
          count++
        }
      }
    }
    if (count > 0) {
      return Math.floor(lv / count)
    } else {
      return 0
    }
  }
  function paintBox (boxName) {
    let w = Math.floor(MP.MAIN_WIDTH / 3)
    let x = MP.MAIN_X + MP.MAIN_WIDTH / 2 - w / 2
    let y = MP.MAIN_Y + MP.MAIN_HEIGHT / 2 - w / 2
    MP.paintGraphic(
      MP.MainSurface,
      GraphicData['graphic/' + boxName],
      x,
      y,
      w,
      w
    )
  }
  function replaceAmbush (str) {
    str = str.replace(/monster\.ac($|[^01])/g, 'monster.ac2$1')
    return str
  }
  function setBoxItem (alarm) {
    let strAry
    let haveItem = ''
    if (alarm) {
      haveItem = TempVariable['haveItem']
      if (haveItem != '') {
        strAry = haveItem.split(',')
        TempVariable['nonAlarmItemNum'] = strAry.length
      }
    }
    let str
    if (TempVariable['itemDrop'] != '') {
      str = TempVariable['itemDrop']
    } else {
      str = MONSTER_DATA[TempVariable['firstMonster']].HAVE_ITEM
    }
    strAry = str.split('<+>')
    for (let i = 0; i < strAry.length; i++) {
      let strAry2 = strAry[i].split('<>')
      let prob = Number(strAry2[0])
      prob = Math.floor(calTimes(prob, GenericVariable['DropGained']))
      if (prob > 100) {
        prob = 100
      } else if (prob < 0) {
        prob = 0
      }
      printDebugMessage(
        'item' + String(i + 1) + ' possession rate: ' + prob + '%'
      )
      if (prob >= dice(1, 100)) {
        let strAry3 = MP.getCmNum(strAry2[1]).split(',')
        if (haveItem != '') {
          haveItem += ','
        }
        haveItem += strAry3[dice(1, strAry3.length) - 1]
      }
    }
    TempVariable['haveItem'] = haveItem
  }
  function setMonsterAction (monNumInGroup1, monNumInGroup2) {
    let monType = 'monster'
    if (monNumInGroup1 >= 10) {
      monNumInGroup1 -= 10
      monType = 'summon'
    }
    let monNum, monNum2, mon
    if (monType == 'monster') {
      monNum = PlayData['MonsterList'][monNumInGroup1][monNumInGroup2]
      monNum2 = monNum
      mon = MONSTER[monNum]
    } else {
      monNum = PlayData['SummonList'][monNumInGroup1][monNumInGroup2]
      monNum2 = monNum + 50
      mon = SUMMON[monNum]
    }
    let mData = MONSTER_DATA[mon.MonsterDataNum]
    if (!mon.possibleToAction()) {
      return
    }
    let ptNum = PlayData['ActiveParty']
    let pt = PARTY[ptNum]
    let memberNum = pt.getMemberNum()
    let attackTarget = [-1, -1],
      castSpell = -1,
      spellTarget = -1,
      spellBranch = -1
    let possibleAction = {
      battle: false,
      spAttack: false,
      breath: false,
      call: false
    }
    if (monNumInGroup2 < GameData['FRONT_RANK_NUM'] * 2) {
      let targetStack = []
      if (monType == 'monster') {
        for (let i = 0; i < memberNum; i++) {
          let pcNum = pt.PartyMember[i]
          let pc = [pcNum]
          if (pc.State > 3 || pc.Hide) {
            continue
          }
          if (monNumInGroup1 < 2) {
            if (pt.frontRankCheck(i)) {
              if (mData.RANGE[0] > 0) {
                targetStack.push(i)
              }
            } else if (
              mData.RANGE[0] > 2 ||
              (TempVariable['frontHide'] && mData.RANGE[0] > 0)
            ) {
              targetStack.push(i)
            }
          } else {
            if (pt.frontRankCheck(i)) {
              if (mData.RANGE[1] > 0) {
                targetStack.push(i)
              }
            } else if (
              mData.RANGE[1] > 2 ||
              (TempVariable['frontHide'] && mData.RANGE[1] > 0)
            ) {
              targetStack.push(i)
            }
          }
        }
        for (let i = 0; i < 2; i++) {
          if (TempVariable['summonNum'][i] < 1) {
            continue
          }
          let rank = 0
          if (i == 1) {
            rank = 2
          }
          if (monNumInGroup1 < 2) {
            if (mData.RANGE[0] > rank) {
              let half = Math.ceil(TempVariable['summonNum'][i])
              for (let j = 0; j < half; j++) {
                targetStack.push(60 + i)
              }
            }
          } else {
            if (mData.RANGE[1] > rank) {
              let half = Math.ceil(TempVariable['summonNum'][i])
              for (let j = 0; j < half; j++) {
                targetStack.push(60 + i)
              }
            }
          }
        }
      } else {
        for (let i = 0; i < 4; i++) {
          if (TempVariable['monsterNum'][i] < 1) {
            continue
          }
          let rank = 0
          if (i > 1) {
            rank = 2
          }
          if (monNumInGroup1 == 0) {
            if (mData.RANGE[0] > rank) {
              targetStack.push(10 + i)
            }
          } else {
            if (mData.RANGE[1] > rank) {
              targetStack.push(10 + i)
            }
          }
        }
      }
      if (targetStack.length > 0) {
        possibleAction['battle'] = true
        attackTarget[0] = getHateTarget(
          monType,
          monNumInGroup1,
          monNumInGroup2,
          0
        )
        if (attackTarget[0] < 0) {
          attackTarget[0] = targetStack[dice(1, targetStack.length) - 1]
          attackTarget[1] = targetStack[dice(1, targetStack.length) - 1]
        } else {
          attackTarget[1] = attackTarget[0]
        }
        if (
          mon.AttackAdd.indexOf(true) > -1 ||
          mon.AttackPoison > 0 ||
          mData.DRAIN > 0 ||
          mData.TWICE_ATTACKS
        ) {
          possibleAction['spAttack'] = true
        }
      }
    }
    if (mData.BREATH > 0 && mon.NoBreath == 0) {
      possibleAction['breath'] = true
    }
    let spellAry = []
    for (let i = 0; i < 10; i++) {
      spellAry.push(-1)
    }
    let spaceSpellUsedNum = DUNGEON.checkSpaceSpellUsed(
      pt.DungeonNumber,
      pt.Floor,
      pt.X,
      pt.Y
    )
    if (
      mon.State == 0 &&
      mon.NoBreath == 0 &&
      (TempVariable['turn'] > 0 || GameData['SPELL_CAN_BE_USED']) &&
      spaceSpellUsedNum != 0 &&
      spaceSpellUsedNum != 2
    ) {
      for (let i = 0; i < 10; i++) {
        let str = ''
        if (i == 0) {
          str = GameData['SPELL_AT']
        } else if (i == 1) {
          str = GameData['SPELL_SUPPORT']
        } else {
          str = GameData['SPELL_HEAL2'][i - 2]
        }
        if (str == '') {
          continue
        }
        let strAry = str.split('<>')
        let stack = []
        for (let j = 0; j < strAry.length; j++) {
          let strAry2 = strAry[j].split(',')
          for (let k = 0; k < strAry2.length; k++) {
            let spell = Number(strAry2[k])
            let kind = Math.floor(spell / 100)
            spell %= 100
            let lv = Math.floor(spell / 10)
            spell %= 10
            if (
              mData.SPELL[kind] > lv &&
              mon.Mp[kind][lv] >=
                GameData['SPELL_CONSUMPTION_MP'][kind][lv][spell] &&
              (mon.Silence == 0 ||
                GameData['SPELL_EVEN_SILENCE'][kind][lv][spell])
            ) {
              stack.push(Number(strAry2[k]))
            }
          }
          if (stack.length > 0) {
            break
          }
        }
        if (stack.length > 0) {
          spellAry[i] = stack[dice(1, stack.length) - 1]
        }
      }
    }
    let monsterNum
    if (monType == 'monster') {
      monsterNum = TempVariable['monsterNum'][monNumInGroup1]
    } else {
      monsterNum = TempVariable['summonNum'][monNumInGroup1]
    }
    if (mData.CALL && monsterNum < 7 && mon.NoBreath == 0) {
      possibleAction['call'] = true
    }
    let action = -1
    let ap
    if (mData.ACTION_PATTERN == '') {
      ap = ['Normal']
    } else {
      ap = mData.ACTION_PATTERN.split('<->')
    }
    if (mData.RUN) {
      let formula = replaceFormula(GameData['MONSTER_RUN_PROB'], [
        ['monster', monNum2]
      ])
      let prob = Math.floor(strCalculation(formula))
      if (prob > 100) {
        prob = 100
      } else if (prob < 0) {
        prob = 0
      }
      if (prob >= dice(1, 100)) {
        action = 8
      }
    }
    if (action == -1 && ap[0] == 'Heal') {
      if (spellAry[2] > -1 && !mon.GetHeal[0]) {
        if (mon.Hp < Math.ceil(mon.HpMax / 4)) {
          if (75 >= dice(1, 100)) {
            action = 6
          }
        } else if (mon.Hp < Math.ceil(mon.HpMax / 2)) {
          if (50 >= dice(1, 100)) {
            action = 6
          }
        }
        if (action == 6) {
          castSpell = spellAry[2]
          spellTarget = monNumInGroup1 * 10 + monNumInGroup2
          if (monType == 'monster') {
            spellTarget += 20
          } else {
            spellTarget += 70
          }
          mon.GetHeal[0] = true
        }
      }
      if (action < 0) {
        let str = healSpellCheck(monType)
        let ary = healSpellJudgment(str, spellAry)
        if (ary[0] > -1) {
          action = 6
          castSpell = ary[0]
          spellTarget = healSpellTarget(monType, ary[1])
        }
      }
    }
    if (action == -1 && (ap[0] == 'Normal' || ap[0] == 'Heal')) {
      let stack = []
      if (spellAry[0] > -1 || spellAry[1] > -1) {
        stack.push(6)
        if (possibleAction['spAttack']) {
          stack.push(0)
        } else if (possibleAction['battle'] && dice(1, 100) <= 20) {
          stack.push(0)
        }
      } else if (possibleAction['battle']) {
        stack.push(0)
      } else {
        stack.push(4)
      }
      if (possibleAction['breath']) {
        if (mon.Hp > Math.ceil(mon.HpMax / 2)) {
          stack.push(3)
        } else if (dice(1, 100) <= 20) {
          stack.push(3)
        }
      }
      if (possibleAction['call']) {
        let targetLv
        if (monType == 'monster') {
          targetLv = pt.averageLevel(2)
        } else {
          targetLv = monsterAverageLevel()
        }
        if (mon.Level >= targetLv * 2) {
          let prob = 12 - TempVariable['monsterNum'][monNumInGroup1]
          if (prob >= dice(1, 100)) {
            stack.push(9)
          }
        } else {
          let prob = 90 - TempVariable['monsterNum'][monNumInGroup1] * 5
          if (prob >= dice(1, 100)) {
            stack.push(9)
          }
        }
      }
      if (
        monNumInGroup2 >= GameData['FRONT_RANK_NUM'] &&
        monNumInGroup2 * 2 >= dice(1, 100)
      ) {
        action = 4
      } else {
        if (stack.length > 0) {
          action = stack[dice(1, stack.length) - 1]
        }
      }
      if (action == 6) {
        castSpell = -1
        if (spellAry[1] > -1) {
          let formula = GameData['MONSTER_SUPPORT_SPELL']
          formula = replaceFormula(formula, [['monster', monNum2]])
          let prob = Math.floor(strCalculation(formula))
          if (prob >= dice(1, 100)) {
            castSpell = spellAry[1]
          }
        }
        if (castSpell < 0) {
          if (spellAry[0] > -1) {
            castSpell = spellAry[0]
          } else {
            action = -1
          }
        }
      }
    }
    if (ap[0] != 'Normal' && ap[0] != 'Heal') {
      action = -1
      for (let i = 0; i < ap.length; i++) {
        let strAry = ap[i].split(',')
        let formula = replaceFormula(strAry[0], [['monster', monNum2]])
        let prob = Math.floor(strCalculation(formula))
        let actionNum = Number(strAry[1])
        if (prob >= dice(1, 100)) {
          if (actionNum == 0 && possibleAction['battle']) {
            action = 0
          } else if (actionNum == 1 && possibleAction['breath']) {
            action = 3
          } else if (actionNum == 2) {
            action = 4
          } else if (actionNum == 3 && possibleAction['call']) {
            action = 9
          } else if (actionNum == 4 && mData.RUN) {
            action = 8
          } else if (actionNum == 5 && spellAry[0] > -1) {
            action = 6
            castSpell = spellAry[0]
          } else if (actionNum == 6 && spellAry[1] > -1) {
            action = 6
            castSpell = spellAry[1]
          } else if (actionNum == 7) {
            if (spellAry[2] > -1 && !mon.GetHeal[0]) {
              if (mon.Hp < Math.ceil(mon.HpMax / 4)) {
                if (75 >= dice(1, 100)) {
                  action = 6
                }
              } else if (mon.Hp < Math.ceil(mon.HpMax / 2)) {
                if (50 >= dice(1, 100)) {
                  action = 6
                }
              }
              if (action == 6) {
                castSpell = spellAry[2]
                spellTarget = monNumInGroup1 * 10 + monNumInGroup2
                if (monType == 'monster') {
                  spellTarget += 20
                } else {
                  spellTarget += 70
                }
                mon.GetHeal[0] = true
              }
            }
            if (action < 0) {
              let str = healSpellCheck(monType)
              let ary = healSpellJudgment(str, spellAry)
              if (ary[0] > -1) {
                action = 6
                castSpell = ary[0]
                spellTarget = healSpellTarget(monType, ary[1])
              } else if (spellAry[2] > -1) {
                action = 6
                castSpell = spellAry[2]
                spellTarget = monNumInGroup1 * 10 + monNumInGroup2
                if (monType == 'monster') {
                  spellTarget += 20
                } else {
                  spellTarget += 70
                }
                mon.GetHeal[0] = true
              }
            }
          } else if (actionNum == 8) {
            let spaceSpellUsedNum = DUNGEON.checkSpaceSpellUsed(
              pt.DungeonNumber,
              pt.Floor,
              pt.X,
              pt.Y
            )
            if (
              mon.NoBreath == 0 &&
              (TempVariable['turn'] > 0 || GameData['SPELL_CAN_BE_USED']) &&
              spaceSpellUsedNum != 0 &&
              spaceSpellUsedNum != 2
            ) {
              let ary = new Array(strAry.length - 2)
              for (let j = 2; j < strAry.length; j++) {
                ary[j - 2] = Number(strAry[j])
              }
              if (ary[0] < 0) {
                continue
              }
              let stack = []
              for (let j = 0; j < ary.length; j++) {
                let spell = ary[j]
                if (spell < 0 || spell >= 500) {
                  continue
                }
                let kind = Math.floor(spell / 100)
                spell %= 100
                let lv = Math.floor(spell / 10)
                spell %= 10
                if (
                  kind >= GameData['SPELL'].length ||
                  lv >= GameData['SPELL'][0].length ||
                  spell >= GameData['SPELL'][0][0].length
                ) {
                  continue
                }
                if (
                  mData.SPELL[kind] > lv &&
                  mon.Mp[kind][lv] >=
                    GameData['SPELL_CONSUMPTION_MP'][kind][lv][spell] &&
                  GameData['SPELL'][kind][lv][spell] != '' &&
                  (mon.Silence == 0 ||
                    GameData['SPELL_EVEN_SILENCE'][kind][lv][spell])
                ) {
                  stack.push(ary[j])
                }
              }
              if (stack.length > 0) {
                action = 6
                castSpell = stack[dice(1, stack.length) - 1]
              }
            }
          }
        }
        if (action > -1) {
          break
        }
      }
    }
    if (action < 0) {
      if (possibleAction['battle']) {
        action = 0
      } else {
        action = 4
      }
    }
    if (action == 6) {
      let spell = castSpell
      let kind = Math.floor(spell / 100)
      spell %= 100
      let lv = Math.floor(spell / 10)
      spell %= 10
      let spellData = decomposeSpell(
        spellEffectReplace(GameData['SPELL_EFFECT'][kind][lv][spell], 0)
      )
      spellBranch = spellData['branch']
      if (spellTarget < 0) {
        if (spellData['target'] == 1) {
          let stack = []
          if (monType == 'monster') {
            for (let i = 0; i < 4; i++) {
              if (TempVariable['monsterNum'][i] > 0) {
                stack.push(10 + i)
              }
            }
          } else {
            stack = stack.concat(getTargetPcAndSummon())
          }
          spellTarget = stack[dice(1, stack.length) - 1]
        } else if (spellData['target'] == 4) {
          let stack = []
          spellTarget = getHateTarget(
            monType,
            monNumInGroup1,
            monNumInGroup2,
            6
          )
          if (spellTarget < 0) {
            if (monType == 'monster') {
              stack = stack.concat(getTargetPcAndSummon())
              spellTarget = stack[dice(1, stack.length) - 1]
            } else {
              for (let i = 0; i < 4; i++) {
                if (TempVariable['monsterNum'][i] < 1) {
                  continue
                }
                stack.push(10 + i)
              }
              spellTarget = stack[dice(1, stack.length) - 1]
            }
          }
        } else if (spellData['target'] == 6) {
          let stack = []
          spellTarget = getHateTarget(
            monType,
            monNumInGroup1,
            monNumInGroup2,
            6,
            true
          )
          if (spellTarget < 0) {
            if (monType == 'monster') {
              stack.push(8)
              if (pt.checkBackRank() || TempVariable['summonNum'][1] > 0) {
                stack.push(9)
              }
              spellTarget = stack[dice(1, stack.length) - 1]
            } else {
              for (let i = 0; i < 4; i++) {
                if (TempVariable['monsterNum'][i] < 1) {
                  continue
                }
                stack.push(10 + i)
              }
              spellTarget = stack[dice(1, stack.length) - 1]
            }
          }
        }
      }
    } else if (action == 3) {
      if (monType == 'monster') {
        if (mData.BREATH_RANGE == 0) {
          let target = getHateTarget(monType, monNumInGroup1, monNumInGroup2, 3)
          if (target < 0) {
            let stack = getTargetPcAndSummon()
            target = stack[dice(1, stack.length) - 1]
          }
          mon.Action[2] = target
        } else if (mData.BREATH_RANGE == 1) {
          let target = getHateTarget(
            monType,
            monNumInGroup1,
            monNumInGroup2,
            3,
            true
          )
          if (target < 0) {
            if (
              memberNum <= GameData['FRONT_RANK_NUM'] &&
              TempVariable['summonNum'][1] < 1
            ) {
              target = 8
            } else if (dice(1, 100) <= 50) {
              target = 8
            } else {
              target = 9
            }
          }
          mon.Action[2] = target
        } else {
          mon.Action[2] = -1
        }
      } else {
        if (mData.BREATH_RANGE == 0 || mData.BREATH_RANGE == 1) {
          let target = getHateTarget(monType, monNumInGroup1, monNumInGroup2, 3)
          if (target < 0) {
            let stack = []
            for (let i = 0; i < 4; i++) {
              if (TempVariable['monsterNum'][i] > 0) {
                stack.push(10 + i)
              }
            }
            target = stack[dice(1, stack.length) - 1]
          }
          mon.Action[2] = target
        } else {
          mon.Action[2] = -1
        }
      }
    }
    mon.Action[0] = action
    if (action == 0) {
      mon.Action[1] = attackTarget[0]
      mon.Action[2] = attackTarget[1]
    } else if (action == 6) {
      mon.Action[1] = castSpell
      mon.Action[2] = spellTarget
      mon.Action[3] = spellBranch
    }
    function getTargetPcAndSummon () {
      let ptNum = PlayData['ActiveParty']
      let pt = PARTY[ptNum]
      let memberNum = pt.getMemberNum()
      let stack = []
      for (let i = 0; i < TempVariable['summonNum'][0]; i += 2) {
        stack.push(60)
      }
      for (let i = 0; i < TempVariable['summonNum'][1]; i += 2) {
        stack.push(61)
      }
      for (let i = 0; i < memberNum; i++) {
        let pcNum = pt.PartyMember[i]
        let pc = PC[pcNum]
        if (pc.Hp > 0) {
          stack.push(i)
        }
      }
      return stack
    }
  }
  function setMonsterList () {
    let ptNum = PlayData['ActiveParty']
    let pt = PARTY[ptNum]
    TempVariable['monsterLineChange'] = [false, false]
    if (
      TempVariable['monsterNum'][0] < 1 &&
      TempVariable['monsterNum'][1] < 1
    ) {
      TempVariable['monsterLineChange'][0] = true
      if (
        TempVariable['monsterNum'][2] > 0 &&
        TempVariable['monsterNum'][3] > 0
      ) {
        TempVariable['monsterLineChange'][1] = true
      }
    } else if (
      TempVariable['monsterNum'][0] < 1 ||
      TempVariable['monsterNum'][1] < 1
    ) {
      if (
        TempVariable['monsterNum'][2] > 0 ||
        TempVariable['monsterNum'][3] > 0
      ) {
        TempVariable['monsterLineChange'][1] = true
      }
    }
    for (let i = 0; i < 4; i++) {
      if (TempVariable['monsterNum'][i] < 1) {
        for (let j = 0; j < 9; j++) {
          PlayData['MonsterList'][i][j] = -1
        }
        continue
      }
      let stack = []
      for (let j = 0; j < 9; j++) {
        let monNum = PlayData['MonsterList'][i][j]
        if (monNum > -1) {
          if (MONSTER[monNum].Hp > 0) {
            stack.push(monNum)
          }
        }
        PlayData['MonsterList'][i][j] = -1
      }
      for (let j = 0; j < stack.length; j++) {
        PlayData['MonsterList'][i][j] = stack[j]
      }
    }
    for (let i = 0; i < 3; i++) {
      if (TempVariable['monsterNum'][i] > 0) {
        continue
      }
      for (let j = i + 1; j < 4; j++) {
        if (TempVariable['monsterNum'][j] > 0) {
          TempVariable['monsterNum'][i] = TempVariable['monsterNum'][j]
          TempVariable['monsterNum'][j] = 0
          TempVariable['setMonster'][i] = TempVariable['setMonster'][j]
          TempVariable['setMonster'][j] = -1
          TempVariable['monsterDecided'][i] = TempVariable['monsterDecided'][j]
          TempVariable['monsterDecided'][j] = false
          TempVariable['monsterDecidedChange'][i] =
            TempVariable['monsterDecidedChange'][j]
          TempVariable['monsterDecidedChange'][j] = false
          for (let k = 0; k < 9; k++) {
            PlayData['MonsterList'][i][k] = PlayData['MonsterList'][j][k]
            PlayData['MonsterList'][j][k] = -1
          }
          let memberNum = pt.getMemberNum()
          for (let k = 0; k < memberNum; k++) {
            let pc = PC[pt.PartyMember[k]]
            if (pc.Hp < 1) {
              continue
            }
            if (pc.Hate == 200 + j) {
              pc.Hate = 200 + i
            }
          }
          for (let k = 0; k < 2; k++) {
            for (let l = 0; l < 9; l++) {
              if (PlayData['SummonList'][k][l] < 0) {
                break
              }
              let summon = SUMMON[PlayData['SummonList'][k][l]]
              if (summon.Hate == 200 + j) {
                summon.Hate = 200 + i
              }
            }
          }
          break
        }
      }
    }
    for (let i = 0; i < MONSTER.length; i++) {
      if (MONSTER[i].Hp < 1) {
        MONSTER[i].initialize()
      } else {
        MONSTER[i].battleActionReset()
        MONSTER[i].check()
      }
    }
    for (let i = 0; i < 2; i++) {
      if (TempVariable['summonNum'][i] < 1) {
        for (let j = 0; j < 9; j++) {
          PlayData['SummonList'][i][j] = -1
        }
        continue
      }
      let stack = []
      for (let j = 0; j < 9; j++) {
        let monNum = PlayData['SummonList'][i][j]
        if (monNum > -1) {
          if (SUMMON[monNum].Hp > 0) {
            stack.push(monNum)
          }
        }
        PlayData['SummonList'][i][j] = -1
      }
      for (let j = 0; j < stack.length; j++) {
        PlayData['SummonList'][i][j] = stack[j]
      }
    }
    for (let i = 0; i < SUMMON.length; i++) {
      if (SUMMON[i].Hp < 1) {
        SUMMON[i].initialize()
      } else {
        SUMMON[i].battleActionReset()
        SUMMON[i].check()
      }
    }
    TempVariable['summonListStr'] = ''
    for (let i = 0; i < 2; i++) {
      if (TempVariable['summonNum'][i] < 1) {
        continue
      }
      if (i > 0) {
        TempVariable['summonListStr'] += '\n'
      }
      TempVariable['summonListStr'] +=
        ' ' + String(TempVariable['summonNum'][i]) + ' '
      let str
      let monNum = PlayData['SummonList'][i][0]
      if (TempVariable['summonNum'][i] > 1) {
        str = SUMMON[monNum].Names[1]
      } else {
        str = SUMMON[monNum].Name[1]
      }
      TempVariable['summonListStr'] += MP.strFitLength(str, 24) + ' ('
      TempVariable['summonListStr'] +=
        String(SUMMON[monNum].getGroupMemberNum(true)) + ')'
    }
  }
  function shareGold (gold) {
    let ptNum = PlayData['ActiveParty']
    let pt = PARTY[ptNum]
    let memberNum = pt.getMemberNum(),
      pMemberNum = pt.getMemberNum(true)
    let remainder = gold % pMemberNum
    gold = Math.floor(gold / pMemberNum)
    let count = 0
    for (let i = 0; i < memberNum; i++) {
      let pcNum = pt.PartyMember[i]
      let pc = PC[pcNum]
      if (pc.possibleToAction()) {
        pc.Gold += gold
        if (count < remainder) {
          pc.Gold++
          count++
        }
      }
    }
    if (remainder > 0) {
      gold++
    }
    return gold
  }
  function sortNoAction () {
    let ptNum = PlayData['ActiveParty']
    let pt = PARTY[ptNum]
    let oldList = TempVariable['partyList'].slice()
    let newList = []
    let count = 0
    while (count < oldList.length) {
      let pcNum = oldList[count]
      let pc = PC[pcNum]
      if (pc.State < 2 && pc.Asleep == 0) {
        newList.push(oldList[count])
        oldList.splice(count, 1)
      } else {
        count++
      }
    }
    count = 0
    while (count < oldList.length) {
      let pcNum = oldList[count]
      let pc = PC[pcNum]
      if (pc.State == 2 || pc.State == 3 || pc.Asleep != 0) {
        newList.push(oldList[count])
        oldList.splice(count, 1)
      } else {
        count++
      }
    }
    while (oldList.length > 0) {
      newList.push(oldList.shift())
    }
    for (let i = 0; i < newList.length; i++) {
      pt.PartyMember[i] = newList[i]
    }
  }
}
