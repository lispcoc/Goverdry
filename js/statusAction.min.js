function statusAction (key) {
  GenericVariable['ReturnAction'] = statusAction
  if (key == undefined || key == null) {
    key = ''
    MP.SelectMode['selectF'] = 0
  }
  if (key.match(/^(none|start)$/)) {
    MP.SelectMode['selectF'] = 0
  }
  let value
  if (key == '' || key.match(/^(cancel|escape|start)$/)) {
    value = 0
  } else if (MP.SelectMode['select'] > -1) {
    value = MP.SelectMode['valueAry'][MP.SelectMode['select']]
  } else {
    value = -1
  }
  let ptNum = PlayData['ActiveParty']
  let pt = PARTY[ptNum]
  let selAry = [],
    valueAry = [],
    colorAry = null
  let mode = 'normal',
    comment = ''
  let align = 'center',
    y = MP.LINE_HEIGHT,
    charMin = 0,
    lineNum = 0,
    textAlign = 'left'
  if (GameState == 'inspect') {
    if (key == '') {
      MP.MainSurface.clear()
      value = MP.PreSelect['valueAry'][0][MP.PreSelect['select'][0]]
    } else if (key == 'enter') {
      MP.PreSelect['select'][0] = MP.SelectMode['select']
      GameState = 'inspectCommand'
      statusAction()
      return
    } else if (key == 'cancel') {
      PlayData['StatusNow'] = ''
      MP.PreSelect['select'][0] = MP.SelectMode['select']
      MP.PreSelect['select'][0]++
      if (MP.PreSelect['select'][0] >= MP.PreSelect['valueAry'][0].length) {
        MP.PreSelect['select'][0] = 0
      }
      MP.controlPreSelect('pop')
      GameState = PlayData['StatusAction']
      MP.MainSurface.clear()
      if (GameState == 'trainingInspect') {
        MP.drawFrame_Full_Title(
          MP.MainSurface,
          getDefaultMessage('TRAINING', 1, 24),
          GraphicData['graphic/bg/trainingGround']
        )
        townAction('return')
      } else if (GameState == 'tavernInspect') {
        MP.drawFrame_Center_Title(
          MP.MainSurface,
          GameData['Tavern'],
          GraphicData['graphic/bg/tavern']
        )
        townAction('return')
      } else if (GameState == 'campInspect') {
        MP.drawFrame_Center_Title(MP.MainSurface, getDefaultMessage('CAMP', 1))
        dungeonAction('return')
      }
      return
    }
    MP.clearTextSurface('all')
    PlayData['StatusNow'] = 'status'
    PlayData['StatusNum'] = Number(value)
    selAry = MP.PreSelect['valueAry'][0].slice()
    valueAry = MP.PreSelect['valueAry'][0].slice()
    mode = 'status'
  } else if (GameState == 'inspectCommand') {
    if (key == 'cancel') {
      key = 'enter'
      value = 'leave'
    }
    if (key == 'enter') {
      if (value == 'cast') {
        MP.controlPreSelect('push')
        GameState = 'inspectCast'
        statusAction()
        return
      } else if (value == 'item') {
        MP.controlPreSelect('push')
        GameState = 'inspectItem'
        statusAction()
        return
      } else if (value == 'equip' && GameData['ITEM_EQUIP_LIST'].length > 0) {
        MP.controlPreSelect('push')
        GameState = 'inspectEquip'
        statusAction()
        return
      } else if (value == 'poolGold') {
        PARTY[PlayData['ActiveParty']].poolGold(PlayData['StatusNum'])
      } else if (value == 'read') {
        MP.controlPreSelect('push')
        GameState = 'inspectRead'
        statusAction()
        return
      } else if (value == 'ability') {
        PlayData['StatusNow'] = 'ability'
        GameState = 'inspectAbility'
        statusAction()
        return
      } else if (value == 'setFaceGraphic') {
        GameState = 'setFaceGraphic'
        GenericVariable['FullKeyInvalid'] = true
        MP.paintMask()
        MP.TopSurface.clear()
        MP.clearTextSurface('all')
        MP.drawTextFrame(
          MP.TopSurface,
          getDefaultMessage('SPECIFY_IMAGE', 1, 56),
          'center',
          MP.LINE_HEIGHT * 5
        )
        MP.controlInputText('set')
        let pcNum = PlayData['StatusNum']
        let faceStr = PC[pcNum].FaceGraphic
        if (faceStr.match(/^(| |none)$/)) {
          faceStr = 'none'
        }
        MP.OptionParts['text']._element.value = faceStr
        GenericVariable['FullKeyInvalid'] = false
        return
      } else if (value == 'leave') {
        GameState = 'inspect'
        statusAction()
        return
      }
    }
    PlayData['StatusNum'] = Number(
      MP.PreSelect['valueAry'][0][MP.PreSelect['select'][0]]
    )
    MP.viewStatus(PlayData['StatusNow'], PlayData['StatusNum'])
    MP.clearTextSurface('all')
    MP.TopSurface.clear()
    let commandAry = getInspectCommand()
    selAry = commandAry[0].slice()
    valueAry = commandAry[1].slice()
    mode = 'statusCommand'
    align = MP.MAIN_X + MP.MAIN_WIDTH / 2 + (MP.FONT_SIZE / 2) * 7
    y *= 12
  } else if (GameState.match(/^inspect(Cast|Read)$/)) {
    if (key == 'enter') {
      let modeNum = 0
      if (GameState == 'inspectCast') {
        modeNum = 1
      }
      let ary = PC[PlayData['StatusNum']].getLearnedSpell(
        modeNum,
        MP.SelectMode['select'],
        MP.SelectMode['selectF']
      )
      if (ary.length > 0) {
        MP.controlPreSelect('push')
        GameState += '2'
        statusAction()
        return
      }
      value = MP.SelectMode['select']
    } else if (key == 'cancel') {
      deleteTempVariable()
      MP.controlPreSelect('pop')
      GameState = 'inspectCommand'
      statusAction('return')
      return
    } else if (key == '') {
      let ary = PC[PlayData['StatusNum']].getSpellSelect()
      value = ary[0]
      MP.SelectMode['selectF'] = ary[1]
    }
    MP.viewStatus(PlayData['StatusNow'], PlayData['StatusNum'])
    MP.clearTextSurface('all')
    MP.viewPreSelectMode(MP.TextSurfaceNum, 1, 'none')
    MP.TextSurfaceNum++
    mode = 'spellLvSel'
    comment = 'spellLv'
    y *= 5
  } else if (GameState.match(/^(inspectCast2|inspectRead2)$/)) {
    let pcNum = PlayData['StatusNum']
    let pc = PC[pcNum]
    let kind, lv
    MP.viewPartyStatus('clear')
    MP.TopSurface.clear()
    if (key == 'enter') {
      if (GameState == 'inspectCast2') {
        TempVariable['haman'] = false
        TempVariable['hamanSel'] = -1
        MP.controlPreSelect('push')
        kind = MP.PreSelect['select'][2]
        lv = MP.PreSelect['selectF'][2]
        let spell = Number(
          MP.PreSelect['valueAry'][3][MP.PreSelect['select'][3]]
        )
        let spellData = decomposeSpell(
          spellEffectReplace(GameData['SPELL_EFFECT'][kind][lv][spell], 0),
          pcNum
        )
        TempVariable['selPc'] = -1
        if (spellData['target'] == 1) {
          if (pt.getMemberNum() == 1) {
            GameState = 'inspectCastActivate'
            statusAction('0')
          } else {
            sePlay('enter')
            MP.TextSurfaceNum++
            GameState = 'inspectCastPcSel'
            statusAction()
          }
        } else {
          GameState = 'inspectCastActivate'
          statusAction('-1')
        }
        return
      }
    } else if (key == 'cancel') {
      MP.controlPreSelect('pop')
      GameState = GameState.replace(/2/, '')
      MP.SelectMode['valueAry'][MP.SelectMode['select']] =
        MP.SelectMode['select']
      statusAction('return')
      return
    }
    MP.viewStatus(PlayData['StatusNow'], PlayData['StatusNum'])
    MP.clearTextSurface('all')
    MP.viewPreSelectMode(MP.TextSurfaceNum, 1, 'none')
    MP.viewPreSelectMode(MP.TextSurfaceNum, 2, 'none')
    MP.TextSurfaceNum++
    MP.SelectMode['selectF'] = 0
    let modeNum = 0
    if (GameState == 'inspectCast2') {
      modeNum = 1
    }
    kind = MP.PreSelect['select'][2]
    lv = MP.PreSelect['selectF'][2]
    let ary = pc.getLearnedSpell(modeNum, kind, lv)
    if (ary.length < 1) {
      MP.controlPreSelect('pop')
      GameState = GameState.replace(/2/, '')
      MP.SelectMode['valueAry'][MP.SelectMode['select']] =
        MP.SelectMode['select']
      statusAction('return')
      return
    }
    colorAry = []
    for (let i = 0; i < ary.length; i++) {
      let strAry = GameData['SPELL'][kind][lv][ary[i]].split('<>')
      selAry.push(strAry[0])
      valueAry.push(String(ary[i]))
      if (
        pc.Mp[kind][lv] >= GameData['SPELL_CONSUMPTION_MP'][kind][lv][ary[i]]
      ) {
        colorAry.push('white')
      } else {
        colorAry.push('gray')
      }
    }
    align = MP.MAIN_X + MP.MAIN_WIDTH / 2 - (MP.FONT_SIZE / 2) * 12
    y *= 7 + GameData['SPELL_KIND']
    charMin = 24
    lineNum = 6
    mode = 'spellSel'
    comment = 'spell'
  } else if (GameState.match(/^inspect(Cast|ItemUse)Activate$/)) {
    let pcNum = PlayData['StatusNum']
    let pc = PC[pcNum]
    let spellData
    if (GameState == 'inspectCastActivate') {
      let kind = MP.PreSelect['select'][2]
      let lv = MP.PreSelect['selectF'][2]
      let spell = Number(MP.PreSelect['valueAry'][3][MP.PreSelect['select'][3]])
      spellData = decomposeSpell(
        spellEffectReplace(GameData['SPELL_EFFECT'][kind][lv][spell], 0),
        pcNum
      )
    } else {
      let itemNum = PC[pcNum].Item[TempVariable['haveNum']]
      let item = ITEM[itemNum]
      spellData = decomposeSpell(spellEffectReplace(item.USE, 1), pcNum)
    }
    let activate = false
    let spellSelNum = 0
    let targetPcNumInPt = -1
    if (!isNaN(key)) {
      if (TempVariable['haman']) {
        sePlay('enter')
      } else {
        sePlay('spell')
      }
      targetPcNumInPt = Number(key)
    } else if (key == 'enter') {
      spellSelNum = value
      TempVariable['hamanSel'] = spellSelNum
      TempVariable['haman'] = true
      activate = true
    }
    if (!activate) {
      if (
        pc.Level >= spellData['levelLimit'] &&
        spellData['selectNum'] > 0 &&
        TempVariable['hamanSel'] < 0
      ) {
        MP.drawTextFrame(
          MP.TextSurface[MP.TextSurfaceNum],
          getDefaultMessage('WHICH_BOON_DO_YOU_DESIRE_IN_CAMP', 1),
          'center',
          MP.LINE_HEIGHT * 7
        )
        MP.TextSurfaceNum++
        let spellSelectAry = SPELL_EF.getSelectSpellEffect(
          spellData['selectNum'],
          spellData['spellEffect'].length
        )
        for (let i = 0; i < spellSelectAry.length; i++) {
          let num = spellSelectAry[i]
          let selText = ''
          if (num < spellData['selectText'].length) {
            selText = spellData['selectText'][num]
          }
          selAry.push(selText)
          valueAry.push(num)
        }
        y *= 10
        mode = 'noCancel'
      } else {
        if (TempVariable['hamanSel'] > -1) {
          spellSelNum = TempVariable['hamanSel']
          TempVariable['hamanSel'] = -1
        } else {
          spellSelNum = dice(1, spellData['spellEffect'].length) - 1
        }
        activate = true
      }
    }
    if (activate) {
      if (TempVariable['hamanSel'] > -1) {
        if (spellData['hamanTarget'][spellSelNum] == 1) {
          if (GameState == 'inspectCastActivate') {
            GameState = 'inspectCastPcSel'
          } else {
            GameState = 'inspectItemPcSel'
          }
          statusAction()
          return
        }
      }
      let situation
      if (GameState == 'inspectCastActivate') {
        situation = 'campSpell'
      } else {
        situation = 'campItem'
      }
      SPELL_EF.spellEffect(
        spellData,
        spellSelNum,
        situation,
        pt.getMemberForPcNum(pcNum),
        targetPcNumInPt
      )
      if (SPELL_EF.Effect.indexOf('partyLocation') > -1) {
        if (Config['AutoMapping']) {
          PlayData['StatusNow'] = ''
          let gameState
          if (GameState == 'inspectCastActivate') {
            gameState = 'mapCampSpell'
          } else {
            gameState = 'mapCampItem'
          }
          let ary = SPELL_EF.Effect.split(',')
          MP.setDrawMap(gameState, ary[1], ary[2])
        } else {
          if (GameState == 'inspectCastActivate') {
            GameState = 'inspectCastResultNotEnterReturn'
          } else {
            GameState = 'inspectItemUseResultNotEnterReturn'
          }
          MP.drawMapText(pt.DungeonNumber, pt.Floor, pt.X, pt.Y, pt.Direction)
        }
        return
      } else if (SPELL_EF.Effect.indexOf('searchForPC') > -1) {
        PlayData['StatusNow'] = ''
        if (GameState == 'inspectCastActivate') {
          GameState = 'searchForPcCampSpell'
        } else {
          GameState = 'searchForPcCampItem'
        }
        statusAction()
        return
      } else if (SPELL_EF.Effect.indexOf('teleport') > -1) {
        if (DUNGEON.NotUseWarp[pt.DungeonNumber][pt.Floor]) {
          SPELL_EF.Effect = 'fizzle'
        } else {
          let ary = SPELL_EF.Effect.split(',')
          if (ary[2] == '1') {
            PlayData['StatusNow'] = ''
            let teleportPoint = SPELL_EF.getPointRandomTeleport(
              ptNum,
              ary[1],
              ary[3]
            )
            if (
              teleportPoint[0] == pt.Floor &&
              teleportPoint[1] == pt.X &&
              teleportPoint[2] == pt.Y
            ) {
              SPELL_EF.Effect = 'fizzle'
            } else {
              TempVariable['nextDungeon'] = pt.DungeonNumber
              TempVariable['nextFloor'] = teleportPoint[0]
              TempVariable['nextX'] = teleportPoint[1]
              TempVariable['nextY'] = teleportPoint[2]
              GenericVariable['KeyInvalid'] = true
              GenericVariable['TimeEventCountMax'] = TIME_COUNT[1]
              GenericVariable['TimeEventCount'] = 0
              GenericVariable['TimeEvent'] = 'moveFloorFromCamp'
              return
            }
          } else {
            PlayData['StatusNow'] = ''
            if (Config['AutoMapping']) {
              TempVariable['floor'] = pt.Floor
              if (GameData['TELEPORT_START_ZERO']) {
                TempVariable['x'] = 0
                TempVariable['y'] = 0
              } else {
                TempVariable['x'] = pt.X
                TempVariable['y'] = pt.Y
              }
              TempVariable['direction'] = -1
              TempVariable['mapViewFloor'] = []
              for (
                let i = 0;
                i < DUNGEON.FloorMinMax[pt.DungeonNumber].length;
                i++
              ) {
                let onFoot = false
                if (i == pt.Floor) {
                  onFoot = true
                } else if (ary[1] == '0') {
                  if (ary[3] == '1') {
                    onFoot = true
                  } else {
                    for (let j = 0; j < DUNGEON.Width[pt.DungeonNumber]; j++) {
                      if (onFoot) {
                        break
                      }
                      for (
                        let k = 0;
                        k < DUNGEON.Height[pt.DungeonNumber];
                        k++
                      ) {
                        if (PlayData['MapFlag'][pt.DungeonNumber][i][j][k]) {
                          onFoot = true
                          break
                        }
                      }
                    }
                  }
                }
                if (onFoot) {
                  TempVariable['mapViewFloor'].push(i)
                }
              }
              if (TempVariable['mapViewFloor'].length < 2) {
                if (GameState == 'inspectCastActivate') {
                  GameState = 'teleportSpell'
                } else {
                  GameState = 'teleportItem'
                }
                MP.drawMap(
                  pt.DungeonNumber,
                  TempVariable['floor'],
                  TempVariable['x'],
                  TempVariable['y'],
                  -1,
                  ary[4],
                  ary[5]
                )
              } else {
                if (GameState == 'inspectCastActivate') {
                  GameState = 'teleportFloorSpell'
                } else {
                  GameState = 'teleportFloorItem'
                }
                statusAction()
              }
              return
            } else {
              if (GameState == 'inspectCastActivate') {
                GameState = 'teleportTextSpell'
              } else {
                GameState = 'teleportTextItem'
              }
              MP.clearMainWindow()
              MP.clearTextSurface('all')
              MP.drawFrame_Full_Title(
                MP.MainSurface,
                DUNGEON.DungeonName[pt.DungeonNumber]
              )
              TempVariable['select'] = 0
              TempVariable['floor'] = 0
              TempVariable['x'] = 0
              TempVariable['y'] = 0
              MP.drawPartyTeleport(
                TempVariable['select'],
                TempVariable['x'],
                TempVariable['y'],
                TempVariable['floor']
              )
              return
            }
          }
        }
      } else if (SPELL_EF.Effect == 'return') {
        TempVariable['nextDungeon'] = -1
        TempVariable['nextFloor'] = -1
        TempVariable['nextX'] = 0
        TempVariable['nextY'] = 0
        GenericVariable['KeyInvalid'] = true
        GenericVariable['TimeEventCountMax'] = TIME_COUNT[1]
        GenericVariable['TimeEventCount'] = 0
        GenericVariable['TimeEvent'] = 'moveFloor'
        return
      } else if (SPELL_EF.Effect.indexOf('coordinateTeleport') > -1) {
        let ary = SPELL_EF.Effect.split(',')
        let tp = [
          Number(ary[1]),
          Number(ary[2]),
          Number(ary[3]),
          Number(ary[4])
        ]
        if (tp[0] < 0) {
          TempVariable['nextDungeon'] = -1
          TempVariable['nextFloor'] = -1
          TempVariable['nextX'] = 0
          TempVariable['nextY'] = 0
          GenericVariable['KeyInvalid'] = true
          GenericVariable['TimeEventCountMax'] = TIME_COUNT[1]
          GenericVariable['TimeEventCount'] = 0
          GenericVariable['TimeEvent'] = 'moveFloor'
          return
        } else {
          PlayData['StatusNow'] = ''
          TempVariable['nextDungeon'] = tp[0]
          TempVariable['nextFloor'] = tp[1]
          TempVariable['nextX'] = tp[2]
          TempVariable['nextY'] = tp[3]
          GenericVariable['KeyInvalid'] = true
          GenericVariable['TimeEventCountMax'] = TIME_COUNT[1]
          GenericVariable['TimeEventCount'] = 0
          GenericVariable['TimeEvent'] = 'moveFloorFromCamp'
          return
        }
      } else if (SPELL_EF.Effect == 'probeSpace') {
        let x = pt.X,
          y = pt.Y,
          d = pt.Direction
        if (d == 0) {
          y++
        } else if (d == 1) {
          x++
        } else if (d == 2) {
          y--
        } else if (d == 3) {
          x--
        }
        x = DUNGEON.getPoint(pt.DungeonNumber, 'w', x)
        y = DUNGEON.getPoint(pt.DungeonNumber, 'h', y)
        let space = DUNGEON.Space[pt.DungeonNumber][pt.Floor][x][y]
        let str
        if (space == 'a') {
          str = 'THERE_IS_NO_SPACE'
        } else {
          str = 'THERE_IS_A_SPACE'
        }
        MP.drawTextFrame(
          MP.TextSurface[MP.TextSurfaceNum],
          '\n' + getDefaultMessage(str, 1, 52) + '\n',
          'center',
          MP.LINE_HEIGHT * 10
        )
        if (GameState == 'inspectCastActivate') {
          GameState = 'inspectCastResultNotEnterReturn'
        } else {
          GameState = 'inspectItemUseResultNotEnterReturn'
        }
        return
      } else if (SPELL_EF.MessageStack[0].length > 0) {
        MP.TextSurfaceNum++
        if (GameState == 'inspectCastActivate') {
          GameState = 'messageInCampSpell'
        } else {
          GameState = 'messageInCampItem'
        }
        statusAction()
        return
      }
      if (GameState == 'inspectCastActivate') {
        GameState = 'inspectCastResult'
      } else {
        GameState = 'inspectItemUseResult'
      }
      if (SPELL_EF.Effect.match(/^(levelLimit|notCast|fizzle)$/)) {
        GameState += 'Fizzle'
      }
      statusAction()
      return
    }
  } else if (
    GameState.match(/^inspect(Cast|ItemUse)Result(|Cursed|Fizzle|Less|None)$/)
  ) {
    let pcNum = PlayData['StatusNum']
    let pc = PC[pcNum]
    MP.viewStatus(PlayData['StatusNow'], PlayData['StatusNum'])
    MP.clearTextSurface('all')
    MP.viewPreSelectMode(MP.TextSurfaceNum, 1, 'none')
    MP.viewPreSelectMode(MP.TextSurfaceNum, 2, 'none')
    if (TempVariable['selPc'] > -1) {
      MP.viewPartyStatus(true, TempVariable['selPc'])
    }
    let done = false
    if (GameState.match(/^inspectCastResult/)) {
      let str = '',
        sel = -1,
        spell
      let kind = MP.PreSelect['select'][2]
      let lv = MP.PreSelect['selectF'][2]
      let ary = pc.getLearnedSpell(1, kind, lv)
      if (ary.length > 0) {
        sel = MP.PreSelect['select'][3]
        spell = Number(MP.PreSelect['valueAry'][3][MP.PreSelect['select'][3]])
        let ck = false
        if (sel >= ary.length) {
          ck = true
        } else if (ary[sel] != spell) {
          ck = true
        }
        if (ck) {
          let num = ary.indexOf(spell)
          if (num > -1) {
            sel = num
          } else if (sel >= ary.length) {
            sel = ary.length - 1
          }
          MP.PreSelect['select'][3] = sel
          MP.PreSelect['valueAry'][3] = []
          for (let i = 0; i < ary.length; i++) {
            MP.PreSelect['valueAry'][3].push(String(ary[i]))
          }
        }
        colorAry = []
        for (let i = 0; i < ary.length; i++) {
          if (i > 0) {
            str += '\n'
          }
          let strAry = GameData['SPELL'][kind][lv][ary[i]].split('<>')
          str += strAry[0]
          if (
            pc.Mp[kind][lv] >=
            GameData['SPELL_CONSUMPTION_MP'][kind][lv][ary[i]]
          ) {
            colorAry.push('white')
          } else {
            colorAry.push('gray')
          }
        }
      }
      align = MP.MAIN_X + MP.MAIN_WIDTH / 2 - (MP.FONT_SIZE / 2) * 12
      y *= 7 + GameData['SPELL_KIND']
      charMin = 24
      lineNum = 6
      MP.drawTextFrame(
        MP.TextSurface[MP.TextSurfaceNum],
        str,
        align,
        y,
        charMin,
        lineNum,
        'left',
        colorAry,
        sel
      )
      if (sel > -1 && TempVariable['selPc'] < 0 && GameData['HELP_COMMENT']) {
        str = GameData['SPELL_COMMENT'][kind][lv][ary[sel]]
        let strAry = str.split('<+>')
        if (strAry.length == 4) {
          str = strAry[pc.Sex]
        } else if (strAry.length == 3) {
          str = strAry[pc.Alignment]
        }
        if (str != '') {
          MP.drawTextFrame(
            MP.TextSurface[MP.TextSurfaceNum],
            str,
            'center',
            MP.LINE_HEIGHT * 19,
            54,
            5
          )
        }
      }
      if (GameState.match(/Fizzle/)) {
        doneStr = 'FIZZLE'
      } else {
        doneStr = 'CAST_DONE'
        done = true
      }
      let canUseSpell = false
      if (
        TempVariable['selPc'] > -1 &&
        ary.indexOf(spell) > -1 &&
        !TempVariable['haman']
      ) {
        if (
          pc.Mp[kind][lv] >= GameData['SPELL_CONSUMPTION_MP'][kind][lv][spell]
        ) {
          canUseSpell = true
        }
      }
      if (canUseSpell) {
        MP.TextSurfaceNum++
        MP.SelectMode['select'] = 0
        MP.SelectMode['valueAry'][MP.SelectMode['select']] = String(
          pt.PartyMember[TempVariable['selPc']]
        )
        GameState = 'inspectCastPcSelReturn'
      } else {
        MP.controlPreSelect('pop')
        GameState = 'inspectCast2Return'
      }
    } else {
      let str = getDefaultMessage('USE_WHICH', 1, 34)
      let strAlign = 'center'
      if (GameData['EQUIP_COMMENT']) {
        strAlign =
          MP.MAIN_X +
          (MP.FONT_SIZE / 2) * 42 -
          (MP.FONT_SIZE / 2) * Math.ceil(MP.strCount(str) / 2)
      }
      MP.drawTextFrame(
        MP.TextSurface[MP.TextSurfaceNum],
        str,
        strAlign,
        MP.LINE_HEIGHT * 1
      )
      str = ''
      lineNum = pc.ItemMaxNum
      if (lineNum > 12) {
        lineNum = 12
      }
      let itemMax = pc.haveItemNum(-1)
      let selNum = TempVariable['haveNum']
      if (selNum >= itemMax) {
        selNum = itemMax - 1
      }
      let selF = TempVariable['itemUseSelectF']
      if (selF >= itemMax) {
        selF = itemMax - 1
      }
      if (selF < 0) {
        selF = 0
      }
      MP.SelectMode['selectF'] = selF
      let count = 0
      for (let i = selF; i < itemMax; i++) {
        if (count > 0) {
          str += '\n'
        }
        str += pc.getItemName(i, 'equip')
        count++
        if (count >= lineNum) {
          break
        }
      }
      if (GameData['EQUIP_COMMENT']) {
        align = MP.MAIN_X + (MP.FONT_SIZE / 2) * 29
      }
      y *= 4
      charMin = 26
      MP.drawTextFrame(
        MP.TextSurface[MP.TextSurfaceNum],
        str,
        align,
        y,
        charMin,
        lineNum,
        'left',
        null,
        selNum - selF
      )
      if (TempVariable['haveNum'] > -1 && GameData['HELP_COMMENT']) {
        if (pc.ItemDecided[TempVariable['haveNum']] == 1) {
          str = ITEM[pc.Item[TempVariable['haveNum']]].COMMENT
          if (str != '') {
            MP.drawTextFrame(
              MP.TextSurface[MP.TextSurfaceNum],
              str,
              'center',
              MP.LINE_HEIGHT * 19,
              54,
              5
            )
          }
        }
      }
      if (GameState.match(/Cursed/)) {
        doneStr = 'CURSED'
      } else if (GameState.match(/Fizzle/)) {
        doneStr = 'FIZZLE'
      } else if (GameState.match(/Less/)) {
        doneStr = 'POWERLESS'
      } else if (GameState.match(/None/)) {
        doneStr = 'WHAT'
      } else {
        doneStr = 'ITEM_USE_DONE'
        done = true
      }
      if (TempVariable['selPc'] > -1 && !TempVariable['haman']) {
        MP.controlPreSelect('pop')
      }
      if (itemMax == 0) {
        MP.controlPreSelect('pop')
        GameState = 'inspectItemReturn'
      } else {
        GameState = 'inspectItemUseReturn'
      }
    }
    MP.drawTextFrame(
      MP.TextSurface[MP.TextSurfaceNum],
      getDefaultMessage(doneStr, 1, 48),
      'center',
      MP.LINE_HEIGHT * 11
    )
    if (done && SPELL_EF.Effect == 'heal') {
      let text = ''
      let memberNum = pt.getMemberNum()
      for (let i = 0; i < memberNum; i++) {
        let resultChar = SPELL_EF.ResultChar['pc' + String(i)]
        if (
          arrayIndexOf(resultChar, 'heal') < 0 &&
          resultChar.indexOf('fullHeal') < 0
        ) {
          continue
        }
        let pc = PC[pt.PartyMember[i]]
        if (text != '') {
          text += '\n'
        }
        text += MP.strFitLength(pc.Name[0], 22)
        text +=
          MP.strFitLength(String(SPELL_EF.FirstHp[i]), 5, 'right') + '  ->  '
        text += MP.strFitLength(String(pc.Hp), 5, 'right') + '/'
        text += MP.strFitLength(String(pc.HpMax), 5, 'right')
      }
      if (text != '') {
        MP.drawTextFrame(MP.TopSurface, text, 'center', MP.LINE_HEIGHT * 14)
      }
    }
    return
  } else if (GameState == 'inspectItem') {
    if (key == 'cancel') {
      key = 'enter'
      value = 'leave'
    }
    if (key == 'enter') {
      if (value == 'leave') {
        MP.controlPreSelect('pop')
        GameState = 'inspectCommand'
        statusAction('return')
        return
      } else if (value == 'trade') {
        if (pt.getMemberNum() > 1) {
          MP.controlPreSelect('push')
          GameState = 'inspectItemTrade'
          statusAction()
          return
        }
      } else {
        MP.controlPreSelect('push')
        if (value == 'inspect') {
          GameState = 'inspectItemInspect'
        } else if (value == 'use') {
          GameState = 'inspectItemUse'
        } else if (value == 'identify') {
          GameState = 'inspectItemIdentify'
        } else if (value == 'sort') {
          GameState = 'inspectItemSort'
        } else if (value == 'drop') {
          GameState = 'inspectItemDrop'
        }
        statusAction()
        return
      }
    }
    PlayData['StatusNum'] = Number(
      MP.PreSelect['valueAry'][0][MP.PreSelect['select'][0]]
    )
    MP.viewStatus(PlayData['StatusNow'], PlayData['StatusNum'])
    MP.clearTextSurface('all')
    MP.TopSurface.clear()
    MP.viewPartyStatus(false)
    let commandAry = getInspectCommand()
    MP.PreSelect['selAry'][1] = commandAry[0].slice()
    MP.PreSelect['valueAry'][1] = commandAry[1].slice()
    MP.PreSelect['lineNum'][1] = MP.PreSelect['selAry'][1].length
    MP.PreSelect['select'][1] = MP.PreSelect['valueAry'][1].indexOf('item')
    MP.viewPreSelectMode(MP.TextSurfaceNum, 1, 'none')
    MP.TextSurfaceNum++
    let pcNum = PlayData['StatusNum']
    let itemNum = PC[pcNum].haveItemNum(-1)
    if (itemNum > 0) {
      let checkSpace = -1
      if (PlayData['StatusAction'] == 'campInspect') {
        checkSpace = DUNGEON.checkSpaceSpellUsed(
          pt.DungeonNumber,
          pt.Floor,
          pt.X,
          pt.Y
        )
      }
      if (
        PlayData['StatusAction'] == 'campInspect' &&
        checkSpace < 1 &&
        PC[pcNum].State == 0
      ) {
        selAry.push(getDefaultMessage('USE', 1, 14))
        valueAry.push('use')
      } else if (GameData['HELP_COMMENT'] || itemNum > 12) {
        selAry.push(getDefaultMessage('INSPECT', 1, 14))
        valueAry.push('inspect')
      }
    }
    selAry.push(getDefaultMessage('TRADE', 1, 14))
    valueAry.push('trade')
    if (GameData['CLASS_IDENTIFY'][PC[pcNum].PcClass] && PC[pcNum].State == 0) {
      let list = pt.getItemDecidedList(pcNum)
      if (list.length > 0) {
        selAry.push(getDefaultMessage('IDENTIFY', 1, 14))
        valueAry.push('identify')
      }
    }
    if (itemNum > 1) {
      selAry.push(getDefaultMessage('SORTING', 1, 14))
      valueAry.push('sort')
    }
    if (itemNum > 0) {
      selAry.push(getDefaultMessage('DROP', 1, 14))
      valueAry.push('drop')
    }
    selAry.push(getDefaultMessage('LEAVE', 1, 14))
    valueAry.push('leave')
    mode = 'statusCommand'
    align = MP.MAIN_X + MP.MAIN_WIDTH / 2 + (MP.FONT_SIZE / 2) * 14
    y *= 13
  } else if (GameState.match(/^inspectItem(Inspect|Use|Drop)$/)) {
    MP.viewPartyStatus('clear')
    let pcNum = PlayData['StatusNum']
    let pc = PC[pcNum]
    if (key == 'enter') {
      TempVariable['haveNum'] = Number(
        MP.SelectMode['valueAry'][MP.SelectMode['select']]
      )
      if (GameState == 'inspectItemUse') {
        TempVariable['itemUseSelectF'] = MP.SelectMode['selectF']
        TempVariable['selPc'] = -1
        TempVariable['haman'] = false
        TempVariable['hamanSel'] = -1
        let itemUse = pc.haveItemUseInCampCheck(TempVariable['haveNum'])
        if (itemUse == 2) {
          let itemNum = pc.Item[TempVariable['haveNum']]
          let item = ITEM[itemNum]
          let spellData = decomposeSpell(spellEffectReplace(item.USE, 1), pcNum)
          if (spellData['target'] == 1) {
            if (pt.getMemberNum() == 1) {
              GameState = 'inspectItemUseActivate'
              statusAction('0')
            } else {
              MP.controlPreSelect('push')
              sePlay('enter')
              MP.TextSurfaceNum++
              GameState = 'inspectItemPcSel'
              statusAction()
            }
          } else {
            GameState = 'inspectItemUseActivate'
            statusAction('-1')
          }
        } else {
          sePlay('enter')
          if (itemUse == 0) {
            GameState = 'inspectItemUseResultLess'
          } else if (itemUse == 1) {
            GameState = 'inspectItemUseResultCursed'
          } else {
            GameState = 'inspectItemUseResultNone'
          }
          statusAction()
        }
        return
      } else if (GameState == 'inspectItemDrop') {
        let equip = pc.Equip[TempVariable['haveNum']]
        if (equip > 0) {
          let strTmp = 'EQUIPED'
          if (equip == 2) {
            strTmp = 'CURSED'
          }
          MP.drawTextFrame(
            MP.TextSurface[MP.TextSurfaceNum],
            getDefaultMessage(strTmp, 1),
            'center',
            MP.LINE_HEIGHT * 6
          )
          GameState = 'inspectItemDropReturn'
          return
        }
        let item = pc.Item[TempVariable['haveNum']]
        dumpItem(ptNum, item)
        pc.removeHaveItem(TempVariable['haveNum'])
        pc.check()
        if (pc.haveItemNum(-1) < 1) {
          key = 'cancel'
        } else {
          value = MP.controlSelect('deleteSlide')
        }
      }
    }
    if (key == 'cancel') {
      MP.controlPreSelect('pop')
      GameState = 'inspectItem'
      statusAction('return')
      return
    } else if (key == 'return') {
      if (GameState.indexOf('Use') > -1) {
        value = TempVariable['haveNum']
      }
    }
    MP.viewStatus(PlayData['StatusNow'], PlayData['StatusNum'])
    MP.clearTextSurface('all')
    MP.TopSurface.clear()
    MP.viewPreSelectMode(MP.TextSurfaceNum, 1, 'none')
    MP.viewPreSelectMode(MP.TextSurfaceNum, 2, 'none')
    let str = 'INSPECT_WHICH'
    let strAlign = 'center'
    if (GameState == 'inspectItemDrop') {
      str = getDefaultMessage('DROP_WHICH', 1)
    } else {
      if (GameState == 'inspectItemUse') {
        str = 'USE_WHICH'
      }
      str = getDefaultMessage(str, 1, 34)
      if (GameData['EQUIP_COMMENT']) {
        strAlign =
          MP.MAIN_X +
          (MP.FONT_SIZE / 2) * 42 -
          (MP.FONT_SIZE / 2) * Math.ceil(MP.strCount(str) / 2)
      }
    }
    MP.drawTextFrame(
      MP.TextSurface[MP.TextSurfaceNum],
      str,
      strAlign,
      MP.LINE_HEIGHT * 1
    )
    MP.TextSurfaceNum++
    let itemMax = pc.haveItemNum(-1)
    for (let i = 0; i < itemMax; i++) {
      selAry.push(pc.getItemName(i, 'equip'))
      valueAry.push(String(i))
    }
    if (
      GameState.match(/^inspectItem(Inspect|Use)$/) &&
      GameData['EQUIP_COMMENT']
    ) {
      align = MP.MAIN_X + (MP.FONT_SIZE / 2) * 29
    }
    y *= 4
    charMin = 26
    lineNum = pc.ItemMaxNum
    if (lineNum > 12) {
      lineNum = 12
    }
    comment = 'haveItem'
  } else if (GameState.match(/PcSel$/)) {
    if (key == 'cancel') {
      MP.controlPreSelect('pop')
      if (GameState == 'inspectItemPcSel') {
        GameState = 'inspectItemUse'
      } else if (GameState == 'inspectCastPcSel') {
        GameState = 'inspectCast2'
      }
      statusAction('return')
      return
    } else if (key == 'enter') {
      TempVariable['selPc'] = pt.getMemberForPcNum(Number(value))
      MP.clearTextSurface()
      let pcNum = PlayData['StatusNum']
      let pc = PC[pcNum]
      if (GameState == 'inspectItemPcSel') {
        GameState = 'inspectItemUseActivate'
      } else if (GameState == 'inspectCastPcSel') {
        GameState = 'inspectCastActivate'
      }
      statusAction(String(TempVariable['selPc']))
      return
    }
    MP.clearTextSurface()
    MP.TopSurface.clear()
    let str = ''
    if (GameState.match(/Cast/)) {
      str = 'CAST_WHOM'
    } else {
      str = 'ITEM_USE_WHOM'
    }
    MP.drawTextFrame(
      MP.TextSurface[MP.TextSurfaceNum],
      getDefaultMessage(str, 1, 48),
      'center',
      MP.LINE_HEIGHT * 11
    )
    MP.TextSurfaceNum++
    memberNum = pt.getMemberNum()
    for (let i = 0; i < memberNum; i++) {
      selAry.push(String(i))
      valueAry.push(String(pt.PartyMember[i]))
    }
    if (TempVariable['haman']) {
      mode = 'pcSelNoCancel'
    } else {
      mode = 'pcSel'
    }
  } else if (GameState == 'inspectItemTrade') {
    if (key.match(/^shift_(right|left)$/)) {
      key = key.replace(/shift_/, '')
      TempVariable['targetNum'] = getNextTradeMember(
        PlayData['StatusNum'],
        TempVariable['targetNum'],
        key
      )
      TempVariable['targetSelectF'] = 0
      if (TempVariable['trade'] == 'target') {
        MP.SelectMode['selectF'] = 0
        value = 0
      }
    } else if (key.match(/^upDown/)) {
      value = key.replace(/upDown/, '')
    } else if (key == 'enter') {
      let my, target
      if (TempVariable['trade'] == 'my') {
        my = PC[PlayData['StatusNum']]
        target = PC[TempVariable['targetNum']]
      } else {
        my = PC[TempVariable['targetNum']]
        target = PC[PlayData['StatusNum']]
      }
      let sel = MP.SelectMode['select']
      if (my.Equip[sel] < 1) {
        let tradeItem = target.tradePossibleItem()
        if (target.putItem(-1) > -1) {
          target.putItem(my.Item[sel], my.ItemDecided[sel])
          target.check()
          setTradeSelectF(target)
          my.removeHaveItem(sel)
          my.check()
          value = MP.controlSelect('deleteSlide')
          MP.viewStatus(PlayData['StatusNow'], PlayData['StatusNum'])
        } else if (tradeItem > -1) {
          let item = [target.Item[tradeItem], target.ItemDecided[tradeItem]]
          target.removeHaveItem(tradeItem)
          target.putItem(my.Item[sel], my.ItemDecided[sel])
          target.check()
          setTradeSelectF(target)
          my.Item[sel] = item[0]
          my.ItemDecided[sel] = item[1]
          my.check()
          MP.viewStatus(PlayData['StatusNow'], PlayData['StatusNum'])
        }
      }
    } else if (key == 'cancel') {
      deleteTempVariable()
      MP.controlPreSelect('pop')
      GameState = 'inspectItem'
      statusAction('return')
      return
    } else if (key == '') {
      MP.clearTextSurface('all')
      MP.viewPreSelectMode(MP.TextSurfaceNum, 1, 'none')
      MP.viewPreSelectMode(MP.TextSurfaceNum, 2, 'none')
      TempVariable['targetNum'] = getNextTradeMember(
        PlayData['StatusNum'],
        PlayData['StatusNum'],
        'right'
      )
      ;(TempVariable['mySelectF'] = 0), (TempVariable['targetSelectF'] = 0)
      TempVariable['trade'] = 'my'
      if (PC[PlayData['StatusNum']].haveItemNum(-1) < 1) {
        TempVariable['trade'] = 'target'
      }
      MP.TextSurfaceNum++
    }
    let pcNum
    if (TempVariable['trade'] == 'my') {
      pcNum = PlayData['StatusNum']
    } else {
      pcNum = TempVariable['targetNum']
    }
    let itemMax = PC[pcNum].haveItemNum(-1)
    for (let i = 0; i < itemMax; i++) {
      selAry.push(PC[pcNum].getItemName(i, 'equip'))
      valueAry.push(String(i))
    }
    if (selAry.length < 1) {
      value = -1
    }
    mode = 'itemTrade'
    if (TempVariable['trade'] == 'my') {
      align = MP.MAIN_X + MP.MAIN_WIDTH / 2 - (MP.FONT_SIZE / 2) * 28
      y *= 4
    } else {
      align = MP.MAIN_X + MP.MAIN_WIDTH / 2 + (MP.FONT_SIZE / 2) * 2
      y *= 10
    }
    charMin = 26
    lineNum = PC[pcNum].ItemMaxNum
    if (lineNum > 12) {
      lineNum = 12
    }
    comment = 'itemTrade'
    MP.viewStatus(PlayData['StatusNow'], PlayData['StatusNum'])
  } else if (GameState == 'inspectItemIdentify') {
    let pcNum = PlayData['StatusNum']
    if (key == 'enter') {
      let num = Number(MP.SelectMode['valueAry'][MP.SelectMode['select']])
      let targetNum = Math.floor(num / 100)
      let haveNum = num % 100
      let itemNum = PC[targetNum].Item[haveNum]
      let item = ITEM[itemNum]
      let prob = Math.floor(
        strCalculation(
          replaceFormula(GameData['IDENTIFY_PROB'], [
            ['pc', pcNum],
            ['item', itemNum]
          ])
        )
      )
      printDebugMessage('identify rate: ' + String(prob) + '%')
      let str = ''
      let delFlag = false
      if (prob >= dice(1, 100)) {
        PC[targetNum].ItemDecided[haveNum] = 1
        PlayData['ItemFlag'][itemNum] = true
        MP.SelectMode['selAry'][MP.SelectMode['select']] = ' ' + item.getName()
        str = getDefaultMessage('IDENTIFIED', 1)
        delFlag = true
      } else {
        prob = Math.floor(
          strCalculation(
            replaceFormula(GameData['CURSE_EVASION_PROB'], [
              ['pc', pcNum],
              ['item', itemNum]
            ])
          )
        )
        printDebugMessage('curse evasion rate: ' + String(prob) + '%')
        if (prob >= dice(1, 100)) {
          str = getDefaultMessage('NOT_HAVE_A_CLUE', 1)
        } else {
          if (
            item.EQUIP_REQ_CLASS != '-' &&
            (item.CURSE_REQ_ALI != '-' || item.CURSE_REQ_SEX != '-') &&
            !GameData['IDENTIFY_NOT_CURSED']
          ) {
            delFlag = true
            let curseMode = 'normal'
            let tradeNum = PC[pcNum].tradePossibleItem()
            if (pcNum != targetNum) {
              if (PC[pcNum].getItemSpaceNum() > 0) {
                curseMode = 'trade'
                tradeNum = -1
              } else if (tradeNum > -1) {
                curseMode = 'trade'
              } else {
                curseMode = 'brake'
              }
            }
            if (curseMode != 'brake') {
              if (PC[pcNum].kindCursedCheck(item.TYPE)) {
                curseMode = 'brake'
              } else {
                let tmpHaveNum = PC[pcNum].kindEquipedItem(item.TYPE)
                if (tmpHaveNum > -1) {
                  PC[pcNum].Equip[tmpHaveNum] = 0
                }
                if (item.TYPE == 0) {
                  tmpHaveNum = PC[pcNum].kindEquipedItem(7)
                  if (tmpHaveNum > -1) {
                    PC[pcNum].Equip[tmpHaveNum] = 0
                  }
                } else if (item.TYPE == 2) {
                  tmpHaveNum = PC[pcNum].kindEquipedItem(7)
                  if (tmpHaveNum > -1) {
                    PC[pcNum].Equip[tmpHaveNum] = 0
                  }
                  tmpHaveNum = PC[pcNum].kindEquipedItem(0)
                  if (tmpHaveNum > -1) {
                    let tmpItem = PC[pcNum].Item[tmpHaveNum]
                    if (tmpItem.WEAPON_TYPE == 1) {
                      PC[pcNum].Equip[tmpHaveNum] = 0
                    }
                  }
                }
              }
            }
            if (curseMode == 'brake') {
              PC[targetNum].removeHaveItem(haveNum)
              str = getDefaultMessage('BROKEN', 1)
            } else {
              let curseHaveNum = -1
              if (curseMode == 'normal') {
                curseHaveNum = haveNum
              } else if (curseMode == 'trade') {
                PC[targetNum].removeHaveItem(haveNum)
                if (tradeNum > -1) {
                  PC[targetNum].putItem(
                    PC[pcNum].Item[tradeNum],
                    PC[pcNum].ItemDecided[tradeNum]
                  )
                  PC[pcNum].removeHaveItem(tradeNum)
                }
                curseHaveNum = PC[pcNum].putItem(itemNum, 0)
              }
              PC[pcNum].Equip[curseHaveNum] = 2
              MP.SelectMode['selAry'][MP.SelectMode['select']] =
                '-' + item.getName(0)
              MP.SelectMode['valueAry'][MP.SelectMode['select']] =
                pcNum * 100 + itemNum
              str = getDefaultMessage('CURSED', 1)
            }
            if (pcNum != targetNum) {
              PC[targetNum].check()
            }
            PC[pcNum].check()
          }
          PC[pcNum].State = 1
          if (str == '') {
            str = getDefaultMessage('BE_AFRAID', 1).replace(
              /\[name\]/g,
              PC[pcNum].Name[0]
            )
          }
        }
      }
      MP.viewStatus(PlayData['StatusNow'], PlayData['StatusNum'])
      MP.clearTextSurface()
      MP.viewSelectMode()
      let select2 = MP.SelectMode['select'] - MP.SelectMode['selectF']
      let lineNum2 = 6
      if (select2 == 1) {
        lineNum2 = 7
      } else if (select2 == 2) {
        lineNum2 = 8
      } else if (select2 == 3) {
        lineNum2 = 5
      }
      MP.drawTextFrame(
        MP.TextSurface[MP.TextSurfaceNum],
        str,
        'center',
        MP.LINE_HEIGHT * lineNum2
      )
      if (delFlag) {
        MP.controlSelect('delete')
      }
      GameState = 'inspectItemIdentifyReturn'
      return
    }
    let ary = pt.getItemDecidedList(pcNum)
    if (ary.length < 1 || PC[pcNum].State > 0) {
      key = 'cancel'
    }
    if (key == 'cancel') {
      MP.controlPreSelect('pop')
      GameState = 'inspectItem'
      statusAction('return')
      return
    }
    MP.viewStatus(PlayData['StatusNow'], PlayData['StatusNum'])
    MP.clearTextSurface('all')
    MP.viewPreSelectMode(MP.TextSurfaceNum, 1, 'none')
    MP.viewPreSelectMode(MP.TextSurfaceNum, 2, 'none')
    MP.drawTextFrame(
      MP.TextSurface[MP.TextSurfaceNum],
      getDefaultMessage('IDENTIFY_WHICH', 1),
      'center',
      MP.LINE_HEIGHT * 1
    )
    MP.TextSurfaceNum++
    for (let i = 0; i < ary.length; i++) {
      selAry.push(
        ' ' + PC[Math.floor(ary[i] / 100)].getItemName(ary[i] % 100, 'decided')
      )
      valueAry.push(String(ary[i]))
    }
    y *= 4
    charMin = 26
    lineNum = 16
    comment = 'itemIdentify'
  } else if (GameState == 'inspectItemSort') {
    let pcNum = PlayData['StatusNum']
    if (key == '') {
      MP.clearTextSurface('all')
      MP.viewPreSelectMode(MP.TextSurfaceNum, 1, 'none')
      MP.viewPreSelectMode(MP.TextSurfaceNum, 2, 'none')
      MP.TextSurfaceNum++
      TempVariable['itemList1'] = []
      TempVariable['itemList2'] = []
      let itemNum = PC[pcNum].haveItemNum(-1)
      for (let i = 0; i < itemNum; i++) {
        TempVariable['itemList1'].push([
          PC[pcNum].Item[i],
          PC[pcNum].ItemDecided[i],
          PC[pcNum].Equip[i]
        ])
      }
      TempVariable['itemList1'].push([-1, 0, 0])
    } else if (key == 'enter') {
      let sel = MP.SelectMode['select']
      if (TempVariable['itemList1'][sel][0] < 0) {
        while (TempVariable['itemList1'].length > 1) {
          let ary = TempVariable['itemList1'].shift()
          TempVariable['itemList2'].push([ary[0], ary[1], ary[2], 0])
        }
      } else {
        TempVariable['itemList2'].push([
          TempVariable['itemList1'][sel][0],
          TempVariable['itemList1'][sel][1],
          TempVariable['itemList1'][sel][2],
          sel
        ])
        TempVariable['itemList1'].splice(sel, 1)
      }
      if (TempVariable['itemList1'].length < 2) {
        for (let i = 0; i < TempVariable['itemList2'].length; i++) {
          PC[pcNum].Item[i] = TempVariable['itemList2'][i][0]
          PC[pcNum].ItemDecided[i] = TempVariable['itemList2'][i][1]
          PC[pcNum].Equip[i] = TempVariable['itemList2'][i][2]
        }
        deleteTempVariable()
        MP.controlPreSelect('pop')
        GameState = 'inspectItem'
        statusAction('return')
        return
      }
    } else if (key == 'cancel') {
      if (TempVariable['itemList2'].length > 0) {
        let ary = TempVariable['itemList2'].pop()
        TempVariable['itemList1'].splice(ary[3], 0, [ary[0], ary[1], ary[2]])
        value = String(MP.SelectMode['select'])
      } else {
        deleteTempVariable()
        MP.controlPreSelect('pop')
        GameState = 'inspectItem'
        statusAction('return')
        return
      }
    }
    for (let i = 0; i < TempVariable['itemList1'].length; i++) {
      if (TempVariable['itemList1'][i][0] < 0) {
        selAry.push(getDefaultMessage('FINISH', 1, 26))
      } else {
        selAry.push(
          ITEM[TempVariable['itemList1'][i][0]].getName(
            TempVariable['itemList1'][i][1],
            TempVariable['itemList1'][i][2],
            pcNum
          )
        )
      }
      valueAry.push(String(i))
    }
    align = MP.MAIN_X + MP.MAIN_WIDTH / 2 - (MP.FONT_SIZE / 2) * 28
    y *= 4
    charMin = 26
    lineNum = PC[pcNum].ItemMaxNum
    if (lineNum > 12) {
      lineNum = 12
    }
    comment = 'itemSort'
    MP.viewStatus(PlayData['StatusNow'], PlayData['StatusNum'])
  } else if (GameState == 'inspectEquip') {
    let pcNum = PlayData['StatusNum']
    let pc = PC[pcNum]
    if (key == '') {
      key = 'next'
      TempVariable['equipSel'] = -1
    } else if (key == 'cancel') {
      key = 'enter'
      value = '-1'
    }
    if (changeEquipAction(key, value)) {
      return
    }
    value = TempVariable['value']
    selAry = TempVariable['selAry'].slice()
    valueAry = TempVariable['valueAry'].slice()
    y *= 4
    charMin = 26
    lineNum = pc.ItemMaxNum
    if (lineNum > 12) {
      lineNum = 12
    }
    comment = 'haveItem'
  } else if (GameState == 'inspectSP') {
    let pcNum = PlayData['StatusNum']
    let pc = PC[pcNum]
    if (key == 'cancel') {
      key = 'enter'
      value = 1
    }
    if (key == 'enter') {
      if (value == 0) {
        TempVariable['haveNum'] = TempVariable['stack'].shift()
        let item = ITEM[pc.Item[TempVariable['haveNum']]]
        let spellData = decomposeSpell(spellEffectReplace(item.SP, 2), pcNum)
        let spellSelNum = 0
        if (spellData['spellEffect'].length > 1) {
          spellSelNum = dice(1, spellData['spellEffect'].length) - 1
        }
        SPELL_EF.spellEffect(
          spellData,
          spellSelNum,
          'campSp',
          pt.getMemberForPcNum(pcNum)
        )
        sePlay('spell')
        if (SPELL_EF.Effect == 'return') {
          TempVariable['nextDungeon'] = -1
          TempVariable['nextFloor'] = -1
          TempVariable['nextX'] = 0
          TempVariable['nextY'] = 0
          GenericVariable['KeyInvalid'] = true
          GenericVariable['TimeEventCountMax'] = TIME_COUNT[1]
          GenericVariable['TimeEventCount'] = 0
          GenericVariable['TimeEvent'] = 'moveFloor'
          return
        } else if (SPELL_EF.Effect.indexOf('coordinateTeleport') > -1) {
          let ary = SPELL_EF.Effect.split(',')
          let tp = [
            Number(ary[1]),
            Number(ary[2]),
            Number(ary[3]),
            Number(ary[4])
          ]
          if (tp[0] < 0) {
            TempVariable['nextDungeon'] = -1
            TempVariable['nextFloor'] = -1
            TempVariable['nextX'] = 0
            TempVariable['nextY'] = 0
            GenericVariable['KeyInvalid'] = true
            GenericVariable['TimeEventCountMax'] = TIME_COUNT[1]
            GenericVariable['TimeEventCount'] = 0
            GenericVariable['TimeEvent'] = 'moveFloor'
            return
          } else {
            PlayData['StatusNow'] = ''
            TempVariable['nextDungeon'] = tp[0]
            TempVariable['nextFloor'] = tp[1]
            TempVariable['nextX'] = tp[2]
            TempVariable['nextY'] = tp[3]
            GenericVariable['KeyInvalid'] = true
            GenericVariable['TimeEventCountMax'] = TIME_COUNT[1]
            GenericVariable['TimeEventCount'] = 0
            GenericVariable['TimeEvent'] = 'moveFloorFromCamp'
            return
          }
        } else if (SPELL_EF.MessageStack[0].length > 0) {
          MP.TextSurfaceNum++
          GameState = 'messageInCampSP'
          statusAction()
          return
        }
      } else {
        TempVariable['stack'].shift()
      }
    } else if (key == '') {
      TempVariable['stack'] = []
      let party = PARTY[pc.PartyNum]
      let checkSpace = DUNGEON.checkSpaceSpellUsed(
        party.DungeonNumber,
        party.Floor,
        party.X,
        party.Y
      )
      if (checkSpace != 1 && checkSpace != 2) {
        let itemMax = pc.haveItemNum(-1)
        for (let i = 0; i < itemMax; i++) {
          let item = ITEM[pc.Item[i]]
          if (item.SP != '' && item.equipCheck(pcNum)) {
            if (!(GameData['CANNOT_USE_CURSED_ITEM'] && pc.Equip[i] == 2)) {
              TempVariable['stack'].push(i)
            }
          }
        }
      }
    }
    if (TempVariable['stack'].length == 0) {
      deleteTempVariable()
      MP.controlPreSelect('pop')
      GameState = 'inspectCommand'
      statusAction('return')
      return
    }
    MP.viewStatus(PlayData['StatusNow'], PlayData['StatusNum'])
    MP.clearTextSurface('all')
    MP.TopSurface.clear()
    MP.viewPreSelectMode(MP.TextSurfaceNum, 1, 'none')
    let haveNum = TempVariable['stack'][0]
    let str = pc.getItemName(haveNum, 'decided')
    str = getDefaultMessage('INVOKE_SP').replace(/\[item\]/g, str)
    str = MP.strChangeLine(str, 48, 12, true)
    MP.drawTextFrame(
      MP.TextSurface[MP.TextSurfaceNum],
      str,
      'center',
      MP.LINE_HEIGHT * 6
    )
    MP.TextSurfaceNum++
    selAry.push(getDefaultMessage('YES', 1))
    selAry.push(getDefaultMessage('NO', 1))
    y *= 8 + MP.strGetLineNum(str)
    value = 1
  } else if (GameState == 'inspectAbility') {
    if (key.match(/^(enter|cancel)$/)) {
      PlayData['StatusNow'] = 'status'
      GameState = 'inspectCommand'
      MP.SelectMode['valueAry'][MP.SelectMode['select']] = 'ability'
      statusAction('return')
      return
    }
    PlayData['StatusNum'] = Number(
      MP.PreSelect['valueAry'][0][MP.PreSelect['select'][0]]
    )
    MP.viewStatus(PlayData['StatusNow'], PlayData['StatusNum'])
    MP.clearTextSurface('all')
    mode = 'statusAbility'
  } else if (GameState.match(/^searchForPc/)) {
    if (key == 'enter') {
      let pcNum = Number(value)
      let pc = PC[pcNum]
      let dunNum = -1
      if (pc.PartyNum > -1) {
        dunNum = PARTY[pc.PartyNum].DungeonNumber
      }
      let text = null
      if (pc.PartyNum == ptNum) {
        text = getDefaultMessage('IN_THIS_PARTY')
      } else if (pc.PartyNum < 0) {
        text = getDefaultMessage('OUT_OF_DUNGEON')
      } else if (pc.PartyNum > -1 && dunNum != pt.DungeonNumber) {
        text = getDefaultMessage('IN_OTHER_DUNGEON')
        text = text.replace(/\[dungeon\]/g, DUNGEON.DungeonName[dunNum])
      } else if (!Config['AutoMapping']) {
        let pcPt = PARTY[pc.PartyNum]
        text = getDefaultMessage('IN_THE_POINT')
        text = text.replace(
          /\[floor\]/g,
          DUNGEON.getFloorName(dunNum, pcPt.Floor)
        )
        text = text.replace(/\[eastPoint\]/g, String(pcPt.X))
        text = text.replace(/\[northPoint\]/g, String(pcPt.Y))
      }
      if (text != null) {
        text = text.replace(/\[name\]/g, pc.Name[0])
        text = MP.strChangeLine(text, 52, 12, true)
        MP.drawTextFrame(
          MP.TextSurface[MP.TextSurfaceNum],
          text,
          'center',
          MP.LINE_HEIGHT * 8,
          36
        )
      } else {
        let pcPt = PARTY[pc.PartyNum]
        TempVariable['x'] = pcPt.X
        TempVariable['y'] = pcPt.Y
        TempVariable['direction'] = -1
        let ary = SPELL_EF.Effect.split(',')
        MP.drawMap(
          pcPt.DungeonNumber,
          pcPt.Floor,
          pcPt.X,
          pcPt.Y,
          -1,
          ary[1],
          ary[2]
        )
      }
      if (GameState.indexOf('Camp') > -1) {
        PlayData['StatusNow'] = 'status'
        if (GameState.indexOf('Spell') > -1) {
          GameState = 'inspectCastResultNotEnterReturn'
        } else {
          GameState = 'inspectItemUseResultNotEnterReturn'
        }
      } else if (GameState.indexOf('Event') > -1) {
        if (GameState.indexOf('Step') > -1) {
          GameState = 'moveStepNotEnterReturn'
        } else {
          GameState = 'moveNotEnterReturn'
        }
      }
      return
    }
    MP.clearMainWindow()
    MP.drawFrame_Full_Title(MP.MainSurface)
    MP.drawTextFrame(
      MP.TextSurface[MP.TextSurfaceNum],
      getDefaultMessage('FIND_WHOM', 1),
      'center',
      MP.LINE_HEIGHT * 3
    )
    MP.TextSurfaceNum++
    for (let i = 0; i < PlayData['PcMax']; i++) {
      selAry.push(PC[PlayData['PcList'][i]].nameListStr())
      valueAry.push(String(PlayData['PcList'][i]))
    }
    y *= 6
    lineNum = 16
    mode = 'noCancel'
  } else if (GameState.match(/^teleportFloor(Spell|Item)$/)) {
    if (key == 'enter') {
      TempVariable['floor'] = Number(value)
      if (GameState.indexOf('Spell') > -1) {
        GameState = 'teleportSpell'
      } else {
        GameState = 'teleportItem'
      }
      let ary = SPELL_EF.Effect.split(',')
      MP.drawMap(
        pt.DungeonNumber,
        TempVariable['floor'],
        TempVariable['x'],
        TempVariable['y'],
        -1,
        ary[4],
        ary[5]
      )
      return
    } else if (key == 'cancel') {
      TempVariable['floor'] = pt.Floor
      if (GameData['TELEPORT_START_ZERO']) {
        TempVariable['x'] = 0
        TempVariable['y'] = 0
      } else {
        TempVariable['x'] = pt.X
        TempVariable['y'] = pt.Y
      }
    }
    MP.clearMainWindow()
    MP.drawFrame_Full_Title(
      MP.MainSurface,
      DUNGEON.DungeonName[pt.DungeonNumber]
    )
    MP.drawTextFrame(
      MP.TextSurface[MP.TextSurfaceNum],
      getDefaultMessage('HOW_MANY_FLOORS', 1, 52),
      'center',
      MP.LINE_HEIGHT * 3
    )
    MP.TextSurfaceNum++
    for (let i = TempVariable['mapViewFloor'].length - 1; i >= 0; i--) {
      selAry.push(
        DUNGEON.getFloorName(pt.DungeonNumber, TempVariable['mapViewFloor'][i])
      )
      valueAry.push(String(TempVariable['mapViewFloor'][i]))
    }
    value = String(TempVariable['floor'])
    y *= 6
    textAlign = 'right'
  } else if (GameState.indexOf('messageInCamp') > -1) {
    MP.clearTextSurface()
    let text = SPELL_EF.MessageStack[0].shift()
    text = text.replace(/<p>/g, '<br>')
    text = MP.strChangeLine(text, 52, 5, true)
    MP.drawTextFrame(
      MP.TextSurface[MP.TextSurfaceNum],
      text,
      'center',
      MP.LINE_HEIGHT * 8,
      52
    )
    if (SPELL_EF.MessageStack[0].length > 0) {
      GameState += 'Return'
    } else if (GameState.indexOf('Spell') > -1) {
      GameState = 'inspectCastResultReturn'
    } else if (GameState.indexOf('Item') > -1) {
      GameState = 'inspectItemUseResultReturn'
    } else {
      MP.TextSurfaceNum--
      GameState = 'inspectSPReturn'
    }
    return
  }
  MP.setSelectMode(
    statusAction,
    mode,
    selAry,
    valueAry,
    colorAry,
    comment,
    align,
    y,
    charMin,
    lineNum,
    textAlign,
    value,
    MP.SelectMode['selectF'],
    GameData['SELECT_COLOR']
  )
  function getInspectCommand () {
    let resultAry = [[], []]
    let pc = PC[PlayData['StatusNum']]
    let checkSpell = pc.spellMaster(-1, -1, -1)
    if (PlayData['StatusAction'] == 'campInspect') {
      let party = PARTY[pc.PartyNum]
      let checkSpace = DUNGEON.checkSpaceSpellUsed(
        party.DungeonNumber,
        party.Floor,
        party.X,
        party.Y
      )
      if (checkSpell && pc.State < 1 && checkSpace != 0 && checkSpace != 2) {
        resultAry[0].push(getDefaultMessage('CAST', 1, 20))
        resultAry[1].push('cast')
      }
    }
    if (PlayData['StatusAction'] != 'trainingInspect') {
      resultAry[0].push(getDefaultMessage('ITEM', 1, 20))
      resultAry[1].push('item')
      if (pc.haveItemNum(-1) > 0) {
        resultAry[0].push(getDefaultMessage('EQUIP', 1, 20))
        resultAry[1].push('equip')
      }
      resultAry[0].push(getDefaultMessage('POOL_GOLD', 1, 20))
      resultAry[1].push('poolGold')
    }
    if (checkSpell) {
      resultAry[0].push(getDefaultMessage('READ', 1, 20))
      resultAry[1].push('read')
    }
    if (GameData['HELP_COMMENT']) {
      resultAry[0].push(getDefaultMessage('ABILITY', 1, 20))
      resultAry[1].push('ability')
    }
    if (
      PlayData['StatusAction'] == 'trainingInspect' &&
      (GameData['FACE_GRAPHIC_STATUS'] || GameData['FACE_GRAPHIC_BATTLE'])
    ) {
      resultAry[0].push(getDefaultMessage('SET_FACE_GRAPHIC', 1, 20))
      resultAry[1].push('setFaceGraphic')
    }
    resultAry[0].push(getDefaultMessage('LEAVE', 1, 20))
    resultAry[1].push('leave')
    return resultAry
  }
  function getNextTradeMember (myNum, targetNum, control) {
    let pt = PARTY[PlayData['ActiveParty']]
    let my = pt.getMemberForPcNum(myNum)
    let target = pt.getMemberForPcNum(targetNum)
    let memberNum = pt.getMemberNum()
    if (memberNum < 2) {
      return targetNum
    }
    while (true) {
      if (control == 'left') {
        target--
      } else {
        target++
      }
      if (target < 0) {
        target = memberNum - 1
      } else if (target >= memberNum) {
        target = 0
      }
      if (target != my) {
        break
      }
    }
    return pt.PartyMember[target]
  }
  function setTradeSelectF (pc) {
    let itemMax = pc.haveItemNum(-1)
    let sel = itemMax - 1
    let lineNum = pc.ItemMaxNum
    if (lineNum > 12) {
      lineNum = 12
    }
    let selectF = 0
    if (sel >= lineNum) {
      selectF = sel - (lineNum - 1)
    }
    if (TempVariable['trade'] == 'my') {
      TempVariable['targetSelectF'] = selectF
    } else {
      TempVariable['mySelectF'] = selectF
    }
  }
}
