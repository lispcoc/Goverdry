class CharactorModel {
  constructor (pcNum) {
    pcNum = checkNull(pcNum, -1)
    this.PC_NUM = pcNum
    this.initializeVariable()
    this.spellEffectClear(true)
    this.battleReset()
    if (this.PC_NUM > -2) {
      this.check(0)
    }
  }
  battleActionReset () {
    this.Action = new Array(4)
    for (let i = 0; i < this.Action.length; i++) {
      this.Action[i] = -1
    }
    this.GetHeal = new Array(8)
    for (let i = 0; i < this.GetHeal.length; i++) {
      this.GetHeal[i] = false
    }
  }
  battleReset () {
    this.battleActionReset()
    this.AttackCount = 0
    ;(this.Asleep = 0),
      (this.Silence = 0),
      (this.NoBreath = 0),
      (this.NotSpellCancel = false)
    ;(this.Hide = false), (this.BreathNum = this.BreathMax)
    ;(this.BtSpellEffectTurn = []), (this.BtSpellEffectPlus = [])
    for (let i = 0; i < 9; i++) {
      ;(this.BtSpellEffectTurn[i] = -1), (this.BtSpellEffectPlus[i] = 0)
    }
    ;(this.BtOnlySpellEffectTurn = []), (this.BtOnlySpellEffectPlus = [])
    for (let i = 0; i < 1; i++) {
      ;(this.BtOnlySpellEffectTurn[i] = -1), (this.BtOnlySpellEffectPlus[i] = 0)
    }
    ;(this.Bt_abiPlus = []), (this.AbiTurn = [])
    for (let i = 0; i < GameData['ABILITY'].length; i++) {
      ;(this.Bt_abiPlus[i] = 0), (this.AbiTurn[i] = -1)
    }
    ;(this.TrapInspect = -2), (this.TrapSpell = -2)
    ;(this.CD_Attribute = []),
      (this.CD_Turn = []),
      (this.CD_Value = []),
      (this.CD_Resist = [])
    ;(this.Bt_resistPlus = []), (this.ResistTurn = [])
    for (let i = 0; i < RESIST_LENGTH; i++) {
      ;(this.Bt_resistPlus[i] = -2), (this.ResistTurn[i] = -1)
    }
    ;(this.Bt_attackAddPlus = []), (this.AttackAddTurn = [])
    for (let i = 0; i < ATTACK_ADD_LENGTH + 1; i++) {
      ;(this.Bt_attackAddPlus[i] = false), (this.AttackAddTurn[i] = -1)
    }
    this.Bt_poisonPlus = 0
    ;(this.Hate = -1), (this.HateTurn = -1)
    this.InspectTrap = [-2, -2]
  }
  boxItem (haveItemNum) {
    let result = 0
    if (this.State > 0) {
      return result
    }
    let start, end
    if (haveItemNum == undefined || haveItemNum == null) {
      ;(start = 0), (end = this.ItemMaxNum)
    } else {
      ;(start = haveItemNum), (end = start + 1)
      if (end > this.ItemMaxNum) {
        end = this.ItemMaxNum
      }
    }
    for (let i = start; i < end; i++) {
      if (this.Item[i] < 0) {
        break
      }
      let item = ITEM[this.Item[i]]
      if (GameData['CANNOT_USE_CURSED_ITEM'] && this.Equip[i] == 2) {
        continue
      }
      if (item.USE_EQUIP && !item.equipCheck(this.PC_NUM)) {
        continue
      }
      let strAry = item.USE.split('</>')
      if (strAry.length > 1) {
        if (strAry[0] == '3') {
          result++
        }
      }
    }
    return result
  }
  boxSpell (kind, lv, spell) {
    if (kind == undefined || kind == null) {
      ;(kind = -1), (lv = -1), (spell = -1)
    }
    if (lv == undefined || lv == null) {
      ;(lv = -1), (spell = -1)
    }
    if (spell == undefined || spell == null) {
      spell = -1
    }
    let result = 0
    if (this.State > 0) {
      return result
    }
    let kindStart, kindEnd
    if (kind < 0) {
      ;(kindStart = 0), (kindEnd = GameData['SPELL_KIND'])
    } else {
      ;(kindStart = kind), (kindEnd = kindStart + 1)
    }
    let lvStart, lvEnd
    if (lv < 0) {
      ;(lvStart = GameData['SPELL_LVMAX'] - 1), (lvEnd = 0)
    } else {
      ;(lvStart = lv), (lvEnd = lv)
    }
    let spellStart, spellEnd
    if (spell < 0) {
      ;(spellStart = 0), (spellEnd = 6)
    } else {
      ;(spellStart = spell), (spellEnd = spellStart + 1)
    }
    let stack = []
    for (let i = kindStart; i < kindEnd; i++) {
      for (let j = lvStart; j >= lvEnd; j--) {
        let lvNum = -1
        for (let k = spellStart; k < spellEnd; k++) {
          if (GameData['SPELL'][i][j][k] == '') {
            continue
          }
          let strAry = GameData['SPELL'][i][j][k].split('<>')
          if (strAry[1] == '3') {
            if (
              this.Spell[i][j][k] &&
              !this.SealSpell &&
              this.Mp[i][j] >= GameData['SPELL_CONSUMPTION_MP'][i][j][k]
            ) {
              lvNum = j * 1000 + i * 100 + j * 10 + k
              break
            }
          }
        }
        if (lvNum > -1) {
          stack.push(lvNum)
          break
        }
      }
    }
    if (stack.length < 1) {
      return -1
    } else {
      stack.sort(function (a, b) {
        return b - a
      })
      return stack[0] % 1000
    }
  }
  check (zero) {
    if (this.Name[0] == '' && this.Name[1] == '') {
      return
    }
    if (zero == 0) {
      zero = true
    } else {
      zero = false
    }
    let classAcEquipCheck = true
    let minusAt = 0
    if (this.PC_NUM > -1) {
      for (let i = 0; i < RESIST_LENGTH; i++) {
        this.Resist[i] = false
        this.Resist1[i] = false
        this.Resist0[i] = false
      }
      for (let i = 0; i < MONSTER_TYPE; i++) {
        this.Attack[i] = false
        this.Defense[i] = false
      }
      let nullItem = false
      for (let i = 0; i < this.Item.length; i++) {
        if (this.Item[i] < 0 || this.Item[i] == null) {
          continue
        }
        if (this.Item[i] >= ITEM.length) {
          this.Item[i] = 0
          this.ItemDecided[i] = 1
          nullItem = true
        }
      }
      if (nullItem) {
        for (let i = 0; i < this.Equip.length; i++) {
          this.Equip[i] = 0
        }
      }
      if (this.Race >= GameData['RACE'].length) {
        this.Race = 0
      }
      if (this.PcClass >= GameData['PC_CLASS'].length) {
        this.PcClass = 0
      }
      this.checkSexByRace()
      this.checkItemMaxNum()
      for (let i = 0; i < this.ItemMaxNum; i++) {
        if (this.Item[i] < 0) {
          continue
        }
        if (this.Equip[i] == 1 || this.Equip[i] == 3) {
          if (ITEM[this.Item[i]].curseCheck(this.PC_NUM)) {
            this.Equip[i] = 2
          }
        }
      }
      if (this.weaponCursedCheck() == -1 || this.kindCursedCheck(0)) {
        let num = this.kindEquipedItem(7)
        if (num > -1) {
          this.Equip[num] = 0
        }
      }
      this.Lifetime = GameData['RACE_LIFETIME'][this.Race]
      this.Ac0 = GameData['RACE_AC'][this.Race]
      this.Ac1 = this.Ac0
      this.Healing = GameData['RACE_HEALING'][this.Race]
      for (let i = 0; i < RESIST_LENGTH; i++) {
        if (GameData['RACE_RESIST'][this.Race].indexOf(i.toString(16)) > -1) {
          this.Resist0[i] = true
        } else {
          this.Resist0[i] = false
        }
      }
      if (this.NotSpellCancel) {
        this.SpellCancel0 = 0
      } else {
        this.SpellCancel0 = GameData['RACE_SPELL_CANCEL'][this.Race]
      }
      this.SpellCancel1 = this.SpellCancel0
      this.Hit0 = 0
      this.Hit1 = this.Hit0
      this.Hit = this.Hit0
      this.At0 = 0
      this.At = this.At0
      this.Range = [0, 0]
      this.Dmg = 'bareHands'
      this.DmgSub = ''
      this.AttackKind = ''
      this.AttackKindSub = ''
      this.GroupAtNum = 1
      this.GroupAtNumSub = 1
      this.SubweaponHalf = true
      for (let i = 0; i < ATTACK_ADD_LENGTH; i++) {
        this.AttackAdd[i] = false
      }
      this.AttackPoison = 0
      let attackAddEquipCheck = true
      for (let i = 0; i < this.ItemMaxNum; i++) {
        if (this.Item[i] < 0) {
          break
        }
        if (this.Equip[i] > 0 && ITEM[this.Item[i]].CLASS_ATTACK_ADD_EQUIP) {
          attackAddEquipCheck = false
          break
        }
      }
      if (attackAddEquipCheck) {
        if (GameData['CLASS_ATTACK_ADD'][this.PcClass] == 1) {
          this.AttackAdd[3] = true
        } else if (GameData['CLASS_ATTACK_ADD'][this.PcClass] == 2) {
          this.AttackAdd[4] = true
        }
      }
      this.ThiefLv = GameData['CLASS_THIEF'][this.PcClass]
      if (this.HpMax0 < 1) {
        this.HpMax0 = 1
      } else if (this.HpMax0 > 99999) {
        this.HpMax0 = 99999
      }
      this.HpMax = this.HpMax0
      if (this.Level < 0) {
        this.Level = 0
      } else if (this.Level > 99999) {
        this.Level = 99999
      }
      for (let i = 0; i < GameData['ABILITY'].length; i++) {
        if (
          this.Ability0[i] == undefined ||
          this.Ability0[i] == null ||
          Number.isNaN(this.Ability0[i])
        ) {
          this.Ability0[i] =
            GameData['RACE_ABI'][this.Race][i] +
            GameData['ABILITY_SEX'][this.Sex][i]
        }
        if (this.Ability0[i] < 0) {
          this.Ability0[i] = 0
        } else if (this.Ability0[i] > 999) {
          this.Ability0[i] = 999
        }
        this.Ability1[i] = this.Ability0[i]
      }
      for (let i = 0; i < RESIST_LENGTH; i++) {
        this.Resist1[i] = this.Resist0[i]
      }
      let mainWeapon = this.weaponCursedCheck()
      for (let i = 0; i < this.ItemMaxNum; i++) {
        if (this.Item[i] < 0) {
          continue
        }
        let item = ITEM[this.Item[i]]
        let eqCheck = item.equipCheck(this.PC_NUM)
        if (item.TYPE == 0 && item.WEAPON_TYPE != 2 && this.Equip[i] == 3) {
          this.Equip[i] = 0
        }
        if (this.Equip[i] > 0) {
          if (item.CLASS_AC_EQUIP) {
            classAcEquipCheck = false
          }
          if (this.Equip[i] == 2) {
            this.Ac1 += item.CURSE_AC
          } else {
            this.Ac1 += item.AC
          }
          if (item.TYPE == 0 && eqCheck) {
            if (i == mainWeapon) {
              this.Dmg = item.DMG
              this.GroupAtNum = item.GROUP_AT_NUM
              if (this.GroupAtNum < 1) {
                this.GroupAtNum = 1
              } else if (this.GroupAtNum > 9) {
                this.GroupAtNum = 9
              }
              if (this.Range[0] < item.RANGE[0]) {
                this.Range[0] = item.RANGE[0]
              }
              if (this.Range[1] < item.RANGE[1]) {
                this.Range[1] = item.RANGE[1]
              }
              this.AttackKind = item.ATTACK_KIND
            } else if (this.Equip[i] == 3) {
              this.DmgSub = item.DMG
              this.GroupAtNumSub = item.GROUP_AT_NUM
              this.AttackKindSub = item.ATTACK_KIND
              this.SubweaponHalf = item.SUBWEAPON_HALF
            }
          } else {
            if (this.Range[0] < item.RANGE[0]) {
              this.Range[0] = item.RANGE[0]
            }
            if (this.Range[1] < item.RANGE[1]) {
              this.Range[1] = item.RANGE[1]
            }
          }
          if (eqCheck) {
            this.Hit1 += item.HIT
            this.Hit += item.HIT
            if (item.AT < 0) {
              minusAt += item.AT
            } else if (this.At0 < item.AT) {
              this.At0 = item.AT
            }
            if (item.ATTACK_ADD > -1) {
              this.AttackAdd[item.ATTACK_ADD] = true
            }
            this.AttackPoison += item.POISON
          }
        }
        if (item.ITEM_EFFECT_EQUIP && this.Equip[i] == 0) {
          continue
        }
        if (item.ITEM_NOT_APPLIED && !eqCheck && this.Equip[i] == 0) {
          continue
        }
        this.Healing += item.HEALING
        for (let j = 0; j < RESIST_LENGTH; j++) {
          if (item.RESIST.indexOf(j.toString(16)) > -1) {
            this.Resist1[j] = true
          }
        }
        if (!this.NotSpellCancel) {
          this.SpellCancel1 += item.SPELL_CANCEL
        }
        for (let j = 0; j < MONSTER_TYPE; j++) {
          let str = j.toString(16)
          if (item.ATTACK_EFFECT.indexOf(str) > -1) {
            this.Attack[j] = true
          }
          if (item.DEFENSE_EFFECT.indexOf(str) > -1) {
            this.Defense[j] = true
          }
        }
        let strAry = item.ITEM_ABI.split(',')
        for (let j = 0; j < GameData['ABILITY'].length; j++) {
          if (j >= strAry.length) {
            break
          }
          this.Ability1[j] += Number(strAry[j])
        }
      }
    } else if (this.MonsterDataNum > -1) {
      this.Hit0 = 0
      this.Hit1 = this.Hit0
      this.Hit = this.Hit0
      for (let i = 0; i < RESIST_LENGTH; i++) {
        this.Resist[i] = false
        this.WeakPoint[i] = false
      }
      this.HpMax = this.HpMax0
      for (let i = 0; i < ATTACK_ADD_LENGTH; i++) {
        if (
          MONSTER_DATA[this.MonsterDataNum].ATTACK_ADD.indexOf(String(i)) > -1
        ) {
          this.AttackAdd[i] = true
        } else {
          this.AttackAdd[i] = false
        }
      }
      this.AttackPoison = MONSTER_DATA[this.MonsterDataNum].POISON
      this.Healing = MONSTER_DATA[this.MonsterDataNum].HEALING
      this.checkMonsterAt('init')
    }
    if (this.Poison < 0) {
      this.Poison = 0
    } else if (this.Poison > 99999) {
      this.Poison = 99999
    }
    if (this.PC_NUM > -1) {
      for (let i = 0; i < RESIST_LENGTH; i++) {
        this.Resist[i] = this.Resist1[i]
      }
      this.Ac = this.Ac1 + this.SpellEffectPlus[0]
      this.Hit += this.SpellEffectPlus[1]
      this.SpellCancel = this.SpellCancel1 + this.SpellEffectPlus[2]
      this.SrPlus = this.SpellEffectPlus[3]
      this.BrPlus = this.SpellEffectPlus[4]
      this.Healing += this.SpellEffectPlus[5]
      this.HpMax += this.SpellEffectPlus[7]
      for (let i = 0; i < GameData['ABILITY'].length; i++) {
        this.Ability[i] = this.Ability1[i] + this.AbiPlus[i]
      }
      for (let i = 0; i < RESIST_LENGTH; i++) {
        let resist = this.ResistPlus[i]
        if (resist == 1) {
          this.Resist[i] = true
        } else if (resist == 0 || resist == -1) {
          this.Resist[i] = false
        }
      }
      for (let i = 0; i < ATTACK_ADD_LENGTH + 1; i++) {
        if (this.AttackAddPlus[i]) {
          if (i == ATTACK_ADD_LENGTH) {
            this.AttackPoison += this.PoisonPlus
          } else {
            this.AttackAdd[i] = true
          }
        }
      }
    } else if (this.MonsterDataNum > -1) {
      for (let i = 0; i < RESIST_LENGTH; i++) {
        this.Resist[i] = this.Resist1[i]
        this.WeakPoint[i] = this.WeakPoint1[i]
      }
      this.Ac = this.Ac1
      this.SpellCancel = this.SpellCancel1
      this.SrPlus = 0
      this.BrPlus = 0
      for (let i = 0; i < GameData['ABILITY'].length; i++) {
        this.Ability[i] = this.Ability1[i]
      }
      for (let i = 0; i < RESIST_LENGTH; i++) {
        this.Resist[i] = this.Resist1[i]
        this.WeakPoint[i] = this.WeakPoint1[i]
      }
    }
    if (this.PC_NUM > -1 && this.PartyNum > -1) {
      let party = PARTY[this.PartyNum]
      this.Ac += party.SpellEffectPlus[0]
      this.Hit += party.SpellEffectPlus[1]
      this.SpellCancel += party.SpellEffectPlus[2]
      this.SrPlus += party.SpellEffectPlus[3]
      this.BrPlus += party.SpellEffectPlus[4]
      this.Healing += party.SpellEffectPlus[5]
      this.HpMax += party.SpellEffectPlus[7]
      for (let i = 0; i < GameData['ABILITY'].length; i++) {
        this.Ability[i] += party.AbiPlus[i]
      }
      for (let i = 0; i < RESIST_LENGTH; i++) {
        let resist = party.ResistPlus[i]
        if (resist == 1) {
          this.Resist[i] = true
        } else if (resist == 0 || resist == -1) {
          this.Resist[i] = false
        }
      }
      for (let i = 0; i < ATTACK_ADD_LENGTH + 1; i++) {
        if (party.AttackAddPlus[i]) {
          if (i == ATTACK_ADD_LENGTH) {
            this.AttackPoison += party.PoisonPlus
          } else {
            this.AttackAdd[i] = true
          }
        }
      }
    }
    this.Ac += this.BtSpellEffectPlus[0]
    this.Hit += this.BtSpellEffectPlus[1]
    this.SpellCancel += this.BtSpellEffectPlus[2]
    this.SrPlus += this.BtSpellEffectPlus[3]
    this.BrPlus += this.BtSpellEffectPlus[4]
    this.Healing += this.BtSpellEffectPlus[5]
    this.HpMax += this.BtSpellEffectPlus[7]
    for (let i = 0; i < GameData['ABILITY'].length; i++) {
      this.Ability[i] += this.Bt_abiPlus[i]
    }
    for (let i = 0; i < RESIST_LENGTH; i++) {
      let resist = this.Bt_resistPlus[i]
      if (this.PC_NUM > -1) {
        if (resist == 1) {
          this.Resist[i] = true
        } else if (resist == 0 || resist == -1) {
          this.Resist[i] = false
        }
      } else if (this.MonsterDataNum > -1) {
        if (resist == 1) {
          this.Resist[i] = true
          this.WeakPoint[i] = false
        } else if (resist == 0) {
          this.Resist[i] = false
          this.WeakPoint[i] = false
        } else if (resist == -1) {
          this.Resist[i] = false
          this.WeakPoint[i] = true
        }
      }
    }
    for (let i = 0; i < ATTACK_ADD_LENGTH + 1; i++) {
      if (this.Bt_attackAddPlus[i]) {
        if (i == ATTACK_ADD_LENGTH) {
          this.AttackPoison += this.Bt_poisonPlus
        } else {
          this.AttackAdd[i] = true
        }
      }
    }
    if (this.PC_NUM > -1) {
      if (this.HpMax < 1) {
        this.HpMax = 1
      } else if (this.HpMax > 99999) {
        this.HpMax = 99999
      }
    } else {
      if (this.HpMax < 1) {
        this.HpMax = 1
      } else if (this.HpMax > 999999999) {
        this.HpMax = 999999999
      }
    }
    if (this.AttackPoison < 0) {
      this.AttackPoison = 0
    } else if (this.AttackPoison > 99999) {
      this.AttackPoison = 99999
    }
    if (this.SpellCancel < 0) {
      this.SpellCancel = 0
    } else if (this.SpellCancel > 999) {
      this.SpellCancel = 999
    }
    if (this.SpellCancel0 < 0) {
      this.SpellCancel0 = 0
    } else if (this.SpellCancel0 > 999) {
      this.SpellCancel0 = 999
    }
    if (this.SpellCancel1 < 0) {
      this.SpellCancel1 = 0
    } else if (this.SpellCancel1 > 999) {
      this.SpellCancel1 = 999
    }
    if (this.Exp < 0) {
      this.Exp = 0
    } else if (this.Exp > 999999999999) {
      this.Exp = 999999999999
    }
    if (this.Gold < 0) {
      this.Gold = 0
    } else if (this.Gold > 999999999999) {
      this.Gold = 999999999999
    }
    if (this.Age < 1) {
      this.Age = 1
    } else if (this.Age > 9999999) {
      this.Age = 9999999
    }
    if (this.Marks < 0) {
      this.Marks = 0
    } else if (this.Marks > 999999999999) {
      this.Marks = 999999999999
    }
    if (this.Rip < 0) {
      this.Rip = 0
    } else if (this.Rip > 999) {
      this.Rip = 999
    }
    for (let i = 0; i < GameData['ABILITY'].length; i++) {
      if (this.Ability[i] < 0) {
        this.Ability[i] = 0
      } else if (this.Ability[i] > 999) {
        this.Ability[i] = 999
      }
      if (this.Ability1[i] < 0) {
        this.Ability1[i] = 0
      } else if (this.Ability1[i] > 999) {
        this.Ability1[i] = 999
      }
    }
    if (this.Hp > this.HpMax) {
      this.Hp = this.HpMax
    } else if (this.Hp < 0) {
      this.Hp = 0
    }
    for (let i = 0; i < GameData['SPELL_KIND'] + 1; i++) {
      for (let j = 0; j < GameData['SPELL_LVMAX']; j++) {
        if (this.MpMax[i][j] > 99) {
          this.MpMax[i][j] = 99
        } else if (this.MpMax[i][j] < 0) {
          this.MpMax[i][j] = 0
        }
        if (this.Mp[i][j] > this.MpMax[i][j]) {
          this.Mp[i][j] = this.MpMax[i][j]
        } else if (this.Mp[i][j] < 0) {
          this.Mp[i][j] = 0
        }
      }
    }
    if (this.PC_NUM > -1 && classAcEquipCheck) {
      let num = 0
      if (!zero) {
        let str = GameData['CLASS_AC'][this.PcClass].replace(/pc\.hit/g, '0')
        num = Math.floor(
          strCalculation(replaceFormula(str, [['pc', this.PC_NUM]]))
        )
      }
      this.Ac += num
      this.Ac0 += num
      this.Ac1 += num
    }
    if (this.Ac < -99) {
      this.Ac = -99
    } else if (this.Ac > 999) {
      this.Ac = 999
    }
    if (this.Ac0 < -99) {
      this.Ac0 = -99
    } else if (this.Ac0 > 999) {
      this.Ac0 = 999
    }
    if (this.Ac1 < -99) {
      this.Ac1 = -99
    } else if (this.Ac1 > 999) {
      this.Ac1 = 999
    }
    if (this.PC_NUM > -1) {
      let num = 0
      if (!zero) {
        let str = GameData['HIT_MODIFY'].replace(/my\./g, 'pc.')
        str = str.replace(/pc\.hit/g, '0')
        num = Math.floor(
          strCalculation(replaceFormula(str, [['pc', this.PC_NUM]]))
        )
      }
      this.Hit0 += num
      this.Hit1 += num
      this.Hit += num
      num = 0
      if (!zero) {
        let str = GameData['CLASS_HIT'][this.PcClass].replace(/pc\.hit/g, '0')
        num = Math.floor(
          strCalculation(replaceFormula(str, [['pc', this.PC_NUM]]))
        )
      }
      this.Hit0 += num
      this.Hit1 += num
      this.Hit += num
    } else {
      let num = 0
      if (!zero) {
        let str = GameData['HIT_MODIFY'].replace(/my\./g, 'monster.')
        str = str.replace(/monster\.hit/g, '0')
        num = Math.floor(
          strCalculation(replaceFormula(str, [['monster', this.MonsterNum]]))
        )
      }
      this.Hit0 += num
      this.Hit1 += num
      this.Hit += num
      num = 0
      if (!zero) {
        let str = GameData['MONSTER_HIT_MODIFY'].replace(/monster\.hit/g, '0')
        num = Math.floor(
          strCalculation(replaceFormula(str, [['monster', this.MonsterNum]]))
        )
      }
      this.Hit0 += num
      this.Hit1 += num
      this.Hit += num
    }
    if (this.Hit < -999) {
      this.Hit = -999
    } else if (this.Hit > 999) {
      this.Hit = 999
    }
    if (this.Hit0 < -999) {
      this.Hit0 = -999
    } else if (this.Hit0 > 999) {
      this.Hit0 = 999
    }
    if (this.Hit1 < -999) {
      this.Hit1 = -999
    } else if (this.Hit1 > 999) {
      this.Hit1 = 999
    }
    if (this.PC_NUM > -1) {
      let num = 0
      if (!zero) {
        let str = GameData['CLASS_ATTACK_NUM'][this.PcClass].replace(
          /pc\.at0/g,
          '0'
        )
        str = str.replace(/pc\.at/g, '0')
        num = Math.floor(
          strCalculation(replaceFormula(str, [['pc', this.PC_NUM]]))
        )
      }
      if (num > this.At0) {
        this.At0 = num
      }
      this.At0 += minusAt
      if (this.At0 < 1) {
        this.At0 = 1
      } else if (this.At0 > 99) {
        this.At0 = 99
      }
      this.At = this.At0
    }
    if (this.PC_NUM > -1) {
      if (this.PartyNum > -1) {
        this.At += PARTY[this.PartyNum].SpellEffectPlus[8]
      }
      this.At += this.SpellEffectPlus[8]
      this.At += this.BtSpellEffectPlus[8]
      if (this.At < 1) {
        this.At = 1
      } else if (this.At > 99) {
        this.At = 99
      }
    } else {
      this.checkMonsterAt('spell')
    }
    this.HpPlus = this.Healing + this.Poison * -1
    if (this.Healing < -99999) {
      this.Healing = -99999
    } else if (this.Healing > 99999) {
      this.Healing = 99999
    }
    if (this.HpPlus < -99999) {
      this.HpPlus = -99999
    } else if (this.HpPlus > 99999) {
      this.HpPlus = 99999
    }
    if (this.PC_NUM > -1) {
      this.Breath = 0
      let strAry = GameData['RACE_BREATH'][this.Race].split(',')
      for (let i = 2; i > -1; i--) {
        let num = Number(strAry[i])
        if (num == 0) {
          continue
        } else if (this.Level >= num) {
          this.Breath = i + 1
          break
        }
      }
      if (zero) {
        this.BreathMax = -1
      } else {
        let str = GameData['RACE_BREATH_NUM'][this.Race]
        this.BreathMax = Math.floor(
          strCalculation(replaceFormula(str, [['pc', this.PC_NUM]]))
        )
      }
      if (this.BreathMax < 0) {
        this.BreathMax = -1
      } else if (this.BreathMax > 99999) {
        this.BreathMax = 99999
      }
      if (this.Dmg == 'bareHands') {
        this.Dmg =
          GameData['CLASS_DMG1'][this.PcClass] +
          ',' +
          GameData['CLASS_DMG2'][this.PcClass] +
          ',' +
          GameData['CLASS_DMG3'][this.PcClass]
        this.DmgSub = ''
        if (this.Range[0] < GameData['ATTACK_RANGE'][0]) {
          this.Range[0] = GameData['ATTACK_RANGE'][0]
        }
        if (this.Range[1] < GameData['ATTACK_RANGE'][1]) {
          this.Range[1] = GameData['ATTACK_RANGE'][1]
        }
      }
    }
    if (zero) {
      this.DmgPlus = 0
    } else {
      let dmgPlus = GameData['DMG_PLUS']
      let dmgPlusNum = 0
      if (this.PC_NUM > -1) {
        dmgPlus = dmgPlus.replace(/my\./g, 'pc.')
        dmgPlusNum += this.SpellEffectPlus[6]
        if (this.PartyNum > -1) {
          dmgPlusNum += PARTY[this.PartyNum].SpellEffectPlus[6]
        }
      } else if (this.MonsterDataNum > -1) {
        dmgPlus = dmgPlus.replace(/my\./g, 'monster.')
      }
      dmgPlusNum += this.BtSpellEffectPlus[6]
      dmgPlus = dmgPlus.replace(/plus/g, String(dmgPlusNum))
      if (this.PC_NUM > -1) {
        dmgPlus = replaceFormula(dmgPlus, [['pc', this.PC_NUM]], true)
        this.DmgPlus = Math.floor(strCalculation(dmgPlus))
      } else if (this.MonsterDataNum > -1) {
        dmgPlus = replaceFormula(dmgPlus, [['monster', this.MonsterNum]], true)
        this.DmgPlus = Math.floor(strCalculation(dmgPlus))
      }
    }
    if (this.DmgPlus < -9999) {
      this.DmgPlus = -9999
    } else if (this.DmgPlus > 9999) {
      this.DmgPlus = 9999
    }
    if (this.PC_NUM > -1 && !zero) {
      if (this.NextUpExp < 0) {
        let str = GameData['CLASS_NECESSARY_EXP'][this.PcClass]
        str = replaceFormula(str, [['pc', this.PC_NUM]], true)
        this.NextUpExp = Math.floor(strCalculation(str))
      }
      this.NextExp = this.NextUpExp - this.Exp
      if (this.NextExp < 0) {
        this.NextExp = 0
      } else if (this.NextExp > 999999999999) {
        this.NextExp = 999999999999
      }
    }
  }
  checkAttackAdd (num) {
    if (num >= 0 && num <= 4) {
      return this.AttackAdd[num]
    } else if (num == 5) {
      if (this.AttackPoison > 0) {
        return true
      } else {
        return false
      }
    } else if (num == 6 && this.PC_NUM < 0) {
      if (MONSTER_DATA[this.MonsterDataNum].DRAIN > 0) {
        return true
      } else {
        return false
      }
    }
    return false
  }
  checkCursed () {
    if (this.PC_NUM < 0) {
      return -1
    }
    let result = -1
    for (let i = 0; i < this.ItemMaxNum; i++) {
      if (this.Item[i] < 0) {
        break
      }
      if (this.Equip[i] == 2) {
        result = i
        break
      }
    }
    return result
  }
  checkItemMaxNum () {
    this.ItemMaxNum =
      GameData['RACE_ITEM'][this.Race] + GameData['CLASS_ITEM'][this.PcClass]
    if (this.ItemMaxNum < 1) {
      this.ItemMaxNum = 1
    } else if (this.ItemMaxNum > 99) {
      this.ItemMaxNum = 99
    }
    let itemNum = 0
    for (let i = 0; i < this.Item.length; i++) {
      if (this.Item[i] < 0) {
        break
      }
      itemNum++
    }
    if (itemNum <= this.ItemMaxNum) {
      return
    }
    let stackItem = [],
      stackDecided = [],
      stackEquip = []
    let count = 0
    for (let i = this.ItemMaxNum; i < itemNum; i++) {
      if (this.Equip[i] > 0) {
        count++
      }
      stackItem.push(this.Item[i])
      stackDecided.push(this.ItemDecided[i])
      stackEquip.push(this.Equip[i])
    }
    for (let i = this.ItemMaxNum; i < itemNum; i++) {
      this.Item[i] = -1
      this.ItemDecided[i] = 0
      this.Equip[i] = 0
    }
    let stack = []
    for (let i = this.ItemMaxNum - 1; i >= 0; i--) {
      if (this.Equip[i] == 0) {
        stack.push(i)
      }
    }
    if (count > stack.length) {
      count = stack.length
    }
    for (let i = 0; i < count; i++) {
      let num = stack[count - i - 1]
      let item = this.Item[num]
      let decided = this.ItemDecided[num]
      let equip = this.Equip[num]
      this.Item[num] = stackItem[i]
      this.ItemDecided[num] = stackDecided[i]
      this.Equip[num] = stackEquip[i]
      stackItem[i] = item
      stackDecided[i] = decided
      stackEquip[i] = equip
    }
    for (let i = 0; i < stackItem.length; i++) {
      let dump = true
      if (this.PartyNum > -1) {
        if (PARTY[this.PartyNum].putItem(stackItem[i], stackDecided[i]) > -1) {
          dump = false
        }
      }
      if (dump) {
        dumpItem(this.PartyNum, stackItem[i])
      }
    }
  }
  checkMonsterAt (mode) {
    if (mode == 'init' || mode == undefined || mode == null) {
      let str = MONSTER_DATA[this.MonsterDataNum].AT.replace(
        /monster\.at0/g,
        '0'
      )
      str = str.replace(/monster\.at/g, '0')
      str = replaceFormula(str, [['monster', this.MonsterNum]])
      this.At0 = Math.floor(strCalculation(str))
      if (this.At0 < 1) {
        this.At0 = 1
      } else if (this.At0 > 99) {
        this.At0 = 99
      }
      this.At = this.At0
    }
    if (mode == 'spell' || mode == undefined || mode == null) {
      this.At += this.BtSpellEffectPlus[8]
      if (this.At < 1) {
        this.At = 1
      } else if (this.At > 99) {
        this.At = 99
      }
    }
  }
  checkSexByRace () {
    let rsi = GameData['RACE_SEX_INSIDE'][this.Race]
    if (rsi > -1) {
      if (this.Sex != rsi) {
        this.Sex = rsi
      }
    } else {
      if (GameData['RACE_SEX'][this.Race].indexOf(String(this.Sex)) < 0) {
        this.Sex = Number(GameData['RACE_SEX'][this.Race].charAt(0))
      }
    }
  }
  checkState (state) {
    if (state == 0) {
      if (
        this.State == 0 &&
        this.Silence == 0 &&
        this.Asleep == 0 &&
        this.NoBreath == 0 &&
        !this.SealSpell &&
        this.Poison == 0
      ) {
        return true
      }
    } else if (state < 7) {
      if (this.State == state) {
        return true
      }
    } else if (state == 7) {
      if (this.Silence != 0) {
        return true
      }
    } else if (state == 8) {
      if (this.Asleep > 0) {
        return true
      }
    } else if (state == 9) {
      if (this.Asleep < 0) {
        return true
      }
    } else if (state == 10) {
      if (this.NoBreath > 0) {
        return true
      }
    } else if (state == 11) {
      if (this.SealSpell) {
        return true
      }
    } else if (state == 12) {
      if (this.Poison > 0) {
        return true
      }
    } else if (state == 13) {
      if (GameState.match(/^battle/) && this.Hide) {
        return true
      }
    }
    return false
  }
  classCommentNum (str) {
    let result = 0
    str = MP.zenkaku2hankaku(str)
    let text = deleteLineFeedCode(GameData['CLASS_COMMENT'][this.PcClass])
    text = MP.zenkaku2hankaku(text)
    if (text.indexOf(str) > -1) {
      result = 1
    }
    return result
  }
  controlGold (num, plus) {
    if (plus == undefined || plus == null) {
      plus = false
    }
    if (plus) {
      num += this.Gold
    }
    this.Gold = num
    if (this.Gold < 0) {
      this.Gold = 0
    } else if (this.Gold > 999999999999) {
      this.Gold = 999999999999
    }
  }
  controlHp (num, plus) {
    if (plus == undefined || plus == null) {
      plus = false
    }
    if (this.State > 3) {
      return
    }
    if (plus) {
      num += this.Hp
    }
    this.Hp = num
    if (this.Hp > this.HpMax) {
      this.Hp = this.HpMax
    }
    if (this.Hp < 1) {
      this.Hp = 0
      this.State = 4
      this.Rip++
      this.Poison = 0
      this.battleReset()
      this.check()
      if (this.PC_NUM > -1 && GameState.match(/^battle/)) {
        hateCheck(this.PC_NUM)
      }
    }
  }
  controlMp (kind, lv, num, plus) {
    if (plus == undefined || plus == null) {
      plus = false
    }
    if (this.State > 3) {
      return
    }
    if (plus) {
      num += this.Mp[kind][lv]
    }
    this.Mp[kind][lv] = num
    if (this.Mp[kind][lv] > this.MpMax[kind][lv]) {
      this.Mp[kind][lv] = this.MpMax[kind][lv]
    } else if (this.Mp[kind][lv] < 0) {
      this.Mp[kind][lv] = 0
    }
  }
  controlTitle (str) {
    let strAry = str.split('<>')
    for (let i = 0; i < strAry.length; i++) {
      let strAry2 = strAry[i].split(',')
      if (strAry2.length < 2) {
        continue
      } else if (strAry2.length > 2) {
        let ck = false
        if (strAry2[0] == ' ') {
          ck = true
        } else if (strAry2[0] == 'titleNone') {
          if (this.Title == '') {
            ck = true
          }
        } else {
          strAry2[0] = strAry2[0].replace(/[\[\]]/g, '')
          if (this.Title.indexOf(strAry2[0]) > -1) {
            ck = true
          }
        }
        if (ck) {
          if (strAry2[2] == 'titleDelete') {
            this.Title = ''
          } else if (strAry2[2] != 'titleNone') {
            strAry2[2] = strAry2[2].replace(/[\[\]]/g, '')
            let titleStr = this.Title + '      '
            let titleNum = Number(strAry2[1])
            let strTmp = ''
            if (titleNum <= titleStr.length) {
              strTmp += titleStr.substring(0, titleNum)
            }
            strTmp += strAry2[2]
            titleNum += strAry2[2].length
            if (titleNum <= titleStr.length) {
              strTmp += titleStr.substring(titleNum)
            }
            strAry2[2] = MP.strCut(strTmp, 6)
            strAry2[2] = strAry2[2].replace(/ +$/, '')
            this.Title = strAry2[2]
          }
          break
        }
      } else {
        let ck = false
        if (strAry2[0] == ' ') {
          ck = true
        } else {
          if (strAry2[0] == 'titleNone') {
            strAry2[0] = ''
          }
          if (this.Title == strAry2[0]) {
            ck = true
          }
        }
        if (ck) {
          if (strAry2[1] == 'titleDelete') {
            this.Title = ''
          } else if (strAry2[1] != 'titleNone') {
            strAry2[1] = MP.strCut(strAry2[1], 6)
            strAry2[1] = strAry2[1].replace(/ +$/, '')
            this.Title = strAry2[1]
          }
          break
        }
      }
    }
  }
  createMonster (monsterDataNum, monsterNum, silence) {
    if (silence == undefined || silence == null) {
      silence = 0
    }
    this.initialize()
    this.MonsterDataNum = monsterDataNum
    this.MonsterNum = monsterNum
    let mData = MONSTER_DATA[this.MonsterDataNum]
    this.Name[0] = mData.NAME[0]
    this.Name[1] = mData.NAME[1]
    this.Names[0] = mData.NAMES[0]
    this.Names[1] = mData.NAMES[1]
    let party = PARTY[PlayData['ActiveParty']]
    let strAry = DUNGEON.BoxTrap[party.DungeonNumber][party.Floor].split('<>')
    let trapLv = Number(strAry[0])
    let str = mData.LEVEL.replace(/trap\.lv/g, String(trapLv))
    str = replaceFormula(str, [['monster', this.MonsterNum]])
    this.Level = Math.floor(strCalculation(str))
    if (this.Level < 1) {
      this.Level = 1
    } else if (this.Level > 99999) {
      this.Level = 99999
    }
    for (let i = 0; i < GameData['ABILITY'].length; i++) {
      this.Ability0[i] = mData.ABILITY[i]
      this.Ability1[i] = this.Ability0[i]
    }
    str = mData.HP_MAX.replace(/trap\.lv/g, String(trapLv))
    str = replaceFormula(str, [['monster', this.MonsterNum]])
    this.HpMax0 = Math.floor(strCalculation(str))
    if (this.HpMax0 < 1) {
      this.HpMax0 = 1
    } else if (this.HpMax0 > 999999999) {
      this.HpMax0 = 999999999
    }
    this.HpMax = this.HpMax0
    this.Hp = this.HpMax
    str = mData.MP_MAX.replace(/trap\.lv/g, String(trapLv))
    str = replaceFormula(str, [['monster', this.MonsterNum]])
    let num = Math.floor(strCalculation(str))
    if (num < 0) {
      num = 0
    } else if (num > 99) {
      num = 99
    }
    for (let i = 0; i < GameData['SPELL_KIND'] + 1; i++) {
      for (let j = 0; j < GameData['SPELL_LVMAX']; j++) {
        this.MpMax[i][j] = num
        this.Mp[i][j] = this.MpMax[i][j]
      }
    }
    str = mData.EXP.replace(/trap\.lv/g, String(trapLv))
    str = replaceFormula(str, [['monster', this.MonsterNum]])
    this.Exp = Math.floor(strCalculation(str))
    if (this.Exp < 0) {
      this.Exp = 0
    } else if (this.Exp > 999999999999) {
      this.Exp = 999999999999
    }
    this.Silence = silence
    this.SpellCancel0 = mData.SPELL_CANCEL
    this.SpellCancel1 = this.SpellCancel0
    for (let i = 0; i < RESIST_LENGTH; i++) {
      if (mData.RESIST.indexOf(i.toString(16)) > -1) {
        this.Resist0[i] = true
      } else {
        this.Resist0[i] = false
      }
      this.Resist1[i] = this.Resist0[i]
      if (mData.WEAK_POINT.indexOf(i.toString(16)) > -1) {
        this.WeakPoint0[i] = true
      } else {
        this.WeakPoint0[i] = false
      }
      this.WeakPoint1[i] = this.WeakPoint0[i]
    }
    str = mData.AC.replace(/monster\.ac/g, '0')
    str = replaceFormula(str, [['monster', this.MonsterNum]])
    this.Ac0 = Math.floor(strCalculation(str))
    if (this.Ac0 < -99) {
      this.Ac0 = -99
    } else if (this.Ac0 > 999) {
      this.Ac0 = 999
    }
    this.Ac1 = this.Ac0
    this.check()
  }
  createPc (name, sex, race, pcClass, alignment, abi, age) {
    this.spellEffectClear(true)
    this.battleReset()
    this.Name[0] = name
    ;(sex = Number(sex)), (race = Number(race)), (pcClass = Number(pcClass))
    ;(alignment = Number(alignment)),
      (age = checkNull(age, 0)),
      (age = Number(age))
    ;(this.Sex = sex),
      (this.PcClass = pcClass),
      (this.Race = race),
      (this.Alignment = alignment)
    for (let i = 0; i < GameData['ABILITY'].length; i++) {
      let j
      if (abi[i] == undefined || abi[i] == null || Number.isNaN(abi[i])) {
        j = GameData['RACE_ABI'][race][i] + GameData['ABILITY_SEX'][sex][i]
      } else {
        j = abi[i]
      }
      this.Ability0[i] = j
      this.Ability1[i] = j
      this.Ability[i] = j
    }
    if (age == undefined || age == null || age == 0) {
      this.Age = Math.floor(
        strCalculation(
          replaceFormula(GameData['PC_CREATE_AGE'], [['pc', this.PC_NUM]])
        )
      )
    } else {
      this.Age = age
    }
    let str = replaceFormula(GameData['PC_CREATE_GOLD'], [['pc', this.PC_NUM]])
    this.Gold = Math.floor(strCalculation(str))
    this.HpMax0 = 0
    this.HpMax0 += this.gainedHp()
    if (this.HpMax0 < 1) {
      this.HpMax0 = 1
    }
    this.Hp = this.HpMax0
    for (let i = 0; i < GameData['SPELL_KIND']; i++) {
      for (let j = 0; j < GameData['SPELL_LVMAX']; j++) {
        this.Mp[i][j] = 0
        this.MpMax[i][j] = 0
        for (let k = 0; k < 6; k++) {
          this.Spell[i][j][k] = false
        }
      }
    }
    this.learnedSpell()
    this.gainedMp()
    this.NextUpExp = -1
    this.FaceGraphic = ''
    this.check()
  }
  cureAsleepByDamage (dmg) {
    if (this.Asleep > 0) {
      let formula = GameData['CURE_ASLEEP_DMG']
      formula = formula.replace(/damage/g, String(dmg))
      if (this.PC_NUM > -1) {
        formula = formula.replace(/my\./g, 'pc.')
        formula = replaceFormula(formula, [['pc', this.PC_NUM]])
      } else {
        formula = formula.replace(/my\./g, 'monster.')
        formula = replaceFormula(formula, [['monster', this.MonsterNum]])
      }
      let num = Math.floor(strCalculation(formula))
      if (num < 0) {
        num = 0
      }
      this.Asleep -= num
      if (this.Asleep < 0) {
        this.Asleep = 0
      }
    }
  }
  drainCheck (preLevel) {
    let formula =
      String(this.Level) +
      ' / ' +
      String(preLevel) +
      ' * ' +
      String(this.HpMax0)
    this.HpMax0 = Math.floor(strCalculation(formula))
    if (this.HpMax0 < 1) {
      this.HpMax0 = 1
    }
    let num = this.Level - 1
    if (num < 1) {
      this.Exp = 0
    } else {
      formula = GameData['CLASS_NECESSARY_EXP'][this.PcClass].replace(
        /pc\.lv/g,
        String(num)
      )
      formula = replaceFormula(formula, [['pc', this.PC_NUM]], true)
      this.Exp = Math.floor(strCalculation(formula))
    }
    if (this.Level < 1) {
      this.Level = 1
    }
    this.NextUpExp = -1
  }
  gainedHp () {
    let str = replaceFormula(GameData['CLASS_HP_ADD'][this.PcClass], [
      ['pc', this.PC_NUM]
    ])
    let num = Math.floor(strCalculation(str))
    num -= this.HpMax0
    if (num < 1) {
      num = 1
    }
    return num
  }
  gainedMp () {
    for (let i = 0; i < GameData['SPELL_KIND']; i++) {
      if (
        GameData['CLASS_LEARNED_SPELL'][this.PcClass][i][0] == 0 ||
        GameData['CLASS_LEARNED_SPELL'][this.PcClass][i][2] == 0 ||
        GameData['CLASS_LEARNED_SPELL'][this.PcClass][i][3] == 0
      ) {
        continue
      }
      for (let j = 0; j < GameData['SPELL_LVMAX']; j++) {
        if (this.MpMax[i][j] >= GameData['SPELL_MPMAX']) {
          continue
        }
        if (
          j + 1 < GameData['CLASS_LEARNED_SPELL'][this.PcClass][i][2] ||
          j >= GameData['CLASS_LEARNED_SPELL'][this.PcClass][i][3]
        ) {
          continue
        }
        let count = 0
        for (let k = 0; k < 6; k++) {
          if (this.Spell[i][j][k]) {
            count++
          }
        }
        if (count == 0) {
          continue
        }
        let formula = replaceFormula(GameData['MPMAX_UP'][i][1], [
          ['pc', this.PC_NUM]
        ])
        let mpUpInterval = Math.floor(strCalculation(formula))
        if (mpUpInterval < 0) {
          let compA =
            this.Level -
            (GameData['CLASS_LEARNED_SPELL'][this.PcClass][i][0] +
              GameData['CLASS_LEARNED_SPELL'][this.PcClass][i][1] * j) +
            1
          if (compA <= 0) {
            continue
          }
          formula = replaceFormula(GameData['MPMAX_UP'][i][2], [
            ['pc', this.PC_NUM]
          ])
          let num = Math.floor(strCalculation(formula))
          if (num < 0) {
            num = 0
          }
          compA *= num
          if (compA >= GameData['SPELL_MPMAX']) {
            compA = GameData['SPELL_MPMAX']
          }
          formula = replaceFormula(GameData['MPMAX_UP'][i][0], [
            ['pc', this.PC_NUM]
          ])
          num = Math.floor(strCalculation(formula))
          if (num < 0) {
            num = 0
          }
          let compB = count * num
          if (compB >= GameData['SPELL_MPMAX']) {
            compB = GameData['SPELL_MPMAX']
          }
          if (compA < compB) {
            compA = compB
          }
          compB = compA - this.MpMax[i][j]
          if (compB < 0) {
            compB = 0
          }
          this.MpMax[i][j] = compA
          if (this.MpMax[i][j] >= GameData['SPELL_MPMAX']) {
            this.MpMax[i][j] = GameData['SPELL_MPMAX']
          }
          this.Mp[i][j] += compB
        } else {
          let num = GameData['CLASS_LEARNED_SPELL'][this.PcClass][i][0]
          num += GameData['CLASS_LEARNED_SPELL'][this.PcClass][i][1] * j
          num += mpUpInterval
          if (this.Level >= num) {
            formula = replaceFormula(GameData['MPMAX_UP'][i][2], [
              ['pc', this.PC_NUM]
            ])
            num = Math.floor(strCalculation(formula))
            if (num < 0) {
              num = 0
            }
            this.MpMax[i][j] += num
            if (this.MpMax[i][j] >= GameData['SPELL_MPMAX']) {
              this.MpMax[i][j] = GameData['SPELL_MPMAX']
            }
            this.Mp[i][j] += num
          }
        }
      }
    }
    this.gainedMpMin()
  }
  gainedMpMin (notMpPlus) {
    if (notMpPlus == undefined || notMpPlus == null) {
      notMpPlus = false
    }
    for (let i = 0; i < GameData['SPELL_KIND']; i++) {
      for (let j = 0; j < GameData['SPELL_LVMAX']; j++) {
        if (this.MpMax[i][j] >= GameData['SPELL_MPMAX']) {
          continue
        }
        let count = 0
        for (let k = 0; k < 6; k++) {
          if (this.Spell[i][j][k]) {
            count++
          }
        }
        let str = replaceFormula(GameData['MPMAX_UP'][i][0], [
          ['pc', this.PC_NUM]
        ])
        let num = Math.floor(strCalculation(str))
        if (num < 0) {
          num = 0
        }
        count = num * count
        if (this.MpMax[i][j] < count) {
          num = count - this.MpMax[i][j]
          this.MpMax[i][j] = count
          if (this.MpMax[i][j] >= GameData['SPELL_MPMAX']) {
            this.MpMax[i][j] = GameData['SPELL_MPMAX']
          }
          if (!notMpPlus) {
            this.Mp[i][j] += num
            if (this.Mp[i][j] >= this.MpMax[i][j]) {
              this.Mp[i][j] = this.MpMax[i][j]
            }
          }
        }
      }
    }
  }
  getAbilityMinMax (minMax, abi) {
    let result
    if (minMax == 'max') {
      if (GameData['ABILITY_FIX'] == 0) {
        result = GameData['ABILITY_MAX']
      } else if (GameData['ABILITY_FIX'] == 1) {
        result = GameData['RACE_ABI'][this.Race][abi]
        result += GameData['ABILITY_SEX'][this.Sex][abi]
        result += GameData['ABILITY_MAX']
      } else {
        let formula = GameData['ABILITY_INDIVIDUAL'][abi].replace(
          /initialAbi/g,
          String(GameData['RACE_ABI'][this.Race][abi])
        )
        formula = replaceFormula(formula, [['pc', this.PC_NUM]], true)
        result = Math.floor(strCalculation(formula))
        if (GameData['ABILITY_INDIVIDUAL_SEX'][abi]) {
          result += GameData['ABILITY_SEX'][this.Sex][abi]
        }
      }
    } else {
      result = GameData['RACE_ABI'][this.Race][abi]
      result += GameData['ABILITY_SEX'][this.Sex][abi]
    }
    return result
  }
  getAc (ambush) {
    if (ambush == undefined || ambush == null || this.PC_NUM < 0) {
      ambush = false
    }
    let ac = this.Ac
    if (GameState.match(/^battleTurn/)) {
      let pToAction = this.possibleToAction()
      if (!pToAction || ambush) {
        let formula = GameData['NON_MOVE_AC']
        if (this.PC_NUM > -1) {
          formula = formula.replace(/my\./g, 'pc.')
          formula = replaceFormula(formula, [['pc', this.PC_NUM]])
        } else {
          formula = formula.replace(/my\./g, 'monster.')
          formula = replaceFormula(formula, [['monster', this.MonsterNum]])
        }
        ac += Math.floor(strCalculation(formula))
      }
      if (pToAction && this.Action[0] == 4) {
        let formula = GameData['PARRY_AC']
        if (this.PC_NUM > -1) {
          formula = formula.replace(/my\./g, 'pc.')
          formula = replaceFormula(formula, [['pc', this.PC_NUM]])
        } else {
          formula = formula.replace(/my\./g, 'monster.')
          formula = replaceFormula(formula, [['monster', this.MonsterNum]])
        }
        ac += Math.floor(strCalculation(formula))
      }
      if (ac < -99) {
        ac = -99
      } else if (ac > 999) {
        ac = 999
      }
    }
    return ac
  }
  getGroupMember () {
    let result = 0
    if (this.PC_NUM > -1) {
      if (this.PartyNum > -1) {
        let pt = PARTY[this.PartyNum]
        result = pt.getMemberForPcNum(this.PC_NUM)
        if (result < 0) {
          result = 0
        }
      }
    } else if (GameState.match(/^battle/)) {
      let monGroup = this.getGroupNum()
      if (monGroup < 0) {
        return result
      }
      if (this.MonsterNum < 50) {
        for (let i = 0; i < 9; i++) {
          let monNum = PlayData['MonsterList'][monGroup][i]
          if (monNum == this.MonsterNum) {
            result = i
            break
          }
        }
      } else {
        for (let i = 0; i < 9; i++) {
          let monNum = PlayData['SummonList'][monGroup][i]
          if (monNum == this.MonsterNum - 50) {
            result = i
            break
          }
        }
      }
    }
    return result
  }
  getGroupMemberNum (actionable) {
    if (actionable == 'undefined' || actionable == 'null') {
      actionable = false
    }
    let result = 0
    if (this.PC_NUM > -1) {
      if (this.PartyNum > -1) {
        let pt = PARTY[this.PartyNum]
        if (actionable) {
          result = pt.getMemberNum(true)
        } else {
          result = pt.getMemberNum(false)
        }
      }
    } else if (GameState.match(/^battle/)) {
      let monGroup = this.getGroupNum()
      if (monGroup < 0) {
        return result
      }
      if (this.MonsterNum < 50) {
        for (let i = 0; i < 9; i++) {
          let monNum = PlayData['MonsterList'][monGroup][i]
          if (monNum > -1) {
            if (!actionable) {
              if (MONSTER[monNum].Hp > 0) {
                result++
              }
            } else if (MONSTER[monNum].possibleToAction()) {
              result++
            }
          }
        }
      } else {
        for (let i = 0; i < 9; i++) {
          let monNum = PlayData['SummonList'][monGroup][i]
          if (monNum > -1) {
            if (!actionable) {
              if (SUMMON[monNum].Hp > 0) {
                result++
              }
            } else if (SUMMON[monNum].possibleToAction()) {
              result++
            }
          }
        }
      }
    }
    return result
  }
  getGroupNum () {
    let monGroup = -1
    if (GameState.match(/^battle/) && this.MonsterNum > -1) {
      if (this.MonsterNum < 50) {
        for (let i = 0; i < 4; i++) {
          if (monGroup > -1) {
            break
          }
          for (let j = 0; j < 9; j++) {
            if (PlayData['MonsterList'][i][j] == this.MonsterNum) {
              monGroup = i
              break
            }
          }
        }
      } else {
        let monNum = this.MonsterNum - 50
        for (let i = 0; i < 2; i++) {
          if (monGroup > -1) {
            break
          }
          for (let j = 0; j < 9; j++) {
            if (PlayData['SummonList'][i][j] == monNum) {
              monGroup = i
              break
            }
          }
        }
      }
    }
    return monGroup
  }
  getItemName (haveNum, mode) {
    if (this.Item[haveNum] < 0) {
      return ''
    }
    let item = this.Item[haveNum]
    let decided = this.ItemDecided[haveNum]
    let equip = this.Equip[haveNum]
    if (mode == 'decided') {
      return ITEM[item].getName(decided)
    } else if (mode == 'equip') {
      return ITEM[item].getName(decided, equip, this.PC_NUM)
    } else {
      return ITEM[item].NAME[decided]
    }
  }
  getItemSpaceNum () {
    return this.ItemMaxNum - this.haveItemNum()
  }
  getLearnedSpell (mode, kind, lv) {
    let resultAry = []
    for (let i = 0; i < 6; i++) {
      if (GameData['SPELL'][kind][lv][i] != '' && this.Spell[kind][lv][i]) {
        let strAry = GameData['SPELL'][kind][lv][i].split('<>')
        if (
          mode == 2 &&
          this.Silence != 0 &&
          !GameData['SPELL_EVEN_SILENCE'][kind][lv][i]
        ) {
          continue
        }
        let num = 0
        if (strAry.length > 1) {
          num = Number(strAry[1])
        }
        if (mode == 0 || (mode <= 2 && num == 0) || mode == num) {
          resultAry.push(i)
        }
      }
    }
    return resultAry
  }
  getSpellSelect (box) {
    let resultAry = [0, 0]
    if (box) {
      if (this.State > 0 || this.SealSpell) {
        return [-1, -1]
      }
      resultAry = [-1, 0]
      for (let i = 0; i < GameData['SPELL_KIND']; i++) {
        for (let j = GameData['SPELL_LVMAX'] - 1; j >= 0; j--) {
          for (let k = 0; k < 6; k++) {
            if (GameData['SPELL'][i][j][k] == '') {
              continue
            }
            let strAry = GameData['SPELL'][i][j][k].split('<>')
            if (strAry[1] == '3') {
              if (
                this.Spell[i][j][k] &&
                this.Mp[i][j] >= GameData['SPELL_CONSUMPTION_MP'][i][j][k]
              ) {
                resultAry[0] = i
                resultAry[1] = j
                break
              }
            }
          }
          if (resultAry[0] > -1) {
            break
          }
        }
        if (resultAry[0] > -1) {
          break
        }
      }
    } else {
      resultAry = [-1, 0]
      for (let i = 0; i < GameData['SPELL_KIND']; i++) {
        if (
          GameData['CLASS_LEARNED_SPELL'][this.PcClass][i][0] > 0 &&
          GameData['CLASS_LEARNED_SPELL'][this.PcClass][i][2] > 0 &&
          GameData['CLASS_LEARNED_SPELL'][this.PcClass][i][3] > 0
        ) {
          resultAry[0] = i
          break
        }
      }
      if (resultAry[0] > -1) {
        let lv =
          GameData['CLASS_LEARNED_SPELL'][this.PcClass][resultAry[0]][2] - 1
        if (lv < 0) {
          lv = 0
        }
        let ary = this.getLearnedSpell(0, resultAry[0], lv)
        if (ary.length == 0) {
          resultAry[0] = -1
        }
      }
      let start = 0,
        end = GameData['SPELL_KIND']
      if (resultAry[0] > -1) {
        start = resultAry[0]
        end = start + 1
      }
      for (let i = start; i < end; i++) {
        for (let j = 0; j < GameData['SPELL_LVMAX']; j++) {
          let ary = this.getLearnedSpell(0, i, j)
          if (ary.length > 0) {
            resultAry[0] = i
            resultAry[1] = j
            break
          }
        }
        if (resultAry[0] > -1) {
          break
        }
      }
    }
    return resultAry
  }
  getStateStr () {
    let result
    if (this.State == 2) {
      result = getDefaultMessage('STATUS_PARALYZED', 1)
    } else if (this.State == 3) {
      result = getDefaultMessage('STATUS_STONED', 1)
    } else if (this.State == 4) {
      result = getDefaultMessage('STATUS_DEAD', 1)
    } else if (this.State == 5) {
      result = getDefaultMessage('STATUS_ASHED', 1)
    } else if (this.State == 6) {
      result = getDefaultMessage('STATUS_LOST', 1)
    } else if (this.Asleep < 0) {
      result = getDefaultMessage('STATUS_FAINTED', 1)
    } else if (this.Asleep > 0) {
      result = getDefaultMessage('STATUS_ASLEEP', 1)
    } else if (this.NoBreath > 0) {
      result = getDefaultMessage('STATUS_RESTRAINED', 1)
    } else if (this.State == 1) {
      result = getDefaultMessage('STATUS_AFRAID', 1)
    } else if (this.Silence != 0) {
      result = getDefaultMessage('STATUS_SILENCE', 1)
    } else if (this.SealSpell) {
      result = getDefaultMessage('STATUS_SEAL_SPELL', 1)
    } else if (this.Poison > 0) {
      result = getDefaultMessage('STATUS_POISONED', 1)
    } else if (this.Hate > -1) {
      result = getDefaultMessage('STATUS_HATED', 1)
    } else {
      result = getDefaultMessage('STATUS_OK')
    }
    return MP.strFitLength(result, 10)
  }
  itemCommentNum (str, equip) {
    if (this.PC_NUM < 0) {
      return 0
    }
    let result = 0
    str = MP.zenkaku2hankaku(str)
    if (equip < 0 || equip > 5 || equip == undefined || equip == null) {
      equip = 2
    }
    for (let i = 0; i < this.ItemMaxNum; i++) {
      if (
        this.Item[i] == -1 ||
        this.Item[i] == undefined ||
        this.Item[i] == null
      ) {
        break
      }
      if (equip == 0) {
        if (this.Equip[i] != 0) {
          continue
        }
      } else if (equip == 1) {
        if (this.Equip[i] == 2) {
          continue
        }
      } else if (equip == 3) {
        if (this.Equip[i] == 0 || this.Equip[i] == 2) {
          continue
        }
      } else if (equip == 4) {
        if (this.Equip[i] != 2) {
          continue
        }
      } else if (equip == 5) {
        if (this.Equip[i] == 0) {
          continue
        }
      }
      let text = deleteLineFeedCode(ITEM[this.Item[i]].COMMENT)
      text = MP.zenkaku2hankaku(text)
      if (text.indexOf(str) > -1) {
        result++
      }
    }
    return result
  }
  haveEquipItem (kind) {
    let result = false
    let itemMax = this.haveItemNum(-1)
    for (let i = 0; i < itemMax; i++) {
      if (kind == 7) {
        if (
          ITEM[this.Item[i]].TYPE == 0 &&
          ITEM[this.Item[i]].WEAPON_TYPE == 2 &&
          ITEM[this.Item[i]].EQUIP_REQ_CLASS.indexOf('-') < 0 &&
          (this.Equip[i] == 0 || this.Equip[i] == 3)
        ) {
          result = true
          break
        }
      } else if (
        ITEM[this.Item[i]].TYPE == kind &&
        ITEM[this.Item[i]].EQUIP_REQ_CLASS.indexOf('-') < 0
      ) {
        result = true
        break
      }
    }
    return result
  }
  haveItem (item, equip, excludeHaveNum) {
    if (this.PC_NUM < 0) {
      return -1
    }
    if (equip == undefined || equip == null) {
      equip = 2
    }
    if (excludeHaveNum == undefined || excludeHaveNum == null) {
      excludeHaveNum = -1
    }
    let result = -1
    if (equip < 0 || equip > 2) {
      equip = 2
    }
    for (let i = 0; i < this.ItemMaxNum; i++) {
      if (
        this.Item[i] == -1 ||
        this.Item[i] == undefined ||
        this.Item[i] == null
      ) {
        break
      } else if (this.Item[i] == item && i != excludeHaveNum) {
        if (equip == 0) {
          if (this.Equip[i] == 1 || this.Equip[i] == 3) {
            continue
          }
        } else if (equip == 1) {
          if (this.Equip[i] == 2) {
            continue
          }
        }
        result = i
        break
      }
    }
    return result
  }
  haveItemBattle () {
    let result = 0
    for (let i = 0; i < this.ItemMaxNum; i++) {
      if (
        this.Item[i] == -1 ||
        this.Item[i] == undefined ||
        this.Item[i] == null
      ) {
        break
      }
      let itemNum = this.Item[i]
      let item = ITEM[itemNum]
      if (!item.USE_EQUIP || (item.USE_EQUIP && item.equipCheck(this.PC_NUM))) {
        if (!(GameData['CANNOT_USE_CURSED_ITEM'] && this.Equip[i] == 2)) {
          let spellData = decomposeSpell(
            spellEffectReplace(item.USE, 1),
            this.PC_NUM
          )
          if (spellData['situation'] == 0 || spellData['situation'] == 2) {
            result++
          }
        }
      }
    }
    return result
  }
  haveItemNum (item, equip) {
    if (this.PC_NUM < 0) {
      return 0
    }
    let result = 0
    if (item == undefined || item == null) {
      item = -1
    }
    if (equip < 0 || equip > 5 || equip == undefined || equip == null) {
      equip = 2
    }
    for (let i = 0; i < this.ItemMaxNum; i++) {
      if (
        this.Item[i] == -1 ||
        this.Item[i] == undefined ||
        this.Item[i] == null
      ) {
        break
      } else if (this.Item[i] == item || item < 0) {
        if (equip == 0) {
          if (this.Equip[i] != 0) {
            continue
          }
        } else if (equip == 1) {
          if (this.Equip[i] == 2) {
            continue
          }
        } else if (equip == 3) {
          if (this.Equip[i] == 0 || this.Equip[i] == 2) {
            continue
          }
        } else if (equip == 4) {
          if (this.Equip[i] != 2) {
            continue
          }
        } else if (equip == 5) {
          if (this.Equip[i] == 0) {
            continue
          }
        }
        result++
      }
    }
    return result
  }
  haveItemUseInCampCheck (haveItemNum) {
    let itemNum = this.Item[haveItemNum]
    let item = ITEM[itemNum]
    let spellData = decomposeSpell(spellEffectReplace(item.USE, 1), this.PC_NUM)
    if (spellData['situation'] == -1) {
      return -1
    }
    if (item.USE_EQUIP && !item.equipCheck(this.PC_NUM)) {
      return 0
    }
    if (GameData['CANNOT_USE_CURSED_ITEM'] && this.Equip[haveItemNum] == 2) {
      return 1
    }
    if (spellData['situation'] == 2 || spellData['situation'] == 3) {
      return 0
    }
    return 2
  }
  healingEffect (battle) {
    if (!battle) {
      this.controlHp(this.HpPlus, true)
    }
    if (this.State == 1 && this.PC_NUM > -1) {
      let formula = replaceFormula(GameData['CURE_AFRAID_PROB'], [
        ['pc', this.PC_NUM]
      ])
      let prob = Math.floor(strCalculation(formula))
      if (prob < 0) {
        prob = 0
      } else if (prob > 100) {
        prob = 100
      }
      if (prob >= dice(1, 100)) {
        this.State = 0
      }
    }
    if (battle) {
      if (this.Asleep > 0) {
        let formula = GameData['CURE_ASLEEP_TURN']
        if (this.PC_NUM > -1) {
          formula = formula.replace(/my\./g, 'pc.')
          formula = replaceFormula(formula, [['pc', this.PC_NUM]])
        } else {
          formula = formula.replace(/my\./g, 'monster.')
          formula = replaceFormula(formula, [['monster', this.MonsterNum]])
        }
        let num = Math.floor(strCalculation(formula))
        if (num < 1) {
          num = 1
        }
        this.Asleep -= num
        if (this.Asleep < 0) {
          this.Asleep = 0
        }
      }
      if (this.Silence > 0 || this.NoBreath > 0) {
        let formula = GameData['CURE_SILENCE']
        if (this.PC_NUM > -1) {
          formula = formula.replace(/my\./g, 'pc.')
          formula = replaceFormula(formula, [['pc', this.PC_NUM]])
        } else {
          formula = formula.replace(/my\./g, 'monster.')
          formula = replaceFormula(formula, [['monster', this.MonsterNum]])
        }
        let num = Math.floor(strCalculation(formula))
        if (num < 1) {
          num = 1
        }
        if (this.Silence > 0) {
          this.Silence -= num
          if (this.Silence < 0) {
            this.Silence = 0
          }
        }
        if (this.NoBreath > 0) {
          this.NoBreath -= num
          if (this.NoBreath < 0) {
            this.NoBreath = 0
          }
        }
      }
    }
  }
  initialize () {
    this.initializeVariable()
    this.spellEffectClear(true)
    this.battleReset()
    if (this.PC_NUM > -2) {
      this.check()
    }
  }
  initializeVariable () {
    this.MonsterNum = -1
    this.MonsterDataNum = -1
    ;(this.Name = ['', '']), (this.Names = ['', ''])
    ;(this.Title = ''),
      (this.Sex = 0),
      (this.Race = 0),
      (this.Alignment = 1),
      (this.PcClass = 0)
    ;(this.Ability = []), (this.Ability0 = []), (this.Ability1 = [])
    for (let i = 0; i < 36; i++) {
      ;(this.Ability[i] = -1), (this.Ability0[i] = -1), (this.Ability1[i] = -1)
    }
    ;(this.Level = 1), (this.Exp = 0), (this.NextUpExp = 0), (this.State = 0)
    ;(this.Rip = 0), (this.Poison = 0), (this.Marks = 0)
    ;(this.Ac = 0), (this.Ac0 = 0), (this.Ac1 = 0), (this.PartyNum = -1)
    this.ItemMaxNum = 0
    ;(this.Item = []), (this.ItemDecided = []), (this.Equip = [])
    for (let i = 0; i < 99; i++) {
      ;(this.Item[i] = -1), (this.ItemDecided[i] = 1), (this.Equip[i] = 0)
    }
    ;(this.Resist = []), (this.Resist0 = []), (this.Resist1 = [])
    ;(this.WeakPoint = []), (this.WeakPoint0 = []), (this.WeakPoint1 = [])
    for (let i = 0; i < RESIST_LENGTH; i++) {
      ;(this.Resist[i] = false),
        (this.Resist0[i] = false),
        (this.Resist1[i] = false)
      ;(this.WeakPoint[i] = false),
        (this.WeakPoint0[i] = false),
        (this.WeakPoint1[i] = false)
    }
    ;(this.Attack = []), (this.Defense = [])
    for (let i = 0; i < MONSTER_TYPE; i++) {
      ;(this.Attack[i] = false), (this.Defense[i] = false)
    }
    this.Range = [0, 0]
    ;(this.Dmg = ''),
      (this.DmgSub = ''),
      (this.AttackKind = ''),
      (this.AttackKindSub = '')
    ;(this.GroupAtNum = 1),
      (this.GroupAtNumSub = 1),
      (this.SubweaponHalf = true)
    this.AttackAdd = []
    for (let i = 0; i < ATTACK_ADD_LENGTH; i++) {
      this.AttackAdd[i] = false
    }
    ;(this.AttackPoison = 0),
      (this.Days = 1),
      (this.Hp = 1),
      (this.HpMax = 1),
      (this.HpMax0 = 1)
    ;(this.Spell = []), (this.Mp = []), (this.MpMax = [])
    for (let i = 0; i < 5; i++) {
      ;(this.Spell[i] = []), (this.Mp[i] = []), (this.MpMax[i] = [])
      for (let j = 0; j < 10; j++) {
        ;(this.Mp[i][j] = 0), (this.MpMax[i][j] = 0)
        this.Spell[i][j] = []
        for (let k = 0; k < 6; k++) {
          this.Spell[i][j].push(false)
        }
      }
    }
    ;(this.SrPlus = 0), (this.BrPlus = 0)
    this.Transmigrates = ''
    ;(this.SpellCancel = 0), (this.SpellCancel0 = 0), (this.SpellCancel1 = 0)
    ;(this.Gold = 0), (this.Hit = 0), (this.Hit0 = 0), (this.Hit1 = 0)
    this.DmgPlus = 0
    ;(this.Age = 0), (this.Lifetime = 0), (this.ThiefLv = 0)
    this.Healing = 0
    this.NextExp = 0
    ;(this.At = 0), (this.At0 = 0), (this.BreathMax = 0)
    this.HpPlus = 0
    this.Breath = 0
    this.FaceGraphic = ''
  }
  kindCursedCheck (kind) {
    if (this.PC_NUM < 0) {
      return false
    }
    let result = false
    for (let i = 0; i < this.ItemMaxNum; i++) {
      if (this.Item[i] < 0) {
        break
      }
      if (this.Equip[i] == 2 && ITEM[this.Item[i]].TYPE == kind) {
        result = true
        break
      }
    }
    return result
  }
  kindEquipedItem (kind, cursed) {
    if (this.PC_NUM < 0) {
      return -1
    }
    if (cursed == undefined || cursed == null) {
      cursed = false
    }
    let result = -1
    for (let i = 0; i < this.ItemMaxNum; i++) {
      if (this.Item[i] < 0) {
        break
      }
      if (kind == 7) {
        if (this.Equip[i] == 3 && ITEM[this.Item[i]].TYPE == 0) {
          result = i
          break
        }
      } else if (this.Equip[i] == 1 && ITEM[this.Item[i]].TYPE == kind) {
        result = i
        break
      } else if (
        cursed &&
        this.Equip[i] == 2 &&
        ITEM[this.Item[i]].TYPE == kind
      ) {
        result = i
        break
      }
    }
    return result
  }
  learnedSpell () {
    let learndSpell = false
    for (let i = 0; i < GameData['SPELL_KIND']; i++) {
      let str = replaceFormula(GameData['SPELL_LEARNED_PROB'][i], [
        ['pc', this.PC_NUM]
      ])
      let prob = Math.floor(strCalculation(str))
      if (GameData['SPELL_ACQUIRED_INT_TURN']) {
        let stack = []
        for (let j = 0; j < GameData['SPELL_LVMAX']; j++) {
          if (!this.learnedSpellPossible(i, j)) {
            continue
          }
          for (let k = 0; k < 6; k++) {
            if (
              GameData['SPELL'][i][j][k] != '' &&
              !GameData['SPELL_NOT_LEARNED'][i][j][k] &&
              !this.Spell[i][j][k]
            ) {
              stack.push(j * 10 + k)
            }
          }
        }
        if (stack.length == 0) {
          continue
        }
        while (true) {
          if (prob >= dice(1, 100)) {
            this.Spell[i][Math.floor(stack[0] / 10)][stack[0] % 10] = true
            str = replaceFormula(GameData['SPELL_LEARNED_PROB_DEC'], [
              ['pc', this.PC_NUM]
            ])
            prob -= Math.floor(strCalculation(str))
            learndSpell = true
            stack.splice(0, 1)
            if (stack.length == 0) {
              break
            }
          } else {
            break
          }
        }
      } else {
        for (let j = 0; j < GameData['SPELL_LVMAX']; j++) {
          if (!this.learnedSpellPossible(i, j)) {
            continue
          }
          while (true) {
            if (prob >= dice(1, 100)) {
              let stack = []
              for (let k = 0; k < 6; k++) {
                if (
                  GameData['SPELL'][i][j][k] != '' &&
                  !GameData['SPELL_NOT_LEARNED'][i][j][k] &&
                  !this.Spell[i][j][k]
                ) {
                  stack.push(k)
                }
              }
              if (stack.length == 0) {
                break
              }
              let num = stack[dice(1, stack.length) - 1]
              this.Spell[i][j][num] = true
              str = replaceFormula(GameData['SPELL_LEARNED_PROB_DEC'], [
                ['pc', this.PC_NUM]
              ])
              prob -= Math.floor(strCalculation(str))
              learndSpell = true
            } else {
              break
            }
          }
        }
      }
      if (GameData['LEAST_ONE_LEARNS_SPELL']) {
        for (let j = 0; j < GameData['SPELL_LVMAX']; j++) {
          if (!this.learnedSpellPossible(i, j)) {
            continue
          }
          let noLearned = true
          for (let k = 0; k < 6; k++) {
            if (this.Spell[i][j][k]) {
              noLearned = false
              break
            }
          }
          if (noLearned) {
            let stack = []
            for (let k = 0; k < 6; k++) {
              if (
                GameData['SPELL'][i][j][k] != '' &&
                !GameData['SPELL_NOT_LEARNED'][i][j][k] &&
                !this.Spell[i][j][k]
              ) {
                stack.push(k)
              }
            }
            if (stack.length > 0) {
              let num
              if (GameData['SPELL_ACQUIRED_INT_TURN']) {
                num = stack[0]
              } else {
                num = stack[dice(1, stack.length) - 1]
              }
              this.Spell[i][j][num] = true
              learndSpell = true
            }
          }
        }
      }
    }
    return learndSpell
  }
  learnedSpellPossible (kind, lv) {
    if (
      GameData['CLASS_LEARNED_SPELL'][this.PcClass][kind][2] == 0 ||
      GameData['CLASS_LEARNED_SPELL'][this.PcClass][kind][3] == 0 ||
      lv + 1 < GameData['CLASS_LEARNED_SPELL'][this.PcClass][kind][2] ||
      lv >= GameData['CLASS_LEARNED_SPELL'][this.PcClass][kind][3]
    ) {
      return false
    }
    let ck1 = false,
      ck2 = false
    for (let i = 0; i < 6; i++) {
      if (GameData['SPELL'][kind][lv][i] != '') {
        if (this.Spell[kind][lv][i]) {
          ck2 = true
        } else {
          ck1 = true
        }
      }
    }
    if (!ck1) {
      return false
    } else if (ck2) {
      return true
    }
    let num = GameData['CLASS_LEARNED_SPELL'][this.PcClass][kind][0]
    if (num == 0) {
      return false
    }
    num +=
      GameData['CLASS_LEARNED_SPELL'][this.PcClass][kind][1] *
      (lv - (GameData['CLASS_LEARNED_SPELL'][this.PcClass][kind][2] - 1))
    if (num <= this.Level) {
      return true
    } else {
      return false
    }
  }
  levelUp (lv) {
    if (lv > 99999) {
      return
    }
    for (let i = this.Level; i < lv; i++) {
      this.Level++
      this.learnedSpell()
      this.gainedMp()
      this.levelUpAbility()
      this.check()
      if (this.HpMax0 < 99999) {
        let num = this.gainedHp()
        this.HpMax0 += num
        this.Hp += num
      }
    }
    this.check()
    for (let i = 0; i < GameData['ABILITY'].length; i++) {
      if (this.Ability0[i] < 1) {
        this.Ability0[i] = 1
      }
    }
    let tmpNum
    if (lv < 2) {
      tmpNum = 0
    } else {
      let str = GameData['CLASS_NECESSARY_EXP'][this.PcClass].replace(
        /pc\.lv/g,
        String(this.Level - 1)
      )
      str = replaceFormula(str, [['pc', this.PC_NUM]], true)
      tmpNum = Math.floor(strCalculation(str))
    }
    if (this.Exp < tmpNum) {
      this.Exp = tmpNum
    }
    let expStr = replaceFormula(
      GameData['CLASS_NECESSARY_EXP'][this.PcClass],
      [['pc', this.PC_NUM]],
      true
    )
    this.NextUpExp = Math.floor(strCalculation(expStr))
  }
  levelUpAbility (innProb) {
    if (innProb == undefined || innProb == null) {
      innProb = 200
    }
    let resultAry = []
    for (let i = 0; i < GameData['ABILITY'].length; i++) {
      let str = replaceFormula(GameData['ABILITY_CHANGE_PROB'][i], [
        ['pc', this.PC_NUM]
      ])
      let prob = Math.floor(strCalculation(str))
      if (innProb < 200) {
        printDebugMessage(
          'abi[' + String(i) + '] change rate: ' + String(prob) + '%'
        )
      }
      if (prob < dice(1, 100)) {
        resultAry.push(0)
        continue
      }
      let limit
      if (GameData['ABILITY_FIX'] == 0) {
        limit = GameData['ABILITY_MAX']
      } else if (GameData['ABILITY_FIX'] == 1) {
        limit = GameData['RACE_ABI'][this.Race][i]
        limit += GameData['ABILITY_SEX'][this.Sex][i]
        limit += GameData['ABILITY_MAX']
      } else {
        let abiStr = GameData['ABILITY_INDIVIDUAL'][i].replace(
          /initialAbi/g,
          String(GameData['RACE_ABI'][this.Race][i])
        )
        abiStr = replaceFormula(abiStr, [['pc', this.PC_NUM]], true)
        limit = Math.floor(strCalculation(abiStr))
        if (GameData['ABILITY_INDIVIDUAL_SEX'][i]) {
          limit += GameData['ABILITY_SEX'][this.Sex][i]
        }
      }
      if (limit < 0) {
        limit = 0
      } else if (limit > 999) {
        limit = 999
      }
      str = replaceFormula(GameData['ABILITY_DOWN_PROB'][i], [
        ['pc', this.PC_NUM]
      ])
      prob = Math.floor(strCalculation(str))
      if (this.Ability0[i] >= limit) {
        prob = Math.ceil(strCalculation('(' + String(prob) + ' * 3) / 4'))
      }
      if (innProb < 200) {
        printDebugMessage(
          'abi[' + String(i) + '] decrease rate: ' + String(prob) + '%'
        )
        printDebugMessage(
          'abi[' +
            String(i) +
            '] decrease rate by room: ' +
            String(innProb) +
            '%'
        )
      }
      let changeNum = 0
      if (prob >= dice(1, 100)) {
        if (this.Ability0[i] > 0) {
          if (innProb >= dice(1, 100)) {
            this.Ability0[i]--
            changeNum = -1
          }
        } else if (innProb < 200) {
          printDebugMessage(
            'abi[' + String(i) + "] It doesn't change below the minimum value."
          )
        }
      } else if (this.Ability0[i] < limit) {
        this.Ability0[i]++
        changeNum = 1
      } else if (innProb < 200) {
        printDebugMessage(
          'abi[' +
            String(i) +
            "] It doesn't change for more than the max value."
        )
      }
      if (
        innProb < 200 &&
        GameData['DEBUG'] &&
        PlayData['DebugView'] &&
        changeNum != 0
      ) {
        let debugStr = 'abi[' + String(i) + '] '
        if (changeNum > 0) {
          debugStr += 'up'
        } else {
          debugStr += 'down'
        }
        console.log(debugStr)
      }
      if (
        innProb >= 200 &&
        this.Ability0[i] < 1 &&
        !GameData['ABILITY_NO_DEATH'][i]
      ) {
        this.Ability0[i] = 1
      }
      if (i > 9 || GameData['ABILITY_NOT_DISPLAY'][i]) {
        resultAry.push(0)
      } else {
        resultAry.push(changeNum)
      }
    }
    return resultAry
  }
  mpDamage (dmg) {
    let stack = []
    let kind = GameData['SPELL_KIND']
    if (this.PC_NUM < 0) {
      kind++
    }
    for (let i = 0; i < kind; i++) {
      for (let j = 0; j < GameData['SPELL_LVMAX']; j++) {
        if (this.Mp[i][j] > 0) {
          stack.push(i * 10 + j)
        }
      }
    }
    let ck = false
    while (dmg > 0 && stack.length > 0) {
      ck = true
      let num = stack[dice(1, stack.length) - 1]
      let i = Math.floor(num / 10)
      let j = num % 10
      this.Mp[i][j]--
      if (this.Mp[i][j] < 1) {
        stack.splice(num, 1)
      }
      dmg--
    }
    return ck
  }
  nameListStr (outCheck) {
    let result = MP.strFitLength(this.Name[0], 21)
    result += MP.strFitLength(getDefaultMessage('LEVEL', 1), 6, 'right')
    result += MP.strFitLength(String(this.Level), 6)
    if (this.PartyNum > -1 && outCheck) {
      let str = MP.strCut(getDefaultMessage('OUT_PT', 1), 8)
      str += String(this.PartyNum + 1)
      result += MP.strFitLength(str, 11)
    } else {
      if (this.State > 0 || this.Poison > 0) {
        result += this.getStateStr() + ' '
      } else {
        result += MP.strFitLength(GameData['RACE_ABBR'][this.Race], 4, 'right')
        result += '-'
        result += GameData['ALIGNMENT_ABBR'][this.Alignment]
        result += '-'
        result += MP.strFitLength(GameData['PC_CLASS_ABBR'][this.PcClass], 4)
      }
    }
    return result
  }
  possibleToAction () {
    if (this.State < 2 && this.Asleep == 0) {
      return true
    } else {
      return false
    }
  }
  putItem (itemNum, decided) {
    if (this.PC_NUM < 0) {
      return -1
    }
    if (itemNum == undefined || itemNum == null) {
      itemNum = -1
    } else if (itemNum >= ITEM.length) {
      itemNum = 0
    }
    if (decided == undefined || decided == null) {
      decided = 1
    } else if (decided) {
      decided = 1
    } else {
      decided = 0
    }
    let result = -1
    let count = 0
    for (let i = 0; i < this.ItemMaxNum; i++) {
      if (this.Item[i] < 0) {
        break
      }
      count++
    }
    if (count < this.ItemMaxNum) {
      if (itemNum > -1) {
        this.Item[count] = itemNum
        this.ItemDecided[count] = decided
        this.Equip[count] = 0
      }
      return count
    } else {
      return -1
    }
  }
  raceCommentNum (str) {
    let result = 0
    str = MP.zenkaku2hankaku(str)
    let text
    if (this.PC_NUM > -1) {
      text = deleteLineFeedCode(GameData['RACE_COMMENT'][this.Race])
    } else {
      text = deleteLineFeedCode(MONSTER_DATA[this.MonsterDataNum].COMMENT)
    }
    text = MP.zenkaku2hankaku(text)
    if (text.indexOf(str) > -1) {
      result = 1
    }
    return result
  }
  removeEquip (mode) {
    if (mode == undefined || mode == null) {
      mode = 0
    }
    let loop = this.haveItemNum(-1)
    for (let i = 0; i < loop; i++) {
      if (this.Equip[i] > 0) {
        if (mode == 2) {
          this.Equip[i] = 0
        } else if (mode == 1) {
          if (this.Equip[i] != 2) {
            this.Equip[i] = 0
          }
        } else {
          if (this.Equip[i] != 2) {
            if (
              ITEM[this.Item[i]].EQUIP_REQ_CLASS.indexOf(
                toString(this.PcClass, 36)
              ) < 0 ||
              ITEM[this.Item[i]].EQUIP_REQ_RACE.indexOf(
                toString(this.Race, 36)
              ) < 0
            ) {
              this.Equip[i] = 0
            }
          }
        }
      }
    }
  }
  removeHaveItem (haveNum) {
    if (haveNum < 0 || haveNum >= this.ItemMaxNum) {
      return
    }
    this.Item.splice(haveNum, 1)
    this.ItemDecided.splice(haveNum, 1)
    this.Equip.splice(haveNum, 1)
    this.Item.push(-1)
    this.ItemDecided.push(1)
    this.Equip.push(0)
  }
  removeItem (itemNum, equip, excludeHaveNum) {
    if (equip == undefined || equip == null) {
      equip = 2
    }
    if (excludeHaveNum == undefined || excludeHaveNum == null) {
      excludeHaveNum = -1
    }
    let result = -1
    let itemMax = this.haveItemNum(-1)
    for (let i = 0; i < itemMax; i++) {
      if (this.Item[i] == itemNum && i != excludeHaveNum) {
        if ((this.Equip[i] == 1 || this.Equip[i] == 3) && equip == 0) {
          continue
        } else if (this.Equip[i] == 2 && equip < 2) {
          continue
        }
        this.removeHaveItem(i)
        result = i
        break
      }
    }
    return result
  }
  spellEffectClear (full) {
    ;(this.SpellEffectRate = []), (this.SpellEffectPlus = [])
    for (let i = 0; i < 9; i++) {
      ;(this.SpellEffectRate[i] = 0), (this.SpellEffectPlus[i] = 0)
    }
    if (full) {
      ;(this.SealSpell = false), (this.SealSpellInt = 0)
    }
    ;(this.AbiRate = []), (this.AbiPlus = [])
    for (let i = 0; i < 36; i++) {
      ;(this.AbiRate[i] = 0), (this.AbiPlus[i] = 0)
    }
    ;(this.ResistPlus = new Array(RESIST_LENGTH)),
      (this.ResistRate = new Array(RESIST_LENGTH))
    for (let i = 0; i < this.ResistPlus.length; i++) {
      ;(this.ResistPlus[i] = -2), (this.ResistRate[i] = 0)
    }
    this.AttackAddPlus = new Array(ATTACK_ADD_LENGTH + 1)
    this.AttackAddRate = new Array(ATTACK_ADD_LENGTH + 1)
    for (let i = 0; i < this.AttackAddPlus.length; i++) {
      ;(this.AttackAddPlus[i] = false), (this.AttackAddRate[i] = 0)
    }
    this.PoisonPlus = 0
  }
  spellMaster (kind, lv, spell) {
    let result = false
    let kindStart = 0,
      kindEnd = 0,
      lvStart = 0,
      lvEnd = 0,
      spellStart = 0,
      spellEnd = 0
    if (kind < 0 || kind >= GameData['SPELL_KIND']) {
      kindEnd = GameData['SPELL_KIND']
    } else {
      kindStart = kind
      kindEnd = kind + 1
    }
    if (lv < 0 || lv >= GameData['SPELL_LVMAX']) {
      lvEnd = GameData['SPELL_LVMAX']
    } else {
      lvStart = lv
      lvEnd = lv + 1
    }
    if (spell < 0 || spell >= 6) {
      spellEnd = 6
    } else {
      spellStart = spell
      spellEnd = spell + 1
    }
    for (let i = kindStart; i < kindEnd; i++) {
      if (result) {
        break
      }
      for (let j = lvStart; j < lvEnd; j++) {
        if (result) {
          break
        }
        for (let k = spellStart; k < spellEnd; k++) {
          if (this.Spell[i][j][k]) {
            result = true
            break
          }
        }
      }
    }
    return result
  }
  spellMasterSilence () {
    let result = false
    for (let i = 0; i < GameData['SPELL_KIND']; i++) {
      if (result) {
        break
      }
      for (let j = 0; j < GameData['SPELL_LVMAX']; j++) {
        if (result) {
          break
        }
        for (let k = 0; k < 6; k++) {
          if (this.Spell[i][j][k] && GameData['SPELL_EVEN_SILENCE'][i][j][k]) {
            result = true
            break
          }
        }
      }
    }
    return result
  }
  tradePossibleItem () {
    let result = -1
    let itemMax = this.haveItemNum(-1)
    for (let i = itemMax - 1; i >= 0; i--) {
      if (this.Equip[i] < 1) {
        result = i
        break
      }
    }
    return result
  }
  weaponCursedCheck () {
    if (this.PC_NUM < 0) {
      return -1
    }
    let equip = -1,
      curse = -1,
      result = -1
    for (let i = 0; i < this.ItemMaxNum; i++) {
      if (this.Item[i] < 0) {
        break
      }
      if (ITEM[this.Item[i]].TYPE == 0) {
        if (this.Equip[i] == 1) {
          equip = i
          break
        } else if (this.Equip[i] == 2 && curse == -1) {
          curse = i
        }
        if (equip > -1 && curse > -1) {
          break
        }
      }
    }
    if (equip > -1) {
      result = equip
    } else if (curse > -1) {
      result = curse
    }
    return result
  }
}
